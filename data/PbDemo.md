"""

Algorithm：binary_search
Description：monotonicity is necessary for solution like these, which always work together with SortedList, or can also use Bisect, sometimes with high precision
====================================LeetCode====================================
4（https://leetcode.cn/problems/median-of-two-sorted-arrays/）binary_search|median|two_arrays|same_direction_pointer
81（https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/）binary_search|rotated_array|sorting
154（https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/）binary_search|rotated_array|sort|duplicate_nums
162（https://leetcode.cn/problems/find-peak-element/）binary_search|peak_index
2179（https://leetcode.cn/problems/count-good-triplets-in-an-array/）binary_search|sorted_list
2141（https://leetcode.cn/problems/maximum-running-time-of-n-computers/）greedy|binary_search|implemention
2102（https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/）binary_search|sorted_list
2563（https://leetcode.cn/problems/count-the-number-of-fair-pairs/）binary_search|sorted_list
2604（https://leetcode.cn/problems/minimum-time-to-eat-all-grains/）binary_search|greedy|pointer
1201（https://leetcode.cn/problems/ugly-number-iii/）binary_search|counter|inclusion_exclusion
1739（https://leetcode.cn/problems/building-boxes/）math|binary_search
1889（https://leetcode.cn/problems/minimum-space-wasted-from-packaging/）sort|prefix_sum|greedy|binary_search
2071（https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/）binary_search|greedy
2594（https://leetcode.cn/problems/minimum-time-to-repair-cars/）binary_search
2517（https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/）binary_search
1482（https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/）binary_search
2528（https://leetcode.cn/problems/maximize-the-minimum-powered-city/description/）binary_search|prefix_sum|diff_array|greedy
2560（https://leetcode.cn/problems/house-robber-iv/）binary_search|dp
2234（https://leetcode.cn/problems/maximum-total-beauty-of-the-gardens/description/）prefix_sum|binary_search|brute_force
100123（https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/）binary_search|greedy|median_greedy|brute_force
100267（https://leetcode.com/contest/weekly-contest-393/problems/kth-smallest-amount-with-single-denomination-combination/）inclusion_exclusion|binary_search|math|classical
3134（https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array）binary_search|median|two_pointers|classical

=====================================LuoGu======================================
P1577（https://www.luogu.com.cn/problem/P1577）math|floor|binary_search
P1570（https://www.luogu.com.cn/problem/P1570）math|greedy|binary_search
P1843（https://www.luogu.com.cn/problem/P1843）greedy|binary_search
P2309（https://www.luogu.com.cn/problem/P2309）prefix_sum|sorted_list|binary_search|counter|sub_consequence_sum
P2390（https://www.luogu.com.cn/problem/P2390）brute_force|binary_search|two_pointers
P2759（https://www.luogu.com.cn/problem/P2759）math|binary_search
P1404（https://www.luogu.com.cn/problem/P1404）math|prefix_sum|binary_search
P1592（https://www.luogu.com.cn/problem/P1592）binary_search|inclusion_exclusion|kth_coprime_of_n
P2855（https://www.luogu.com.cn/problem/P2855）greedy|binary_search
P2884（https://www.luogu.com.cn/problem/P2884）binary_search
P2985（https://www.luogu.com.cn/problem/P2985）greedy|binary_search|implemention
P3184（https://www.luogu.com.cn/problem/P3184）binary_search|counter
P3611（https://www.luogu.com.cn/problem/P3611）binary_search|greedy|heapq|implemention
P3743（https://www.luogu.com.cn/problem/P3743）binary_search
P4058（https://www.luogu.com.cn/problem/P4058）binary_search
P4670（https://www.luogu.com.cn/problem/P4670）sort|binary_search|counter
P5119（https://www.luogu.com.cn/problem/P5119）greedy|binary_search
P5250（https://www.luogu.com.cn/problem/P5250）sorted_list
P6174（https://www.luogu.com.cn/problem/P6174）greedy|binary_search
P6281（https://www.luogu.com.cn/problem/P6281）greedy|binary_search
P6423（https://www.luogu.com.cn/problem/P6423）binary_search
P7177（https://www.luogu.com.cn/problem/P7177）binary_search|tree|dfs|implemention
P1314（https://www.luogu.com.cn/problem/P1314）binary_search|sum_nearest_subsequence
P3017（https://www.luogu.com.cn/problem/P3017）binary_search|sub_matrix_sum|max_min
P1083（https://www.luogu.com.cn/problem/P1083）binary_search|diff_array
P1281（https://www.luogu.com.cn/problem/P1281）binary_search|specific_plans
P1381（https://www.luogu.com.cn/problem/P1381）binary_search|sliding_window|brain_teaser
P1419（https://www.luogu.com.cn/problem/P1419）binary_search|monotonic_queue
P1525（https://www.luogu.com.cn/problem/P1525）binary_search|bfs|bipartite_graph|union_find|coloring
P1542（https://www.luogu.com.cn/problem/P1542）binary_search|fraction|high_precision
P2237（https://www.luogu.com.cn/problem/P2237）brain_teaser|sort|binary_search
P2810（https://www.luogu.com.cn/problem/P2810）binary_search|brute_force
P3718（https://www.luogu.com.cn/problem/P3718）binary_search|greedy
P3853（https://www.luogu.com.cn/problem/P3853）binary_search|greedy
P4343（https://www.luogu.com.cn/problem/P4343）bound|binary_search|implemention
P5844（https://www.luogu.com.cn/problem/P5844）median|greedy|prefix_sum|binary_search
P5878（https://www.luogu.com.cn/problem/P5878）binary_search|brute_force
P6058（https://www.luogu.com.cn/problem/P6058）dfs_order|offline_lca|binary_search
P6069（https://www.luogu.com.cn/problem/P6069）math|binary_search
P6733（https://www.luogu.com.cn/problem/P6733）binary_search|sorted_list
P8161（https://www.luogu.com.cn/problem/P8161）greedy|binary_search
P8198（https://www.luogu.com.cn/problem/P8198）binary_search|pointer
P9050（https://www.luogu.com.cn/problem/P9050）binary_search|data_range|greedy|implemention
P1798（https://www.luogu.com.cn/problem/P1798）binary_search|greedy|implemention

===================================CodeForces===================================
1251D（https://codeforces.com/problemset/problem/1251/D）greedy|median|binary_search
830A（https://codeforces.com/problemset/problem/830/A）greedy|point_coverage|binary_search
847E（https://codeforces.com/problemset/problem/847/E）greedy|binary_search|pointer
732D（https://codeforces.com/problemset/problem/732/D）greedy|binary_search|pointer
778A（https://codeforces.com/problemset/problem/778/A）binary_search|pointer
913C（https://codeforces.com/problemset/problem/913/C）dp|binary_search|greedy|implemention
1791G2（https://codeforces.com/problemset/problem/1791/G2）greedy|sort|prefix_sum|brute_force|binary_search
448D（https://codeforces.com/problemset/problem/448/D）binary_search|kth_max_of_n_mul_m_table
1475D（https://codeforces.com/problemset/problem/1475/D）greedy|sort|prefix_sum|brute_force|binary_search
1370D（https://codeforces.com/problemset/problem/1370/D）binary_search|greedy|check
1486D（https://codeforces.com/problemset/problem/1486/D）binary_search|hash|prefix_sum|maximum_length_of_sub_consequence_with_pos_sum
1118D2（https://codeforces.com/problemset/problem/1118/D2）greedy|binary_search
883I（https://codeforces.com/problemset/problem/883/I）binary_search|two_pointers|dp
1680C（https://codeforces.com/contest/1680/problem/C）binary_search|greedy|two_pointers|check
1251D（https://codeforces.com/contest/1251/problem/D）greedy|binary_search
1165F2（https://codeforces.com/contest/1165/problem/F2）reverse_order|greedy|classical|binary_search
1490G（https://codeforces.com/contest/1490/problem/G）binary_search|prefix_sum
1883G2（https://codeforces.com/contest/1883/problem/G2）binary_search|greedy|sorted_list
1843E（https://codeforces.com/problemset/problem/1843/E）binary_search|query_order|classical
1288D（https://codeforces.com/contest/1288/problem/D）binary_search|bit_masks
1393C（https://codeforces.com/problemset/problem/1393/C）binary_search|implemention|stack|classical|math
1117C（https://codeforces.com/problemset/problem/1117/C）binary_search|observation|brain_teaser
1379C（https://codeforces.com/contest/1379/problem/C）observation|prefix_sum|binary_search|brute_force|greedy
1679D（https://codeforces.com/problemset/problem/1679/D）binary_search|graph|longest_path
1244E（https://codeforces.com/problemset/problem/1244/E）binary_search|observation|two_pointers
1998C（https://codeforces.com/problemset/problem/1998/C）binary_search|observation|greedy
1623C（https://codeforces.com/problemset/problem/1623/C）binary_search|reverse_order|greedy
1610C（https://codeforces.com/problemset/problem/1610/C）binary_search|brain_teaser|monotonic_property
1946C（https://codeforces.com/problemset/problem/1946/C）binary_search|point_head|tree_dp|greedy
1168A（https://codeforces.com/problemset/problem/1168/A）binary_search|brain_teaser|greedy

====================================AtCoder=====================================
ARC070B（https://atcoder.jp/contests/abc056/tasks/arc070_b）binary_search|bag_dp
ARC075B（https://atcoder.jp/contests/abc063/tasks/arc075_b）binary_search|greedy
ABC341D（https://atcoder.jp/contests/abc341/tasks/abc341_d）binary_search|math|classical
ABC324F（https://atcoder.jp/contests/abc324/tasks/abc324_f）binary_search|dag_dp|find_float_right|classical
ABC305D（https://atcoder.jp/contests/abc305/tasks/abc305_d）binary_search|prefix_sum
ABC294F（https://atcoder.jp/contests/abc294/tasks/abc294_f）binary_search|classical|brain_teaser
ABC346F（https://atcoder.jp/contests/abc346/tasks/abc346_f）binary_search|brute_force|greedy|implemention|pointer|circular_array
ABC270E（https://atcoder.jp/contests/abc270/tasks/abc270_e）binary_search|implemention
ABC257D（https://atcoder.jp/contests/abc257/tasks/abc257_d）binary_search|bfs|brute_force
ABC246D（https://atcoder.jp/contests/abc246/tasks/abc246_d）binary_search|brute_force
ABC236E（https://atcoder.jp/contests/abc236/tasks/abc236_e）median|average|dp|greedy|binary_search|classical
ABC216E（https://atcoder.jp/contests/abc216/tasks/abc216_e）binary_search|greedy|implemention
ABC215F（https://atcoder.jp/contests/abc215/tasks/abc215_f）two_pointers|binary_search|sort|brain_teaser
ABC203D（https://atcoder.jp/contests/abc203/tasks/abc203_d）binary_search|prefix_sum
ABC198C（https://atcoder.jp/contests/abc198/tasks/abc198_c）binary_search|corner_case
ABC192D（https://atcoder.jp/contests/abc192/tasks/abc192_d）binary_search|n_base|corner_case

=====================================AcWing=====================================
120（https://www.acwing.com/problem/content/122/）binary_search
14（https://www.acwing.com/problem/content/description/15/）pigeonhole_principle|binary_search
3973（https://www.acwing.com/problem/content/3976/）high_precision|binary_search|sliding_window|two_pointers
4866（https://www.acwing.com/problem/content/description/4866/）binary_search|pigeonhole_principle
5051（https://www.acwing.com/problem/content/description/5051/）high_precision|binary_search|specific_plan

=====================================CodeChef=====================================
1（https://www.codechef.com/START125D/problems/BILM）binary_search|brute_force|brain_teaser|classical

=====================================LibraryChecker=====================================
1（https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/B）find_float_right
2（https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/C）find_int_left
3（https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/D）find_int_left

"""
import bisect
import heapq
import math
from collections import deque, defaultdict, Counter
from functools import reduce
from itertools import accumulate, combinations
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.basis.diff_array.template import PreFixSumMatrix
from src.data_structure.sorted_list.template import SortedList
from src.mathmatics.high_precision.template import FloatToFrac
from src.mathmatics.number_theory.template import NumFactor
from src.search.dfs.template import UnWeightedTree
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1314(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1314
        tag: binary_search|sum_nearest_subsequence|classical|can_not_be_ternary_search
        """
        n, m, s = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        queries = [ac.read_list_ints() for _ in range(m)]

        def compute(w):
            cnt = [0] * (n + 1)
            pre = [0] * (n + 1)
            for i in range(n):
                cnt[i + 1] = cnt[i] + int(nums[i][0] >= w)
                pre[i + 1] = pre[i] + int(nums[i][0] >= w) * nums[i][1]
            res = 0
            for a, b in queries:
                res += (pre[b] - pre[a - 1]) * (cnt[b] - cnt[a - 1])
            return res

        def check(w):
            return compute(w) >= s

        # ternary_search will be wrong answer
        low = 0
        high = max(ls[0] for ls in nums)
        mid = BinarySearch().find_int_right(low, high, check)
        ans = min(abs(s - compute(mid)), abs(s - compute(mid + 1)))
        ac.st(ans)
        return

    @staticmethod
    def cf_448d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/448/D
        tag: binary_search|kth_max_of_n_mul_m_table
        """
        n, m, k = ac.read_list_ints()

        def check(num):
            res = 0
            for x in range(1, m + 1):
                res += min(n, num // x)
            return res >= k

        if m > n:
            m, n = n, m

        ans = BinarySearch().find_int_left(1, m * n, check)
        ac.st(ans)
        return

    @staticmethod
    def cf_1370d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1370/D
        tag: binary_search|greedy|check|odd_even
        """
        n, k = map(int, input().split())
        nums = list(map(int, input().split()))

        def check(x):
            for ind in [0, 1]:
                cnt = 0
                for num in nums:
                    if not ind:
                        cnt += 1
                        ind = 1 - ind
                    else:
                        if num <= x:
                            cnt += 1
                            ind = 1 - ind
                    if cnt >= k:
                        return True
            return False

        low = min(nums)
        high = max(nums)
        ans = BinarySearch().find_int_left(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def cf_1475d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1475/D
        tag: greedy|sort|prefix_sum|brute_force|binary_search
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            if sum(a) < m:
                ac.st(-1)
                continue

            a1 = [a[i] for i in range(n) if b[i] == 1]
            a2 = [a[i] for i in range(n) if b[i] == 2]
            a1.sort(reverse=True)
            a2.sort(reverse=True)

            x, y = len(a1), len(a2)
            pre1 = [0] * (x + 1)
            for i in range(x):
                pre1[i + 1] = pre1[i] + a1[i]

            ans = math.inf
            pre = 0
            j = bisect.bisect_left(pre1, m - pre)
            if j <= x:
                ans = min(ans, j)

            for i in range(y):
                cnt = i + 1
                pre += a2[i]
                j = bisect.bisect_left(pre1, m - pre)
                if j <= x:
                    ans = min(ans, j + cnt * 2)
            ac.st(ans)
        return

    @staticmethod
    def lg_p3017(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3017
        tag: binary_search|sub_matrix_sum|maximum_minimum|classical
        """

        def check(x):

            def cut():
                cur = 0
                c = 0
                for num in pre:
                    cur += num
                    if cur >= x:
                        c += 1
                        cur = 0
                return c >= b

            cnt = i = 0
            pre = [0] * n
            while i < m:
                if cut():
                    pre = [0] * n
                    cnt += 1
                else:
                    for j in range(n):
                        pre[j] += grid[i][j]
                    i += 1
            if cut():
                cnt += 1
            return cnt >= a

        m, n, a, b = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        low = 0
        high = sum(sum(g) for g in grid) // (a * b)
        ans = BinarySearch().find_int_right(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def cf_1680c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1680/problem/C
        tag: binary_search|greedy|two_pointers|check|classical
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            tot_1 = s.count("1")

            def check(x):
                j = cnt = ceil_1 = 0
                cnt_1 = 0
                for i in range(n):
                    while j < n and (cnt + int(s[j] == "0")) <= x:
                        cnt += s[j] == "0"
                        cnt_1 += s[j] == "1"
                        j += 1
                    if cnt <= x:
                        ceil_1 = max(ceil_1, cnt_1)
                    if s[i] == "0":
                        cnt -= 1
                    else:
                        cnt_1 -= 1
                return tot_1 - ceil_1 <= x

            ans = BinarySearch().find_int_left(0, n, check)
            ac.st(ans)
        return

    @staticmethod
    def cf_1791g2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1791/G2
        tag: greedy|sort|prefix_sum|brute_force|binary_search|can_not_to_be_two_pointers
        """
        for _ in range(ac.read_int()):

            n, c = ac.read_list_ints()
            cost = ac.read_list_ints()
            lst = [[min(x, n + 1 - x) + cost[x - 1], x + cost[x - 1]]
                   for x in range(1, n + 1)]

            lst.sort(key=lambda it: it[0])
            pre = [0] * (n + 1)
            for i in range(n):
                pre[i + 1] = pre[i] + lst[i][0]

            ans = 0
            for i in range(n):
                if lst[i][1] + pre[i] <= c:
                    cur = bisect.bisect_right(pre, c - lst[i][1] + lst[i][0]) - 1
                else:
                    cur = bisect.bisect_right(pre, c - lst[i][1])
                ans = max(ans, cur)
            ac.st(ans)
        return

    @staticmethod
    def lc_1889(packages: List[int], boxes: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-space-wasted-from-packaging/
        tag: sort|prefix_sum|greedy|binary_search
        """
        packages.sort()
        pre = list(accumulate(packages, initial=0))
        n = len(packages)
        ans = math.inf
        mod = 10 ** 9 + 7
        for box in boxes:
            box.sort()
            if box[-1] < packages[-1]:
                continue
            i = cur = 0
            for num in box:
                if i == n:
                    break
                if num < packages[i]:
                    continue
                j = bisect.bisect_right(packages, num) - 1
                cur += (j - i + 1) * num - (pre[j + 1] - pre[i])
                i = j + 1
            if cur < ans:
                ans = cur
        return ans % mod if ans < math.inf else -1

    @staticmethod
    def lc_2141(n: int, batteries: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-running-time-of-n-computers/
        tag: greedy|binary_search|implemention|classical
        """
        batteries.sort(reverse=True)
        rest = sum(batteries[n:])

        def check(w):
            res = 0
            for num in batteries[:n]:
                if num < w:
                    res += w - num
            return res <= rest

        return BinarySearch().find_int_right(0, batteries[n - 1] + rest, check)

    @staticmethod
    def lc_2528(stations: List[int], r: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximize-the-minimum-powered-city/description/
        tag: binary_search|prefix_sum|diff_array|greedy|classical
        """
        n = len(stations)
        nums = [0] * n
        for i in range(n):
            left = max(0, i - r)
            nums[left] += stations[i]
            if i + r + 1 < n:
                nums[i + r + 1] -= stations[i]
        for i in range(1, n):
            nums[i] += nums[i - 1]

        def check(x):
            diff = [0] * (n + 2 * r + 10)
            res = 0
            for j in range(n):
                diff[j] += diff[j - 1] if j else 0
                cur = diff[j] + nums[j]
                if cur < x:
                    res += x - cur
                    diff[j] += x - cur
                    diff[j + 2 * r + 1] -= x - cur

            return res <= k

        return BinarySearch().find_int_right(0, max(nums) + k, check)

    @staticmethod
    def lc_2563(nums, lower, upper):
        """
        url: https://leetcode.cn/problems/count-the-number-of-fair-pairs/
        tag: binary_search|sorted_list
        """
        nums.sort()
        n = len(nums)
        ans = 0
        for i in range(n):
            x = bisect.bisect_right(nums, upper - nums[i], hi=i)
            y = bisect.bisect_left(nums, lower - nums[i], hi=i)
            ans += x - y
        return ans

    @staticmethod
    def lc_4(nums1: List[int], nums2: List[int]) -> float:
        """
        url: https://leetcode.cn/problems/median-of-two-sorted-arrays/
        tag: binary_search|median|two_arrays|same_direction_pointer
        """

        def get_kth_num(k):
            ind1 = ind2 = 0
            while k:
                if ind1 == m:
                    return nums2[ind2 + k - 1]
                if ind2 == n:
                    return nums1[ind1 + k - 1]
                if k == 1:
                    return min(nums1[ind1], nums2[ind2])
                index1 = min(ind1 + k // 2 - 1, m - 1)
                index2 = min(ind2 + k // 2 - 1, n - 1)
                val1 = nums1[index1]
                val2 = nums2[index2]
                if val1 < val2:
                    k -= index1 - ind1 + 1
                    ind1 = index1 + 1
                else:
                    k -= index2 - ind2 + 1
                    ind2 = index2 + 1
            return

        m, n = len(nums1), len(nums2)
        s = m + n
        if s % 2:
            return get_kth_num(s // 2 + 1)
        else:
            return (get_kth_num(s // 2 + 1) + get_kth_num(s // 2)) / 2

    @staticmethod
    def cf_1486d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1486/D
        tag: binary_search|index|hash|prefix_sum|maximum_length_of_sub_consequence_with_pos_sum|classical|median|greedy
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = sorted(nums)

        def check(ind):
            x = lst[ind]
            dct = dict()
            pre = 0
            dct[0] = -1
            for i, num in enumerate(nums):
                pre += 1 if num >= x else -1
                if pre > 0 and i + 1 >= k:
                    return True
                if pre - 1 in dct and i - dct[pre - 1] >= k:
                    return True
                if pre not in dct:
                    dct[pre] = i
            return False

        ans = BinarySearch().find_int_right(0, n - 1, check)
        ac.st(lst[ans])
        return

    @staticmethod
    def lg_p1083(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1083
        tag: binary_search|diff_array
        """

        def check(s):
            diff = [0] * n
            for c, a, b in lst[:s]:
                diff[a - 1] += c
                if b < n:
                    diff[b] -= c
            if diff[0] > nums[0]:
                return False
            pre = diff[0]
            for i in range(1, n):
                pre += diff[i]
                if pre > nums[i]:
                    return False
            return True

        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = [ac.read_list_ints() for _ in range(m)]
        ans = BinarySearch().find_int_right(0, n, check)
        if ans == n:
            ac.st(0)
        else:
            ac.st(-1)
            ac.st(ans + 1)
        return

    @staticmethod
    def ac_120(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/122/
        tag: binary_search|classical
        """

        def solve():

            def check(pos):
                res = 0
                for s, e, d in nums:
                    if s <= pos:
                        res += (min(pos, e) - s) // d + 1
                return res % 2 == 1

            def compute(pos):
                res = 0
                for s, e, d in nums:
                    if s <= pos <= e:
                        res += (pos - s) % d == 0
                return [pos, res]

            n = ac.read_int()
            nums = [ac.read_list_ints() for _ in range(n)]
            low = min(x for x, _, _ in nums)
            high = max(x for _, x, _ in nums)
            mid = BinarySearch().find_int_left(low, high, check)
            if check(mid):
                ac.lst(compute(mid))
            elif check(mid + 1):
                ac.lst(compute(mid + 1))
            else:
                ac.st("There's no weakness.")

            return

        for _ in range(ac.read_int()):
            solve()
        return

    @staticmethod
    def arc_070b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc056/tasks/arc070_b
        tag: binary_search|bag_dp
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums.sort()

        def check(i):
            dp = [0] * k
            dp[0] = 1
            xx = nums[i]
            if xx >= k:
                return False

            for j in range(n):
                if j != i:
                    x = nums[j]
                    for p in range(k - 1, x - 1, -1):
                        if dp[p - x]:
                            dp[p] = 1
                            if p + xx >= k:
                                return False

            return True

        ans = BinarySearch().find_int_right(0, n - 1, check)
        if check(ans):
            ac.st(ans + 1)
        else:
            ac.st(0)
        return

    @staticmethod
    def arc_075b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc063/tasks/arc075_b
        tag: binary_search|greedy
        """
        n, a, b = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]

        def check(s):
            res = 0
            for num in nums:
                if num > s * b:
                    res += ac.ceil((num - s * b), (a - b))
            return res <= s

        ans = BinarySearch().find_int_left(0, ac.ceil(max(nums), b), check)
        ac.st(ans)
        return

    @staticmethod
    def ac_14(nums):
        """
        url: https://www.acwing.com/problem/content/description/15/
        tag: pigeonhole_principle|binary_search|O(nlogn)|in_place_hash
        """
        n = len(nums) - 1
        low = 1
        high = n
        while low < high:
            mid = low + (high - low) // 2
            cnt = 0
            for num in nums:
                if low <= num <= mid:
                    cnt += 1
            if cnt > mid - low + 1:
                high = mid
            else:
                low = mid + 1
        return low

    @staticmethod
    def lg_p1281(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1281
        tag: binary_search|specific_plans
        """
        m, k = ac.read_list_ints()
        nums = ac.read_list_ints()

        def compute(xx):
            res = []
            pre = nums[m - 1]
            post = m - 1
            for i in range(m - 2, -1, -1):
                if pre + nums[i] > xx:
                    res.append([i + 2, post + 1])
                    pre = nums[i]
                    post = i
                else:
                    pre += nums[i]
            res.append([1, post + 1])
            return res

        def check(xx):
            return len(compute(xx)) <= k

        x = BinarySearch().find_int_left(max(nums), sum(nums), check)
        ans = compute(x)
        for a in ans[::-1]:
            ac.lst(a)
        return

    @staticmethod
    def lg_p1381(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1381
        tag: sliding_window|two_pointers
        """
        n = ac.read_int()
        dct = set([ac.read_str() for _ in range(n)])
        m = ac.read_int()
        words = [ac.read_str() for _ in range(m)]
        target = set(words)
        k = sum(word in dct for word in target)
        ac.st(k)
        if not k:
            ac.st(0)
            return
        ans = m
        j = 0
        cnt = dict()
        for i in range(m):
            while j < m and len(cnt) < k:
                if words[j] in dct:
                    cnt[words[j]] = cnt.get(words[j], 0) + 1
                j += 1
            if len(cnt) == k and j - i < ans:
                ans = j - i
            if words[i] in dct:
                cnt[words[i]] -= 1
                if not cnt[words[i]]:
                    del cnt[words[i]]
        ac.st(ans)
        return

    @staticmethod
    def lg_p1592(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1592
        tag: binary_search|inclusion_exclusion|kth_coprime_of_n|number_theory|classical
        """
        n, k = ac.read_list_ints()
        if n == 1:
            ac.st(k)
            return
        lst = NumFactor().get_prime_factor(n)
        prime = [x for x, _ in lst]
        m = len(prime)

        def check(x):
            res = 0
            for i in range(1, m + 1):
                for item in combinations(prime, i):  # the same as euler_phi2
                    cur = 1
                    for num in item:
                        cur *= num
                    res += (x // cur) * (-1) ** (i + 1)
            return x - res >= k

        ans = BinarySearch().find_int_left(1, n * k, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1419(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1419
        tag: binary_search|monotonic_queue|prefix_sum|average|classical
        """

        def check(x):
            stack = deque()
            res = []
            for i in range(n):
                while stack and stack[0][0] <= i - k:
                    stack.popleft()
                while stack and stack[-1][1] >= pre[i] - x * i:
                    stack.pop()
                stack.append([i, pre[i] - x * i])
                res.append(stack[0][1])
                if i >= s - 1:
                    if pre[i + 1] - x * (i + 1) >= res[i - s + 1]:
                        return True
            return False

        n = ac.read_int()
        s, t = ac.read_list_ints()
        nums = []
        for _ in range(n):
            nums.append(int(input().strip()))
        pre = [0] * (n + 1)
        for j in range(n):
            pre[j + 1] = pre[j] + nums[j]

        k = t - s
        ans = BinarySearch().find_float_right(min(nums), max(nums), check)
        ac.st("%.3f" % ans)
        return

    @staticmethod
    def lg_p1525(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1525
        tag: binary_search|bfs|bipartite_graph|union_find|coloring_method|classical
        """
        n, m = ac.read_list_ints()
        lst = [ac.read_list_ints() for _ in range(m)]

        def check(weight):
            edges = [[i, j] for i, j, w in lst if w > weight]
            dct = defaultdict(list)
            for i, j in edges:
                dct[i].append(j)
                dct[j].append(i)
            visit = [0] * (n + 1)
            for i in range(1, n + 1):
                if visit[i] == 0:
                    stack = [i]
                    visit[i] = 1
                    order = 2
                    while stack:
                        nex = []
                        for j in stack:
                            for y in dct[j]:
                                if not visit[y]:
                                    visit[y] = order
                                    nex.append(y)
                        order = 1 if order == 2 else 2
                        stack = nex
            return all(visit[i] != visit[j] for i, j in edges)

        low = 0
        high = max(ls[-1] for ls in lst)
        ans = BinarySearch().find_int_left(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1542(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1542
        tag: binary_search|frac_to_float|high_precision|float_to_frac
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ff = FloatToFrac()

        def check(xx):
            speed = [xx, 1]
            while int(speed[0]) != speed[0]:
                speed[0] *= 10
                speed[1] *= 10
            speed = [int(w) for w in speed]
            early = [0, 1]
            for x, y, s in nums:
                cur = ff.frac_add_without_gcd(early, [s * speed[1], speed[0]])
                if cur[0] > y * cur[1]:
                    return False
                if cur[0] < x * cur[1]:
                    early = [x, 1]
                else:
                    early = cur[:]
            return True

        ans = BinarySearch().find_float_left(1e-4, 10 ** 7, check)
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def cf_1118d2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1118/D2
        tag: greedy|binary_search
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        s = sum(nums)
        if s < m:
            ac.st(-1)
            return
        nums.sort(reverse=True)

        def check(x):
            ans = 0
            for i in range(n):
                j = i // x
                ans += max(0, nums[i] - j)
            return ans >= m

        ac.st(BinarySearch().find_int_left(1, n, check))
        return

    @staticmethod
    def cf_883i(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/883/I
        tag: binary_search|two_pointers|dp
        """
        n, k = ac.read_list_ints()
        nums = sorted(ac.read_list_ints())

        def check(x):
            dp = [0] * (n + 1)
            dp[0] = 1
            j = 0
            for i in range(n):
                while nums[i] - nums[j] > x:
                    j += 1
                while not dp[j] and j < i - k + 1:
                    j += 1
                if dp[j] and i + 1 - j >= k:
                    dp[i + 1] = 1
            return dp[-1] == 1

        ans = BinarySearch().find_int_left(0, nums[-1] - nums[0], check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2237(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2237
        tag: brain_teaser|sort|binary_search
        """
        w, n = ac.read_list_ints()
        nums = [ac.read_str() for _ in range(w)]
        ind = list(range(w))
        ind.sort(key=lambda it: nums[it])
        nums.sort()
        for _ in range(n):
            k, s = ac.read_list_strs()
            k = int(k)
            x = bisect.bisect_left(nums, s) + k - 1
            if x < w and nums[x][:len(s)] == s:
                ac.st(ind[x] + 1)
            else:
                ac.st(-1)
        return

    @staticmethod
    def lg_p2810(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2810
        tag: binary_search|brute_force|classical
        """
        n = ac.read_int()

        low = 0
        high = 10 ** 18

        def compute(x):
            k = 2
            res = 0
            while k * k * k <= x:
                res += x // (k * k * k)
                k += 1
            return res

        def check(x):
            return compute(x) >= n

        ans = BinarySearch().find_int_left(low, high, check)
        if compute(ans) == n:
            ac.st(ans)
            return
        ac.st(-1)
        return

    @staticmethod
    def lg_p3718(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3718
        tag: binary_search|greedy|classical
        """
        n, k = ac.read_list_ints()
        s = ac.read_str()

        def check(x):
            if x == 1:
                # special judge
                op1 = op2 = 0
                for i in range(n):
                    if i % 2:
                        op1 += 1 if s[i] == "N" else 0
                        op2 += 1 if s[i] == "F" else 0
                    else:
                        op1 += 1 if s[i] == "F" else 0
                        op2 += 1 if s[i] == "N" else 0
                return op1 <= k or op2 <= k

            op = 0
            pre = s[0]
            cnt = 1
            for w in s[1:]:
                if w == pre:
                    cnt += 1
                else:
                    op += cnt // (x + 1)
                    pre = w
                    cnt = 1
            op += cnt // (x + 1)
            return op <= k

        ans = BinarySearch().find_int_left(1, n, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p3853(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3853
        tag: binary_search|greedy
        """
        length, n, k = ac.read_list_ints()
        lst = ac.read_list_ints()
        lst.sort()

        def check(x):
            return sum((lst[i + 1] - lst[i] + x - 1) // x - 1 for i in range(n - 1)) <= k

        low = 1
        high = max(lst[i + 1] - lst[i] for i in range(n - 1))
        ans = BinarySearch().find_int_left(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p4343(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4343
        tag: bound|binary_search|implemention|classical
        """
        l, k = ac.read_list_ints()
        lst = []
        for _ in range(l):
            lst.append(int(input().strip()))
        low = 1
        high = sum(abs(ls) for ls in lst)

        def compute(n):
            cnt = cur = 0
            for num in lst:
                cur += num
                if cur >= n:
                    cnt += 1
                    cur = 0
                cur = 0 if cur < 0 else cur
            return cnt

        def check1(n):
            return compute(n) >= k

        def check2(n):
            return compute(n) <= k

        ceil = BinarySearch().find_int_right(low, high, check1)
        if compute(ceil) != k:
            ac.st(-1)
            return
        floor = BinarySearch().find_int_left(low, high, check2)
        ac.lst([floor, ceil])
        return

    @staticmethod
    def lg_p5844(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5844
        tag: median_greedy|prefix_sum|binary_search|classical
        """
        n, m, b = ac.read_list_ints()
        pos = [ac.read_int() for _ in range(n)]
        ans = j = 0
        pre = ac.accumulate(pos)

        def check(x, y):
            mid = (x + y) // 2
            left = (mid - x) * pos[mid] - (pre[mid] - pre[x])
            right = pre[y + 1] - pre[mid + 1] - (y - mid) * pos[mid]
            return left + right

        for i in range(n):
            while j < n and check(i, j) <= b:
                j += 1
            ans = max(ans, j - i)
        ac.st(ans)
        return

    @staticmethod
    def lg_p5878(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5878
        tag: binary_search|brute_force
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]

        def check(num):
            cost = 0
            for x, y, sm, pm, sv, pv in nums:
                need = num * x - y
                if need <= 0:
                    continue
                cur = math.inf
                for i in range(need + 1):
                    rest = need - i * sm
                    if rest > 0:
                        cur = min(cur, i * pm + math.ceil(rest / sv) * pv)
                    else:
                        cur = min(cur, i * pm)
                        break
                cost += cur
                if cost > m:
                    return False

            return cost <= m

        ans = BinarySearch().find_int_right(0, m, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6058(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6058
        tag: dfs_order|binary_search
        """
        n, k = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y, z = ac.read_list_ints_minus_one()
            dct[x].append((y, z + 1))
        for i in range(n):
            dct[i].reverse()

        if n == 1:
            ac.st(0)
            exit()

        dis = [0] * n
        stack = [0]
        while stack:
            x = stack.pop()
            for y, w in dct[x]:
                dis[y] = dis[x] + w
                stack.append(y)

        def find_high():
            q = [(0, 0)]
            d = 0
            while q:
                a, s = q.pop()
                if a >= 0:
                    d += s
                    q.append((~a, s))
                    for b, dd in dct[a]:
                        q.append((b, dd))
                else:
                    d += s
            return d

        def check(t):
            q = [(0, 0)]
            d = 0
            res = 0
            while q:
                a, s = q.pop()
                if a >= 0:
                    d += s
                    q.append((~a, s))
                    for b, dd in dct[a]:
                        q.append((b, dd))
                else:
                    a = ~a
                    if not dct[a]:
                        if d + dis[a] > t:
                            res += 1
                            if res + 1 > k:
                                return False
                            d = dis[a]
                    d += s
            return res + 1 <= k

        low = max(dis) * 2
        high = find_high()
        ans = BinarySearch().find_int_left(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6069(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6069
        tag: math|binary_search|variance|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums.sort()

        def check(x):
            ss = s = 0
            for i in range(n):
                ss += nums[i] ** 2
                s += nums[i]
                if i >= x - 1:
                    # variance equation
                    if x * ss - s * s <= x * m:
                        return True
                    ss -= nums[i - x + 1] ** 2
                    s -= nums[i - x + 1]
            return False

        ans = BinarySearch().find_int_right(1, n, check)
        ac.st(n - ans)
        return

    @staticmethod
    def lg_p6733(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6733
        tag: binary_search|sorted_list
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: -it[1])

        def check(x):
            res = 0
            pre = SortedList()
            for a, c in nums:
                res += pre.bisect_right(a * c - x * a)
                pre.add(-(a * c - x * a))
                if res >= k:
                    return True
            return res >= k

        ans = BinarySearch().find_float_right(0, nums[0][1], check, 1e-3)
        ac.st(ans)
        return

    @staticmethod
    def lc_2594(ranks: List[int], cars: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-repair-cars/
        tag: binary_search
        """

        def check(x):
            res = 0
            for r in ranks:
                res += int((x / r) ** 0.5)
            return res >= cars

        return BinarySearch().find_int_left(0, ranks[0] * cars ** 2, check)

    @staticmethod
    def lc_2604(hens: List[int], grains: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-eat-all-grains/
        tag: binary_search|greedy|pointer
        """
        hens.sort()
        grains.sort()
        m, n = len(hens), len(grains)

        def check(x):
            i = 0
            for pos in hens:
                left = right = 0
                while i < n:
                    if grains[i] >= pos:
                        right = right if right > grains[i] - pos else grains[i] - pos
                    else:
                        left = left if left > pos - grains[i] else pos - grains[i]
                    if left * 2 + right <= x or right * 2 + left <= x:
                        i += 1
                    else:
                        break
                if i == n:
                    return True
            return False

        low = 0
        high = sum(abs(g - hens[0]) * 2 for g in grains)
        return BinarySearch().find_int_left(low, high, check)

    @staticmethod
    def lc_100123(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/
        tag: binary_search|greedy|median_greedy|brute_force
        """
        n = len(nums)
        nums.sort()
        pre = list(accumulate(nums, initial=0))

        def check(x):
            for mid in range(n - x + 1):
                right = mid + x - 1
                left = mid
                i = mid + x // 2
                cur = pre[right + 1] - pre[i + 1] - (right - i) * nums[i] + (i - left) * nums[i] - (pre[i] - pre[left])
                if cur <= k:
                    return True
            return False

        ans = BinarySearch().find_int_right(0, n, check)
        return ans

    @staticmethod
    def lg_p8161(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8161
        tag: greedy|binary_search|classical
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()

        def check(x):
            res = 0
            for i in range(n):
                if a[i] < b[i]:
                    res += (x + b[i] - 1) // b[i]
                else:
                    if m * a[i] >= x:
                        res += (x + a[i] - 1) // a[i]
                    else:
                        res += m
                        res += (x - a[i] * m + b[i] - 1) // b[i]
                if res > m * n:
                    return False
            return res <= m * n

        low = 0
        high = 10 ** 18
        ans = BinarySearch().find_int_right(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p8198(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8198
        tag: binary_search|pointer
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()

        def check(x):
            res = pre = 0
            for num in nums:
                if pre + num * num > x:
                    res += 1
                    pre = num * num
                else:
                    pre += num * num
            res += 1
            return res <= k

        low = max(nums) ** 2
        high = sum(num * num for num in nums)
        ans = BinarySearch().find_int_left(low, high, check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p9050(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9050
        tag: binary_search|data_range|greedy|implemention|classical
        """
        n = ac.read_int()
        if n == 1:
            ac.st("T")
            return

        nums = ac.read_list_ints()
        lst = sorted(nums)

        def check(x):
            flag = 1
            res = lst[x]
            for w in lst:
                if w == lst[x] and flag:
                    flag = 0
                    continue
                if res <= w:
                    return False
                res += w
            return True

        floor = BinarySearch().find_int_left(0, n - 1, check)
        if check(floor):
            ans = ["N" if nums[x] < lst[floor] else "T" for x in range(n)]
            ac.st("".join(ans))
        else:
            ac.st("N" * n)
        return

    @staticmethod
    def ac_3973(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3976/
        tag: high_precision|binary_search|sliding_window|two_pointers
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        pos = ac.read_list_ints()
        pos.sort()
        nums.sort()

        def check(x):
            i = 0
            for num in nums:
                while i < m and not (pos[i] - x <= num <= pos[i] + x):
                    i += 1
                if i == m:
                    return False
            return True

        ans = BinarySearch().find_float_left(0, 2 * 10 ** 9, check)
        if ans - int(ans) >= 0.5:
            ac.st(int(ans) + 1)
        else:
            ac.st(int(ans))
        return

    @staticmethod
    def ac_4866(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4866/
        tag: binary_search|pigeonhole_principle|classical
        """
        for _ in range(ac.read_int()):
            ac.read_str()
            m, n = ac.read_list_ints()
            grid = [ac.read_list_ints() for _ in range(m)]

            def check(x):
                row = [0] * m
                col = [0] * n
                for i in range(m):
                    for j in range(n):
                        if grid[i][j] >= x:
                            row[i] += 1
                            col[j] = 1
                if any(x == 0 for x in col):
                    return False
                if m <= n - 1:
                    return True
                return max(row) >= 2

            ac.st(BinarySearch().find_int_right(0, 10 ** 9, check))
        return

    @staticmethod
    def ac_5051(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/5051/
        tag: high_precision|binary_search|specific_plan
        """
        ac.read_int()
        nums = ac.read_list_ints()
        nums.sort()

        def compute(r):
            pre = -math.inf
            res = []
            for num in nums:
                if num > pre:
                    res.append(num + r)
                    pre = num + 2 * r
                    if len(res) > 3:
                        break
            return res

        def check(r):
            return len(compute(r)) <= 3

        x = BinarySearch().find_float_left(0, nums[-1] - nums[0], check, 1e-6)
        ac.st(x)
        ans = compute(x)
        while len(ans) < 3:
            ans.append(ans[-1] + 1)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/B
        tag: find_float_right
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]

        def check(x):
            return sum(num // x for num in nums) >= k

        ans = BinarySearch().find_float_right(0, max(nums), check)
        ac.st(ans)
        return

    @staticmethod
    def library_check_2(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/C
        tag: find_int_left
        """
        n, x, y = ac.read_list_ints()

        def check(t):
            return t // x + t // y >= n - 1

        ans = BinarySearch().find_int_left(0, n * (x + y), check) + min(x, y)
        ac.st(ans)
        return

    @staticmethod
    def library_check_3(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/6/2/practice/contest/283932/problem/D
        tag: find_int_left
        """
        m, n = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]

        def compute(tt):
            lst = []
            for t, z, y in nums:
                k1, k2 = divmod(tt, z * t + y)
                lst.append(k1 * z + min(k2 // t, z))
            return lst

        def check(tt):
            return sum(compute(tt)) >= m

        res = BinarySearch().find_int_left(0, m * 200, check)
        ans = compute(res)
        more = sum(ans) - m
        for i in range(n):
            x = min(ans[i], more)
            ans[i] -= x
            more -= x
        ac.st(res)
        ac.lst(ans)
        return

    @staticmethod
    def cf_1165f2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1165/problem/F2
        tag: reverse_order|greedy|classical|binary_search
        """
        n, m = ac.read_list_ints()
        cnt = [0] + ac.read_list_ints()
        k = 2 * 10 ** 5
        dct = [set() for _ in range(k + 1)]
        for _ in range(m):
            d, t = ac.read_list_ints()
            dct[d].add(t)

        def check(x):

            tmp = cnt[:]
            cur = [set() for _ in range(min(k + 1, x + 1))]
            pre = set()
            for dd in range(min(k, x), -1, -1):
                for tt in dct[dd]:
                    if tt not in pre:
                        pre.add(tt)
                        cur[dd].add(tt)
            pre = 0
            for dd in range(1, min(k + 1, x + 1)):
                pre += 1
                for tt in cur[dd]:
                    buy = min(pre, tmp[tt])
                    pre -= buy
                    tmp[tt] -= buy
            rest = sum(tmp) * 2
            day = min(k, x)
            if pre < rest:
                day += rest - pre
            return day <= x

        ans = BinarySearch().find_int_left(sum(cnt), sum(cnt) * 2, check)
        ac.st(ans)
        return

    @staticmethod
    def cf_1883g2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1883/problem/G2
        tag: binary_search|greedy|sorted_list
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            a = [1] + ac.read_list_ints()
            lst = SortedList(a)

            b = ac.read_list_ints()
            b.sort()

            def compute(x):
                lst.discard(1)
                lst.add(x)
                res = j = 0
                for num in lst:
                    while j < n and b[j] <= num:
                        j += 1
                    res += j < n
                    j += 1
                lst.add(1)
                lst.discard(x)
                return n - res

            def check(x):
                return compute(x) <= pre

            pre = compute(1)
            ceil = BinarySearch().find_int_right(1, m, check)
            ans = pre * ceil + (pre + 1) * (m - ceil)
            ac.st(ans)
        return

    @staticmethod
    def abc_324f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc324/tasks/abc324_f
        tag: binary_search|dag_dp|find_float_right|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            u, v, bb, cc = ac.read_list_ints()
            u -= 1
            v -= 1
            dct[u].append((v, bb, cc))
            degree[v] += 1

        def check(s):
            dp = [-math.inf] * n
            dp[0] = 0
            for i in range(n):
                for j, b, c in dct[i]:
                    dp[j] = max(dp[j], dp[i] + b - s * c)
            return dp[-1] >= 0

        ans = BinarySearch().find_float_right(0, 2 * 10 ** 9, check, 10 ** (-10))
        ac.st(ans)
        return

    @staticmethod
    def lc_100267(coins: List[int], k: int) -> int:
        """
        url: https://leetcode.com/contest/weekly-contest-393/problems/kth-smallest-amount-with-single-denomination-combination/
        tag: inclusion_exclusion|binary_search|math|classical
        """
        n = len(coins)
        dct = defaultdict(list)
        for i in range(1, 1 << n):
            lst = [coins[x] for x in range(n) if i & (1 << x)]
            dct[len(lst)].append(reduce(math.lcm, lst))

        def check(s):
            res = 0
            for num in dct:
                sign = (-1) ** (num - 1)
                for val in dct[num]:
                    res += sign * (s // val)
            return res >= k

        ans = BinarySearch().find_int_left(0, min(coins) * k, check)
        return ans

    @staticmethod
    def abc_246d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc246/tasks/abc246_d
        tag: binary_search|brute_force
        """
        n = ac.read_int()
        ans = math.inf

        def check(b):
            return a * a * a + a * a * b + a * b * b + b * b * b >= n

        pre = n
        for a in range(10 ** 6 + 1):
            bb = BinarySearch().find_int_left(a, pre, check)
            ans = min(ans, a * a * a + a * a * bb + a * bb * bb + bb * bb * bb)
            pre = bb
            if a > bb:
                break
        ac.st(ans)
        return

    @staticmethod
    def abc_236e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc236/tasks/abc236_e
        tag: median|average|dp|greedy|binary_search|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [0] * (n + 1)

        def check(x):
            dp[1] = nums[0] - x
            for i in range(1, n):
                dp[i + 1] = max(dp[i], dp[i - 1]) + nums[i] - x
            return max(dp[-1], dp[-2]) >= 0

        ans = BinarySearch().find_float_right(0, max(nums), check)
        ac.st(ans)

        def check(x):
            dp[0] = 0
            dp[1] = int(nums[0] >= x)
            for i in range(1, n):
                dp[i + 1] = 0
                if nums[i] >= x:
                    dp[i + 1] = 1
                else:
                    if not dp[i]:
                        dp[i + 1] = 1
            ceil = sum(num >= x for num in nums)
            tot = sum(dp)
            return ceil >= tot - ceil if tot % 2 else ceil >= tot // 2 + 1

        ans = BinarySearch().find_int_right(0, max(nums), check)
        ac.st(ans)
        return

    @staticmethod
    def abc_215f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc215/tasks/abc215_f
        tag: two_pointers|binary_search|sort|brain_teaser
        """
        n = ac.read_int()

        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort()
        pre_min = [math.inf] * (n + 1)
        pre_max = [-math.inf] * (n + 1)
        for i in range(n):
            _, y = nums[i]
            pre_min[i + 1] = min(pre_min[i], y)
            pre_max[i + 1] = max(pre_max[i], y)

        post_min = [math.inf] * (n + 1)
        post_max = [-math.inf] * (n + 1)
        for i in range(n - 1, -1, -1):
            _, y = nums[i]
            post_min[i] = min(post_min[i + 1], y)
            post_max[i] = max(post_max[i + 1], y)

        def check(x):
            jj = 0
            for ii in range(n):
                xx, _ = nums[ii]
                while jj < n and nums[jj][0] - xx < x:
                    jj += 1
                if jj == n:
                    return False
                for a in [pre_min[ii + 1], pre_max[ii + 1]]:
                    for c in [post_min[jj], post_max[jj]]:
                        if abs(a - c) >= x:
                            return True
            return False

        ans = BinarySearch().find_int_right(0, 10 ** 9, check)
        ac.st(ans)
        return

    @staticmethod
    def cf_1843e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1843/E
        tag: binary_search|query_order|classical
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            ran = [ac.read_list_ints_minus_one() for _ in range(m)]
            q = ac.read_int()
            change = [ac.read_int() - 1 for _ in range(q)]

            def check(x):
                lst = [0]*n
                for i in change[:x]:
                    lst[i] = 1
                pre = ac.accumulate(lst)
                for a, b in ran:
                    one = pre[b+1]-pre[a]
                    if b-a+1-one < one:
                        return True
                return False

            ans = BinarySearch().find_int_left(0, q, check)
            if check(ans):
                ac.st(ans)
            else:
                ac.st(-1)
        return

    @staticmethod
    def cf_1288d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1288/problem/D
        tag: binary_search|bit_masks
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        tot = (1 << m) - 1
        low = [min(lst) for lst in nums]

        def compute(x):
            pre = [-1] * (1 << m)
            for i, lst in enumerate(nums):
                if low[i] >= x:
                    return [i, i]
                cur = 0
                for num in lst:
                    cur = cur * 2 + int(num >= x)
                mask = cur
                nex = []
                while cur:
                    if pre[cur ^ tot] != -1:
                        return [pre[cur ^ tot], i]
                    nex.append(cur)
                    cur = (cur - 1) & mask
                nex.append(cur)
                for xx in nex:
                    pre[xx] = i
            return []

        def check(x):
            return len(compute(x)) > 0

        ans = BinarySearch().find_int_right(max(low), 10 ** 9, check)
        ac.lst([x + 1 for x in compute(ans)])
        return

    @staticmethod
    def cf_1393c_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1393/C
        tag: binary_search|implemention|stack|classical|math
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            dct = list(Counter(nums).values())

            def check(x):
                total = [(0, -c) for c in dct]
                now = []
                for i in range(n):
                    while total and total[0][0] <= i:
                        _, y = heapq.heappop(total)
                        heapq.heappush(now, y)
                    if not now:
                        return False
                    y = heapq.heappop(now)
                    y += 1
                    if y:
                        heapq.heappush(total, (i + x + 1, y))
                return True

            ans = BinarySearch().find_int_right(0, n, check)
            ac.st(ans)
        return

    @staticmethod
    def cf_1393c_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1393/C
        tag: binary_search|implemention|stack|classical|math
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            dct = Counter(Counter(nums).values())
            ceil = max(dct)
            cnt = dct[ceil]
            ans = (n - cnt * ceil) // (ceil - 1) + cnt - 1
            ac.st(ans)
        return


    @staticmethod
    def cf_1117c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1117/C
        tag: binary_search|observation|brain_teaser
        """
        x1, y1 = ac.read_list_ints()
        x2, y2 = ac.read_list_ints()
        n = ac.read_int()
        s = ac.read_str()
        pre_x = [0] * (n + 1)
        pre_y = [0] * (n + 1)

        for i, w in enumerate(s):
            if w == "L":
                pre_x[i + 1] = pre_x[i] - 1
                pre_y[i + 1] = pre_y[i]
            elif w == "R":
                pre_x[i + 1] = pre_x[i] + 1
                pre_y[i + 1] = pre_y[i]
            elif w == "U":
                pre_x[i + 1] = pre_x[i]
                pre_y[i + 1] = pre_y[i] + 1
            else:
                pre_x[i + 1] = pre_x[i]
                pre_y[i + 1] = pre_y[i] - 1

        def check(d):
            xx = pre_x[-1] * (d // n) + pre_x[d % n]
            yy = pre_y[-1] * (d // n) + pre_y[d % n]

            return abs(x1 + xx - x2) + abs(y1 + yy - y2) <= d

        ans = BinarySearch().find_int_left(0, 10 ** 20, check)
        ac.st(ans if ans < 10 ** 20 else -1)
        return

    @staticmethod
    def cf_1379c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1379/problem/C
        tag: observation|prefix_sum|binary_search|brute_force|greedy
        """
        q = ac.read_int()
        for i in range(q):
            if i:
                ac.read_str()
            n, m = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(m)]
            nums.sort(reverse=True)

            lst = [a for a, _ in nums]
            pre = ac.accumulate(lst)
            ans = sum(lst[:n])

            if n == 1:
                ac.st(ans)
                continue

            def check(x):
                if x == -1:
                    return True
                if lst[x] < b:
                    return False
                c = x + 1
                if j <= x:
                    c -= 1
                return c <= n - 2

            for j, (a, b) in enumerate(nums):
                i = BinarySearch().find_int_right(-1, m - 1, check)

                if i < j:
                    cur = pre[i + 1] + (n - i - 2) * b + a
                else:
                    cur = pre[i + 1] + (n - i - 1) * b

                ans = max(ans, cur)
            ac.st(ans)
        return

    @staticmethod
    def cf_1679d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1679/D
        tag: binary_search|graph|longest_path
        """
        n, m, k = ac.read_list_ints()
        a = ac.read_list_ints()
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        dct = [[] for _ in range(n)]
        degree = [0] * n
        depth = [-2] * n

        def check(x):
            for i in range(n):
                degree[i] = 0
                dct[i] = []
                depth[i] = -2
            for i, j in edges:
                if a[i] <= x and a[j] <= x:
                    dct[i].append(j)
                    degree[j] += 1

            stack = [i for i in range(n) if not degree[i] and a[i] <= x]
            for i in stack:
                depth[i] = 0
            while stack:
                i = stack.pop()
                for j in dct[i]:
                    degree[j] -= 1
                    if depth[j] < depth[i] + 1:
                        depth[j] = depth[i] + 1
                    if depth[j] >= k - 1:
                        return True
                    if not degree[j]:
                        stack.append(j)
            for i in range(n):
                if a[i] <= x:
                    if degree[i] > 0 or depth[i] >= k - 1:
                        return True
            return False

        ceil = 10 ** 9 + 1
        ans = BinarySearch().find_int_left(1, ceil, check)
        ac.st(ans if ans < ceil else -1)
        return

    @staticmethod
    def abc_203d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc203/tasks/abc203_d
        tag: binary_search|prefix_sum
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        cnt = (k * k) // 2 + 1

        def check(x):
            grid = [[num <= x for num in lls] for lls in nums]
            pre = PreFixSumMatrix(grid)
            for i in range(n - k + 1):
                for j in range(n - k + 1):
                    if pre.query(i, j, i + k - 1, j + k - 1) >= k * k - cnt + 1:
                        return True
            return False

        ans = BinarySearch().find_int_left(0, 10 ** 9, check)
        ac.st(ans)
        return

    @staticmethod
    def cf_1610c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1610/C
        tag: binary_search|brain_teaser|monotonic_property
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            a = []
            b = []
            for _ in range(n):
                x, y = ac.read_list_ints()
                a.append(x)
                b.append(y)

            def check(num):
                cnt = 0
                for i in range(n):
                    if a[i] >= num - cnt - 1 and b[i] >= cnt:
                        cnt += 1
                return cnt >= num

            ans = BinarySearch().find_int_right(1, n, check)
            ac.st(ans)
        return

    @staticmethod
    def cf_1946c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1946/C
        tag: binary_search|point_head|tree_dp|greedy
        """

        class Graph(UnWeightedTree):
            def tree_dp(self, x):
                sub = [0] * self.n
                parent = [0] * self.n
                stack = [0]
                res = 0
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        sub[i] = 1
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                sub[i] += sub[j]
                            ind = self.edge_next[ind]
                        if sub[i] >= x:
                            res += 1
                            sub[i] = 0
                return res

        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            graph = Graph(n)
            for _ in range(n - 1):
                u, v = ac.read_list_ints_minus_one()
                graph.add_undirected_edge(u, v)

            def check(x):
                return graph.tree_dp(x) >= k + 1

            ans = BinarySearch().find_int_right(1, n, check)
            ac.st(ans)
        return

    @staticmethod
    def cf_1168a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1168/A
        tag: binary_search|brain_teaser|greedy
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        def check(x):
            pre = 0
            for i in range(n):
                if nums[i] == pre:
                    continue
                if nums[i] > pre:
                    if m - nums[i] + pre > x:
                        pre = nums[i]
                else:
                    if pre - nums[i] > x:
                        return False
            return True

        ans = BinarySearch().find_int_left(0, sum(m - num for num in nums), check)
        ac.st(ans)
        return
"""
Algorithm：brute_force|matrix_rotate|matrix_spiral|contribution_method
Description：brute force according to the data range

====================================LeetCode====================================
670（https://leetcode.cn/problems/maximum-swap/）greedy|brute_force
395（https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/）brute_force|divide_and_conquer
1330（https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/）brute_force
2488（https://leetcode.cn/problems/count-subarrays-with-median-k/）median|brute_force|pre_consequence|post_consequence
2484（https://leetcode.cn/problems/count-palindromic-subsequences/）prefix_suffix|hash|brute_force|palindrome_substring
2322（https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/）brute_force|tree_dp|union_find|xor_min
2321（https://leetcode.cn/problems/maximum-score-of-spliced-array/）brute_force
2306（https://leetcode.cn/problems/naming-a-company/）alphabet|brute_force
2272（https://leetcode.cn/problems/substring-with-largest-variance/）alphabet|brute_force
2183（https://leetcode.cn/problems/count-array-pairs-divisible-by-k/）gcd|brute_force
2151（https://leetcode.cn/problems/maximum-good-people-based-on-statements/）state_compression|brute_force
2147（https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/）brute_force|counter
2122（https://leetcode.cn/problems/recover-the-original-array/）brute_force
2468（https://leetcode.cn/problems/split-message-based-on-limit/）binary_search
2417（https://leetcode.cn/problems/closest-fair-integer/）digit|greedy|brute_force
2681（https://leetcode.cn/problems/power-of-heroes/）contribution_method|brute_force|counter
1625（https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/）brute_force|lexicographical_order
1819（https://leetcode.cn/problems/number-of-different-subsequences-gcds/）harmonic_progression|brute_force
1862（https://leetcode.cn/submissions/detail/371754298/）brute_force|harmonic_progression
2014（https://leetcode.cn/problems/longest-subsequence-repeated-k-times/）data_range|brute_force|greedy|permutations
2077（https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/）bit_operation|brute_force
2081（https://leetcode.cn/problems/sum-of-k-mirror-numbers/）palindrome_num|base_n|brute_force
2170（https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/）brute_force|secondary_maximum
1215（https://leetcode.cn/problems/stepping-numbers/）data_range|back_trace|brute_force
2245（https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/）prefix_sum|brute_force
1878（https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/）prefix_sum|brute_force
2018（https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/description/）brute_force
2591（https://leetcode.cn/problems/distribute-money-to-maximum-children/）brute_force
910（https://leetcode.cn/problems/smallest-range-ii/description/）brute_force|data_range
1131（https://leetcode.cn/problems/maximum-of-absolute-value-expression/description/）manhattan_distance|brute_force
1761（https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/）directed_graph|undirected_graph|brute_force
1178（https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/）hash|counter|brute_force|bit_operation
1638（https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/description/）brute_force|dp|brute_force
2212（https://leetcode.cn/problems/maximum-points-in-an-archery-competition/）bit_operation|brute_force|back_trace
2749（https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/）brute_force|bit_operation
2094（https://leetcode.cn/problems/finding-3-digit-even-numbers/description/）brain_teaser|brute_force|data_range
842（https://leetcode.cn/problems/split-array-into-fibonacci-sequence/description/）brain_teaser|brute_force|back_trace
2122（https://leetcode.cn/problems/recover-the-original-array/）brute_force|hash|implemention
1782（https://leetcode.cn/problems/count-pairs-of-nodes/description/）brute_force
3102（https://leetcode.cn/problems/minimize-manhattan-distances/）manhattan_distance|brain_teaser|implemention|prefix_suffix|classical
100406（https://leetcode.com/problems/find-the-count-of-good-integers/）brute_force|palindrome_num

=====================================LuoGu======================================
P1548（https://www.luogu.com.cn/problem/P1548）brute_force
P1632（https://www.luogu.com.cn/problem/P1632）brute_force
P2128（https://www.luogu.com.cn/problem/P2128）brute_force
P2191（https://www.luogu.com.cn/problem/P2191）reverse_thinking|matrix_rotate
P2699（https://www.luogu.com.cn/problem/P2699）classification_discussion|brute_force|implemention
P1371（https://www.luogu.com.cn/problem/P1371）prefix_suffix|brute_force|counter
P1369（https://www.luogu.com.cn/problem/P1369）matrix_dp|greedy|brute_force
P1158（https://www.luogu.com.cn/problem/P1158）sort|brute_force|suffix_maximum
P8928（https://www.luogu.com.cn/problem/P8928）brute_force|counter
P8892（https://www.luogu.com.cn/problem/P8892）brute_force
P8799（https://www.luogu.com.cn/problem/P8799）brute_force
P3142（https://www.luogu.com.cn/problem/P3142）brute_force|sorted_list
P3143（https://www.luogu.com.cn/problem/P3143）brute_force|prefix_suffix
P3670（https://www.luogu.com.cn/problem/P3670）hash|brute_force|counter
P3799（https://www.luogu.com.cn/problem/P3799）brute_force|regular_triangle
P3910（https://www.luogu.com.cn/problem/P3910）factorization|brute_force
P4086（https://www.luogu.com.cn/problem/P4086）suffix|reverse_order|brute_force
P4596（https://www.luogu.com.cn/problem/P4596）brute_force
P4759（https://www.luogu.com.cn/problem/P4759）factorization|brute_force
P6267（https://www.luogu.com.cn/problem/P6267）factorization|brute_force
P5077（https://www.luogu.com.cn/problem/P5077）factorization|brute_force可
P4960（https://www.luogu.com.cn/problem/P4960）implemention|brute_force
P4994（https://www.luogu.com.cn/problem/P4994）implemention|pi(n)<=6n
P5190（https://www.luogu.com.cn/problem/P5190）counter|prefix_sum|harmonic_progression|O(nlogn)
P5614（https://www.luogu.com.cn/problem/P5614）brute_force
P6014（https://www.luogu.com.cn/problem/P6014）hash|mod|counter
P6067（https://www.luogu.com.cn/problem/P6067）sort|prefix_suffix|brute_force
P6248（https://www.luogu.com.cn/problem/P6248）brute_force
P6355（https://www.luogu.com.cn/problem/P6355）brute_force|triangle|counter
P6365（https://www.luogu.com.cn/problem/P6365）inclusion_exclusion|brute_force|counter
P6439（https://www.luogu.com.cn/problem/P6439）brute_force
P6686（https://www.luogu.com.cn/problem/P6686）brute_force|triangle|counter
P2666（https://www.luogu.com.cn/problem/P2666）brute_force|counter
P2705（https://www.luogu.com.cn/problem/P2705）brute_force
P5690（https://www.luogu.com.cn/problem/P5690）brute_force
P7076（https://www.luogu.com.cn/problem/P7076）bit_operation|brute_force|counter
P7094（https://www.luogu.com.cn/problem/P7094）math|data_range|brute_force
P7273（https://www.luogu.com.cn/problem/P7273）brute_force|math|greedy
P7286（https://www.luogu.com.cn/problem/P7286）sort|brute_force|counter
P7626（https://www.luogu.com.cn/problem/P7626）brute_force|matrix|diagonal
P7799（https://www.luogu.com.cn/problem/P7799）hash|brute_force|counter
P1018（https://www.luogu.com.cn/problem/P1018）brute_force
P1311（https://www.luogu.com.cn/problem/P1311）brute_force|counter
P2119（https://www.luogu.com.cn/problem/P2119）brute_force|prefix_suffix|counter
P2652（https://www.luogu.com.cn/problem/P2652）brute_force|two_pointers
P2994（https://www.luogu.com.cn/problem/P2994）brute_force
P3985（https://www.luogu.com.cn/problem/P3985）brute_force
P4181（https://www.luogu.com.cn/problem/P4181）greedy|brute_force|suffix_sum
P6149（https://www.luogu.com.cn/problem/P6149）brute_force|triangle|prefix_sum|binary_search
P6393（https://www.luogu.com.cn/problem/P6393）data_range|brute_force
P6767（https://www.luogu.com.cn/problem/P6767）brute_force
P8270（https://www.luogu.com.cn/problem/P8270）brain_teaser|brute_force
P8587（https://www.luogu.com.cn/problem/P8587）bucket_counter|brute_force
P8663（https://www.luogu.com.cn/problem/P8663）bucket_counter|brute_force
P8672（https://www.luogu.com.cn/problem/P8672）string|brute_force|permutation_circle|counter
P8712（https://www.luogu.com.cn/problem/P8712）brute_force
P8749（https://www.luogu.com.cn/problem/P8749）yanghui_triangle|brute_force
P8808（https://www.luogu.com.cn/problem/P8808）fibonacci|brute_force
P8809（https://www.luogu.com.cn/problem/P8809）brute_force|contribution_method|counter
P9076（https://www.luogu.com.cn/problem/P9076）factorization|brute_force
P9008（https://www.luogu.com.cn/problem/P9008）inclusion_exclusion|brute_force|counter
P9006（https://www.luogu.com.cn/problem/P9006）brute_force|mod|counter
P8948（https://www.luogu.com.cn/problem/P8948）brute_force
P8894（https://www.luogu.com.cn/problem/P8894）data_range|brute_force|prefix_suffix|counter
P8872（https://www.luogu.com.cn/problem/P8872）sort|prefix_suffix|brute_force
P1989（https://www.luogu.com.cn/problem/P1989）ternary_circle|dag|build_graph|counter|brute_force|classical
P8599（https://www.luogu.com.cn/problem/P8599）brute_force

===================================CodeForces===================================
1426F（https://codeforces.com/problemset/problem/1426/F）classification_discussion|brute_force|counter|fast_power
1400D（https://codeforces.com/problemset/problem/1400/D）brute_force|binary_search
1793D（https://codeforces.com/contest/1793/problem/D）brute_force|counter
584D（https://codeforces.com/problemset/problem/584/D）brute_force|prime|decompose_into_sum_of_prime_at_most_3
1311D（https://codeforces.com/problemset/problem/1311/D）greedy|brute_force
1181C（https://codeforces.com/problemset/problem/1181/C）column_wised|brute_force
484B（https://codeforces.com/problemset/problem/484/B）sort|brute_force|binary_search
382C（https://codeforces.com/problemset/problem/382/C）classification_discussion
988E（https://codeforces.com/contest/988/problem/E）brain_teaser|greedy|brute_force
1661B（https://codeforces.com/contest/1661/problem/B）brute_force
1692F（https://codeforces.com/contest/1692/problem/F）brute_force
978D（https://codeforces.com/contest/978/problem/D）brute_force
1029D（https://codeforces.com/contest/1029/problem/D）brute_force|hash|math
1029C（https://codeforces.com/contest/1029/problem/C）classical|prefix_suffix|brute_force
1077E（https://codeforces.com/contest/1077/problem/E）brute_force|data_range
1203D2（https://codeforces.com/contest/1203/problem/D2）brute_force|data_range|prefix_suffix
1216E2（https://codeforces.com/contest/1216/problem/E2）brute_force|data_range|classical
1328F（https://codeforces.com/contest/1328/problem/F）brute_force|prefix_sum|binary_search
1426F（https://codeforces.com/contest/1426/problem/F）brute_force|implemention
1618F（https://codeforces.com/contest/1618/problem/F）brute_force|bfs|data_range
1744F（https://codeforces.com/contest/1744/problem/F）brute_force
1729F（https://codeforces.com/contest/1729/problem/F）brute_force
1846E2（https://codeforces.com/contest/1846/problem/E2）brute_force|binary_search
1926F（https://codeforces.com/contest/1926/problem/F）brute_force|greedy|classical
1689D（https://codeforces.com/contest/1689/problem/D）manhattan_distance|prefix_suffix|classical
1992E（https://codeforces.com/contest/1992/problem/E）brute_force|observation|data_range
1648B（https://codeforces.com/problemset/problem/1648/B）observation|brute_force|data_range|euler_series
466B（https://codeforces.com/problemset/problem/466/B）observation|brute_force
1804C（https://codeforces.com/problemset/problem/1804/C）brute_force|math

====================================AtCoder=====================================
ARC060B（https://atcoder.jp/contests/abc044/tasks/arc060_b）base|classification_discussion|brute_force|factorization
ARC069B（https://atcoder.jp/contests/abc055/tasks/arc069_b）brain_teaser|brute_force
ARC072A（https://atcoder.jp/contests/abc059/tasks/arc072_a）brute_force|prefix_sum|greedy
ARC074A（https://atcoder.jp/contests/abc062/tasks/arc074_a）brute_force
ARC083A（https://atcoder.jp/contests/abc074/tasks/arc083_a）brute_force|math
ARC091B（https://atcoder.jp/contests/abc090/tasks/arc091_b）brute_force
ABC085D（https://atcoder.jp/contests/abc085/tasks/abc085_d）brute_force
ABC338C（https://atcoder.jp/contests/abc338/tasks/abc338_c）brute_force|data_range
ABC334C（https://atcoder.jp/contests/abc334/tasks/abc334_c）brute_force|prefix_suffix
ABC330D（https://atcoder.jp/contests/abc330/tasks/abc330_d）brute_force|prefix_sum
ABC330C（https://atcoder.jp/contests/abc330/tasks/abc330_c）brute_force|prefix_sum
ABC324D（https://atcoder.jp/contests/abc324/tasks/abc324_d）brute_force
ABC323F（https://atcoder.jp/contests/abc323/tasks/abc323_f）brute_force
ABC320C（https://atcoder.jp/contests/abc320/tasks/abc320_c）brute_force
ABC319C（https://atcoder.jp/contests/abc319/tasks/abc319_c）brute_force
ABC310D（https://atcoder.jp/contests/abc310/tasks/abc310_d）brute_force|implemention|state_compression
ABC307C（https://atcoder.jp/contests/abc307/tasks/abc307_c）brute_force|implemention
ABC345D（https://atcoder.jp/contests/abc345/tasks/abc345_d）brute_force|implemention
ABC345C（https://atcoder.jp/contests/abc345/tasks/abc345_c）contribution_method
ABC302G（https://atcoder.jp/contests/abc302/tasks/abc302_g）brute_force
ABC300F（https://atcoder.jp/contests/abc300/tasks/abc300_f）brute_force|circular_array|prefix_sum|greedy
ABC296D（https://atcoder.jp/contests/abc296/tasks/abc296_d）brute_force|math
ABC346D（https://atcoder.jp/contests/abc346/tasks/abc346_d）brute_force|prefix_suffix
ABC290E（https://atcoder.jp/contests/abc290/tasks/abc290_e）brute_force|contribution_method
ABC178E（https://atcoder.jp/contests/abc178/tasks/abc178_e）manhattan_distance|prefix_suffix|classical
ABC260F（https://atcoder.jp/contests/abc260/tasks/abc260_f）brute_force|data_range|brain_teaser|classical
ABC255E（https://atcoder.jp/contests/abc255/tasks/abc255_e）brute_force|hash|counter|contribution_method|data_range
ABC256C（https://atcoder.jp/contests/abc256/tasks/abc256_c）brute_force
ABC252C（https://atcoder.jp/contests/abc252/tasks/abc252_c）brute_force
ABC251C（https://atcoder.jp/contests/abc251/tasks/abc251_c）brute_force
ABC249D（https://atcoder.jp/contests/abc249/tasks/abc249_d）euler_series|nlogn|brute_force|contribution_method|classical
ABC246F（https://atcoder.jp/contests/abc246/tasks/abc246_f）brute_force|inclusion_exclusion|math|counter|bit_operation
ABC247F（https://atcoder.jp/contests/abc247/tasks/abc247_f）brute_force|guess_table|union_find|dp|brain_teaser
ABC247E（https://atcoder.jp/contests/abc247/tasks/abc247_e）inclusion_exclusion|two_pointers|counter|brain_teaser|classical
ABC238C（https://atcoder.jp/contests/abc238/tasks/abc238_c）digit_num|counter|brute_force|classical
ABC234E（https://atcoder.jp/contests/abc234/tasks/abc234_e）brute_force|data_range|classical
ABC232C（https://atcoder.jp/contests/abc232/tasks/abc232_c）brute_force|implemention
ABC230C（https://atcoder.jp/contests/abc230/tasks/abc230_c）brute_force|implemention
ABC223E（https://atcoder.jp/contests/abc223/tasks/abc223_e）brute_force|implemention
ABC353D（https://atcoder.jp/contests/abc353/tasks/abc353_d）contribution_method|implemention
ABC220E（https://atcoder.jp/contests/abc220/tasks/abc220_e）contribution_method|classical|brute_force|binary_tree
ABC219E（https://atcoder.jp/contests/abc219/tasks/abc219_e）brute_force|union_find|brain_teaser
ABC366E（https://atcoder.jp/contests/abc366/tasks/abc366_e）brute_force|prefix_suffix
ABC198D（https://atcoder.jp/contests/abc198/tasks/abc198_d）brute_force|permutation

===================================CodeForces===================================
1971F（https://codeforces.com/contest/1971/problem/F）brute_force|high_precision
1422C（https://codeforces.com/problemset/problem/1422/C）contribution_method|brute_force
451D（https://codeforces.com/problemset/problem/451/D）contribution_method|brute_force
1995B2（https://codeforces.com/problemset/problem/1995/B2）brute_force
1379B（https://codeforces.com/problemset/problem/1379/B）brute_force

=====================================AcWing=====================================
97（https://www.acwing.com/problem/content/description/97/）brute_force

=====================================CodeChef=====================================
1（https://www.codechef.com/problems/GRAPHCOST）prefix_suffix|brute_force|brain_teaser

"""
import bisect
import math
from collections import defaultdict, deque, Counter
from functools import reduce, lru_cache
from itertools import combinations, permutations
from operator import mul, or_, and_
from typing import List

from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def cf_1311d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1311/D
        tag: greedy|brute_force|specific_plan|data_range|classical
        """
        for _ in range(ac.read_int()):
            a, b, c = ac.read_list_ints()
            ans = math.inf
            res = []
            for x in range(1, 2 * a + 1):
                for y in range(x, 2 * b + 1, x):
                    if y % x == 0:
                        for z in [(c // y) * y, (c // y) * y + y]:
                            cost = abs(a - x) + abs(b - y) + abs(c - z)
                            if cost < ans:
                                ans = cost
                                res = [x, y, z]
            ac.st(ans)
            ac.lst(res)
        return

    @staticmethod
    def cf_584d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/584/D
        tag: brute_force|prime|decompose_into_sum_of_prime_at_most_3|classical
        """

        def is_prime4(x):
            if x == 1:
                return False
            if (x == 2) or (x == 3):
                return True
            if (x % 6 != 1) and (x % 6 != 5):
                return False
            for ii in range(5, int(math.sqrt(x)) + 1, 6):
                if (x % ii == 0) or (x % (ii + 2) == 0):
                    return False
            return True

        n = ac.read_int()
        assert 3 <= n < 10 ** 9

        if is_prime4(n):
            ac.st(1)
            ac.st(n)
            return

        # there is a fact that the distance between adjacent prime numbers is not big
        # for n=10**9 the maximal distance is 282
        for i in range(2, 10 ** 5):
            j = n - 3 - i
            if is_prime4(i) and is_prime4(j):
                ac.st(3)
                ac.lst([3, i, j])
                return
        return

    @staticmethod
    def lc_670(num: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-swap/
        tag: greedy|brute_force
        """

        def check():  # greedy
            lst = list(str(num))
            n = len(lst)
            post = list(range(n))
            j = n - 1
            for i in range(n - 2, -1, -1):
                if lst[i] > lst[j]:
                    j = i
                if lst[j] > lst[i]:
                    post[i] = j

            for i in range(n):
                if post[i] != i:
                    lst[i], lst[post[i]] = lst[post[i]], lst[i]
                    return int("".join(lst))
            return int("".join(lst))

        def check2():  # brute_force
            lst = list(str(num))
            n = len(lst)
            ans = num
            for item in combinations(list(range(n)), 2):
                cur = lst[:]
                i, j = item
                cur[i], cur[j] = cur[j], cur[i]
                x = int("".join(cur))
                ans = ans if ans > x else x
            return ans

        check()
        return check2()

    @staticmethod
    def cf_484b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/484/B
        tag: sort|brute_force|binary_search|classical|maximum_mod_pair|euler_series|O(nlogn)
        """
        ac.read_int()
        nums = sorted(list(set(ac.read_list_ints())))
        n = len(nums)
        ceil = nums[-1]

        dp = [0] * (ceil + 1)
        i = 0
        for x in range(1, ceil + 1):
            dp[x] = dp[x - 1]
            while i < n and nums[i] <= x:
                dp[x] = nums[i]
                i += 1

        ans = 0
        for num in nums:
            x = 1
            while x * num <= ceil:
                x += 1
                for a in [x * num - 1]:
                    ans = max(ans, dp[min(a, ceil)] % num)
        ac.st(ans)
        return

    @staticmethod
    def cf_382c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/382/C
        tag: classification_discussion|brute_force
        """
        n = ac.read_int()
        nums = sorted(ac.read_list_ints())

        if n == 1:
            ac.st(-1)
            return

        diff = [nums[i] - nums[i - 1] for i in range(1, n)]
        high = max(diff)
        low = min(diff)
        cnt = len(set(diff))

        if cnt >= 3:
            ac.st(0)
            return
        elif cnt == 2:
            if high != 2 * low or diff.count(high) != 1:
                ac.st(0)
                return

            for i in range(1, n):
                if nums[i] - nums[i - 1] == high:
                    ac.st(1)
                    ac.st(nums[i - 1] + low)
                    return
        else:
            if low == high == 0:
                ac.st(1)
                ac.st(nums[0])
                return
            if n == 2:
                if low % 2 == 0:
                    ac.st(3)
                    ac.lst([nums[0] - low, nums[0] + low // 2, nums[1] + low])
                else:
                    ac.st(2)
                    ac.lst([nums[0] - low, nums[1] + low])
            else:
                ac.st(2)
                ac.lst([nums[0] - low, nums[-1] + low])
        return

    @staticmethod
    def arc_060b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc044/tasks/arc060_b
        tag: n_base|classification_discussion|brute_force|factorization|math

        """

        def check():
            lst = []
            num = n
            while num:
                lst.append(num % b)
                num //= b
            return sum(lst) == s

        n = ac.read_int()
        s = ac.read_int()
        if s > n:
            ac.st(-1)
        elif s == n:
            ac.st(n + 1)
        else:
            ans = math.inf
            for x in range(1, n - s + 1):
                if x * x > n - s:
                    break
                if (n - s) % x == 0:
                    # brute_force (n-s) % (b-1) == 0
                    y = (n - s) // x
                    b = x + 1
                    if check():
                        ans = b if ans > b else ans
                    b = y + 1
                    if check():
                        ans = b if ans > b else ans
            ac.st(-1 if ans == math.inf else ans)
        return

    @staticmethod
    def abc_072a(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc059/tasks/arc072_a
        tag: brute_force|prefix_sum|greedy
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ans1 = 0
        pre = 0
        for i in range(n):
            pre += nums[i]
            if i % 2 == 0:
                if pre <= 0:
                    ans1 += 1 - pre
                    pre = 1
            else:
                if pre >= 0:
                    ans1 += pre + 1
                    pre = -1
        ans2 = 0
        pre = 0
        for i in range(n):
            pre += nums[i]
            if i % 2 == 1:
                if pre <= 0:
                    ans2 += 1 - pre
                    pre = 1
            else:
                if pre >= 0:
                    ans2 += pre + 1
                    pre = -1
        ac.st(min(ans1, ans2))
        return

    @staticmethod
    def abc_074a(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc062/tasks/arc074_a
        tag: brute_force
        """
        m, n = ac.read_list_ints()

        def check1():
            nonlocal ans
            for x in range(1, m):
                lst = [x * n, (m - x) * (n // 2), (m - x) * (n // 2 + n % 2)]
                cur = max(lst) - min(lst)
                if cur < ans:
                    ans = cur
            return

        def check2():
            nonlocal ans
            for x in range(1, m - 1):
                lst = [x * n, ((m - x) // 2) * n, ((m - x) // 2 + (m - x) % 2) * n]
                cur = max(lst) - min(lst)
                if cur < ans:
                    ans = cur
            return

        ans = math.inf
        check1()
        check2()
        m, n = n, m
        check1()
        check2()
        ac.st(ans)
        return

    @staticmethod
    def abc_083a(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc074/tasks/arc083_a
        tag: brute_force|math
        """
        res = 0
        a, b, c, d, e, f = ac.read_list_ints()
        ans = [100 * a, 0]
        for p in range(3001):
            if p * a * 100 > f:
                break
            for q in range(3001):
                if p * a * 100 + q * b * 100 > f:
                    break
                if p == q == 0:
                    continue
                ceil = (p * a + q * b) * e

                for x in range(3001):
                    if x * c > ceil:
                        break
                    y1 = (ceil - x * c) // d
                    y2 = (f - p * a * 100 - q * b * 100 - x * c) // d
                    y1 = y1 if y1 < y2 else y2
                    if y1 < 0:
                        continue
                    y = y1
                    percent = 100 * (x * c + y * d) / (p * a * 100 + q * b * 100 + x * c + y * d)
                    if percent > res:
                        res = percent
                        ans = [p * a * 100 + q * b * 100 + x * c + y * d, x * c + y * d]
        ac.lst(ans)
        return

    @staticmethod
    def ac_97(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/97/
        tag: brute_force
        """
        n = ac.read_int()

        for _ in range(n):
            grid = [[int(w) for w in ac.read_str()] for _ in range(5)]
            ac.read_str()

            ans = -1
            for state in range(1 << 5):
                lst = [x for x in range(5) if state & (1 << x)]
                temp = [g[:] for g in grid]
                cur = len(lst)
                for x in lst:
                    i, j = 0, x
                    temp[i][j] = 1 - temp[i][j]
                    for a, b in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                        if 0 <= a < 5 and 0 <= b < 5:
                            temp[a][b] = 1 - temp[a][b]

                for r in range(1, 5):
                    for j in range(5):
                        if temp[r - 1][j] == 0:
                            i, j = r, j
                            temp[i][j] = 1 - temp[i][j]
                            cur += 1
                            for a, b in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                                if 0 <= a < 5 and 0 <= b < 5:
                                    temp[a][b] = 1 - temp[a][b]
                if all(all(x == 1 for x in g) for g in temp):
                    ans = ans if ans < cur and ans != -1 else cur
            ac.st(ans if ans <= 6 else -1)
        return

    @staticmethod
    def lg_p1018(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1018
        tag: brute_force
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_str()

        ans = 0
        for item in combinations(list(range(1, n)), k):
            cur = nums[:]
            for i in item:
                cur[i] = "*" + cur[i]
            res = [int(w) for w in ("".join(cur)).split("*")]
            cur = reduce(mul, res)
            ans = max(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1311(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1311
        tag: brute_force|counter
        """
        n, k, p = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        cnt = [0] * k
        for i in range(n):
            cnt[nums[i][0]] += 1
        pre = [0] * k
        ans = 0
        for i in range(n):
            c = nums[i][0]
            pre[c] += 1
            if nums[i][1] <= p:
                for j in range(k):
                    if j != c:
                        ans += pre[j] * (cnt[j] - pre[j])
                    else:
                        ans += pre[j] - 1
                        ans += cnt[j] - pre[j]
                        ans += (pre[j] - 1) * (cnt[j] - pre[j])
                    cnt[j] -= pre[j]
                pre = [0] * k
        ac.st(ans)
        return

    @staticmethod
    def lg_p2119(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2119
        tag: brute_force|prefix_suffix|counter
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(m)]

        cnt = [0] * (n + 1)
        for num in nums:
            cnt[num] += 1

        aa = [0] * (n + 1)
        bb = [0] * (n + 1)
        cc = [0] * (n + 1)
        dd = [0] * (n + 1)

        # brute_force b-a=x
        for x in range(1, n // 9 + 1):
            if 1 + 9 * x + 1 > n:
                break

            # ab counter
            pre_ab = [0] * (n + 1)
            for b in range(2 * x + 1, n + 1):
                pre_ab[b] = pre_ab[b - 1]
                pre_ab[b] += cnt[b] * cnt[b - 2 * x]

            # cd
            for c in range(n - x, -1, -1):
                if c - 6 * x - 1 >= 1:
                    cc[c] += pre_ab[c - 6 * x - 1] * cnt[c + x]
                    dd[c + x] += pre_ab[c - 6 * x - 1] * cnt[c]
                else:
                    break

            # cd
            post_cd = [0] * (n + 2)
            for c in range(n - x, -1, -1):
                post_cd[c] = post_cd[c + 1]
                post_cd[c] += cnt[c] * cnt[c + x]

            # ab counter
            for b in range(2 * x + 1, n + 1):
                if b + 6 * x + 1 <= n:
                    aa[b - 2 * x] += post_cd[b + 6 * x + 1] * cnt[b]
                    bb[b] += post_cd[b + 6 * x + 1] * cnt[b - 2 * x]
                else:
                    break

        for x in nums:
            ac.lst([aa[x], bb[x], cc[x], dd[x]])
        return

    @staticmethod
    def lg_p2652(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2652
        tag: brute_force|two_pointers
        """
        n = ac.read_int()
        dct = defaultdict(set)
        for _ in range(n):
            a, b = ac.read_list_ints()
            dct[a].add(b)
        ans = n
        for a in dct:
            lst = sorted(list(dct[a]))
            m = len(lst)
            j = 0
            for i in range(m):
                while j < m and lst[j] - lst[i] <= n - 1:
                    j += 1
                ans = min(ans, n - (j - i))
        ac.st(ans)
        return

    @staticmethod
    def lg_p2994(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2994
        tag: brute_force|reverse_thinking
        """

        def dis():
            return (x1 - x2) ** 2 + (y1 - y2) ** 2

        n, m = ac.read_list_ints()
        cow = [ac.read_list_ints() for _ in range(n)]
        pos = [ac.read_list_ints() for _ in range(n)]
        visit = [0] * n
        for j in range(m):
            ceil = math.inf
            ind = 0
            x1, y1 = pos[j]
            for i in range(n):
                if visit[i]:
                    continue
                x2, y2 = cow[i]
                cur = dis()
                if cur < ceil:
                    ceil = cur
                    ind = i
            if ceil < math.inf:
                visit[ind] = 1
        ans = [i + 1 for i in range(n) if not visit[i]]
        if not ans:
            ac.st(0)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p4181(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4181
        tag: greedy|brute_force|suffix_sum
        """
        n, m, r = ac.read_list_ints()
        cow = [ac.read_int() for _ in range(n)]
        cow.sort()
        nums1 = [ac.read_list_ints()[::-1] for _ in range(m)]
        nums1.sort(key=lambda it: -it[0])
        nums2 = [ac.read_int() for _ in range(r)]
        nums2.sort(reverse=True)

        ind = 0
        post = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            cur = 0
            while ind < m and cow[i]:
                if nums1[ind][1] == 0:
                    ind += 1
                    continue
                x = min(nums1[ind][1], cow[i])
                cow[i] -= x
                nums1[ind][1] -= x
                cur += nums1[ind][0] * x
            post[i] = post[i + 1] + cur

        ans = post[0]
        pre = 0
        for i in range(min(r, n)):
            pre += nums2[i]
            ans = max(ans, pre + post[i + 1])
        ac.st(ans)
        return

    @staticmethod
    def lg_p6149(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6149
        tag: brute_force|triangle|prefix_sum|binary_search
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        dct_x = defaultdict(list)
        dct_y = defaultdict(list)
        for x, y in nums:
            dct_x[x].append(y)
            dct_y[y].append(x)
        pre_x = defaultdict(list)
        for x in dct_x:
            dct_x[x].sort()
            pre_x[x] = ac.accumulate(dct_x[x])
        pre_y = defaultdict(list)
        for y in dct_y:
            dct_y[y].sort()
            pre_y[y] = ac.accumulate(dct_y[y])

        ans = 0
        mod = 10 ** 9 + 7
        for x, y in nums:
            xi = bisect.bisect_left(dct_y[y], x)
            left_x = (xi + 1) * x - pre_y[y][xi + 1]
            right_x = pre_y[y][-1] - pre_y[y][xi + 1] - (len(dct_y[y]) - xi - 1) * x

            yi = bisect.bisect_left(dct_x[x], y)
            left_y = (yi + 1) * y - pre_x[x][yi + 1]
            right_y = pre_x[x][-1] - pre_x[x][yi + 1] - (len(dct_x[x]) - yi - 1) * y
            ans += (left_x + right_x) * (left_y + right_y)
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p6393(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6393
        tag: data_range|brute_force
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        dct = dict()
        for i in range(n):
            a, b = nums[i]
            if b not in dct:
                dct[b] = dict()
            if a not in dct[b]:
                dct[b][a] = deque()
            dct[b][a].append(i)
        for i in range(n):
            a, b = nums[i]
            ind = -2
            for bb in dct:
                if (b * b) % bb == 0:
                    aa = a + b * b // bb + b
                    if aa in dct[bb]:
                        while dct[bb][aa] and dct[bb][aa][0] <= i:
                            dct[bb][aa].popleft()
                        if dct[bb][aa]:
                            j = dct[bb][aa][0]
                            if ind == -2 or j < ind:
                                ind = j
                        else:
                            del dct[bb][aa]
                            if not dct[bb]:
                                del dct[bb]
            ac.st(ind + 1)
        return

    @staticmethod
    def lc_2591(money: int, children: int) -> int:
        """
        url: https://leetcode.cn/problems/distribute-money-to-maximum-children/
        tag: brute_force
        """
        ans = -1
        for x in range(children + 1):
            if x * 8 > money:
                break
            rest_money = money - x * 8
            rest_people = children - x
            if rest_money < rest_people:
                continue
            if not rest_people and rest_money:
                continue
            if rest_people == 1 and rest_money == 4:
                continue
            ans = x
        return ans

    @staticmethod
    def lc_2681(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/power-of-heroes/
        tag: contribution_method|brute_force|counter
        """
        mod = 10 ** 9 + 7
        nums.sort()
        ans = pre = 0
        for num in nums:
            ans += num * num * pre
            ans += num * num * num
            pre %= mod
            ans %= mod
            pre *= 2
            pre += num
        return ans

    @staticmethod
    def lg_p6767(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6767
        tag: brute_force
        """
        n, a, b, c, d = ac.read_list_ints()
        if b * c > a * d:
            a, b, c, d = c, d, a, b

        ans = math.inf
        for x in range(10 ** 5 + 1):
            cur = x * d + b * max(math.ceil((n - x * c) / a), 0)
            ans = min(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lg_p8270(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8270
        tag: brain_teaser|brute_force
        """
        s = ac.read_str()
        t = ac.read_str()
        lst = sorted(list("abcdefghijklmnopqr"))
        m = len(lst)
        pre = set()
        for i in range(m):
            for j in range(i, m):
                cur = {lst[i], lst[j]}
                ss = ""
                tt = ""
                for w in s:
                    if w in cur:
                        ss += w
                for w in t:
                    if w in cur:
                        tt += w
                if ss == tt:
                    pre.add(lst[i] + lst[j])
                    pre.add(lst[j] + lst[i])
        ans = ""
        for _ in range(ac.read_int()):
            st = ac.read_str()
            m = len(st)
            flag = True
            for i in range(m):
                for j in range(i, m):
                    if st[i] + st[j] not in pre:
                        flag = False
                        break
                if not flag:
                    break
            ans += "Y" if flag else "N"
        ac.st(ans)
        return

    @staticmethod
    def lg_p8672(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8672
        tag: string|brute_force|permutation_circle|counter|classical|brain_teaser
        """
        s = ac.read_str()
        n = len(s)
        dct = dict()
        dct["B"] = s.count("B")
        dct["A"] = s.count("A")
        dct["T"] = s.count("T")
        ans = math.inf
        for item in permutations("BAT", 3):
            t = ""
            for w in item:
                t += dct[w] * w
            cnt = defaultdict(int)
            for i in range(n):
                if s[i] != t[i]:
                    cnt[s[i] + t[i]] += 1
            cur = 0
            for w in item:
                for p in item:
                    if w != p:
                        x = min(cnt[w + p], cnt[p + w])
                        cur += x
                        cnt[w + p] -= x
                        cnt[p + w] -= x
            rest = sum(cnt.values())
            cur += rest * 2 // 3
            ans = min(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lg_p9076(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9076
        tag: factorization|brute_force|classical|square_complexity|sqrt_n
        """
        n = ac.read_int()
        ans = 0
        pre = set()
        for a in range(1, int(n ** 0.5) + 1):
            if n % a == 0:
                for bc in [n // a - 1, a - 1]:
                    if bc in pre:
                        continue
                    pre.add(bc)
                    for x in range(2, bc + 1):
                        if x * x > bc:
                            break
                        if bc % x == 0:
                            y = bc // x
                            if x == y:
                                if x >= 3:
                                    ans += 1
                                continue
                            if y >= 3:
                                ans += 1
                            if x >= 3:
                                ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p9008(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9008
        tag: inclusion_exclusion|brute_force|counter|classical
        """
        n, p, q = ac.read_list_ints()
        friend = defaultdict(set)
        for _ in range(p):
            u, v = ac.read_list_ints()
            friend[u].add(v)
            friend[v].add(u)
        ans = n * (n - 1) // 2
        rem = set()
        for _ in range(q):
            u, v = ac.read_list_ints()
            rem.add((u, v) if u < v else (v, u))
            for x in friend[u]:
                if x not in friend[v]:
                    rem.add((x, v) if x < v else (v, x))
            for y in friend[v]:
                if y not in friend[u]:
                    rem.add((y, u) if y < u else (u, y))
        ac.st(ans - len(rem))
        return

    @staticmethod
    def lg_p9006(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9006
        tag: brute_force|mod|counter
        """
        mod = 100000007
        n, k = ac.read_list_ints()
        num = 9 * 10 ** (n - 1)
        x = num // k
        x %= mod
        ans = [x] * k
        for y in range(10 ** (n - 1) + x * k, 10 ** (n - 1) + x * k + num % k):
            ans[y % k] += 1
        ac.lst([x % mod for x in ans])
        return

    @staticmethod
    def lg_p8948(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8948
        tag: brute_force|preprocess
        """
        dct = dict()
        dct[2000] = [400, 600]
        for i in range(401):
            for j in range(601):
                x = (3 * i + 2 * j) * 10 / 12
                x = int(x) + int(x - int(x) >= 0.5)
                if 10 <= x <= 1990:
                    dct[x] = [i, j]
        for _ in range(ac.read_int()):
            ac.lst(dct[ac.read_int()])
        return

    @staticmethod
    def lg_p8894(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8894
        tag: data_range|brute_force|prefix_sum|counter|inclusion_exclusion
        """
        n = ac.read_int()
        mod = 998244353
        nums = [ac.read_list_ints() for _ in range(n)]
        ceil = max(q for _, q in nums)
        low = min(p for p, _ in nums)
        ans = pre = 0
        for s in range(low, ceil + 1):
            cnt = 1
            flag = 0
            for p, q in nums:
                if p <= s <= q:
                    cnt *= (s - p + 1)
                    flag = 1
                    cnt %= mod
                elif s > q:
                    cnt *= (q - p + 1)
                    cnt %= mod
                elif s < p:
                    cnt = 0
                    break
            if flag:
                ans = (ans + (cnt - pre) * s) % mod
                pre = cnt
        ac.st(ans)
        return

    @staticmethod
    def lg_p8872(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8872
        tag: sort|prefix_suffix|brute_force|reverse_order
        """
        n, m = ac.read_list_ints()
        nums = sorted(ac.read_list_ints())
        ans = math.inf
        for i in range(n):
            if i > m:
                break
            right = (m - i) // 2
            if right >= n - i - 1:
                ac.st(0)
                return
            cur = nums[-right - 1] - nums[i]
            ans = min(ans, cur)

        for i in range(n - 1, -1, -1):
            if n - i - 1 > m:
                break
            left = (m - n + i + 1) // 2
            if left >= i:
                ac.st(0)
                return
            cur = nums[i] - nums[left]
            ans = min(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lc_2018(board: List[List[str]], word: str) -> bool:
        """
        url: https://leetcode.cn/problems/check-if-word-can-be-placed-in-crossword/description/
        tag: brute_force
        """
        k = len(word)

        def check(cur):
            if len(cur) != len(word):
                return False
            return all(cur[i] == " " or cur[i] == word[i] for i in range(k))

        def compute(lst):
            length = len(lst)
            pre = 0
            for i in range(length):
                if lst[i] == "#":
                    if check([lst[x] for x in range(pre, i)]):
                        return True
                    pre = i + 1
            if check([lst[x] for x in range(pre, length)]):
                return True
            return False

        for tmp in board:
            if compute(tmp[:]) or compute(tmp[::-1]):
                return True

        for tmp in zip(*board):
            if compute(tmp[:]) or compute(tmp[::-1]):
                return True
        return False

    @staticmethod
    def lc_2170(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-operations-to-make-the-array-alternating/
        tag: brute_force|secondary_maximum
        """
        odd = defaultdict(int)
        even = defaultdict(int)
        n = len(nums)
        odd_cnt = 0
        even_cnt = 0
        for i in range(n):
            if i % 2 == 0:
                even[nums[i]] += 1
                even_cnt += 1
            else:
                odd[nums[i]] += 1
                odd_cnt += 1

        a = b = 0
        for num in even:
            if even[num] >= a:
                a, b = even[num], a
            elif even[num] >= b:
                b = even[num]

        ans = odd_cnt + even_cnt - a
        for num in odd:
            cur = odd_cnt - odd[num]
            if even[num] == a:
                x = b
            else:
                x = a
            cur += even_cnt - x
            if cur < ans:
                ans = cur
        return ans

    @staticmethod
    def lc_910(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/smallest-range-ii/description/
        tag: brute_force|data_range
        """
        nums.sort()
        ans = nums[-1] - nums[0]
        n = len(nums)
        for i in range(n - 1):
            a, b = nums[n - 1] - k, nums[i] + k
            a = a if a > b else b
            c, d = nums[0] + k, nums[i + 1] - k
            c = c if c < d else d
            if a - c < ans:
                ans = a - c
        return ans

    @staticmethod
    def lc_1178(words: List[str], puzzles: List[str]) -> List[int]:
        """
        url: https://leetcode.cn/problems/number-of-valid-words-for-each-puzzle/
        tag: hash|counter|brute_force|bit_operation|subset_enumeration|classical
        """
        n = 7
        dct = defaultdict(int)
        for word in words:
            cur = set(word)
            lst = [ord(w) - ord("a") for w in cur]
            state = reduce(or_, [1 << x for x in lst])
            if len(cur) <= n:
                dct[state] += 1

        ans = []
        for word in puzzles:
            lst = [ord(w) - ord("a") for w in word]
            start = 1 << lst[0]
            cur = 0
            mask = reduce(or_, [1 << x for x in lst])
            sub = mask
            while sub:  # classical
                if sub & start:
                    cur += dct[sub]
                sub = (sub - 1) & mask
            ans.append(cur)
        return ans

    @staticmethod
    def lc_1215(low: int, high: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/stepping-numbers/
        tag: data_range|brute_force|preprocess
        """
        res = []
        pre = list(range(10))
        res.extend(pre)
        ceil = 2 * 10 ** 9
        for _ in range(10):
            cur = []
            for num in pre:
                if str(num)[0] == "0":
                    continue
                d = int(str(num)[-1])
                for w in [d - 1, d + 1]:
                    if 0 <= w <= 9 and num * 10 + w <= ceil:
                        cur.append(num * 10 + w)
            pre = cur[:]
            res.extend(pre)

        i, j = bisect.bisect_left(res, low), bisect.bisect_right(res, high)
        return res[i:j]

    @staticmethod
    def lc_1131(arr1: List[int], arr2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-of-absolute-value-expression/description/
        tag: manhattan_distance|brute_force|classical
        """
        n = len(arr1)
        ans = 0
        for x in [1, -1]:
            for y in [1, -1]:
                for z in [1, -1]:
                    a1 = max(x * arr1[i] + y * arr2[i] + z * i for i in range(n))
                    a2 = min(x * arr1[i] + y * arr2[i] + z * i for i in range(n))
                    if a1 - a2 > ans:
                        ans = a1 - a2
        return ans

    @staticmethod
    def lc_1638_1(s: str, t: str) -> int:
        """
        url: https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/description/
        tag: brute_force|dp|brute_force
        """
        m, n = len(s), len(t)
        ans = 0
        for i in range(m):
            for j in range(n):
                cur = int(s[i] != t[j])
                x, y = i, j
                while cur <= 1 and x < m and y < n:
                    ans += cur == 1
                    x += 1
                    y += 1
                    if x == m or y == n:
                        break
                    cur += int(s[x] != t[y])
        return ans

    @staticmethod
    def lc_1638_2(s: str, t: str) -> int:
        """
        url: https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/description/
        tag: brute_force|dp|brute_force|classical|brain_teaser
        """
        m = len(s)
        n = len(t)
        cnt = [[0] * (n + 1) for _ in range(m + 1)]
        same = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                if s[i] == t[j]:
                    same[i + 1][j + 1] = same[i][j] + 1
                    cnt[i + 1][j + 1] = cnt[i][j]
                else:
                    same[i + 1][j + 1] = 0
                    cnt[i + 1][j + 1] = same[i][j] + 1
        return sum(sum(d) for d in cnt)

    @staticmethod
    def lc_1761(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/
        tag: directed_graph|undirected_graph|brute_force
        """
        edges = [[i - 1, j - 1] for i, j in edges]
        degree = [0] * n
        dct = [set() for _ in range(n)]
        directed = [set() for _ in range(n)]
        for i, j in edges:
            dct[i].add(j)
            degree[i] += 1
            degree[j] += 1
            dct[j].add(i)
        for i, j in edges:
            if degree[i] < degree[j] or (degree[i] == degree[j] and i < j):
                directed[i].add(j)
            else:
                directed[j].add(i)
        ans = math.inf
        for i in range(n):
            for j in directed[i]:
                for k in directed[j]:
                    if k in dct[i]:
                        x = degree[i] + degree[j] + degree[k] - 6
                        if x < ans:
                            ans = x
        return ans if ans < math.inf else -1

    @staticmethod
    def lc_1878(grid: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/get-biggest-three-rhombus-sums-in-a-grid/
        tag: prefix_sum|brute_force
        """
        m, n = len(grid), len(grid[0])

        @lru_cache(None)
        def left_up(p, q):

            if p < 0 or q < 0:
                return 0
            res = grid[p][q]
            if p and q:
                res += left_up(p - 1, q - 1)

            return res

        @lru_cache(None)
        def right_up(p, q):
            if p < 0 or q < 0:
                return 0
            res = grid[p][q]
            if p and q + 1 < n:
                res += right_up(p - 1, q + 1)

            return res

        ans = set()
        k = max(m, n)
        for i in range(m):
            for j in range(n):
                ans.add(grid[i][j])

                for x in range(1, k + 1):
                    up_point = [i - x, j]
                    down_point = [i + x, j]
                    left_point = [i, j - x]
                    right_point = [i, j + x]
                    if not all(0 <= a < m and 0 <= b < n for a, b in [up_point, down_point, left_point, right_point]):
                        break
                    cur = left_up(right_point[0], right_point[1]) - left_up(up_point[0], up_point[1])
                    cur += left_up(down_point[0], down_point[1]) - left_up(left_point[0], left_point[1])

                    cur += right_up(left_point[0], left_point[1]) - right_up(up_point[0], up_point[1])
                    cur += right_up(down_point[0], down_point[1]) - right_up(right_point[0], right_point[1])
                    cur -= grid[down_point[0]][down_point[1]]
                    cur += grid[up_point[0]][up_point[1]]
                    ans.add(cur)
        ans = list(ans)
        ans.sort(reverse=True)
        return ans[:3]

    @staticmethod
    def lc_2212(x: int, y: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-points-in-an-archery-competition/
        tag: bit_operation|brute_force|back_trace
        """
        n = len(y)
        ans = [0] * n
        ans[0] = x
        res = 0
        for i in range(1 << n):
            lst = [0] * n
            cur = 0
            for j in range(n):
                if i & (1 << j):
                    lst[j] = y[j] + 1
                    cur += j
            s = sum(lst)
            if s <= x:
                lst[0] += x - s
                if cur > res:
                    res = cur
                    ans = lst[:]
        return ans

    @staticmethod
    def lc_2245(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-trailing-zeros-in-a-cornered-path/
        tag: prefix_sum|brute_force
        """

        def check(num, f):
            res = 0
            while num % f == 0:
                res += 1
                num //= f
            return res

        m, n = len(grid), len(grid[0])

        cnt = [[[check(grid[i][j], 2), check(grid[i][j], 5)] for j in range(n)] for i in range(m)]

        @lru_cache(None)
        def up(i, j):
            cur = cnt[i][j][:]
            if i:
                nex = up(i - 1, j)
                cur[0] += nex[0]
                cur[1] += nex[1]
            return cur

        @lru_cache(None)
        def down(i, j):
            cur = cnt[i][j][:]
            if i + 1 < m:
                nex = down(i + 1, j)
                cur[0] += nex[0]
                cur[1] += nex[1]
            return cur

        @lru_cache(None)
        def left(i, j):
            cur = cnt[i][j][:]
            if j:
                nex = left(i, j - 1)
                cur[0] += nex[0]
                cur[1] += nex[1]
            return cur

        @lru_cache(None)
        def right(i, j):
            cur = cnt[i][j][:]
            if j + 1 < n:
                nex = right(i, j + 1)
                cur[0] += nex[0]
                cur[1] += nex[1]
            return cur

        ans = 0
        for i in range(m):
            for j in range(n):
                lst = [up(i, j), down(i, j), left(i, j), right(i, j)]
                for ls in lst:
                    x = ls[0] if ls[0] < ls[1] else ls[1]
                    if x > ans:
                        ans = x
                tmp = cnt[i][j]
                for item in combinations(lst, 2):
                    ls1, ls2 = item
                    x = ls1[0] + ls2[0] - tmp[0] if ls1[0] + ls2[0] - tmp[0] < ls1[1] + ls2[1] - tmp[1] \
                        else ls1[1] + ls2[1] - tmp[1]
                    if x > ans:
                        ans = x
        return ans

    @staticmethod
    def abc_296d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc296/tasks/abc296_d
        tag: brute_force|math
        """
        n, m = ac.read_list_ints()
        x = m
        while x <= n * n:
            for y in range(x // n, int(x ** 0.5) + 1):
                if 1 <= y <= n and 1 <= x // y <= n and x % y == 0:
                    ac.st(x)
                    return
            x += 1
        ac.st(-1)
        return

    @staticmethod
    def abc_178e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc178/tasks/abc178_e
        tag: manhattan_distance|prefix_suffix|classical
        """

        nums = [ac.read_list_ints() for _ in range(ac.read_int())]
        nums.sort()

        def check():
            n = len(nums)
            pos = [-math.inf, -1]
            neg = [-math.inf, -1]
            res = [-math.inf, (-1, -1)]
            for i in range(n):
                x, y = nums[i]
                if pos[0] - y + x > res[0]:
                    res = [pos[0] - y + x, (pos[1], i)]
                if neg[0] + y + x > res[0]:
                    res = [neg[0] + y + x, (neg[1], i)]
                if y - x > pos[0]:
                    pos = [y - x, i]
                if -y - x > neg[0]:
                    neg = [-y - x, i]
            return res

        ans = check()[0]
        ac.st(ans)
        return

    @staticmethod
    def lc_3102_1(points: List[List[int]]) -> int:

        """
        url: https://leetcode.cn/problems/minimize-manhattan-distances/
        tag: manhattan_distance|brain_teaser|implemention|prefix_suffix|classical
        """

        points.sort()

        def check():
            n = len(nums)
            pos = [-math.inf, -1]
            neg = [-math.inf, -1]
            res = [-math.inf, (-1, -1)]
            for i in range(n):
                x, y = nums[i]
                if pos[0] - y + x > res[0]:
                    res = [pos[0] - y + x, (pos[1], i)]
                if neg[0] + y + x > res[0]:
                    res = [neg[0] + y + x, (neg[1], i)]
                if y - x > pos[0]:
                    pos = [y - x, i]
                if -y - x > neg[0]:
                    neg = [-y - x, i]
            return res

        ans = math.inf
        nums = points[:]
        m = len(points)
        lst = check()[1][:]
        for xx in lst:
            nums = [points[i] for i in range(m) if i != xx]
            ans = min(ans, check()[0])
        return ans

    @staticmethod
    def lc_3102_2(points: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimize-manhattan-distances/
        tag: manhattan_distance|brain_teaser|implemention|prefix_suffix|classical
        """
        ceil_x1, ceil_x2 = -math.inf, -math.inf
        floor_x1, floor_x2 = math.inf, math.inf
        ceil_ix, floor_ix = -1, -1

        ceil_y1, ceil_y2 = -math.inf, -math.inf
        floor_y1, floor_y2 = math.inf, math.inf
        ceil_iy, floor_iy = -1, -1
        for i, (x, y) in enumerate(points):
            x, y = x + y, x - y
            if x >= ceil_x1:
                ceil_x1, ceil_x2 = x, ceil_x1
                ceil_ix = i
            elif x > ceil_x2:
                ceil_x2 = x

            if x <= floor_x2:
                floor_x1, floor_x2 = floor_x2, x
                floor_ix = i
            elif x < floor_x1:
                floor_x1 = x

            if y >= ceil_y1:
                ceil_y1, ceil_y2 = y, ceil_y1
                ceil_iy = i
            elif y > ceil_y2:
                ceil_y2 = y

            if y <= floor_y2:
                floor_y1, floor_y2 = floor_y2, y
                floor_iy = i
            elif y < floor_y1:
                floor_y1 = y

        ans = 0
        for i in ceil_ix, floor_ix, ceil_iy, floor_iy:
            dx = max(ceil_x1 if i != ceil_ix else ceil_x2) - min(floor_x2 if i != floor_ix else floor_x1)
            dy = max(ceil_y1 if i != ceil_iy else ceil_y2) - min(floor_y2 if i != floor_iy else floor_y1)
            ans = min(ans, max(dx, dy))
        return ans

    @staticmethod
    def abc_260f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc260/tasks/abc260_f
        tag: brute_force|data_range|brain_teaser|classical
        """
        s, t, m = ac.read_list_ints()
        edge = [[] for _ in range(s)]
        pre = [-1] * t * t
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            v -= s
            for i in edge[u]:
                if pre[i * t + v] != -1:
                    ans = [pre[i * t + v] + 1, i + s + 1, v + s + 1, u + 1]
                    ac.lst(ans)
                    return
                pre[i * t + v] = pre[v * t + i] = u
            edge[u].append(v)
        ac.st(-1)
        return

    @staticmethod
    def lg_p1989(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1989
        tag: ternary_circle|dag|build_graph|counter|brute_force|classical
        """
        n, m = ac.read_list_ints()  # TLE
        edge = [set() for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            edge[i].add(j)
            edge[j].add(i)
        degree = [len(e) for e in edge]
        dct = [[] for _ in range(n)]
        for i in range(n):
            for j in edge[i]:
                if (degree[i] < degree[j]) or (degree[i] == degree[j] and i < j):
                    dct[i].append(j)
        ans = 0
        for i in range(n):
            for j in dct[i]:
                ans += sum(k in edge[i] for k in dct[j])
        ac.st(ans)
        return

    @staticmethod
    def abc_249d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc249/tasks/abc249_d
        tag: euler_series|nlogn|brute_force|contribution_method|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        n = 2 * 10 ** 5
        cnt = [0] * (n + 1)
        for num in nums:
            cnt[num] += 1
        ans = cnt[1] ** 3
        for i in range(2, n + 1):
            ans += 2 * cnt[1] * cnt[i] * cnt[i]

        for i in range(2, n + 1):
            for j in range(i, n + 1):
                if i * j > n:
                    break
                if i == j:
                    ans += cnt[i] * cnt[j] * cnt[i * j]
                else:
                    ans += cnt[i] * cnt[j] * cnt[i * j] * 2
        ac.st(ans)
        return

    @staticmethod
    def abc_246f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc246/tasks/abc246_f
        tag: brute_force|inclusion_exclusion|math|counter|bit_operation
        """
        n, ll = ac.read_list_ints()
        lst = [sum(1 << (ord(w) - ord("a")) for w in ac.read_str()) for _ in range(n)]
        mod = 998244353
        p = [pow(x, ll, mod) for x in range(27)]
        res = 0
        for x in range(1, 1 << n):
            cur = [lst[j] for j in range(n) if x & (1 << j)]
            val = reduce(and_, cur)
            res += (-1) ** (len(cur) - 1) * p[val.bit_count()]
            res %= mod
        ac.st(res)
        return

    @staticmethod
    def main(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc247/tasks/abc247_f
        tag: brute_force|guess_table|union_find|dp|brain_teaser
        """
        mod = 998244353
        n = ac.read_int()
        dp = [0] * (2 * 10 ** 5 + 1)
        dp[2] = 3
        dp[3] = 4
        for x in range(4, 2 * 10 ** 5 + 1):
            dp[x] = (dp[x - 1] + dp[x - 2]) % mod
        p = ac.read_list_ints_minus_one()
        q = ac.read_list_ints_minus_one()
        uf = UnionFind(n)
        for i in range(n):
            uf.union(p[i], q[i])
        ans = 1
        group = uf.get_root_size()
        for g in group.values():
            if g != 1:
                ans *= dp[g]
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_247e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc247/tasks/abc247_e
        tag: inclusion_exclusion|two_pointers|counter|brain_teaser|classical
        """
        n, x, y = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre_x = pre_y = -1
        last = ans = 0
        for i, num in enumerate(nums):
            if num < y or num > x:
                last = i + 1
                pre_x = pre_y = -1
            if num == x:
                pre_x = i
            if num == y:
                pre_y = i
            if pre_x != -1 and pre_y != -1:
                ans += min(pre_x, pre_y) - last + 1
        ac.st(ans)
        return


    @staticmethod
    def abc_238c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc238/tasks/abc238_c
        tag: digit_num|counter|brute_force|classical
        """
        n = ac.read_int()
        m = len(str(n))
        mod = 998244353
        ans = 0
        for x in range(1, m + 1):
            cnt = min(10 ** x, n) - 10 ** (x - 1)
            if n < 10 ** x:
                cnt += 1
            ans += (1 + cnt) * cnt // 2
            ans %= mod
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_220e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc220/tasks/abc220_e
        tag: contribution_method|classical|brute_force|binary_tree
        """
        mod = 998244353
        n, d = ac.read_list_ints()
        p = [1] * (n + 1)
        for x in range(1, n + 1):
            p[x] = (p[x - 1] * 2) % mod

        ans = 0
        for ll in range(d + 1):
            rr = d - ll
            ss = max(ll, rr)
            if ss <= n - 1:
                root = p[n - ss] - 1
                left = p[max(0, ll - 1)]
                right = p[max(0, rr - 1)]
                ans += root * left * right * 2
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_219e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc219/tasks/abc219_e
        tag: brute_force|union_find|brain_teaser
        """
        grid = [ac.read_list_ints() for _ in range(4)]
        ans = 0
        nodes = []
        for i in range(4):
            for j in range(4):
                if grid[i][j]:
                    nodes.append(i * 4 + j)

        m = 16
        target = sum(1 << x for x in nodes)
        uf = UnionFind(36)
        for xx in range(1, 1 << m):
            if xx & target != target:
                continue
            mat = [[0] * 6 for _ in range(6)]
            uf.initialize()
            ind = [i for i in range(16) if xx & (1 << i)]
            for i in ind:
                mat[i // 4 + 1][i % 4 + 1] = 1
            edge = 0
            for i in range(6):
                for j in range(6):
                    if i + 1 < 6 and mat[i + 1][j] == mat[i][j]:
                        uf.union(i * 6 + j, i * 6 + j + 6)
                        edge += 1
                    if j + 1 < 6 and mat[i][j + 1] == mat[i][j]:
                        uf.union(i * 6 + j, i * 6 + j + 1)
                        edge += 1
            if uf.part == 2:
                ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lc_100406(n: int, k: int) -> int:

        """
        url: https://leetcode.com/problems/find-the-count-of-good-integers/
        tag: brute_force|palindrome_num
        """
        length = n // 2 + n % 2
        ans = 0
        dct = set()
        for x in range(10 ** (length - 1), 10 ** length):
            s = str(x)
            if n % 2:
                s = s + s[:-1][::-1]
            else:
                s += s[::-1]

            if int(s) % k == 0:
                sk = "".join(sorted(s))
                if sk in dct:
                    continue
                dct.add(sk)
                cnt = Counter(sk)
                pre = n
                cur = 1
                if cnt["0"]:
                    cur = math.comb(pre - 1, cnt["0"])
                    pre -= cnt["0"]
                for w in cnt:
                    if w != "0":
                        cur = cur * math.comb(pre, cnt[w])
                        pre -= cnt[w]
                ans += cur
        return ans
"""
Algorithm：circular_section|permutation_circle
Description：implemention|hash|list|index|circular_section

====================================LeetCode====================================
957（https://leetcode.cn/problems/prison-cells-after-n-days/）circular_section
418（https://leetcode.cn/problems/sentence-screen-fitting/）circular_section
466（https://leetcode.cn/problems/count-the-repetitions/）circular_section
1806（https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/description/）circular_section

=====================================LuoGu======================================
P1965（https://www.luogu.com.cn/problem/P1965）circular_section
P1532（https://www.luogu.com.cn/problem/P1532）circular_section
P2203（https://www.luogu.com.cn/problem/P2203）circular_section
P5550（https://www.luogu.com.cn/problem/P5550）circular_section|matrix_fast_power|dp
P7318（https://www.luogu.com.cn/problem/P7318）circular_section
P7681（https://www.luogu.com.cn/problem/P7681）prefix_sum|circular_section
P1468（https://www.luogu.com.cn/problem/P1468）state_compression|circular_section
P6148（https://www.luogu.com.cn/problem/P6148）circular_section|implemention

===================================CodeForces===================================
1342C（https://codeforces.com/problemset/problem/1342/C）circular_section|counter
1875B（https://codeforces.com/contest/1875/problem/B）circle_section
1760F（https://codeforces.com/contest/1760/problem/F）circle_section|brute_force
1237D（https://codeforces.com/problemset/problem/1237/D）two_pointers|implemention|circular_array
1372D（https://codeforces.com/problemset/problem/1372/D）circular_array|brain_teaser|brute_force|observation|circular_to_linear

===================================AtCoder===================================
ABC258E（https://atcoder.jp/contests/abc258/tasks/abc258_e）two_pointers|brute_force|circle_section|classical
ABC244D（https://atcoder.jp/contests/abc244/tasks/abc244_d）dfs|back_trace|brute_force|circular_section
ABC241E（https://atcoder.jp/contests/abc241/tasks/abc241_e）circular_section|brute_force_valid|classical
ABC214C（https://atcoder.jp/contests/abc214/tasks/abc214_c）circular_section|brain_teaser


"""
import math
from collections import deque
from itertools import combinations
from typing import List

from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_957(cells: List[int], n: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/prison-cells-after-n-days/
        tag: circular_section
        """
        m = len(cells)
        dct = dict()
        state = []
        day = 0
        while day < n:
            busy = set([i for i in range(1, m - 1)
                        if cells[i - 1] == cells[i + 1]])
            cells = [1 if i in busy else 0 for i in range(m)]
            day += 1
            state.append(cells[:])
            if tuple(cells) in dct:
                break
            dct[tuple(cells)] = day

        i = dct[tuple(cells)]
        j = day
        if j == n:
            k = n
        else:
            k = i + (n - i) % (j - i)
        return state[k - 1]

    @staticmethod
    def lc_1806(n: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/description/
        tag: circular_section|permutation_circle|classical|multiplication_method
        """
        ans = 0
        visit = [0] * n
        for i in range(n):
            if visit[i]:
                continue
            cur = 0
            x = i
            while not visit[x]:
                visit[x] = 1
                cur += 1
                if x % 2 == 0:
                    x //= 2
                else:
                    x = n // 2 + (x - 1) // 2
            ans = math.lcm(ans, cur) if ans else cur
        return ans

    @staticmethod
    def lg_p1468(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1468
        tag: state_compression|circular_section|classical
        """
        n = ac.read_int()
        op1 = (1 << n) - 1
        op2 = sum(1 << i for i in range(0, n, 2))
        op3 = sum(1 << i for i in range(1, n, 2))
        op4 = sum(1 << i for i in range(0, n, 3))
        stack = [[(1 << n) - 1]]
        ans = []
        while stack:
            path = stack.pop()
            for op in [op1, op2, op3, op4]:
                if path[-1] ^ op in path:
                    ans.append(path[:])
                else:
                    stack.append(path + [path[-1] ^ op])

        c = ac.read_int()
        light = sum(1 << (i - 1) for i in ac.read_list_ints()[:-1])
        down = sum(1 << (i - 1) for i in ac.read_list_ints()[:-1])
        res = set()
        for p in ans:
            m = len(p)
            state = p[c % m]
            if state & light == light and state & down == 0:
                r = bin(state)[2:]
                res.add("0" * (n - len(r)) + r)
        if not res:
            ac.st("IMPOSSIBLE")
            return
        res = sorted([r[::-1] for r in res])
        for r in res:
            ac.st(r)
        return

    @staticmethod
    def lg_p6148_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6148
        tag: circular_section|implemention|permutation_circle|classical|multiplication_method|classical
        """
        n, m, k = ac.read_list_ints()
        nums = [ac.read_list_ints_minus_one() for _ in range(m)]
        nex = [-1] * n
        for i in range(n):
            x = i
            for a, b in nums:
                if a <= x <= b:
                    x = a + b - x
            nex[i] = x

        ans = [0] * n
        for i in range(n):
            if ans[i]:
                continue
            lst = [i]
            while nex[lst[-1]] != lst[0]:
                lst.append(nex[lst[-1]])
            m = len(lst)
            for j in range(m):
                ans[lst[(j + k) % m]] = lst[j] + 1
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p6148_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6148
        tag: circular_section|implemention|permutation_circle|classical|multiplication_method|classical
        """
        n, m, k = ac.read_list_ints()
        nums = [ac.read_list_ints_minus_one() for _ in range(m)]
        nex = [-1] * n
        for i in range(n):
            x = i
            for a, b in nums:
                if a <= x <= b:
                    x = a + b - x
            nex[x] = i

        ans = list(range(n))
        while k:
            if k & 1:
                ans = [nex[i] for i in ans]
            k >>= 1
            nex = [nex[i] for i in nex]

        for i in ans:
            ac.st(i + 1)
        return

    @staticmethod
    def abc_258e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc258/tasks/abc258_e
        tag: two_pointers|brute_force|circle_section|classical
        """
        n, q, x = ac.read_list_ints()
        w = ac.read_list_ints()
        nex = [-1] * n
        t = sum(w)
        mid = n * (x // t)
        x %= t
        pre = j = 0
        for i in range(n):
            if x == 0:
                nex[i] = i
            else:
                while pre < x:
                    pre += w[j % n]
                    j += 1
                nex[i] = j % n
            pre -= w[i]

        dct = dict()
        xx = 0
        lst = []
        while xx not in dct:
            dct[xx] = len(lst)
            lst.append(xx)
            xx = nex[xx]

        ind = dct[xx]
        length = len(dct)
        for _ in range(q):
            k = ac.read_int() - 1
            if x == 0:
                ac.st(mid)
                continue
            if k < len(lst):
                xx = lst[k]
            else:
                circle = length - ind
                k -= length
                j = k % circle
                xx = lst[ind + j]
            if xx < nex[xx]:
                ac.st(nex[xx] - xx + mid)
            else:
                ac.st(n + nex[xx] - xx + mid)
        return

    @staticmethod
    def abc_244d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc244/tasks/abc244_d
        tag: dfs|back_trace|brute_force|circular_section
        """
        s = ac.read_list_strs()
        t = ac.read_list_strs()
        m = 10 ** 18
        ans = [False]

        def dfs(cur):
            if ans[0]:
                return
            for item in combinations([0, 1, 2], 2):
                i, j = item
                tmp = cur[:]
                tmp[i], tmp[j] = tmp[j], tmp[i]
                if tmp in pre:
                    ind = pre.index(tmp)
                    length = len(pre)
                    circle = length - ind
                    tm = m - length
                    j = tm % circle
                    if pre[ind + j] == t:
                        ans[0] = True
                        return
                else:
                    pre.append(tmp)
                    dfs(tmp[:])
                    pre.pop()

        pre = [s]
        dfs(s[:])
        ac.st("Yes" if ans[0] else "No")
        return

    @staticmethod
    def abc_241e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc241/tasks/abc241_e
        tag: circular_section|brute_force_valid|classical
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = [0]
        dct = dict()
        x = 0
        index = [-1]
        while True:
            x += nums[x % n]
            if x % n in dct:
                break
            lst.append(x)
            index.append(x % n)
            dct[x % n] = len(lst) - 1

        tm = k
        length = len(lst)
        # the first pos of circle section
        ind = dct[x % n]
        # current lst is enough
        if tm < length:
            ac.st(lst[tm])
            return
        tm = k - 1
        # compute by circle section
        circle = length - ind
        tm -= length - 1
        j = tm % circle
        circle_sum = sum(nums[x % n] for x in lst[ind:])
        res = lst[-1] + nums[lst[-1] % n] + sum(nums[x % n] for x in lst[ind:ind + j]) + circle_sum * (tm // circle)
        ac.st(res)
        return

    @staticmethod
    def cf_1237d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1237/D
        tag: two_pointers|implemention|circular_array
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = []
        j = 0
        stack = deque()

        for i in range(n):
            while j < 3 * n and (not stack or nums[j % n] * 2 >= nums[stack[0] % n]):
                while stack and nums[stack[-1] % n] <= nums[j % n]:
                    stack.pop()
                stack.append(j)
                j += 1
            ans.append(j - i if j - i < 2 * n + (n - i) else -1)
            if stack[0] == i:
                stack.popleft()
        ac.lst(ans)
        return

    @staticmethod
    def cf_1372d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1372/D
        tag: circular_array|brain_teaser|brute_force|observation|circular_to_linear
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        nums += nums
        odd = ac.accumulate([nums[i] * (i % 2) for i in range(2 * n)])
        even = ac.accumulate([nums[i] * (1 - i % 2) for i in range(2 * n)])
        ans = 0
        for i in range(n):
            ans = max(ans, max(odd[i + n] - odd[i], even[i + n] - even[i]))
        ac.st(ans)
        return"""

Algorithm：construction
Description：greedy|sort|construction|specific_plan

====================================LeetCode====================================
280（https://leetcode.cn/problems/wiggle-sort/）construction|sort|odd_even
2663（https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/）greedy|construction|palindrome_substring|lexicographical_order
1982（https://leetcode.cn/problems/find-array-given-subset-sums/）construction
1253（https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/）construction|greedy|brain_teaser
2573（https://leetcode.cn/problems/find-the-string-with-lcp/）lcp|construction|union_find
100452（https://leetcode.com/problems/find-the-lexicographically-smallest-valid-sequence/description/）dp|greedy|implemention|specific_plan|lexicographical_order
100431（https://leetcode.com/problems/construct-2d-grid-matching-graph-layout/）construction|unweighted_graph

=====================================LuoGu======================================
P8846（https://www.luogu.com.cn/problem/P8846）greedy|construction
P2902（https://www.luogu.com.cn/problem/P2902）construction
P5823（https://www.luogu.com.cn/problem/P5823）construction
P7383（https://www.luogu.com.cn/problem/P7383）greedy|construction
P7947（https://www.luogu.com.cn/problem/P7947）greedy|construction|product_n_sum_k|prime_factorization
P9101（https://www.luogu.com.cn/problem/P9101）construction|directed_graph|no_circe
P8976（https://www.luogu.com.cn/problem/P8976）brute_force|construction
P8910（https://www.luogu.com.cn/problem/P8910）permutation_circle|construction
P8880（https://www.luogu.com.cn/problem/P8880）brain_teaser|construction|odd_even
P2902（https://www.luogu.com.cn/problem/P2902）construction
P8248（https://www.luogu.com.cn/problem/P8248）dfs|back_trace|brute_force
P7814（https://www.luogu.com.cn/problem/P7814）construction
P7567（https://www.luogu.com.cn/problem/P7567）construction|classical|guess_table
P8683（https://www.luogu.com.cn/problem/P8683）construction

===================================CodeForces===================================
1396A（https://codeforces.com/problemset/problem/1396/A）greedy|construction
1133F2（https://codeforces.com/contest/1133/problem/F2）mst|construction|union_find
1118C（https://codeforces.com/contest/1118/problem/C）construction|matrix_rotate|implemention
1118E（https://codeforces.com/problemset/problem/1118/E）implemention|greedy|construction
960C（https://codeforces.com/problemset/problem/960/C）greedy|construction
1793B（https://codeforces.com/contest/1793/problem/B）brain_teaser|greedy|construction
1375D（https://codeforces.com/problemset/problem/1375/D）mex|construction|sorting
1348D（https://codeforces.com/problemset/problem/1348/D）bin|construction
1554D（https://codeforces.com/problemset/problem/1554/D）construction|floor
1788C（https://codeforces.com/problemset/problem/1788/C）construction
1367D（https://codeforces.com/problemset/problem/1367/D）reverse_thinking|implemention|construction|classical
1485D（https://codeforces.com/problemset/problem/1485/D）data_range|construction
1722G（https://codeforces.com/problemset/problem/1722/G）odd_even|xor_property|construction
1822D（https://codeforces.com/contest/1822/problem/D）construction|prefix_sum|mod|permutation
1509D（https://codeforces.com/contest/1509/problem/D）lcs|shortest_common_hypersequence|construction|data_range|O(n)|pigeonhole_principle
1473C（https://codeforces.com/contest/1473/problem/C）brain_teaser|s1s2..sn..s2s1
1469D（https://codeforces.com/contest/1469/problem/D）square|ceil|greedy|implemention
1478B（https://codeforces.com/contest/1478/problem/B）brute_force|bag_dp|construction
1682B（https://codeforces.com/contest/1682/problem/B）bitwise_and|construction|permutation_circle
1823D（https://codeforces.com/contest/1823/problem/D）greedy|construction|palindrome
1352G（https://codeforces.com/contest/1352/problem/G）construction|odd_even
1352F（https://codeforces.com/contest/1352/problem/G）construction
1003E（https://codeforces.com/contest/1003/problem/E）construction|tree_diameter|classical
1005F（https://codeforces.com/contest/1005/problem/F）construction|shortest_path_spanning_tree|classical|dfs|specific_plan
1092E（https://codeforces.com/contest/1092/problem/E）construction|tree_diameter|classical|greedy
1141G（https://codeforces.com/problemset/problem/1141/G）construction|dfs|color_method|greedy|classical
1144F（https://codeforces.com/contest/1144/problem/F）construction|color_method|classical|bipartite
1157E（https://codeforces.com/contest/1157/problem/E）construction|greedy|sorted_list
1157D（https://codeforces.com/contest/1157/problem/D）construction|greedy
1196E（https://codeforces.com/contest/1196/problem/E）construction|greedy
1213E（https://codeforces.com/contest/1213/problem/E）construction|brute_force
1294F（https://codeforces.com/contest/1294/problem/F）classical|tree_diameter|construction
1311E（https://codeforces.com/contest/1311/problem/E）construction|2-tree
1343F（https://codeforces.com/contest/1343/problem/F）construction|data_range|brain_teaser
1360G（https://codeforces.com/contest/1360/problem/G）construction
1385E（https://codeforces.com/contest/1385/problem/E）construction|topological_sort|classical|undirected|directed
1475F（https://codeforces.com/contest/1475/problem/F）construction|matrix_reverse
1551D2（https://codeforces.com/contest/1551/problem/D2）construction|domino
1714F（https://codeforces.com/contest/1714/problem/F）construction|tree
1702F（https://codeforces.com/contest/1702/problem/F）construction|brain_teaser
1772F（https://codeforces.com/contest/1772/problem/F）construction
1899F（https://codeforces.com/contest/1899/problem/F）construction
1923C（https://codeforces.com/contest/1923/problem/C）construction
1968E（https://codeforces.com/contest/1968/problem/E）construction
1973C（https://codeforces.com/contest/1973/problem/C）construction
1974D（https://codeforces.com/contest/1974/problem/D）construction
1978C（https://codeforces.com/contest/1978/problem/C）construction
1338C（https://codeforces.com/contest/1338/problem/B）construction|tree_xor
1450C2（https://codeforces.com/contest/1450/problem/C2）construction
1854A1（https://codeforces.com/problemset/problem/1854/A1）construction
1854A2（https://codeforces.com/problemset/problem/1854/A2）construction
1416B（https://codeforces.com/problemset/problem/1416/B）construction
1217D（https://codeforces.com/problemset/problem/1217/D）construction|observation|classical
1758D（https://codeforces.com/problemset/problem/1758/D）construction
1268B（https://codeforces.com/problemset/problem/1268/B）construction
1552D（https://codeforces.com/problemset/problem/1552/D）construction
1364D（https://codeforces.com/problemset/problem/1364/D）dfs_tree|construction|independent_set|union_find|undirected_circle|undirected_local_shortest_circle
949A（https://codeforces.com/problemset/problem/949/A）observation|construction
1809C（https://codeforces.com/problemset/problem/1809/C）construction|diff_array|reverse_pair
1481D（https://codeforces.com/problemset/problem/1481/D）observation|construction
1658C（https://codeforces.com/problemset/problem/1658/C）construction
1861D（https://codeforces.com/problemset/problem/1861/D）observation|construction
1951D（https://codeforces.com/problemset/problem/1951/D）construction
1187C（https://codeforces.com/problemset/problem/1187/C）build_graph|brain_teaser|construction
1304D（https://codeforces.com/problemset/problem/1304/D）construction
2001C（https://codeforces.com/contest/2001/problem/C）construction|union_find|observation
1630A（https://codeforces.com/problemset/problem/1630/A）construction|bit_operation
1965B（https://codeforces.com/problemset/problem/1965/B）construction
1991D（https://codeforces.com/problemset/problem/1991/D）construction
1264B（https://codeforces.com/problemset/problem/1264/B）construction
1603B（https://codeforces.com/problemset/problem/1603/B）construction
1848C（https://codeforces.com/problemset/problem/1848/C）construction
735D（https://codeforces.com/problemset/problem/735/D）construction|number_theory
1616D（https://codeforces.com/problemset/problem/1616/D）construction|observation|brain_teaser|average_trick
1545A（https://codeforces.com/problemset/problem/1545/A）construction|observation
1635D（https://codeforces.com/contest/1635/problem/D）fibonacci|brain_teaser|construction
552C（https://codeforces.com/problemset/problem/552/C）construction|math|divide_and_conquer
1371D（https://codeforces.com/problemset/problem/1371/D）construction
1332D（https://codeforces.com/problemset/problem/1332/D）construction|brain_teaser
576A（https://codeforces.com/problemset/problem/576/A）eratosthenes_sieve|construction
348A（https://codeforces.com/problemset/problem/348/A）construction
1798C（https://codeforces.com/problemset/problem/1798/C）construction
1380D（https://codeforces.com/problemset/problem/1380/D）construction
1553D（https://codeforces.com/problemset/problem/1553/D）construction
1537E2（https://codeforces.com/problemset/problem/1537/E2）construction
675C（https://codeforces.com/problemset/problem/675/C）construction
1208C（https://codeforces.com/problemset/problem/1208/C）construction
1924A（https://codeforces.com/problemset/problem/1924/A）construction
1325C（https://codeforces.com/contest/1325/problem/C）construction|observation
1945E（https://codeforces.com/problemset/problem/1945/E）construction|binary_search
1030D（https://codeforces.com/problemset/problem/1030/D）construction
1368C（https://codeforces.com/problemset/problem/1368/C）construction
1956C（https://codeforces.com/contest/1956/problem/C）construction
739A（https://codeforces.com/problemset/problem/739/A）construction|observation|mex_like
582A（https://codeforces.com/problemset/problem/582/A）construction|gcd_like
707C（https://codeforces.com/problemset/problem/707/C）construction|math
1856C（https://codeforces.com/problemset/problem/1856/C）construction|brute_force|greedy
1882C（https://codeforces.com/problemset/problem/1882/C）observation|suffix|brute_force|construction
1567C（https://codeforces.com/problemset/problem/1567/C）observation|construction
743C（https://codeforces.com/problemset/problem/743/C）construction|math
1303C（https://codeforces.com/problemset/problem/1303/C）construction|bfs|euler_path
1718A2（https://codeforces.com/problemset/problem/1718/A2）bit_operation|brain_teaser|construction|greedy
1439A2（https://codeforces.com/problemset/problem/1439/A2）construction|implemention
1202D（https://codeforces.com/problemset/problem/1202/D）construction|binary_search
1355D（https://codeforces.com/problemset/problem/1355/D）construction
1930C（https://codeforces.com/problemset/problem/1930/C）construction|observation
1450D（https://codeforces.com/problemset/problem/1450/D）construction|induction|recursion
1290B（https://codeforces.com/problemset/problem/1290/B）construction
1901D（https://codeforces.com/problemset/problem/1901/D）construction
1583D（https://codeforces.com/problemset/problem/1583/D）interactive|brain_teaser|classical
1582D（https://codeforces.com/problemset/problem/1582/D）construction|data_range
1438D（https://codeforces.com/problemset/problem/1438/D）construction|bit_operation|odd_even|observation
1110E（https://codeforces.com/problemset/problem/1110/E）observation|construction|operation|brain_teaser
1329B（https://codeforces.com/problemset/problem/1329/B）construction|linear_dp|bit_operation

====================================AtCoder=====================================
AGC007B（https://atcoder.jp/contests/agc007/tasks/agc007_b）brain_teaser|math|construction
ARC086B（https://atcoder.jp/contests/abc081/tasks/arc086_b）greedy|construction|classification_discussion
ARC093B（https://atcoder.jp/contests/abc092/tasks/arc093_b）brain_teaser|construction
ABC126F（https://atcoder.jp/contests/abc126/tasks/abc126_f）brain_teaser|construction|xor_property
ABC109D（https://atcoder.jp/contests/abc109/tasks/abc109_d）odd_even|construction
ABC345F（https://atcoder.jp/contests/abc345/tasks/abc345_f）construction|union_find|greedy|implemention
ABC299E（https://atcoder.jp/contests/abc299/tasks/abc299_e）construction|bfs
ABC251F（https://atcoder.jp/contests/abc251/tasks/abc251_f）construction|dfs|bfs|classical
ABC251D（https://atcoder.jp/contests/abc251/tasks/abc251_d）construction|brute_force|brain_teaser
ABC239F（https://atcoder.jp/contests/abc239/tasks/abc239_f）implemention|construction|greedy|brain_teaser|union_find
ABC233F（https://atcoder.jp/contests/abc233/tasks/abc233_f）graph|union_find|construction|mst|brain_teaser|classical
ABC231D（https://atcoder.jp/contests/abc231/tasks/abc231_d）union_find|construction
ABC225C（https://atcoder.jp/contests/abc225/tasks/abc225_c）construction
ABC362F（https://atcoder.jp/contests/abc362/tasks/abc362_f）construction|greedy|observation

====================================AtCoder=====================================
1（https://www.codechef.com/problems/ENVPILE）bfs|construction|classical


"""
import math
from collections import deque, Counter, defaultdict
from heapq import heappush, heappop, heapify
from itertools import permutations
from typing import List

from src.graph.dijkstra.template import UnWeightedGraph
from src.graph.union_find.template import UnionFind
from src.mathmatics.number_theory.template import NumFactor
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def cf_1478b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1478/problem/B
        tag: brute_force|bag_dp|construction|brain_teaser|classical
        """
        for _ in range(ac.read_int()):
            q, d = ac.read_list_ints()
            queries = ac.read_list_ints()
            ceil = 10 * d + 9
            dp = [0] * (ceil + 1)
            dp[0] = 1
            for i in range(1, ceil + 1):
                if str(d) in str(i):
                    for j in range(i, ceil + 1):
                        if dp[j - i]:
                            dp[j] = 1
            for num in queries:
                if num >= 10 * d + 9 or dp[num]:
                    ac.yes()
                else:
                    ac.no()
        return

    @staticmethod
    def cf_1367d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1367/D
        tag: reverse_thinking|implemention|construction
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            m = ac.read_int()
            nums = ac.read_list_ints()
            ans = [""] * m
            lst = deque(sorted(list(s), reverse=True))
            while max(nums) >= 0:
                zero = [i for i in range(m) if nums[i] == 0]
                k = len(zero)
                while len(set(list(lst)[:k])) != 1:
                    lst.popleft()
                for i in zero:
                    nums[i] = -1
                    ans[i] = lst.popleft()
                while lst and lst[0] == ans[zero[0]]:
                    lst.popleft()
                for i in range(m):
                    if nums[i] != -1:
                        nums[i] -= sum(abs(i - j) for j in zero)
            ac.st("".join(ans))
        return

    @staticmethod
    def cf_1788c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1788/C
        tag: construction
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            if n % 2:
                ac.yes()
                x = n // 2
                for i in range(1, n + 1):
                    if i <= x:
                        ac.lst([i, i + n + x + 1])
                    else:
                        ac.lst([i, i - x + n])
            else:
                ac.no()
        return

    @staticmethod
    def lc_280(nums: List[int]) -> None:
        """
        url: https://leetcode.cn/problems/wiggle-sort/
        tag: construction|sort|odd_even|classical
        """
        nums.sort()
        n = len(nums)
        ans = [0] * n
        j = n - 1
        for i in range(1, n, 2):
            ans[i] = nums[j]
            j -= 1
        j = 0
        for i in range(0, n, 2):
            ans[i] = nums[j]
            j += 1
        for i in range(n):
            nums[i] = ans[i]
        return

    @staticmethod
    def lc_1982(n: int, sums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/find-array-given-subset-sums/
        tag: construction|brain_teaser|classical
        """
        low = min(sums)
        if low < 0:
            sums = [num - low for num in sums]

        cnt = Counter(sums)
        lst = sorted(cnt.keys())
        cnt[0] -= 1
        ans = []
        pre = defaultdict(int)
        pre_sum = []
        for _ in range(n):
            for num in lst:
                if cnt[num] > pre[num]:
                    ans.append(num)
                    for p in pre_sum[:]:
                        pre[p + num] += 1
                        pre_sum.append(p + num)
                    pre[num] += 1
                    pre_sum.append(num)
                    break

        for i in range(1 << n):
            cur = [j for j in range(n) if i & (1 << j)]
            if sum(ans[j] for j in cur) == -low:
                for j in cur:
                    ans[j] *= -1
                return ans
        return []

    @staticmethod
    def lc_2663(s: str, k: int) -> str:
        """
        url: https://leetcode.cn/problems/lexicographically-smallest-beautiful-string/
        tag: greedy|construction|palindrome_substring|lexicographical_order|reverse_order|brute_force
        """
        n = len(s)
        for i in range(n - 1, -1, -1):
            for x in range(ord(s[i]) - ord("a") + 1, k):
                w = chr(ord("a") + x)
                if (i == 0 or s[i - 1] != w) and not (i >= 2 and w == s[i - 2]):
                    ans = s[:i] + w
                    while len(ans) < n:
                        for y in range(0, k):
                            x = chr(y + ord("a"))
                            if x != ans[-1] and (len(ans) < 2 or ans[-2] != x):
                                ans += x
                                break
                    return ans
        return ""

    @staticmethod
    def lg_p7947(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7947
        tag: greedy|construction|product_n_sum_k|prime_factorization|brain_teaser
        """
        n, k = ac.read_list_ints()
        ans = []
        for p, c in NumFactor().get_prime_factor(n):
            ans.extend([p] * c)
        if sum(ans) > k:
            ac.st(-1)
        else:
            ans.extend([1] * (k - sum(ans)))
            ac.st(len(ans))
            ac.lst(ans)
        return

    @staticmethod
    def lg_p9101(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9101
        tag: construction|directed_graph|no_circle|classical|number_of_path
        """
        k = ac.read_int()
        ac.st(98)
        ac.lst([33, -1])
        for i in range(2, 34):
            if k & (1 << (i - 2)):
                cur = [i + 32]
            else:
                cur = [-1]
            if i > 2:
                cur.append(i - 1)
            else:
                cur.append(-1)
            ac.lst(cur)
        for i in range(34, 99):
            if i in [34, 66]:
                ac.lst([98, -1])
            elif i == 98:
                ac.lst([-1, -1])
            else:
                ac.lst([i - 1, i - 33 if i >= 67 else i + 31])
        return

    @staticmethod
    def lg_p8976(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8976
        tag: brute_force|construction|classical
        """
        for _ in range(ac.read_int()):
            n, a, b = ac.read_list_ints()
            mid = n // 2 + 1
            if a + b > n * (n + 1) // 2 or max(a, b) > (n // 2) * (mid + n) // 2:
                ac.st(-1)
                continue
            s = n * (n + 1) // 2
            lst = [a, b]
            ans = []
            for i in range(n // 2 + 1):
                if ans:
                    break
                x = n // 2 - i
                for aa, bb in [[0, 1], [1, 0]]:
                    if x:
                        rest = lst[aa] - i * (i + 1) // 2
                        y = math.ceil((rest * 2 / x - x + 1) / 2)
                        y = max(y, i + 1)

                        if y + x - 1 <= n:
                            cur = i * (i + 1) // 2 + x * (y + y + x - 1) // 2
                            if cur >= lst[aa] and s - cur >= lst[bb]:
                                pre = list(range(1, i + 1)) + list(range(y, y + x))
                                post = list(range(i + 1, y)) + list(range(y + x, n + 1))
                                ans = pre + post if aa == 0 else post + pre
                                break
                    else:
                        if n // 2 * (1 + n // 2) // 2 >= a and s - a >= b:
                            ans = list(range(1, n + 1))
                            break
            if not ans:
                ac.st(-1)
            else:
                ac.lst(ans)
        return

    @staticmethod
    def lg_p8910(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8910
        tag: permutation_circle|construction|classical|brain_teaser
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nex = [0] * (n + 1)
            for i in range(k):
                nex[i] = n - k + i
            for i in range(k, n):
                nex[i] = i - k
            ans = []
            for i in range(n):
                if nex[i] != i:
                    lst = [i]
                    while nex[lst[-1]] != i:
                        lst.append(nex[lst[-1]])
                    m = len(lst)
                    ans.append([n + 1, lst[0] + 1])
                    for x in range(1, m):
                        ans.append([lst[x - 1] + 1, lst[x] + 1])
                    ans.append([lst[m - 1] + 1, n + 1])
                    for x in lst:
                        nex[x] = x
            ac.st(len(ans))
            for a in ans:
                ac.lst(a)
        return

    @staticmethod
    def lg_p8880(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8880
        tag: brain_teaser|construction|odd_even|classical
        """
        n = ac.read_int()
        if n % 2 == 0:
            ac.st(-1)
            return
        nums = ac.read_list_ints()
        ind = {num: i for i, num in enumerate(nums)}
        a = [-1] * n
        b = [-1] * n
        for i in range(n):
            j = (i - 1) % n
            x = (i + j) % n
            a[ind[x]] = i
            b[ind[x]] = j
        ac.lst(a)
        ac.lst(b)
        return

    @staticmethod
    def cf_1823d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1823/problem/D
        tag: greedy|construction|palindrome
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            x = [0] + [x - 3 for x in ac.read_list_ints()]
            c = [0] + [x - 3 for x in ac.read_list_ints()]
            st = "abc"
            ans = ["abc"]
            ind = 0
            for i in range(k):
                dx = x[i + 1] - x[i]
                dc = c[i + 1] - c[i]
                if dx < dc:
                    ac.no()
                    break
                ans.append(chr(ord("d") + i) * dc)
                for _ in range(dx - dc):
                    ans.append(st[ind])
                    ind += 1
                    ind %= 3
            else:
                ac.yes()
                ac.st("".join(ans))
        return

    @staticmethod
    def cf_1722g(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1722/G
        tag: odd_even|xor_property|construction
        """

        # def sum_xor(n):
        #     """xor num of range(0, x+1)"""
        #     if n % 4 == 0:
        #         return n  # (4*i)^(4*i+1)^(4*i+2)^(4*i+3)=0
        #     elif n % 4 == 1:
        #         return 1  # n^(n-1)
        #     elif n % 4 == 2:
        #         return n + 1  # n^(n-1)^(n-2)
        #     return 0  # n^(n-1)^(n-2)^(n-3)

        for _ in range(ac.read_int()):
            n = ac.read_int()  # n >= 3
            if n % 4 == 0:
                ans = list(range(n))
            elif n % 4 == 1:
                ans = [0] + list(range(2, n + 1))
            elif n % 4 == 2:
                ans = list(range(1, n - 1)) + [1 << 20, (1 << 20) | (n - 2)]
            else:
                ans = list(range(1, n + 1))
            ac.lst(ans)
        return

    @staticmethod
    def cf_1005f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1005/problem/F
        tag: construction|shortest_path_spanning_tree|classical|dfs|specific_plan
        """
        n, m, k = ac.read_list_ints()
        edges = [[] for _ in range(n)]
        for i in range(m):
            x, y = ac.read_list_ints_minus_one()
            edges[x].append((y, i))
            edges[y].append((x, i))
        stack = deque([0])
        choose = [0] * m
        visit = [math.inf] * n
        visit[0] = 1
        while stack:
            x = stack.popleft()
            for y, i in edges[x]:
                if visit[y] == math.inf:
                    choose[i] = 1
                    stack.append(y)
                    visit[y] = visit[x] + 1
        edges = [[i for y, i in edges[x] if visit[y] + 1 == visit[x]] for x in range(n)]
        del visit
        del choose

        ans = []
        use = [0] * n
        for _ in range(k):
            res = ["0"] * m
            for i in range(1, n):
                res[edges[i][use[i]]] = "1"
            ans.append("".join(res))
            for i in range(1, n):
                if use[i] + 1 < len(edges[i]):
                    use[i] += 1
                    break
                else:
                    use[i] = 0
            else:
                break
        ac.st(len(ans))
        ac.st("\n".join(ans))
        return

    @staticmethod
    def cf_1141g(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1141/G
        tag: construction|dfs|color_method|greedy|classical
        """
        n, k = ac.read_list_ints()
        edges = [[] for _ in range(n)]

        for i in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edges[x].append((y, i))
            edges[y].append((x, i))

        if k == n:
            ac.st(1)
            ac.lst([1] * (n - 1))
            return
        degree = [len(x) for x in edges]
        color = sorted(degree, reverse=True)[k]
        ans = [-1] * (n - 1)
        stack = [(0, -1, -1)]
        while stack:
            x, fa, c = stack.pop()
            cur = 1
            for y, i in edges[x]:
                if y != fa:
                    if cur == c:
                        cur += 1
                    if cur > color:
                        cur = 1
                    ans[i] = cur
                    stack.append((y, x, cur))
                    cur += 1
                    if cur > color:
                        cur = 1
        ac.st(color)
        ac.lst(ans)
        return

    @staticmethod
    def abc_251f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc251/tasks/abc251_f
        tag: construction|dfs|bfs|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for ind in range(m):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(y)
            dct[y].append(x)

        ind = [0] * n
        ans = []
        stack = [0]
        visit = [0] * n
        visit[0] = 1
        while stack:
            x = stack[-1]
            while ind[x] < len(dct[x]):
                y = dct[x][ind[x]]
                ind[x] += 1
                if not visit[y]:
                    stack.append(y)
                    ans.append([x + 1, y + 1])
                    visit[y] = 1
                    break
            else:
                stack.pop()
        for a in ans:
            ac.lst(a)

        ans = []
        stack = [0]
        visit = [0] * n
        visit[0] = 1
        while stack:
            x = stack.pop()
            for y in dct[x]:
                if not visit[y]:
                    stack.append(y)
                    ans.append([x + 1, y + 1])
                    visit[y] = 1
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def abc_251d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc251/tasks/abc251_d
        tag: construction|brute_force|brain_teaser
        """
        ac.read_int()
        base = list(range(1, 100))
        ans = base[:]
        ans.extend([x * 100 for x in base])
        ans.extend([x * 10000 for x in base])
        ans.append(1000000)
        ac.st(len(ans))
        ac.lst(ans)
        return

    @staticmethod
    def abc_239f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc239/tasks/abc239_f
        tag: implemention|construction|greedy|brain_teaser|union_find
        """
        n, m = ac.read_list_ints()
        degree = ac.read_list_ints()
        uf = UnionFind(n)
        pre = degree[:]
        edges = []
        for _ in range(m):
            a, b = ac.read_list_ints_minus_one()
            if not uf.union(a, b):
                ac.st(-1)
                return
            degree[a] -= 1
            degree[b] -= 1
            edges.append((a, b))
        if min(degree) < 0:
            ac.st(-1)
            return
        group = uf.get_root_part()
        group_degree = []
        group_wait = defaultdict(list)
        for g in group:
            dd = sum(degree[x] for x in group[g])
            if dd:
                heappush(group_degree, (-dd, g))
                for x in group[g]:
                    if degree[x]:
                        heappush(group_wait[g], (-degree[x], x))
        ans = []
        while group_degree:
            if len(group_degree) == 1:
                ac.st(-1)
                return
            d1, g1 = heappop(group_degree)
            d2, g2 = heappop(group_degree)
            d1 = -d1
            d2 = -d2
            d1 -= 1
            d2 -= 1
            dd1, xx1 = heappop(group_wait[g1])
            dd2, xx2 = heappop(group_wait[g2])
            dd1 = -dd1 - 1
            dd2 = -dd2 - 1
            ans.append([xx1 + 1, xx2 + 1])
            if dd1:
                heappush(group_wait[g1], (-dd1, xx1))
            if dd2:
                heappush(group_wait[g2], (-dd2, xx2))

            d = d1 + d2
            if len(group_wait[g1]) > len(group_wait[g2]):
                g = g1
                while group_wait[g2]:
                    heappush(group_wait[g1], heappop(group_wait[g2]))
            else:
                g = g2
                while group_wait[g1]:
                    heappush(group_wait[g2], heappop(group_wait[g1]))
            if d:
                heappush(group_degree, (-d, g))
        if len(ans) == n - m - 1:
            uf = UnionFind(n)
            for a, b in edges:
                pre[a] -= 1
                pre[b] -= 1
                uf.union(a, b)
            for a, b in ans:
                pre[a - 1] -= 1
                pre[b - 1] -= 1
                uf.union(a - 1, b - 1)
            if uf.part != 1 or any(x != 0 for x in pre):
                ac.st(-1)
                return
            for a in ans:
                ac.lst(a)
        else:
            ac.st(-1)
        return

    @staticmethod
    def abc_233f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc233/tasks/abc233_f
        tag: graph|union_find|construction|mst|brain_teaser|classical
        """
        n = ac.read_int()
        p = ac.read_list_ints_minus_one()
        m = ac.read_int()
        dct = [dict() for _ in range(n)]
        uf = UnionFind(n)
        edges = []
        for i in range(m):
            a, b = ac.read_list_ints_minus_one()
            if uf.union(a, b):
                dct[a][b] = i
                dct[b][a] = i
            edges.append((a, b))
        lst = p[:]
        group = uf.get_root_part()
        for g in group:
            vals = [p[x] for x in group[g]]
            ind = group[g]
            vals.sort()
            for i, v in zip(ind, vals):
                lst[i] = v
        if lst != list(range(n)):
            ac.st(-1)
            return
        res = []

        for i in range(n):
            if p[i] != i:
                parent = [-1] * n
                j = p.index(i)
                stack = [(i, -1)]
                visit = [0] * n
                visit[i] = 1
                while stack:
                    x, fa = stack.pop()
                    for y in dct[x]:
                        if y != fa and not visit[y]:
                            stack.append((y, x))
                            parent[y] = x
                            visit[y] = 1
                path = [j]
                while path[-1] != i:
                    path.append(parent[path[-1]])

                m = len(path)
                for x in range(1, m):
                    a, b = path[x - 1], path[x]
                    p[a], p[b] = p[b], p[a]
                    res.append(dct[a][b] + 1)

                for x in range(m - 2, 0, -1):
                    a, b = path[x - 1], path[x]
                    p[a], p[b] = p[b], p[a]
                    res.append(dct[a][b] + 1)
        ac.st(len(res))
        ac.lst(res)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/ENVPILE
        tag: bfs|construction|classical
        """
        for _ in range(ac.read_int()):
            n, w = ac.read_list_ints()
            parent = [-1] * 5001
            nums = ac.read_list_ints()
            ind = list(range(n))
            ind.sort(key=lambda it: -nums[it])
            stack = [w]
            visit = [0] * 5001
            visit[w] = 1
            while stack:
                nex = []
                for x in stack:
                    for i in ind:
                        if nums[i] <= x:
                            break
                        y = nums[i] - x
                        if not visit[y]:
                            visit[y] = 1
                            nex.append(y)
                            parent[y] = i
                stack = nex[:]
            for x in range(nums[0]):
                if visit[x]:
                    ans = []
                    while x != w:
                        i = parent[x]
                        ans.append(i + 1)
                        x = nums[i] - x
                    ans.reverse()
                    for i in range(n):
                        ans.append(i + 1)
                    ac.st(len(ans))
                    ac.lst(ans)
                    break
            else:
                ac.st(-1)
        return

    @staticmethod
    def cf_1217d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1217/D
        tag: construction|observation|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        edges = []
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            degree[j] += 1
            edges.append((i, j))
        stack = [i for i in range(n) if not degree[i]]
        while stack:
            i = stack.pop()
            for j in dct[i]:
                degree[j] -= 1
                if not degree[j]:
                    stack.append(j)
        if not max(degree):
            ac.st(1)
            ac.lst([1] * m)
        else:
            ac.st(2)
            ans = [1 if i > j else 2 for i, j in edges]
            ac.lst(ans)
        return

    @staticmethod
    def cf_1364d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1364/D
        tag: dfs_tree|construction|independent_set|union_find|undirected_circle|undirected_local_shortest_circle
        """
        n, m, k = ac.read_list_ints()

        other = []
        dct = [[] for _ in range(n)]
        uf = UnionFind(n)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            if uf.union(i, j):
                dct[i].append(j)
                dct[j].append(i)
            else:
                other.append((i, j))

        parent = [-1] * n
        stack = [0]
        dis = [0] * n
        while stack:
            x = stack.pop()
            for y in dct[x]:
                if y != parent[x]:
                    parent[y] = x
                    stack.append(y)
                    dis[y] = dis[x] + 1
        if not other:
            odd = [i + 1 for i in range(n) if dis[i] % 2 == 0]
            ac.st(1)
            if len(odd) >= (k + 1) // 2:
                ac.lst(odd[:(k + 1) // 2])
            else:
                even = [i + 1 for i in range(n) if dis[i] % 2]
                ac.lst(even[:(k + 1) // 2])
        else:
            res = []
            for i, j in other:
                if not res or abs(dis[i] - dis[j]) < abs(dis[res[0]] - dis[res[1]]):
                    res = [i, j]
            i, j = res
            pre = [i]
            post = [j]
            while pre[-1] != post[-1]:
                if dis[pre[-1]] < dis[post[-1]]:
                    post.append(parent[post[-1]])
                else:
                    pre.append(parent[pre[-1]])
            pre.extend(post[:-1][::-1])
            if len(pre) <= k:
                ac.st(2)
                ac.st(len(pre))
                ac.lst([x + 1 for x in pre])
            else:
                res = [pre[i] + 1 for i in range(0, len(pre) - 1, 2)]
                ac.st(1)
                ac.lst(res[:(k + 1) // 2])
        return

    @staticmethod
    def cf_1809c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1809/C
        tag: construction|diff_array|reverse_pair
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            pre = list(range(n, -1, -1))
            for i in range(n + 1):
                for j in range(i + 1, n + 1):
                    if k:
                        k -= 1
                        pre[i], pre[j] = pre[j], pre[i]
                    else:
                        break
            for i in range(n, 0, -1):
                pre[i] -= pre[i - 1]
            ac.lst(pre[1:])
        return

    @staticmethod
    def abc_362f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc362/tasks/abc362_f
        tag: construction|greedy|observation
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        sub = [1] * n
        parent = [-1] * n
        stack = [(0, -1)]
        while stack:
            x, fa = stack.pop()
            if x >= 0:
                stack.append((~x, fa))
                for y in dct[x]:
                    if y != fa:
                        stack.append((y, x))
                        parent[y] = x
            else:
                x = ~x
                for y in dct[x]:
                    if y != fa:
                        sub[x] += sub[y]
        root = -1
        for i in range(n):
            lst = [sub[j] for j in dct[i] if j != parent[i]]
            lst.append(n - sum(lst) - 1)
            if max(lst) <= n // 2:
                root = i
                break

        parent = [-1] * n
        stack = [(root, -1)]
        son = [[] for _ in range(n)]
        while stack:
            x, fa = stack.pop()
            for y in dct[x]:
                if y != fa:
                    if parent[x] == -1:
                        parent[y] = y
                    else:
                        parent[y] = parent[x]
                    son[parent[y]].append(y)
                    stack.append((y, x))
        stack = [-len(son[x]) * n - x for x in dct[root]]
        heapify(stack)
        while len(stack) >= 2:
            x = -heappop(stack) % n
            y = -heappop(stack) % n
            ac.lst([son[x].pop() + 1, son[y].pop() + 1])
            if son[x]:
                heappush(stack, -len(son[x]) * n - x)
            if son[y]:
                heappush(stack, -len(son[y]) * n - y)
        if stack:
            x = -heappop(stack) % n
            ac.lst([x + 1, root + 1])
        return

    @staticmethod
    def cf_1635d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1635/problem/D
        tag: fibonacci|brain_teaser|construction
        """
        n, p = ac.read_list_ints()
        mod = 10 ** 9 + 7
        ceil = 2 * 10 ** 5 + 10
        f = [0] * (ceil + 1)
        pre = [0] * (ceil + 1)
        f[1] = f[2] = 1
        pre[1] = 1
        pre[2] = 2
        for i in range(3, ceil + 1):
            f[i] = (f[i - 1] + f[i - 2]) % mod
            pre[i] = (pre[i - 1] + f[i]) % mod

        def check(x):
            while x:
                if x in visit:
                    return False
                if x & 1:
                    x >>= 1
                elif x & 2:
                    break
                else:
                    x >>= 2
            return True

        nums = ac.read_list_ints()
        nums.sort()
        visit = set()
        for num in nums:
            if check(num):
                visit.add(num)
        ans = 0
        for num in visit:
            b = num.bit_length()
            if p - b + 1 > 0:
                ans += pre[p - b + 1]
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1882c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1882/C
        tag: observation|suffix|brute_force|construction
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            post = [0] * (n + 1)
            for i in range(n - 1, -1, -1):
                post[i] = post[i + 1] + max(0, nums[i])
            ans = 0
            for i in range(n):
                ans = max(ans, post[i + 1] + nums[i] if i % 2 == 0 else post[i + 1])
            ac.st(ans)
        return

    @staticmethod
    def cf_1567c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1567/C
        tag: observation|construction
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            odd = int("0" + s[:][::2])
            even = int("0" + s[1:][::2])
            ans = (odd + 1) * (even + 1) - 2
            ac.st(ans)
        return

    @staticmethod
    def cf1718a2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1718/A2
        tag: bit_operation|brain_teaser|construction|greedy
        """
        ac.get_random_seed()
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            ans = n

            pre = 0
            dct = {pre ^ ac.random_seed}
            for num in nums:
                pre ^= num
                if pre ^ ac.random_seed in dct:
                    ans -= 1
                    pre = 0
                    dct = {pre ^ ac.random_seed}
                else:
                    dct.add(pre ^ ac.random_seed)
            ac.st(ans)
        return

    @staticmethod
    def cf_1450d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1450/D
        tag: construction|induction|recursion
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints_minus_one()
            cnt = [0] * n
            for num in nums:
                cnt[num] += 1
            i, j = 0, n - 1
            ans = ["0"] * n
            for x in range(n - 1):
                if cnt[x] == 0:
                    break
                ans[x] = "1"
                if cnt[x] > 1:
                    break
                if nums[i] == x:
                    i += 1
                elif nums[j] == x:
                    j -= 1
                else:
                    break
            for x in range(n):
                if cnt[x] != 1:
                    ans[n - 1] = "0"
                    break
            else:
                ans[n - 1] = "1"
            ac.st("".join(ans)[::-1])
        return

    @staticmethod
    def cf_1583d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1583/D
        tag: interactive|brain_teaser|classical
        """
        ac.flush = True
        n = ac.read_int()
        ans = [0] * n
        lst = [n - 1]
        for k in range(2, n + 1):
            cur = [1] * (n - 1) + [k]
            ac.lst(["?"] + cur)
            w = ac.read_int()
            if w == 0:
                break
            lst.append(w - 1)
        lst.reverse()
        for i, x in enumerate(lst):
            ans[x] = n - i

        for k in range(2, ans[-1] + 1):
            cur = [k] * n
            for i in range(n):
                if ans[i] != 0:
                    cur[i] = n
            cur[-1] = 1
            ac.lst(["?"] + cur)
            w = ac.read_int()
            if w == 0:
                break
            ans[w - 1] = ans[-1] + 1 - k
        ac.lst(["!"] + ans)
        return

    @staticmethod
    def lc_100431(n: int, edges: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.com/problems/construct-2d-grid-matching-graph-layout/
        tag: construction|unweighted_graph
        """
        degree = [0] * n
        graph = UnWeightedGraph(n)
        for i, j in edges:
            degree[i] += 1
            degree[j] += 1
            graph.add_undirected_edge(i, j)
        if 1 in degree:
            x = degree.index(1)
            dis = graph.bfs(x, 0)
            ans = [0] * n
            for i in range(n):
                ans[dis[i]] = i
            return [ans]

        degree3 = degree.count(3)
        k = len(edges)
        nodes = [i for i in range(n) if degree[i] == 2]
        for m in range(1, n + 1):
            if n % m == 0:
                p = n // m
                if 2 * m - 4 + 2 * p - 4 == degree3 and degree3 * 3 + 2 * 4 + (n - degree3 - 4) * 4 == 2 * k:
                    for perm in permutations(nodes, 2):
                        x, y = perm
                        dis1 = graph.bfs(x, 0)
                        dis2 = graph.bfs(y, 0)
                        flag = 1
                        lst = []
                        for i in range(n):
                            z1 = dis1[i]
                            z2 = dis2[i]
                            if (z1 + z2 - (m - 1)) % 2:
                                flag = 0
                                break
                            y = (z1 + z2 - (m - 1)) // 2
                            x = z1 - y
                            if not 0 <= x < m and 0 <= y < p:
                                flag = 0
                                break
                            lst.append((x, y))
                        if flag:
                            ans = [[0] * p for _ in range(m)]
                            for i in range(n):
                                ans[lst[i][0]][lst[i][1]] = i
                            return ans
        return []
"""
Algorithm：date
Description：date|year|week|month|day|hour|second


=====================================LuoGu======================================
P2655（https://www.luogu.com.cn/problem/P2655）after_date
P1167#submit（https://www.luogu.com.cn/problem/P1167#submit）between_date
P5407（https://www.luogu.com.cn/problem/P5407）between_date
P5440（https://www.luogu.com.cn/problem/P5440）brute_force|prime


"""
import datetime
from datetime import datetime, timedelta

from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p2655(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2655
        tag: after_date
        """
        n = ac.read_int()
        for _ in range(n):
            lst = ac.read_list_ints()
            x = (1 << (lst[0] - 1)) - 1
            y = lst[1]
            m, d, h, m, s = lst[2:]
            start_date = datetime(year=y, month=m, day=d, hour=h, minute=m, second=s)
            end_date = start_date + timedelta(seconds=x)
            ac.lst([end_date.year, end_date.month, end_date.day, end_date.hour, end_date.minute, end_date.second])
        return
"""

Algorithm：diff_array|prefix_sum|suffix_sum|prefix_max_consequence_sum|suffix_max_consequence_sum|diff_matrix|discretization_diff_array|md_diff_array|matrix_prefix_sum
Description：prefix_sum|prefix_sum_of_prefix_sum|suffix_sum

====================================LeetCode====================================
152（https://leetcode.cn/problems/maximum-product-subarray/）prefix_mul|maximum_sub_consequence_product
598（https://leetcode.cn/problems/range-addition-ii/）diff_matrix
2281（https://leetcode.cn/problems/sum-of-total-strength-of-wizards/）brute_force|prefix_sum_of_prefix_sum
2251（https://leetcode.cn/problems/number-of-flowers-in-full-bloom/）discretization_diff_array
2132（https://leetcode.cn/problems/stamping-the-grid/）prefix_sum|brute_force|diff_matrix|implemention
1229（https://leetcode.cn/problems/meeting-scheduler/）discretization_diff_array
6292（https://leetcode.cn/problems/increment-submatrices-by-one/）diff_matrix|prefix_sum
2565（https://leetcode.cn/problems/subsequence-with-the-minimum-score/）prefix_suffix|pointer|brute_force
644（https://leetcode.cn/problems/maximum-average-subarray-ii/）prefix_sum|binary_search|average
1292（https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/）O(mn)|brute_force
1674（https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/）diff_array|action_scope|counter
1714（https://leetcode.cn/problems/sum-of-special-evenly-spaced-elements-in-array/）prefix_sum
1738（https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/）matrix_prefix_xor_sum
1895（https://leetcode.cn/problems/largest-magic-square/）matrix_prefix_sum|brute_force
1943（https://leetcode.cn/problems/describe-the-painting/）discretization_diff_array
2021（https://leetcode.cn/problems/brightest-position-on-street/）discretization_diff_array
837（https://leetcode.cn/problems/new-21-game/description/）diff_array|implemention|probability
891（https://leetcode.cn/problems/sum-of-subsequence-widths/description/）prefix_suffix|brute_force|counter
1191（https://leetcode.cn/problems/k-concatenation-maximum-sum/description/）prefix_suffix|max_sub_consequence_sum
1074（https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/description/）matrix_prefix_sum|brute_force
1139（https://leetcode.cn/problems/largest-1-bordered-square/）matrix_prefix_sum|counter|brute_force
2281（https://leetcode.cn/problems/sum-of-total-strength-of-wizards/description/）monotonic_stack|counter|prefix_sum_of_prefix_sum
995（https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/description/）greedy|diff_array|implemention
986（https://leetcode.cn/problems/interval-list-intersections/description/）discretization_diff_array|two_pointers
1744（https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/description/）prefix_sum|greedy|implemention
1703（https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/）prefix_sum|median|greedy|1520E
2167（https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/）math|prefix_sum|brute_force
2983（https://leetcode.cn/problems/palindrome-rearrangement-queries/）brain_teaser|prefix_sum|brute_force|range_intersection
3017（https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-ii/description/）diff_array|classical
100311（https://leetcode.cn/contest/weekly-contest-400/problems/count-days-without-meetings/）discretization_diff_array

=====================================LuoGu======================================
list?user=739032&status=12&page=15（https://www.luogu.com.cn/record/list?user=739032&status=12&page=15）suffix_sum
P2367（https://www.luogu.com.cn/problem/P2367）diff_array
P2280（https://www.luogu.com.cn/problem/P2280）matrix_prefix_sum
P3138（https://www.luogu.com.cn/problem/P3138）matrix_prefix_sum
P3406（https://www.luogu.com.cn/problem/P3406）diff_array|greedy
P3655（https://www.luogu.com.cn/problem/P3655）diff_array|implemention
P5542（https://www.luogu.com.cn/problem/P5542）diff_matrix
P5686（https://www.luogu.com.cn/problem/P5686）prefix_sum_of_prefix_sum
P6180（https://www.luogu.com.cn/problem/P6180）prefix_sum|counter
P6481（https://www.luogu.com.cn/problem/P6481）prefix|range_update
P2956（https://www.luogu.com.cn/problem/P2956）diff_matrix|prefix_sum
P3397（https://www.luogu.com.cn/problem/P3397）diff_matrix|prefix_sum
P1869（https://www.luogu.com.cn/problem/P1869）prefix_sum|comb|odd_even
P7667（https://www.luogu.com.cn/problem/P7667）math|sort|prefix_sum
P2671（https://www.luogu.com.cn/problem/P2671）prefix_or_sum|counter|brute_force|odd_even
P1719（https://www.luogu.com.cn/problem/P1719）max_sub_matrix_sum|brute_force|prefix_sum
P2882（https://www.luogu.com.cn/problem/P2882）greedy|brute_force|diff_array
P4552（https://www.luogu.com.cn/problem/P4552）diff_array|brain_teaser|classical
P1627（https://www.luogu.com.cn/problem/P1627）prefix_suffix|median|counter
P1895（https://www.luogu.com.cn/problem/P1895）prefix_sum|counter|binary_search
P1982（https://www.luogu.com.cn/problem/P1982）maximum_prefix_sub_consequence_sum|prefix_max
P2070（https://www.luogu.com.cn/problem/P2070）hash|discretization_diff_array|counter
P2190（https://www.luogu.com.cn/problem/P2190）diff_array|circular_array
P2352（https://www.luogu.com.cn/problem/P2352）discretization_diff_array
P2363（https://www.luogu.com.cn/problem/P2363）matrix_prefix_sum|brute_force
P2706（https://www.luogu.com.cn/problem/P2706）max_sub_matrix_sum
P2879（https://www.luogu.com.cn/problem/P2879）diff_array|greedy
P3028（https://www.luogu.com.cn/problem/P3028）discretization_diff_array|range_cover
P4030（https://www.luogu.com.cn/problem/P4030）brain_teaser|matrix_prefix_sum
P4440（https://www.luogu.com.cn/problem/P4440）prefix_sum|counter
P4623（https://www.luogu.com.cn/problem/P4623）discretization_diff_array|counter
P6032（https://www.luogu.com.cn/problem/P6032）prefix_suffix|counter
P6278（https://www.luogu.com.cn/problem/P6278）reverse_order_pair|action_scope|diff_array|prefix_sum
P6537（https://www.luogu.com.cn/problem/P6537）prefix_sum|brute_force
P6877（https://www.luogu.com.cn/problem/P6877）sort|greedy|prefix_suffix|dp|brute_force
P6878（https://www.luogu.com.cn/problem/P6878）prefix_suffix|brute_force
P8081（https://www.luogu.com.cn/problem/P8081）diff_array|counter|action_scope
P8033（https://www.luogu.com.cn/problem/P8033）matrix_prefix_sum|counter
P7992（https://www.luogu.com.cn/problem/P7992）bucket_counter|action_scope|diff_array|counter
P7948（https://www.luogu.com.cn/problem/P7948）sort|prefix_suffix|pointer
P8343（https://www.luogu.com.cn/problem/P8343）sub_matrix_prefix_sum|brute_force|two_pointers
P8551（https://www.luogu.com.cn/problem/P8551）diff_array
P8666（https://www.luogu.com.cn/problem/P8666）binary_search|md_diff_array|implemention
P8715（https://www.luogu.com.cn/problem/P8715）prefix_suffix|counter
P8783（https://www.luogu.com.cn/problem/P8783）O(n^3)|two_pointers|brute_force|counter|sub_matrix
P6070（https://www.luogu.com.cn/problem/P6070）diff_array|matrix_diff_array|flatten
P3016（https://www.luogu.com.cn/problem/P3016）prefix_sum|triangle|left_up_sum|inclusion_exclusion


===================================CodeForces===================================
33C（https://codeforces.com/problemset/problem/33/C）prefix_suffix|brute_force
797C（https://codeforces.com/problemset/problem/797/C）suffix_min|lexicographical_order|implemention
75D（https://codeforces.com/problemset/problem/75/D）max_sub_consequence_sum|compress_arrays
1355C（https://codeforces.com/problemset/problem/1355/C）action_scope|diff_array|triangle
1795C（https://codeforces.com/problemset/problem/1795/C）prefix_sum|binary_search|diff_array|counter|implemention
1343D（https://codeforces.com/problemset/problem/1343/D）brute_force|diff_array|counter
1722E（https://codeforces.com/problemset/problem/1722/E）data_range|matrix_prefix_sum
1772D（https://codeforces.com/contest/1772/problem/D）discretization_diff_array|action_scope|counter
1015E2（https://codeforces.com/contest/1015/problem/E2）brute_force|dp|diff_array
1234E（https://codeforces.com/contest/1234/problem/E）brute_force|diff_array|classical|action_scope
1985H1（https://codeforces.com/contest/1985/problem/H1）union_find|contribution_method|diff_matrix|brain_teaser
1985H2（https://codeforces.com/contest/1985/problem/H2）union_find|contribution_method|diff_matrix|brain_teaser
245H（https://codeforces.com/problemset/problem/245/H）interval_dp|prefix_sum
1253C（https://codeforces.com/problemset/problem/1253/C）diff_array|contribution_method|greedy|linear_dp
1000C（https://codeforces.com/problemset/problem/1000/C）discretization_diff_array|hash|classical

====================================AtCoder=====================================
ABC106D（https://atcoder.jp/contests/abc106/tasks/abc106_d）prefix_sum|dp|counter
ABC338D（https://atcoder.jp/contests/abc338/tasks/abc338_d）diff_array|action_scope|contribution_method
ABC331D（https://atcoder.jp/contests/abc331/tasks/abc331_d）prefix_sum_matrix|circular_section
ABC309C（https://atcoder.jp/contests/abc309/tasks/abc309_c）discretization_diff_array
ABC288D（https://atcoder.jp/contests/abc288/tasks/abc288_d）diff_array|brain_teaser|classical
ABC347E（https://atcoder.jp/contests/abc347/tasks/abc347_e）diff_array|implemention|prefix
ABC347F（https://atcoder.jp/contests/abc347/tasks/abc347_f）diff_array|matrix_prefix_sum|matrix_rotate|brute_force|implemention
ABC274F（https://atcoder.jp/contests/abc274/tasks/abc274_f）brute_force|brain_teaser|discretization_diff_array|classical
ABC269F（https://atcoder.jp/contests/abc269/tasks/abc269_f）diff_array|inclusion_exclusion|prefix_sum|math|classical
ABC268E（https://atcoder.jp/contests/abc268/tasks/abc268_e）brute_force|diff_array|action_scope|brain_teaser|classical
ABC263D（https://atcoder.jp/contests/abc263/tasks/abc263_d）prefix_sum|brute_force
ABC265D（https://atcoder.jp/contests/abc265/tasks/abc265_d）prefix_sum|brute_force
ABC260E（https://atcoder.jp/contests/abc260/tasks/abc260_e）diff_array|action_scope|two_pointers|hash|classical
ABC221D（https://atcoder.jp/contests/abc221/tasks/abc221_d）discretization_diff_array
ABC210D（https://atcoder.jp/contests/abc210/tasks/abc210_d）prefix_max|matrix_prefix|classical
ABC360D（https://atcoder.jp/contests/abc360/tasks/abc360_d）diff_array|implemention|contribution_method
ABC366D（https://atcoder.jp/contests/abc366/tasks/abc366_d）prefix_sum_cube|md_prefix_sum

=====================================AcWing=====================================
99（https://www.acwing.com/problem/content/description/101/）matrix_prefix_sum
100（https://www.acwing.com/problem/content/102/）diff_array|classical
101（https://www.acwing.com/problem/content/103/）diff_array|greedy
102（https://www.acwing.com/problem/content/104/）prefix_sum|binary_search|brute_force|average
121（https://www.acwing.com/problem/content/description/123/）discretization_diff_array|prefix_sum|two_pointers|binary_search
126（https://www.acwing.com/problem/content/128/）max_sub_matrix_sum
3993（https://www.acwing.com/problem/content/description/3996/）suffix_sum|data_range|brain_teaser

"""
import bisect
import math
from collections import defaultdict
from itertools import accumulate
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.basis.diff_array.template import DiffMatrix, PreFixSumMatrix, PreFixXorMatrix, PreFixSumCube
from src.graph.union_find.template import UnionFindGeneral
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p3397(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3397
        tag: diff_matrix|prefix_sum
        """
        n, m = ac.read_list_ints()
        shifts = []
        for _ in range(m):
            x1, y1, x2, y2 = ac.read_list_ints()
            shifts.append([x1, x2, y1, y2, 1])
        ans = DiffMatrix().get_diff_matrix(n, n, shifts)
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def lg_p4552(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4552
        tag: diff_array|brain_teaser|classical
        """
        n = ac.read_int()
        pre = -1
        pos = 0
        neg = 0
        for _ in range(n):
            num = ac.read_int()
            if pre != -1:
                if pre > num:
                    neg += pre - num
                else:
                    pos += num - pre
            pre = num
        ac.st(max(pos, neg))
        ac.st(abs(pos - neg) + 1)
        return

    @staticmethod
    def lg_p1719(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1719
        tag: max_sub_matrix_sum|brute_force|prefix_sum|classical
        """
        n = ac.read_int()
        total = []
        while len(total) < n * n:
            total.extend(ac.read_list_ints())
        grid = []
        for i in range(n):
            grid.append(total[i * n: (i + 1) * n])
        del total

        ans = float("-math.inf")
        for i in range(n):
            lst = [0] * n
            for j in range(i, n):
                lst = [lst[k] + grid[j][k] for k in range(n)]
                floor = pre = 0
                for num in lst:
                    pre += num
                    ans = max(ans, pre - floor)
                    floor = min(floor, pre)
        ac.st(ans)
        return

    @staticmethod
    def cf_1722e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1722/E
        tag: data_range|matrix_prefix_sum|classical|can_be_discretization_hard_version
        """
        for _ in range(ac.read_int()):
            k, q = ac.read_list_ints()
            rec = [ac.read_list_ints() for _ in range(k)]
            qur = [ac.read_list_ints() for _ in range(q)]
            m = n = 1001
            dp = [[0] * n for _ in range(m)]
            for a, b in rec:
                dp[a][b] += a * b
            pre = [[0] * (n + 1) for _ in range(m + 1)]
            for i in range(m):
                for j in range(n):
                    pre[i + 1][j + 1] = pre[i + 1][j] + \
                                        pre[i][j + 1] - pre[i][j] + dp[i][j]

            for hs, ws, hb, wb in qur:
                hb -= 1
                wb -= 1
                hs += 1
                ws += 1
                ans = pre[hb + 1][wb + 1] - pre[hs][wb + 1] - \
                      pre[hb + 1][ws] + pre[hs][ws]
                ac.st(ans)
        return

    @staticmethod
    def lg_p2671(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2671
        tag: prefix_or_sum|counter|brute_force|odd_even
        """
        n, m = ac.read_list_ints()
        number = ac.read_list_ints()
        colors = ac.read_list_ints()
        mod = 10007

        ans = 0
        pre_sum = [[0, 0] for _ in range(m + 1)]
        pre_cnt = [[0, 0] for _ in range(m + 1)]
        for i in range(n):
            num, color = number[i], colors[i]
            k = i % 2
            z_ax = (i + 1) * pre_sum[color][k]
            z_az = (i + 1) * num * pre_cnt[color][k]
            ans += z_ax + z_az
            pre_sum[color][k] += num
            pre_cnt[color][k] += 1
            ans %= mod

        pre_sum = [[0, 0] for _ in range(m + 1)]
        pre_cnt = [[0, 0] for _ in range(m + 1)]
        for i in range(n - 1, -1, -1):
            num, color = number[i], colors[i]
            k = i % 2
            x_az = (i + 1) * pre_sum[color][k]
            x_ax = (i + 1) * num * pre_cnt[color][k]
            ans += x_ax + x_az
            pre_sum[color][k] += num
            pre_cnt[color][k] += 1
            ans %= mod

        ac.st(ans)
        return

    @staticmethod
    def cf_1795c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1795/C
        tag: prefix_sum|binary_search|diff_array|counter|implemention
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            pre = [0] * (n + 1)
            for i in range(n):
                pre[i + 1] = pre[i] + b[i]

            ans = [0] * n
            diff = [0] * n
            for i in range(n):
                j = bisect.bisect_left(pre, pre[i] + a[i])
                if j == n + 1 or pre[j] > pre[i] + a[i]:
                    j -= 1
                diff[i] += 1
                if j < n:
                    diff[j] -= 1
                if pre[j] - pre[i] < a[i]:
                    if j < n:
                        ans[j] += a[i] - (pre[j] - pre[i])
            for i in range(1, n):
                diff[i] += diff[i - 1]

            for i in range(n):
                ans[i] += b[i] * diff[i]
            ac.lst(ans)
        return

    @staticmethod
    def lc_995(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/description/
        tag: greedy|diff_array|implemention
        """
        n = len(nums)
        ans = 0
        diff = [0] * (n + 1)
        for i in range(n - k + 1):
            diff[i] += diff[i - 1] if i else 0
            nums[i] += diff[i]
            nums[i] %= 2
            if nums[i] == 0:
                nums[i] = 1
                diff[i] += 1
                diff[i + k] -= 1
                ans += 1
        for i in range(n - k + 1, n):
            diff[i] += diff[i - 1] if i else 0
            nums[i] += diff[i]
            nums[i] %= 2
        return ans if all(x == 1 for x in nums) else -1

    @staticmethod
    def lc_1074(matrix: List[List[int]], target: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target/description/
        tag: matrix_prefix_sum|brute_force|classical
        """
        m, n = len(matrix), len(matrix[0])
        pre = PreFixSumMatrix(matrix)
        ans = 0
        for i in range(m):
            for j in range(i, m):
                dct = defaultdict(int)
                dct[0] = 1
                for k in range(n):
                    cur = pre.query(i, 0, j, k)
                    ans += dct[cur - target]
                    dct[cur] += 1
        return ans

    @staticmethod
    def lc_1191(arr: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/k-concatenation-maximum-sum/description/
        tag: prefix_suffix|max_sub_consequence_sum
        """
        mod = 10 ** 9 + 7
        n = len(arr)
        s = sum(arr)
        pre = [0] * n
        x = 0
        for i in range(n):
            x = x if x > 0 else 0
            x += arr[i]
            pre[i] = x

        post = [0] * n
        x = 0
        for i in range(n - 1, -1, -1):
            x = x if x > 0 else 0
            x += arr[i]
            post[i] = x
        ans = max(0, max(pre))
        if k > 1:
            if pre[-1] + post[0] > ans:
                ans = pre[-1] + post[0]
            if pre[-1] + post[0] + s * (k - 2) > ans:
                ans = pre[-1] + post[0] + s * (k - 2)
        return ans % mod

    @staticmethod
    def cf_1355c(a, b, c, d):
        """
        url: https://codeforces.com/problemset/problem/1355/C
        tag: action_scope|diff_array|triangle|classical|brain_teaser|brute_force
        """
        diff = [0] * (b + c + 1)
        for x in range(a, b + 1):
            diff[x + b] += 1
            if x + c + 1 <= b + c:
                diff[x + c + 1] -= 1
        for i in range(1, b + c + 1):
            diff[i] += diff[i - 1]

        for i in range(1, b + c + 1):
            diff[i] += diff[i - 1]

        ans = 0
        for z in range(c, d + 1):
            ans += diff[-1] - diff[min(z, b + c)]
        return ans

    @staticmethod
    def lc_2281(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/sum-of-total-strength-of-wizards/description/
        tag: monotonic_stack|counter|prefix_sum_of_prefix_sum|classical|brain_teaser
        """
        n = len(nums)
        post = [n - 1] * n
        pre = [0] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] > nums[i]:
                post[stack.pop()] = i - 1
            if stack:
                pre[i] = stack[-1] + 1
            stack.append(i)
        mod = 10 ** 9 + 7
        s = list(accumulate(nums, initial=0))
        ss = list(accumulate(s, initial=0))
        ans = 0
        for i in range(n):
            left = pre[i]
            right = post[i]
            ans += nums[i] * ((i - left + 1) * (ss[right + 2] - ss[i + 1]) - (right - i + 1) * (ss[i + 1] - ss[left]))
            ans %= mod
        return ans

    @staticmethod
    def lc_2565(s: str, t: str) -> int:
        """
        url: https://leetcode.cn/problems/subsequence-with-the-minimum-score/
        tag: prefix_suffix|pointer|brute_force|reverse_thinking
        """
        m, n = len(s), len(t)
        pre = [0] * (m + 1)
        ind = 0
        for i in range(m):
            if ind < n and s[i] == t[ind]:
                ind += 1
            pre[i + 1] = ind
        if ind == n:
            return 0

        post = [0] * (m + 1)
        ind = 0
        for i in range(m - 1, -1, -1):
            if ind < n and s[i] == t[-ind - 1]:
                ind += 1
            post[i] = ind

        ans = min(n - (post[i] + pre[i]) for i in range(m + 1))
        return ans

    @staticmethod
    def lg_p2882(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2882
        tag: greedy|brute_force|diff_array|classical
        """
        n = ac.read_int()
        lst = [int(ac.read_str() == "F") for _ in range(n)]
        ans = [math.inf, 0]
        for k in range(1, n + 1):
            diff = [0] * n
            m = 0
            for i in range(n - k + 1):
                if i:
                    diff[i] += diff[i - 1]
                x = diff[i] + lst[i]
                if x % 2:
                    continue
                else:
                    m += 1
                    diff[i] += 1
                    if i + k < n:
                        diff[i + k] -= 1
            for i in range(n - k + 1, n):
                diff[i] += diff[i - 1]
                if (diff[i] + lst[i]) % 2 == 0:
                    break
            else:
                if [m, k] < ans:
                    ans = [m, k]
        ac.lst(ans[::-1])
        return

    @staticmethod
    def cf_1772d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1772/problem/D
        tag: discretization_diff_array|action_scope|counter|classical
        """
        ceil = 10 ** 9
        for _ in range(ac.read_int()):
            n = ac.read_int()
            diff = defaultdict(int)
            nums = ac.read_list_ints()
            for i in range(1, n):
                a, b = nums[i - 1], nums[i]
                if a == b:
                    diff[0] += 1
                    diff[ceil + 1] -= 1
                elif a < b:
                    mid = a + (b - a) // 2
                    diff[0] += 1
                    diff[mid + 1] -= 1
                else:
                    mid = b - (b - a) // 2
                    diff[mid] += 1
                    diff[ceil + 1] -= 1

            axis = sorted(list(diff.keys()))
            m = len(axis)
            for i in range(m):
                if i:
                    diff[axis[i]] += diff[axis[i - 1]]
                if diff[axis[i]] == n - 1:
                    ac.st(axis[i])
                    break
            else:
                ac.st(-1)
        return

    @staticmethod
    def ac_99(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/101/
        tag: matrix_prefix_sum
        """
        n, m = ac.read_list_ints()

        lst = [ac.read_list_ints() for _ in range(n)]
        length = max(max(ls[:-1]) for ls in lst) + 1
        grid = [[0] * length for _ in range(length)]
        for x, y, v in lst:
            grid[x][y] += v
        ans = 0
        dp = [[0] * (length + 1) for _ in range(length + 1)]
        for i in range(length):
            for j in range(length):
                dp[i + 1][j + 1] = dp[i][j + 1] + \
                                   dp[i + 1][j] - dp[i][j] + grid[i][j]
                a, b = max(i - m + 1, 0), max(j - m + 1, 0)
                cur = dp[i + 1][j + 1] - dp[i + 1][b] - dp[a][j + 1] + dp[a][b]
                ans = ans if ans > cur else cur
        ac.st(ans)
        return

    @staticmethod
    def ac_102(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/104/
        tag: prefix_sum|binary_search|brute_force|average
        """
        n, f = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]

        def check(x):
            y = 0
            pre = [0] * (n + 1)
            for i in range(n):
                y += nums[i] * 1000 - x
                pre[i + 1] = pre[i] if pre[i] < y else y
                if i >= f - 1 and y - pre[i - f + 1] >= 0:
                    return True
            return False

        ans = BinarySearch().find_int_right(0, max(nums) * 1000, check)
        ac.st(ans)
        return

    @staticmethod
    def ac_121(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/123/
        tag: discretization_diff_array|prefix_sum|two_pointers|binary_search|classical
        """
        c, b = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(b)]
        lst_x = sorted(list(set([x for x, _ in nums])))
        lst_y = sorted(list(set([x for _, x in nums])))
        m = len(lst_x)
        n = len(lst_y)
        ind_x = {num: i for i, num in enumerate(lst_x)}
        ind_y = {num: i for i, num in enumerate(lst_y)}
        grid = [[0] * (n + 1) for _ in range(m + 1)]
        for x, y in nums:
            grid[ind_x[x] + 1][ind_y[y] + 1] += 1
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                grid[i][j] = grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1] + grid[i][j]

        def check(xx):
            up = 0
            for ii in range(m):
                while up < m and lst_x[up] - lst_x[ii] <= xx - 1:
                    up += 1
                right = 0
                for jj in range(n):
                    while right < n and lst_y[right] - lst_y[jj] <= xx - 1:
                        right += 1
                    cur = grid[up][right] - grid[up][jj] - grid[ii][right] + grid[ii][jj]
                    if cur >= c:
                        return True

            return False

        ans = BinarySearch().find_int_left(0, 10000, check)
        return

    @staticmethod
    def ac_126(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/128/
        tag: max_sub_matrix_sum|brute_force
        """
        n = ac.read_int()
        nums = []
        while len(nums) < n * n:
            nums.extend(ac.read_list_ints())
        grid = [nums[i:i + n] for i in range(0, n * n, n)]
        del nums
        ans = grid[0][0]
        for i in range(n):
            pre = [0] * n
            for k in range(i, n):
                pre = [pre[j] + grid[k][j] for j in range(n)]
                floor = 0
                x = 0
                for j in range(n):
                    x += pre[j]
                    ans = max(ans, x - floor)
                    floor = min(floor, x)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1627(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1627
        tag: prefix_suffix|median|counter|classical
        """
        n, b = ac.read_list_ints()
        nums = ac.read_list_ints()
        i = nums.index(b)

        pre = defaultdict(int)
        cnt = ans = 0
        for j in range(i - 1, -1, -1):
            num = nums[j]
            cnt += 1 if num > b else -1
            pre[cnt] += 1
            if cnt == 0:
                ans += 1

        cnt = 0
        for j in range(i + 1, n):
            num = nums[j]
            cnt += 1 if num > b else -1
            ans += pre[-cnt]
            ans += 1 if not cnt else 0
        ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p1895(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1895
        tag: prefix_sum|counter|binary_search
        """
        n = 10 ** 5
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i - 1] + len(str(i))

        pre = [0] * (n + 1)
        for i in range(1, n + 1):
            pre[i] = pre[i - 1] + dp[i]

        def check(x):
            ii = bisect.bisect_left(pre, x)
            rest = x - pre[ii - 1]
            j = bisect.bisect_left(dp, rest)
            d = rest - dp[j - 1]
            return str(j)[d - 1]

        for _ in range(ac.read_int()):
            ac.st(check(ac.read_int()))
        return

    @staticmethod
    def lg_p1982(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1982
        tag: maximum_prefix_sub_consequence_sum|prefix_max
        """
        n, p = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre = 0
        for i in range(n):
            pre = pre if pre > 0 else 0
            pre += nums[i]
            nums[i] = pre
            if i:
                nums[i] = max(nums[i], nums[i - 1])

        final = nums[0]
        pre = nums[0] * 2
        for i in range(1, n):
            final = max(final, pre)
            pre = max(pre, pre + nums[i])
        pos = 1 if final > 0 else -1
        ac.st(pos * (abs(final) % p))
        return

    @staticmethod
    def lg_p2070(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2070
        tag: hash|discretization_diff_array|counter
        """
        n = ac.read_int()
        pos = 0
        diff = defaultdict(int)
        for _ in range(n):
            dis, op = ac.read_list_strs()
            dis = int(dis)
            if op == "L":
                diff[pos - dis] += 1
                diff[pos] -= 1
                pos -= dis
            else:
                diff[pos] += 1
                diff[pos + dis] -= 1
                pos += dis

        axis = sorted(diff.keys())
        m = len(axis)
        ans = 0
        for i in range(1, m):
            diff[axis[i]] += diff[axis[i - 1]]
            if diff[axis[i - 1]] >= 2:
                ans += axis[i] - axis[i - 1]
        ac.st(ans)
        return

    @staticmethod
    def lg_p2190(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2190
        tag: diff_array|circular_array
        """
        n, m = ac.read_list_ints()
        diff = [0] * n
        for _ in range(m):
            x, y, z = ac.read_list_ints()
            x -= 1
            y -= 1
            if x <= y:
                diff[x] += z
                diff[y] -= z
            else:
                diff[x] += z
                if y > 0:
                    diff[0] += z
                    diff[y] -= z
        for i in range(1, n):
            diff[i] += diff[i - 1]
        ac.st(math.ceil(max(diff) / 36))
        return

    @staticmethod
    def lg_p2352(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2352
        tag: discretization_diff_array
        """
        diff = defaultdict(int)
        for _ in range(ac.read_int()):
            a, b = ac.read_list_ints()
            diff[a] += 1
            diff[b] += 0
            diff[b + 1] -= 1
        axis = sorted(list(diff.keys()))
        m = len(axis)
        ans = diff[axis[0]] * axis[0]
        for i in range(1, m):
            diff[axis[i]] += diff[axis[i - 1]]
            ans = max(ans, diff[axis[i]] * axis[i])
        ac.st(ans)
        return

    @staticmethod
    def lg_p2363(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2363
        tag: matrix_prefix_sum|brute_force|classical
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        pre = PreFixSumMatrix(nums)
        ans = 0
        for i in range(n):
            for j in range(n):
                dct = defaultdict(int)
                for x in range(i + 1):
                    for y in range(j + 1):
                        dct[pre.query(x, y, i, j)] += 1
                for p in range(i + 1, n):
                    for q in range(j + 1, n):
                        ans += dct[pre.query(i + 1, j + 1, p, q)]

                dct = defaultdict(int)
                for x in range(i + 1):
                    for y in range(j, n):
                        dct[pre.query(x, j, i, y)] += 1
                for p in range(i + 1, n):
                    for q in range(j):
                        ans += dct[pre.query(i + 1, q, p, j - 1)]
        ac.st(ans)
        return

    @staticmethod
    def lg_p2706(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2706
        tag: max_sub_matrix_sum|brute_force|classical|monotonic_stack|matrix_prefix_sum
        """
        m, n = ac.read_list_ints()
        grid = []
        while len(grid) < m * n:
            grid.extend(ac.read_list_ints())
        grid = [grid[i:i + n] for i in range(0, m * n, n)]
        pre = PreFixSumMatrix(grid)
        ans = 0
        height = [0] * n
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    height[j] += 1
                else:
                    height[j] = 0

            left = [0] * n
            right = [n - 1] * n
            stack = []
            for j in range(n):
                while stack and height[stack[-1]] > height[j]:
                    right[stack.pop()] = j - 1
                if stack:
                    left[j] = stack[-1] + 1
                stack.append(j)

            for j in range(n):
                if height[j]:
                    cur = pre.query(i - height[j] + 1, left[j], i, right[j])
                    ans = ans if ans > cur else cur
        ac.st(ans)
        return

    @staticmethod
    def lg_p2879(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2879
        tag: diff_array|greedy
        """
        n, _, h, r = ac.read_list_ints()
        diff = [0] * n
        pre = set()
        for _ in range(r):
            a, b = ac.read_list_ints_minus_one()
            if a > b:
                a, b = b, a
            if (a, b) in pre:
                continue
            pre.add((a, b))
            diff[a + 1] -= 1
            diff[b] += 1
        for i in range(1, n):
            diff[i] += diff[i - 1]
        gap = h - max(diff)
        for d in diff:
            ac.st(d + gap)
        return

    @staticmethod
    def lg_p3028(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3028
        tag: discretization_diff_array|range_cover|reverse_thinking
        """
        n = ac.read_int()
        diff = defaultdict(int)
        for _ in range(n):
            a, b = ac.read_list_ints()
            if a > b:
                a, b = b, a
            diff[a] += 1
            diff[b + 1] -= 1
            diff[b] += 0
        axis = sorted(list(diff.keys()))
        ans = diff[axis[0]]
        m = len(axis)
        for i in range(1, m):
            diff[axis[i]] += diff[axis[i - 1]]
            ans = max(ans, diff[axis[i]])
        ac.st(ans)
        return

    @staticmethod
    def lg_p4030(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4030
        tag: brain_teaser|matrix_prefix_sum|classical
        """
        m, n, t = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        mat = [[0] * n for _ in range(m)]
        for i in range(1, m):
            for j in range(1, n):
                a, b = grid[i - 1][j - 1], grid[i - 1][j]
                c, d = grid[i][j - 1], grid[i][j]
                if a + d == b + c:
                    mat[i][j] = 1
        pm = PreFixSumMatrix(mat)
        for i in range(t):
            x, y, k = ac.read_list_ints()
            if k == 1:
                ac.st("Y")
                continue
            x -= 1
            y -= 1
            if pm.query(x + 1, y + 1, x + k - 1, y + k - 1) == (k - 1) * (k - 1):
                ac.st("Y")
            else:
                ac.st("N")
        return

    @staticmethod
    def lg_p4440(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4440
        tag: prefix_sum|counter|alphabet|date_range
        """
        s = ac.read_str()
        pre = []
        cnt = [0] * 26
        pre.append(cnt[:])
        for w in s:
            cnt[ord(w) - ord("a")] += 1
            pre.append(cnt[:])
        for _ in range(ac.read_int()):
            a, b, c, d = ac.read_list_ints_minus_one()
            if d - c != b - a:
                ac.st("NE")
                continue
            if all(pre[b + 1][j] - pre[a][j] == pre[d + 1][j] - pre[c][j] for j in range(26)):
                ac.st("DA")
            else:
                ac.st("NE")
        return

    @staticmethod
    def lg_p4623(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4623
        tag: discretization_diff_array|counter|triangle
        """
        n = ac.read_int()
        m = 10 ** 6 + 1
        diff_x = [0] * m
        diff_y = [0] * m
        for _ in range(n):
            x1, y1, x2, y2, x3, y3 = ac.read_list_ints()
            low_x = min(x1, x2, x3)
            high_x = max(x1, x2, x3)
            low_y = min(y1, y2, y3)
            high_y = max(y1, y2, y3)
            diff_x[low_x + 1] += 1
            diff_x[high_x] -= 1
            diff_y[low_y + 1] += 1
            diff_y[high_y] -= 1

        for i in range(1, m):
            diff_x[i] += diff_x[i - 1]
        for i in range(1, m):
            diff_y[i] += diff_y[i - 1]

        for _ in range(ac.read_int()):
            op, _, num = ac.read_list_strs()
            num = int(num)
            if op == "x":
                ac.st(diff_x[num])
            else:
                ac.st(diff_y[num])
        return

    @staticmethod
    def lg_p6032(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6032
        tag: prefix_suffix|counter|classical
        """
        n, k, p = ac.read_list_ints()  # TLE
        nums = [ac.read_list_ints() for _ in range(n)]
        post = [0] * k
        for cc, _ in nums:
            post[cc] += 1

        pre = dict()
        ans = ss = 0
        for i in range(n):
            cc, pp = nums[i]
            if pp <= p:
                ans += ss + post[cc] - 1
                ss = 0
                pre = dict()
                post[cc] -= 1
                continue

            ss -= pre.get(cc, 0)
            pre[cc] = pre.get(cc, 0) + 1
            post[cc] -= 1
            ss += post[cc]
        ac.st(ans)
        return

    @staticmethod
    def lg_p6278(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6278
        tag: reverse_order_pair|action_scope|diff_array|prefix_sum
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        diff = [0] * (n + 1)
        pre = []
        for num in nums:
            diff[num] += len(pre) - bisect.bisect_right(pre, num)
            bisect.insort_left(pre, num)
        diff = ac.accumulate(diff)
        for i in range(n):
            ac.st(diff[i])
        return

    @staticmethod
    def lg_p6537(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6537
        tag: prefix_sum|brute_force
        """
        n = ac.read_int()
        grid = [ac.read_list_ints() for _ in range(n)]
        pre = PreFixSumMatrix(grid)  # MLE
        ans = 0
        for i in range(n):
            for j in range(n):
                dct = dict()
                for x in range(i + 1):
                    for y in range(j + 1):
                        val = pre.query(x, y, i, j)
                        dct[val] = dct.get(val, 0) + 1
                for x in range(i + 1, n):
                    for y in range(j + 1, n):
                        val = pre.query(i + 1, j + 1, x, y)
                        ans += dct.get(val, 0)
                dct = defaultdict(int)
                for x in range(i + 1):
                    for y in range(j, n):
                        val = pre.query(x, j, i, y)
                        dct[val] = dct.get(val, 0) + 1
                for x in range(i + 1, n):
                    for y in range(j):
                        val = pre.query(i + 1, y, x, j - 1)
                        ans += dct.get(val, 0)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6877(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6877
        tag: sort|greedy|prefix_suffix|dp|brute_force
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        aa = a[:]

        a.sort()
        b.sort()
        pre = [0] * (n + 2)
        for i in range(n):
            pre[i + 1] = max(pre[i], a[i] - b[i])

        post = [0] * (n + 2)
        for i in range(n - 1, -1, -1):
            post[i] = max(post[i + 1], a[i + 1] - b[i])

        ans = dict()
        for i in range(n + 1):
            ans[a[i]] = max(pre[i], post[i])
        ac.lst([ans[x] for x in aa])
        return

    @staticmethod
    def lg_p6878(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6878
        tag: two_pointers|brute_force
        """
        n, k = ac.read_list_ints()
        s = ac.read_str()
        ans = math.inf
        ind1 = [i for i in range(n) if s[i] == "J"]
        ind2 = [i for i in range(n) if s[i] == "O"]
        ind3 = [i for i in range(n) if s[i] == "I"]
        m = len(ind2)
        left = 0
        right = 0

        for mid in range(m - k + 1):
            while left + 1 < len(ind1) and ind1[left + 1] < ind2[mid]:
                left += 1
            while right < len(ind3) and ind3[right] <= ind2[mid + k - 1]:
                right += 1

            if k - 1 <= left < len(ind1) and right < len(ind3) and ind1[left] < ind2[mid] < ind3[
                right] and right + k - 1 < len(ind3):
                cur = ind3[right + k - 1] - ind1[left - k + 1] + 1 - 3 * k
                if cur < ans:
                    ans = cur
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p8081(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8081
        tag: diff_array|counter|action_scope
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ice = []
        cnt = 0
        for i in range(n):
            if nums[i] < 0:
                cnt += 1
            else:
                if cnt:
                    ice.append((i - cnt, i - 1))
                cnt = 0
        if cnt:
            ice.append((n - cnt, n - 1))
        if not ice:
            ac.st(0)
            return

        diff = [0] * n
        ceil = 0
        for x, y in ice:
            t = y - x + 1
            ceil = max(ceil, t)
            low = max(0, x - 2 * t)
            if low <= x - 1:
                diff[low] += 1
                diff[x] -= 1

        diff = ac.accumulate(diff)
        diff = ac.accumulate([int(x == 0) for x in diff[1:]])
        ans = n - diff[-1]
        another = 0
        for x, y in ice:
            t = y - x + 1
            if x - 2 * t - 1 >= 0 and t == ceil:
                another = max(another, diff[x - 2 * t] - diff[max(x - 3 * t, 0)])
        ac.st(ans + another)
        return

    @staticmethod
    def lg_p8033(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8033
        tag: matrix_prefix_sum|counter|specific_plan
        """
        m, n, k = ac.read_list_ints()
        grid = [list(ac.read_str()) for _ in range(m)]
        mat = [[int(w == "*") for w in lst] for lst in grid]
        pre = PreFixSumMatrix(mat)
        val = 0
        ans = []

        for i in range(k - 1, m):
            for j in range(k - 1, n):
                cur = pre.query(i - k + 2, j - k + 2, i - 1, j - 1)
                if cur > val:
                    val = cur
                    ans = [i, j]
        i, j = ans
        x1, y1, x2, y2 = i - k + 1, j - k + 1, i, j
        grid[x1][y1] = grid[x1][y2] = "+"
        grid[x2][y1] = grid[x2][y2] = "+"
        for i in [x1, x2]:
            for j in range(y1 + 1, y2):
                grid[i][j] = "-"
        for j in [y1, y2]:
            for i in range(x1 + 1, x2):
                grid[i][j] = "|"
        ac.st(val)
        for g in grid:
            ac.st("".join(g))
        return

    @staticmethod
    def lg_p7992(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7992
        tag: bucket_counter|action_scope|diff_array|counter|data_range|inclusion_exclusion
        """
        n, m = ac.read_list_ints()
        a = [0] * (m + 1)
        b = [0] * (m + 1)
        diff = [0] * (2 * m + 2)
        for _ in range(n):
            x, y = ac.read_list_ints()
            a[x] += 1
            b[y] += 1
        for i in range(m + 1):
            for j in range(m + 1):
                diff[i + j] += a[i] * a[j]
                diff[i + j + 1] -= b[i] * b[j]
        for i in range(2 * m + 1):
            if i:
                diff[i] += diff[i - 1]
            ac.st(diff[i])
        return

    @staticmethod
    def lg_p7948(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7948
        tag: sort|prefix_suffix|pointer|classical|offline_query
        """
        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            a.sort(reverse=True)
            pre = [0] * n
            s = 0
            for i in range(n):
                s += a[i]
                pre[i] = (i + 1) * a[i] - s

            ind = list(range(q))
            ind.sort(key=lambda it: -b[it])
            ans = [-1] * q
            j = n - 1
            for i in ind:
                k = b[i]
                while j >= 0 and pre[j] < - k * (j + 1):
                    j -= 1
                ans[i] = j + 1
            ac.lst(ans)
        return

    @staticmethod
    def lg_p8343(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8343
        tag: sub_matrix_prefix_sum|brute_force|two_pointers|math
        """
        m, n, a, b = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        if a > b:
            a, b = b, a
        pre = PreFixSumMatrix(grid)
        ans = math.inf
        for i in range(m):
            for k in range(i, m):
                lst = [0]
                ind_a = ind_b = 0
                for j in range(n):
                    cur = pre.query(i, 0, k, j)
                    lst.append(cur)
                    while ind_a + 1 < j + 1 and cur - lst[ind_a] >= a:
                        ans = min(ans, abs(cur - lst[ind_a] - a) + abs(cur - lst[ind_a] - b))
                        ind_a += 1

                    while ind_b + 1 < j + 1 and cur - lst[ind_b] <= b:
                        ans = min(ans, abs(cur - lst[ind_b] - a) + abs(cur - lst[ind_b] - b))
                        ind_b += 1

                    ans = min(ans, abs(cur - lst[ind_a] - a) + abs(cur - lst[ind_a] - b))
                    ans = min(ans, abs(cur - lst[ind_b] - a) + abs(cur - lst[ind_b] - b))
                    if ans == b - a:
                        ac.st(ans)
                        return
        ac.st(ans)
        return

    @staticmethod
    def lg_p8551(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8551
        tag: diff_array|brain_teaser|pointer|classical|brute_force
        """
        n = ac.read_int()
        m = 3 * 10 ** 5 + 1
        diff = [0] * (m + 2)
        point = [0] * (m + 2)
        for _ in range(n):
            a, b = ac.read_list_ints()
            diff[a] += 1
            diff[b + 1] -= 1
            point[a - 1] = 1
            point[b] = 1
        ans = 0
        pre = math.inf
        for i in range(1, m + 2):
            diff[i] += diff[i - 1]
            if point[i]:
                ans = max(ans, diff[i] * (i - pre))
                pre = i + 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p8666(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8666
        tag: binary_search|md_diff_array|implemention|classical|matrix_flatten|inclusion_exclusion|performance
        """
        aa, bb, cc, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        def tuple_to_pos(i, j, k, b, c):
            pos = (i * b + j) * c + k
            return pos

        lst = [ac.read_list_ints() for _ in range(m)]
        diff = [0] * (cc + 2) * (bb + 2) * (aa + 2)

        def check(x):
            for i in range(len(diff)):
                diff[i] = 0
            for i1, i2, j1, j2, k1, k2, h in lst[:x]:
                diff[tuple_to_pos(i1, j1, k1, bb + 2, cc + 2)] += h

                diff[tuple_to_pos(i2 + 1, j1, k1, bb + 2, cc + 2)] -= h
                diff[tuple_to_pos(i1, j2 + 1, k1, bb + 2, cc + 2)] -= h
                diff[tuple_to_pos(i1, j1, k2 + 1, bb + 2, cc + 2)] -= h

                diff[tuple_to_pos(i2 + 1, j2 + 1, k1, bb + 2, cc + 2)] += h
                diff[tuple_to_pos(i1, j2 + 1, k2 + 1, bb + 2, cc + 2)] += h
                diff[tuple_to_pos(i2 + 1, j1, k2 + 1, bb + 2, cc + 2)] += h

                diff[tuple_to_pos(i2 + 1, j2 + 1, k2 + 1, bb + 2, cc + 2)] -= h

            for i1 in range(aa):
                for j1 in range(bb):
                    for k1 in range(cc):
                        cur = diff[tuple_to_pos(i1 + 1, j1 + 1, k1 + 1, bb + 2, cc + 2)]

                        cur += diff[tuple_to_pos(i1, j1 + 1, k1 + 1, bb + 2, cc + 2)]
                        cur += diff[tuple_to_pos(i1 + 1, j1, k1 + 1, bb + 2, cc + 2)]
                        cur += diff[tuple_to_pos(i1 + 1, j1 + 1, k1, bb + 2, cc + 2)]

                        cur -= diff[tuple_to_pos(i1, j1, k1 + 1, bb + 2, cc + 2)]
                        cur -= diff[tuple_to_pos(i1, j1 + 1, k1, bb + 2, cc + 2)]
                        cur -= diff[tuple_to_pos(i1 + 1, j1, k1, bb + 2, cc + 2)]

                        cur += diff[tuple_to_pos(i1, j1, k1, bb + 2, cc + 2)]

                        diff[tuple_to_pos(i1 + 1, j1 + 1, k1 + 1, bb + 2, cc + 2)] = cur
                        if cur > nums[tuple_to_pos(i1, j1, k1, bb, cc)]:
                            return True

            return False

        ans = BinarySearch().find_int_left(1, m, check)
        ac.st(ans)
        return

    @staticmethod
    def lc_891(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/sum-of-subsequence-widths/description/
        tag: prefix_suffix|brute_force|counter|contribution_method
        """
        mod = 10 ** 9 + 7
        dp = [1]
        for i in range(10 ** 5):
            dp.append((dp[-1] * 2) % mod)
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n):
            ans += nums[i] * dp[i]
            ans -= nums[i] * dp[n - 1 - i]
            ans %= mod
        return ans

    @staticmethod
    def lc_1292(mat: List[List[int]], threshold: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/
        tag: O(mn)|brute_force|binary_search|classical
        """
        m, n = len(mat), len(mat[0])
        ans = 0
        pre = PreFixSumMatrix(mat)
        for i in range(m):
            for j in range(n):
                r = n - j if n - j < m - i else m - i
                for d in range(ans + 1, r + 1):
                    cur = pre.query(i, j, i + d - 1, j + d - 1)
                    if cur > threshold:
                        break
                    ans = d
        return ans

    @staticmethod
    def lc_1674(nums: List[int], limit: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-moves-to-make-array-complementary/
        tag: diff_array|action_scope|counter|contribution_method|classical
        """
        n = len(nums)
        diff = [0] * (2 * limit + 2)
        for i in range(n // 2):
            x, y = nums[i], nums[n - 1 - i]
            low_1 = 1 + x if x < y else 1 + y
            high_1 = limit + x if x > y else limit + y
            if low_1 <= high_1:
                diff[low_1] += 1
                diff[high_1 + 1] -= 1
            diff[x + y] -= 1
            diff[x + y + 1] += 1

            if 2 <= low_1 - 1:
                diff[2] += 2
                diff[low_1] -= 2
            if high_1 + 1 <= 2 * limit:
                diff[high_1 + 1] += 2
                diff[2 * limit + 1] -= 2
        for i in range(1, 2 * limit + 2):
            diff[i] += diff[i - 1]
        return min(diff[2:2 * limit + 1])

    @staticmethod
    def lc_1738(matrix: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/
        tag: matrix_prefix_xor_sum|classical
        """
        mat = PreFixXorMatrix(matrix)
        m, n = len(matrix), len(matrix[0])
        lst = []
        for i in range(m):
            lst.extend(mat.pre[i + 1][1:])
        lst.sort()
        return lst[-k]

    @staticmethod
    def lc_2132(grid: List[List[int]], h: int, w: int) -> bool:
        """
        url: https://leetcode.cn/problems/stamping-the-grid/
        tag: prefix_sum|brute_force|diff_matrix|implemention|classical|prefix_sum_prefix_sum
        """
        m, n = len(grid), len(grid[0])
        pre = PreFixSumMatrix(grid)
        dp = [[0] * n for _ in range(m)]
        for i in range(m - h + 1):
            for j in range(n - w + 1):
                cur = pre.query(i, j, i + h - 1, j + w - 1)
                if cur == 0:
                    dp[i][j] = 1

        pre = PreFixSumMatrix(dp)
        for i in range(m):
            for j in range(n):
                if not grid[i][j]:
                    x = i - h + 1 if i - h + 1 > 0 else 0
                    y = j - w + 1 if j - w + 1 > 0 else 0
                    cur = pre.query(x, y, i, j)
                    if not cur:
                        return False
        return True

    @staticmethod
    def ac_3993(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3996/
        tag: suffix_sum|data_range|brain_teaser|classical|hard
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        low = min(nums)
        high = max(nums)
        if low == high:
            ac.st(0)
            return

        cnt = [0] * (high - low + 1)
        for num in nums:
            cnt[num - low] += 1
        ans = post_cnt = post_sum = 0
        for i in range(high - low, 0, -1):
            post_cnt += cnt[i]
            post_sum += post_cnt
            if post_sum > k:
                ans += 1
                post_sum = post_cnt
        ans += post_sum > 0
        ac.st(ans)
        return

    @staticmethod
    def lc_837(n: int, k: int, max_pts: int) -> float:
        """
        url: https://leetcode.cn/problems/new-21-game/description/
        tag: diff_array|implemention|probability|refresh_table|classical
        """
        s = k + max_pts
        dp = [0] * (s + 1)
        dp[0] = 1
        diff = [0] * (s + 1)
        for i in range(s + 1):
            diff[i] += diff[i - 1]
            dp[i] += diff[i]
            if i < k:
                diff[i + 1] += dp[i]
                diff[i + max_pts + 1] -= dp[i]
        return sum(dp[k:n + 1]) / max_pts

    @staticmethod
    def lg_p6070(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6070
        tag: diff_array|matrix_diff_array|flatten
        """
        n, m, k = ac.read_list_ints()
        grid = [0] * (n * n)
        for _ in range(m):
            x, y, z = ac.read_list_ints_minus_one()
            grid[x * n + y] = z + 1
        diff = [0] * ((n + 2) * (n + 2))

        ans = 0
        for i in range(n):
            for j in range(n):
                val = diff[(i + 1) * (n + 2) + j] + diff[i * (n + 2) + j + 1] - diff[i * (n + 2) + j]
                diff[(i + 1) * (n + 2) + j + 1] += val
                d = diff[(i + 1) * (n + 2) + j + 1] + grid[i * n + j]
                if d:
                    if i + k + 1 > n + 1 or j + k + 1 > n + 1:
                        ac.st(-1)
                        return
                    diff[(i + 1) * (n + 2) + j + 1] -= d
                    diff[(i + 1) * (n + 2) + j + k + 1] += d
                    diff[(i + k + 1) * (n + 2) + j + 1] += d
                    diff[(i + k + 1) * (n + 2) + j + k + 1] -= d
                    ans += abs(d)
        ac.st(ans)
        return

    @staticmethod
    def lc_2983(s: str, queries: List[List[int]]) -> List[bool]:
        """
        url: https://leetcode.cn/problems/palindrome-rearrangement-queries/
        tag: brain_teaser|prefix_sum|brute_force|range_intersection
        """
        lst = [ord(w) - ord("a") for w in s]
        n = len(lst)
        lst1, lst2 = lst[:n // 2], lst[n // 2:][::-1]
        pre1 = []
        pre2 = []
        for i in range(26):
            pre1.append(list(accumulate([int(w == i) for w in lst1], initial=0)))
            pre2.append(list(accumulate([int(w == i) for w in lst2], initial=0)))

        right = [0] * (n // 2 + 1)
        right[n // 2] = 1
        for i in range(n // 2 - 1, -1, -1):
            if lst1[i] == lst2[i]:
                right[i] = 1
            else:
                break

        left = [0] * (n // 2 + 1)
        left[0] = 1
        for i in range(n // 2):
            if lst1[i] == lst2[i]:
                left[i + 1] = 1
            else:
                break

        ans = []
        for a, b, c, d in queries:
            c, d = n - 1 - d, n - 1 - c
            cc = min(a, c)
            dd = max(b, d)
            if not left[cc] or not right[dd + 1]:
                ans.append(False)
                continue
            if a <= c <= d <= b or c <= a <= b <= d:
                c, d = cc, dd
                cur1 = [pre1[j][d + 1] - pre1[j][c] for j in range(26)]
                cur2 = [pre2[j][d + 1] - pre2[j][c] for j in range(26)]
                if cur1 != cur2:
                    ans.append(False)
                else:
                    ans.append(True)
            elif b < c or d < a:
                cur1 = [pre1[j][b + 1] - pre1[j][a] for j in range(26)]
                cur2 = [pre2[j][b + 1] - pre2[j][a] for j in range(26)]
                if cur1 != cur2:
                    ans.append(False)
                    continue
                cur1 = [pre1[j][d + 1] - pre1[j][c] for j in range(26)]
                cur2 = [pre2[j][d + 1] - pre2[j][c] for j in range(26)]
                if cur1 != cur2:
                    ans.append(False)
                    continue
                if b < c:
                    c, d = b + 1, c - 1
                else:
                    c, d = d + 1, a - 1
                cur1 = [pre1[j][d + 1] - pre1[j][c] for j in range(26)]
                cur2 = [pre2[j][d + 1] - pre2[j][c] for j in range(26)]
                if cur1 != cur2:
                    ans.append(False)
                else:
                    ans.append(True)
            elif b <= d:
                cur1 = [pre1[j][b + 1] - pre1[j][a] for j in range(26)]
                cur2 = [pre2[j][d + 1] - pre2[j][c] for j in range(26)]
                x, y = a, c - 1
                cur = [pre2[j][y + 1] - pre2[j][x] for j in range(26)]
                cur1 = [cur1[j] - cur[j] for j in range(26)]

                x, y = b + 1, d
                cur = [pre1[j][y + 1] - pre1[j][x] for j in range(26)]
                cur2 = [cur2[j] - cur[j] for j in range(26)]

                if cur1 != cur2 or any(x < 0 for x in cur1 + cur2):
                    ans.append(False)
                else:
                    ans.append(True)
            else:
                cur1 = [pre1[j][b + 1] - pre1[j][a] for j in range(26)]
                cur2 = [pre2[j][d + 1] - pre2[j][c] for j in range(26)]
                x, y = d + 1, b
                cur = [pre2[j][y + 1] - pre2[j][x] for j in range(26)]
                cur1 = [cur1[j] - cur[j] for j in range(26)]

                x, y = c, a - 1
                cur = [pre1[j][y + 1] - pre1[j][x] for j in range(26)]
                cur2 = [cur2[j] - cur[j] for j in range(26)]

                if cur1 != cur2 or any(x < 0 for x in cur1 + cur2):
                    ans.append(False)
                else:
                    ans.append(True)
        return ans

    @staticmethod
    def lc_3017(n: int, x: int, y: int) -> List[int]:
        """
        url: https://leetcode.com/problems/count-the-number-of-houses-at-a-certain-distance-ii/description/
        tag: diff_array|classical
        """

        def update():
            if 0 <= low <= high:
                cnt[low] += 1
                if high + 1 <= n:
                    cnt[high + 1] -= 1
            return

        cnt = [0] * (n + 1)
        x -= 1
        y -= 1
        if x > y:
            x, y = y, x
        if abs(x - y) <= 1:
            for i in range(n):
                low = 0
                high = i
                update()

                low = 0
                high = n - 1 - i
                update()
            for i in range(1, n + 1):
                cnt[i] += cnt[i - 1]
            return cnt[1:]

        for i in range(x + 1):
            # 左边
            if i + 1 <= x:
                low = i + 1 - i
                high = x - i
                update()  # [i+1, x]

            if y <= n - 1:
                low = x - i + 1 + y - y  # [y, n-1]
                high = x - i + 1 + n - 1 - y
                update()

            j = (x + y + 1) // 2
            # [x+1, j]
            if x + 1 <= j < y:
                low = x + 1 - i
                high = j - i
                update()

            # [j+1, y-1]
            if j + 1 <= y - 1:
                low = x - i + 1 + y - (y - 1)
                high = x - i + 1 + y - (j + 1)
                update()

        # 右边
        for i in range(y, n):
            # [i+1, n-1]
            low = i + 1 - i
            high = n - 1 - i
            update()

        # 中间
        for i in range(x + 1, y):

            # [y, n-1]
            if y <= n - 1:
                right = min(y - i, i - x + 1)
                low = right + y - y
                high = right + n - 1 - y
                update()

            j = min((2 * i + y - x + 1) // 2, y - 1)
            # [i+1, j]
            if i + 1 <= j < y:
                low = 1
                high = j - i
                update()
            # [j+1, y-1]
            if j + 1 <= y - 1:
                low = i - x + 1 + y - (y - 1)
                high = i - x + 1 + y - (j + 1)
                update()

        for i in range(1, n + 1):
            cnt[i] += cnt[i - 1]
        return [x * 2 for x in cnt[1:]]

    @staticmethod
    def abc_331d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc331/tasks/abc331_d
        tag: prefix_sum_matrix|circular_section
        """
        n, q = ac.read_list_ints()
        grid = []
        for i in range(n):
            grid.append([int(w == "B") for w in ac.read_str()])
        pre = PreFixSumMatrix(grid)

        def check(x, y):
            aa = x // n
            bb = y // n
            res = aa * bb * pre.query(0, 0, n - 1, n - 1)
            if x % n:
                block = pre.query(0, 0, (x % n) - 1, n - 1)
                res += block * bb
                if y % n:
                    res += pre.query(0, 0, (x % n) - 1, (y % n) - 1)
            if y % n:
                block = pre.query(0, 0, n - 1, (y % n) - 1)
                res += block * aa
            return res

        for _ in range(q):
            a, b, c, d = ac.read_list_ints()
            ans = check(c + 1, d + 1) - check(c + 1, b) - check(a, d + 1) + check(a, b)
            ac.st(ans)
        return

    @staticmethod
    def abc_288d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc288/tasks/abc288_d
        tag: diff_array|brain_teaser|classical
        """
        n, k = ac.read_list_ints()
        a = [0] + ac.read_list_ints()
        diff = [0] * (n + 1)
        for i in range(1, n + 1):
            diff[i] = a[i] - a[i - 1]

        pre = []
        for i in range(k):
            lst = diff[:]
            for j in range(n + 1):
                if j % k != i:
                    lst[j] = 0
            pre.append(ac.accumulate(lst))

        for _ in range(ac.read_int()):
            ll, rr = ac.read_list_ints()
            for j in range(k):
                v = pre[j][rr + 1] - pre[j][ll]
                if j == ll % k:
                    v += a[ll - 1]
                if j == (rr + 1) % k:
                    continue
                if v:
                    ac.no()
                    break
            else:
                ac.yes()
        return

    @staticmethod
    def abc_347f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc347/tasks/abc347_f
        tag: diff_array|matrix_prefix_sum|matrix_rotate|brute_force|implemention
        """
        n, m = ac.read_list_ints()
        matrix = [ac.read_list_ints() for _ in range(n)]
        ans = -math.inf
        for _ in range(4):
            n = len(matrix)
            for i in range(n // 2):
                for j in range((n + 1) // 2):
                    a, b, c, d = matrix[n - j - 1][i], matrix[n - i - 1][n - j - 1], matrix[j][n - i - 1], matrix[i][j]
                    matrix[i][j], matrix[n - j - 1][i], matrix[n - i - 1][n - j - 1], matrix[j][n - i - 1] = a, b, c, d

            pre = PreFixSumMatrix(matrix)
            left = [-math.inf] * (n + 1) * (n + 1)
            for i in range(n):
                for j in range(n):
                    if i - m + 1 >= 0 and j - m + 1 >= 0:
                        left[(i + 1) * (n + 1) + j + 1] = max(left[i * (n + 1) + j + 1], left[(i + 1) * (n + 1) + j],
                                                              left[i * (n + 1) + j],
                                                              pre.query(i - m + 1, j - m + 1, i, j))
                    else:
                        left[(i + 1) * (n + 1) + j + 1] = max(left[i * (n + 1) + j + 1], left[(i + 1) * (n + 1) + j],
                                                              left[i * (n + 1) + j])

            right = [-math.inf] * (n + 1) * (n + 1)
            for i in range(n):
                for j in range(n - 1, -1, -1):
                    if i - m + 1 >= 0 and j + m - 1 < n:
                        right[(i + 1) * (n + 1) + j] = max(right[(i + 1) * (n + 1) + j + 1], right[i * (n + 1) + j],
                                                           right[i * (n + 1) + j + 1],
                                                           pre.query(i - m + 1, j, i, j + m - 1))
                    else:
                        right[(i + 1) * (n + 1) + j] = max(right[(i + 1) * (n + 1) + j + 1], right[i * (n + 1) + j],
                                                           right[i * (n + 1) + j + 1])

            down = [-math.inf] * (n + 1)
            for i in range(n - 1, -1, -1):
                if i + m - 1 < n:
                    down[i] = max(down[i + 1], max(pre.query(i, j, i + m - 1, j + m - 1) for j in range(n - m + 1)))

            up = [-math.inf] * (n + 1)
            for i in range(n):
                if i - m + 1 >= 0:
                    up[i + 1] = max(up[i], max(pre.query(i - m + 1, j, i, j + m - 1) for j in range(n - m + 1)))

            for i in range(n):
                for j in range(n):
                    cur = down[i + 1] + left[(i + 1) * (n + 1) + j + 1] + right[(i + 1) * (n + 1) + j + 1]
                    ans = max(ans, cur)
            for i in range(n):
                if i - m + 1 >= 0:
                    cur = max(pre.query(i - m + 1, j, i, j + m - 1) for j in range(n - m + 1)) + up[i - m + 1] + down[
                        i + 1]
                    ans = max(ans, cur)

        ac.st(ans)
        return

    @staticmethod
    def abc_274f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc274/tasks/abc274_f
        tag: brute_force|brain_teaser|discretization_diff_array|classical
        """
        n, a = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = 0
        for i in range(n):
            w, x, v = nums[i]
            dct = defaultdict(int)
            cur = 0
            lst = []
            for j, (ww, xx, vv) in enumerate(nums):
                if vv == v:
                    if x <= xx <= x + a:
                        cur += ww
                    continue
                ceil = (x + a - xx) / (vv - v)
                floor = (x - xx) / (vv - v)
                if vv - v < 0:
                    floor, ceil = ceil, floor
                floor = max(0, floor)
                if floor <= ceil:
                    lst.append([floor, ceil, ww])

            nodes = [math.inf]
            for ls in lst:
                nodes.extend(ls[:-1])
            nodes = sorted(set(nodes))
            ind = {num: i for i, num in enumerate(nodes)}
            for aa, bb, ww in lst:
                dct[ind[aa]] += ww
                dct[ind[bb] + 1] -= ww
            m = len(nodes)
            for j in range(1, m):
                dct[j] += dct[j - 1]
            ans = max(ans, cur + max(dct.values()) if dct else cur)
        ac.st(ans)
        return

    @staticmethod
    def abc_269f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc269/tasks/abc269_f
        tag: diff_array|inclusion_exclusion|prefix_sum|math|classical
        """
        n, m = ac.read_list_ints()
        mod = 998244353

        def compute(start, diff, cnt):
            return (start + start + diff * (cnt - 1)) * cnt // 2

        def check(x, y):

            if not x or not y:
                return 0

            odd_start = (y + y % 2) * ((y + 1) // 2) // 2
            odd_diff = ((y + 1) // 2) * 2 * m
            odd_cnt = (x + 1) // 2

            even_start = m * (y // 2) + y * (y + 1) // 2 - odd_start
            even_diff = (y // 2) * 2 * m
            even_cnt = x // 2
            res = compute(odd_start, odd_diff, odd_cnt) + compute(even_start, even_diff, even_cnt)
            return res % mod

        for _ in range(ac.read_int()):
            a, b, c, d = ac.read_list_ints()
            ans = check(b, d) - check(b, c - 1) - check(a - 1, d) + check(a - 1, c - 1)
            ac.st(ans % mod)
        return

    @staticmethod
    def abc_268e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc268/tasks/abc268_e
        tag: brute_force|diff_array|action_scope|brain_teaser|classical
        """
        n = ac.read_int()
        tmp = ac.read_list_ints()
        diff = [0] * n

        def range_add(a, b, c):
            diff[a] += c
            if b + 1 < n:
                diff[b + 1] -= c
            return

        mid = n // 2
        for i in range(n):
            x = tmp[i]
            if x >= i:
                d = x - i
            else:
                d = n + x - i
            if d > mid:
                range_add(0, 0, n - d)
                if n % 2:
                    if 1 <= d - mid - 1:
                        range_add(1, d - mid - 1, 1)
                else:
                    range_add(1, d - mid, 1)
                range_add(d - mid + 1, d, -1)
                if d + 1 < n:
                    range_add(d + 1, n - 1, 1)
            elif d == mid:
                range_add(0, 0, mid)
                range_add(1, d, -1)
                range_add(d + 1, n - 1, 1)
            elif d + mid < n - 1:
                range_add(0, 0, d)
                range_add(1, d, -1)
                range_add(d + 1, d + mid, 1)
                if n % 2:
                    if d + mid + 2 < n:
                        range_add(d + mid + 2, n - 1, -1)
                else:
                    range_add(d + mid + 1, n - 1, -1)
            else:
                range_add(d + 1, d + mid, 1)
                range_add(0, 0, d)
                range_add(1, d, -1)
        res = ac.accumulate(ac.accumulate(diff)[1:])[1:]
        ac.st(min(res))
        return

    @staticmethod
    def abc_268e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc268/tasks/abc268_e
        tag: brute_force|diff_array|action_scope|brain_teaser|classical
        """
        n = ac.read_int()
        tmp = ac.read_list_ints()
        diff = [0] * n

        def range_add(a, b, c):
            diff[a] += c
            if b + 1 < n:
                diff[b + 1] -= c
            return

        mid = n // 2
        for i in range(n):
            x = tmp[i]
            if x >= i:
                d = x - i
            else:
                d = n + x - i
            if d > mid:
                range_add(0, 0, n - d)
                if n % 2:
                    if 1 <= d - mid - 1:
                        range_add(1, d - mid - 1, 1)
                else:
                    range_add(1, d - mid, 1)
                range_add(d - mid + 1, d, -1)
                if d + 1 < n:
                    range_add(d + 1, n - 1, 1)
            elif d == mid:
                range_add(0, 0, mid)
                range_add(1, d, -1)
                range_add(d + 1, n - 1, 1)
            elif d + mid < n - 1:
                range_add(0, 0, d)
                range_add(1, d, -1)
                range_add(d + 1, d + mid, 1)
                if n % 2:
                    if d + mid + 2 < n:
                        range_add(d + mid + 2, n - 1, -1)
                else:
                    range_add(d + mid + 1, n - 1, -1)
            else:
                range_add(d + 1, d + mid, 1)
                range_add(0, 0, d)
                range_add(1, d, -1)
        res = ac.accumulate(ac.accumulate(diff)[1:])[1:]
        ac.st(min(res))
        return

    @staticmethod
    def abc_260e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc260/tasks/abc260_e
        tag: diff_array|action_scope|two_pointers|hash|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(m)]
        for i in range(n):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(i)
            dct[y].append(i)
        cnt = [0] * n
        tot = 0
        ans = 0
        diff = [0] * (m + 2)
        j = 0
        for i in range(m):
            while j < m and tot < n:
                for x in dct[j]:
                    cnt[x] += 1
                    if cnt[x] == 1:
                        tot += 1
                j += 1
            if tot == n:
                low = j - i
                high = m - i
                diff[low] += 1
                diff[high + 1] -= 1
            for x in dct[i]:
                cnt[x] -= 1
                if not cnt[x]:
                    tot -= 1
        diff = ac.accumulate(diff[1:])
        ac.lst(diff[1:m + 1])
        return

    @staticmethod
    def abc_210d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc210/tasks/abc210_d
        tag: prefix_max|matrix_prefix|classical
        """
        m, n, c = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        ans = math.inf
        pre = [[math.inf] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                p = min(pre[i + 1][j], pre[i][j + 1])
                ans = min(ans, p + c * i + c * j + grid[i][j])
                pre[i + 1][j + 1] = min(p, grid[i][j] - c * i - c * j)

        pre = [[math.inf] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n - 1, -1, -1):
                p = min(pre[i][j], pre[i + 1][j + 1])
                ans = min(ans, p + c * i - c * j + grid[i][j])
                pre[i + 1][j] = min(p, grid[i][j] - c * i + c * j)
        ac.st(ans)
        return

    @staticmethod
    def cf_1985h1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1985/problem/H1
        tag: union_find|contribution_method|diff_matrix|brain_teaser
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_str() for _ in range(m)]
            uf = UnionFindGeneral(m * n)
            row = [0] * m
            col = [0] * n
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == "#":
                        uf.size[i * n + j] = 1
                    else:
                        row[i] += 1
                        col[j] += 1
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == "#":
                        if i + 1 < m and grid[i + 1][j] == "#":
                            uf.union(i * n + j, i * n + j + n)
                        if j + 1 < n and grid[i][j + 1] == "#":
                            uf.union(i * n + j, i * n + j + 1)
            group = uf.get_root_part()
            row_diff = [0] * (m + 1)
            col_diff = [0] * (n + 1)
            for g in group:
                if uf.size[g]:
                    x1 = max(min(x // n for x in group[g]) - 1, 0)
                    x2 = min(max(x // n for x in group[g]) + 1, m - 1)
                    y1 = max(min(x % n for x in group[g]) - 1, 0)
                    y2 = min(max(x % n for x in group[g]) + 1, n - 1)
                    row_diff[x1] += uf.size[g]
                    row_diff[x2 + 1] -= uf.size[g]
                    col_diff[y1] += uf.size[g]
                    col_diff[y2 + 1] -= uf.size[g]
            ans = 0
            for i in range(m):
                row_diff[i] += row_diff[i - 1] if i else 0
                ans = max(row[i] + row_diff[i], ans)
            for j in range(n):
                col_diff[j] += col_diff[j - 1] if j else 0
                ans = max(col[j] + col_diff[j], ans)
            ac.st(ans)
        return

    @staticmethod
    def cf_1985h2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1985/problem/H2
        tag: union_find|contribution_method|diff_matrix|brain_teaser
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_str() for _ in range(m)]
            uf = UnionFindGeneral(m * n)
            row = [0] * m
            col = [0] * n
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == "#":
                        uf.size[i * n + j] = 1
                    else:
                        row[i] += 1
                        col[j] += 1
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == "#":
                        if i + 1 < m and grid[i + 1][j] == "#":
                            uf.union(i * n + j, i * n + j + n)
                        if j + 1 < n and grid[i][j + 1] == "#":
                            uf.union(i * n + j, i * n + j + 1)
            group = uf.get_root_part()
            lst = []
            for g in group:
                if uf.size[g]:
                    x1 = max(min(x // n for x in group[g]) - 1, 0)
                    x2 = min(max(x // n for x in group[g]) + 1, m - 1)
                    y1 = max(min(x % n for x in group[g]) - 1, 0)
                    y2 = min(max(x % n for x in group[g]) + 1, n - 1)
                    lst.append((x1, x2, y1, y2, -uf.size[g]))
                    lst.append((x1, x2, 0, n - 1, uf.size[g]))
                    lst.append((0, m - 1, y1, y2, uf.size[g]))
            res = DiffMatrix().get_diff_matrix3(m, n, lst)
            ans = max(max(row[i] + col[j] - (grid[i][j] == ".") + res[i][j] for j in range(n)) for i in range(m))
            ac.st(ans)
        return

    @staticmethod
    def lg_p3016(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3016
        tag: prefix_sum|triangle|left_up_sum|inclusion_exclusion
        """
        n, k = ac.read_list_ints()
        grid = []
        for i in range(n):
            lst = ac.read_list_ints() + [0] * (n - 1 - i)
            grid.append(lst)
        pre = PreFixSumMatrix(grid)
        left_up = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n):
            cur = 0
            for j in range(i + 1):
                cur += grid[i][j]
                left_up[i + 1][j + 1] = left_up[i][j] + cur
        ans = -math.inf
        for x in range(k, 2 * k + 1):
            cnt = x * (x + 1) // 2
            for i in range(x - 1, n):
                for j in range(i - x + 2):
                    cur = left_up[i + 1][j + x] - left_up[i - x + 1][j]
                    cur -= pre.query(i - x + 1, 0, i, j - 1) if j else 0
                    ans = max(ans, int(cur / cnt))

        for x in range(k, 2 * k + 1):
            cnt = x * (x + 1) // 2
            for i in range(x - 1, n - x + 1):
                for j in range(x - 1, i + 1):
                    cur = pre.query(i, 0, i + x - 1, j)
                    cur -= left_up[i + x][j]
                    cur += left_up[i][j - x] if j >= x else 0
                    ans = max(ans, int(cur / cnt))
        ac.st(ans)
        return

    @staticmethod
    def abc_366d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc366/tasks/abc366_d
        tag: prefix_sum_cube|md_prefix_sum
        """
        n = ac.read_int()
        arr = []
        for _ in range(n):
            arr.append([ac.read_list_ints() for _ in range(n)])
        pre = PreFixSumCube(arr)
        for _ in range(ac.read_int()):
            x1, x2, y1, y2, z1, z2 = ac.read_list_ints()
            ac.st(pre.query(x1, x2, y1, y2, z1, z2))
        return"""
Algorithm：hash|contribution_method|matrix_hash|tree_hash|string_hash|prefix_hash|suffix_hash|hash_crush
Description：prefix_suffix|counter|index|prefix_sum

====================================LeetCode====================================
2143（https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/）prefix_sum|hash|counter
17（https://leetcode.cn/problems/find-longest-subarray-lcci/）prefix_sum|hash
1590（https://leetcode.cn/problems/make-sum-divisible-by-p/）prefix_sum|hash|mod|counter
2588（https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/）prefix_sum|hash|counter
02（https://leetcode.cn/contest/hhrc2022/problems/0Wx4Pc/）prefix_sum|hash|brain_teaser|greedy
03（https://leetcode.cn/contest/hhrc2022/problems/VAc7h3/）tree_hash
2031（https://leetcode.cn/problems/count-subarrays-with-more-ones-than-zeros/）prefix_sum|hash|counter
2025（https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/description/）hash|contribution_method|counter
895（https://leetcode.cn/problems/maximum-frequency-stack/description/）hash|stack
1658（https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/）prefix_sum|hash|brain_teaser|greedy
2227（https://leetcode.cn/problems/encrypt-and-decrypt-strings/）brain_teaser|reverse_thinking

===================================CodeForces===================================
1692H（https://codeforces.com/contest/1692/problem/H）hash|prefix_min
1800G（https://codeforces.com/contest/1800/problem/G）tree_hash|classical
1974C（https://codeforces.com/contest/1974/problem/C）hash|counter|inclusion_exclusion

=====================================LuoGu======================================
P2697（https://www.luogu.com.cn/problem/P2697）hash|prefix_sum
P1114（https://www.luogu.com.cn/problem/P1114）hash|prefix_sum
P4889（https://www.luogu.com.cn/problem/P4889）math|hash|counter
P6273（https://www.luogu.com.cn/problem/P6273）hash|prefix|counter
P8630（https://www.luogu.com.cn/problem/P8630）hash|counter|permutation|brute_force
P5018（https://www.luogu.com.cn/problem/P5018）tree_hash|random_hash|classical

====================================AtCoder=====================================
ARC061B（https://atcoder.jp/contests/abc045/tasks/arc061_b）hash|inclusion_exclusion|counter
ABC304D（https://atcoder.jp/contests/abc304/tasks/abc304_d）hash|counter|brain_teaser
ABC278E（https://atcoder.jp/contests/abc278/tasks/abc278_e）hash|inclusion_exclusion|implemention
ABC367D（https://atcoder.jp/contests/abc367/tasks/abc367_d）hash|prefix|counter

=====================================AcWing=====================================

"""
import random
from collections import defaultdict, Counter
from itertools import accumulate
from typing import List

from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_2143(nums1: List[int], nums2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/
        tag: prefix_sum|hash|counter|classical|linear_dp
        """
        n = len(nums1)
        mod = 10 ** 9 + 7
        pre = defaultdict(int)
        pre[-nums1[0]] += 1
        pre[nums2[0]] += 1
        ans = pre[0]
        for i in range(1, n):
            cur = defaultdict(int)
            cur[-nums1[i]] += 1
            cur[nums2[i]] += 1
            for p in pre:
                cur[p - nums1[i]] += pre[p]
                cur[p + nums2[i]] += pre[p]
            ans += cur[0]
            ans %= mod
            pre = cur
        return ans

    @staticmethod
    def lc_1658(nums: List[int], x: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/description/
        tag: prefix_sum|hash|brain_teaser|greedy|reverse_thinking
        """
        pre = {0: -1}
        cur = 0
        n = len(nums)
        s = sum(nums)
        ans = -1 if s != x else 0
        for i, w in enumerate(nums):
            cur += w
            if cur - (s - x) in pre and i - pre[cur - (s - x)] > ans:
                ans = i - pre[cur - (s - x)]
            if cur not in pre:
                pre[cur] = i
        return n - ans if ans > -1 else ans

    @staticmethod
    def lc_2025(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-ways-to-partition-an-array/description/
        tag: hash|contribution_method|counter
        """
        n = len(nums)
        ans = 0
        pre = list(accumulate(nums, initial=0))
        for i in range(1, n):
            if pre[i] == pre[-1] - pre[i]:
                ans += 1

        cnt = [0] * n
        dct = defaultdict(int)
        for i in range(n - 2, -1, -1):
            b = pre[-1] - pre[i + 1]
            a = pre[i + 1]
            dct[a - b] += 1
            cnt[i] += dct[nums[i] - k]

        dct = defaultdict(int)
        for i in range(1, n):
            b = pre[-1] - pre[i]
            a = pre[i]
            dct[a - b] += 1
            cnt[i] += dct[k - nums[i]]

        return max(ans, max(cnt))

    @staticmethod
    def arc_061b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc045/tasks/arc061_b
        tag: hash|inclusion_exclusion|counter
        """
        h, w, n = ac.read_list_ints()
        cnt = [0] * 10
        dct = defaultdict(int)
        for _ in range(n):
            a, b = ac.read_list_ints()
            for x in range(3):
                for y in range(3):
                    if 3 <= x + a <= h and 3 <= y + b <= w:
                        dct[(x + a, y + b)] += 1
        for k in dct:
            cnt[dct[k]] += 1

        cnt[0] = (h - 2) * (w - 2) - sum(cnt[1:])
        for a in cnt:
            ac.st(a)
        return

    @staticmethod
    def lg_p4889(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4889
        tag: math|hash|counter|classical
        """
        n, m = ac.read_list_ints()
        height = ac.read_list_ints()
        cnt = defaultdict(int)
        ans = 0
        for i in range(n):
            ans += cnt[height[i] - i]
            cnt[height[i] - i] += 1

        cnt = defaultdict(int)
        for i in range(n):
            ans += cnt[height[i] + i]
            ans += cnt[i - height[i]]
            cnt[height[i] + i] += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p6273(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6273
        tag: hash|prefix|counter|brain_teaser
        """
        ac.read_int()
        s = ac.read_str()
        st = list(set(s))
        ind = {w: i for i, w in enumerate(st)}
        m = len(ind)
        cnt = [0] * m
        pre = defaultdict(int)
        pre[tuple(cnt)] = 1
        ans = 0
        mod = 10 ** 9 + 7
        for w in s:
            if w == st[0]:
                for i in range(m):
                    if i != ind[w]:
                        cnt[i] -= 1
            else:
                cnt[ind[w]] += 1
            tp = tuple(cnt)
            ans += pre[tp]
            pre[tp] += 1
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lc_895():
        """
        url: https://leetcode.cn/problems/maximum-frequency-stack/description/
        tag: hash|stack
        """
        class FreqStack:
            def __init__(self):
                self.freq = defaultdict(list)
                self.dct = defaultdict(int)
                self.ceil = 0

            def push(self, val: int) -> None:
                self.dct[val] += 1
                self.freq[self.dct[val]].append(val)
                if self.dct[val] > self.ceil:
                    self.ceil = self.dct[val]
                return

            def pop(self) -> int:
                val = self.freq[self.ceil].pop()
                self.dct[val] -= 1
                if not self.freq[self.ceil]:
                    self.ceil -= 1
                return val

        FreqStack()
        return

    @staticmethod
    def cf_1800g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1800/problem/G
        tag: tree_hash|classical
        """

        for _ in range(ac.read_int()):

            def check():
                n = ac.read_int()
                edge = [[] for _ in range(n)]
                for _ in range(n - 1):
                    u, v = ac.read_list_ints_minus_one()
                    edge[u].append(v)
                    edge[v].append(u)
                dct = dict()
                hash_id = [-1] * n
                sub = [0] * n
                stack = [(0, -1)]
                while stack:
                    x, fa = stack.pop()
                    if x >= 0:
                        stack.append((~x, fa))
                        for y in edge[x]:
                            if y != fa:
                                stack.append((y, x))
                    else:
                        x = ~x
                        cur = []
                        cnt = 1
                        for y in edge[x]:
                            if y != fa:
                                cur.append(hash_id[y])
                                cnt += sub[y]
                        key = tuple(sorted(cur) + [cnt])
                        if key not in dct:
                            dct[key] = len(dct)
                        hash_id[x] = dct[key]
                        sub[x] = cnt
                x, fa = 0, -1
                while True:
                    cur = []
                    for y in edge[x]:
                        if y != fa:
                            cur.append(hash_id[y])
                    cnt = Counter(cur)
                    cnt_cnt = Counter([va % 2 for va in cnt.values()])
                    if cnt_cnt[1] > 1:
                        ac.no()
                        return
                    for y in edge[x]:
                        if y != fa and cnt[hash_id[y]] % 2 == 1:
                            x, fa = y, x
                            break
                    else:
                        break
                ac.yes()
                return

            check()
        return

    @staticmethod
    def lg_p5018(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5018
        tag: tree_hash|random_hash|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dct = [ac.read_list_ints_minus_one() for _ in range(n)]

        seed = [random.getrandbits(64) for _ in range(3)]

        def make(aa, bb, cc):
            return aa*seed[0] + bb*seed[1] + cc*seed[2]

        sub = [1] * n
        hash1 = [0] * n
        hash2 = [0] * n
        seen = dict()

        stack = [0]
        ans = 1
        while stack:
            x = stack.pop()
            if x >= 0:
                stack.append(~x)
                for y in dct[x]:
                    if y != -2:
                        stack.append(y)
            else:
                x = ~x
                a, b = dct[x]

                cur = make(hash1[a] if a != -2 else 0, nums[x], hash1[b] if b != -2 else 0)
                if cur not in seen:
                    seen[cur] = len(seen) + 1
                hash1[x] = seen[cur]

                cur = make(hash2[b] if b != -2 else 0, nums[x], hash2[a] if a != -2 else 0)
                if cur not in seen:
                    seen[cur] = len(seen) + 1
                hash2[x] = seen[cur]

                for y in dct[x]:
                    if y != -2:
                        sub[x] += sub[y]
                if a != -2 and b != -2 and hash1[a] == hash2[b] and sub[a] == sub[b]:
                    ans = max(ans, sub[x])
        ac.st(ans)
        return
"""
Algorithm：implemention|big_implemention
Description：implemention|joseph_circle

====================================LeetCode====================================
2296（https://leetcode.cn/problems/design-a-text-editor/）pointer|implemention
54（https://leetcode.cn/problems/spiral-matrix/）num_to_pos|pos_to_num|matrix_spiral
59（https://leetcode.cn/problems/spiral-matrix-ii/）num_to_pos|pos_to_num|matrix_spiral
2326（https://leetcode.cn/problems/spiral-matrix-iv/）num_to_pos|pos_to_num|matrix_spiral
62（https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/）joseph_circle|
2534（https://leetcode.cn/problems/time-taken-to-cross-the-door/）implemention
460（https://leetcode.cn/problems/lfu-cache/）order_dict|lfu
146（https://leetcode.cn/problems/lru-cache/）order_dict|lru
2534（https://leetcode.cn/problems/time-taken-to-cross-the-door/）implemention
1823（https://leetcode.cn/problems/find-the-winner-of-the-circular-game/）joseph_circle
927（https://leetcode.cn/problems/three-equal-parts/description/）base|bin|implemention
1599（https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/）implemention|brute_force
2295（https://leetcode.cn/problems/replace-elements-in-an-array/description/）reverse_thinking|linked_list
1914（https://leetcode.cn/problems/cyclically-rotating-a-grid/description/）pointer|circular|implemention
1834（https://leetcode.cn/contest/weekly-contest-237/problems/single-threaded-cpu/）heapq|pointer|implemention

=====================================LuoGu======================================
P1815（https://www.luogu.com.cn/problem/P1815）implemention
P1538（https://www.luogu.com.cn/problem/P1538）implemention
P1535（https://www.luogu.com.cn/problem/P1535）dp|implemention|counter
P2239（https://www.luogu.com.cn/problem/P2239）implemention|matrix_spiral
P2338（https://www.luogu.com.cn/problem/P2338）implemention
P2366（https://www.luogu.com.cn/problem/P2366）implemention
P2552（https://www.luogu.com.cn/problem/P2552）implemention
P2696（https://www.luogu.com.cn/problem/P2696）joseph_circle|implemention|diff_array
P1234（https://www.luogu.com.cn/problem/P1234）implemention
P1166（https://www.luogu.com.cn/problem/P1166）implemention
P1076（https://www.luogu.com.cn/problem/P1076）implemention
P8924（https://www.luogu.com.cn/problem/P8924）implemention|base
P8889（https://www.luogu.com.cn/problem/P8889）counter
P8870（https://www.luogu.com.cn/problem/P8870）base|implemention
P3880（https://www.luogu.com.cn/problem/P3880）implemention
P3111（https://www.luogu.com.cn/problem/P3111）reverse_thinking|implemention
P4346（https://www.luogu.com.cn/problem/P4346）implemention
P5079（https://www.luogu.com.cn/problem/P5079）string|implemention
P5483（https://www.luogu.com.cn/problem/P5483）implemention
P5587（https://www.luogu.com.cn/problem/P5587）implemention
P5759（https://www.luogu.com.cn/problem/P5759）implemention|high_precision|division_to_multiplication
P5989（https://www.luogu.com.cn/problem/P5989）implemention|counter
P5995（https://www.luogu.com.cn/problem/P5995）implemention
P6264（https://www.luogu.com.cn/problem/P6264）implemention
P6282（https://www.luogu.com.cn/problem/P6282）reverse_thinking|reverse_order|implemention
P6410（https://www.luogu.com.cn/problem/P6410）implemention
P6480（https://www.luogu.com.cn/problem/P6480）implemention|counter
P7186（https://www.luogu.com.cn/problem/P7186）brain_teaser|action_scope|implemention
P7338（https://www.luogu.com.cn/problem/P7338）greedy|implemention
P2129（https://www.luogu.com.cn/problem/P2129）stack|pointer|implemention
P3407（https://www.luogu.com.cn/problem/P3407）implemention
P5329（https://www.luogu.com.cn/problem/P5329）lexicographical_order|lexicographical_order|sorting
P6397（https://www.luogu.com.cn/problem/P6397）greedy|implemention
P8247（https://www.luogu.com.cn/problem/P8247）implemention
P8611（https://www.luogu.com.cn/problem/P8611）implemention|classification_discussion
P8755（https://www.luogu.com.cn/problem/P8755）heapq|implemention
P9023（https://www.luogu.com.cn/problem/P9023）matrix_rotate|implemention|counter
P8898（https://www.luogu.com.cn/problem/P8898）greedy|implemention
P8895（https://www.luogu.com.cn/problem/P8895）implemention|counter
P8884（https://www.luogu.com.cn/problem/P8884）classification_discussion|odd_even
P8873（https://www.luogu.com.cn/problem/P8873）math|arithmetic_sequence
P2793（https://www.luogu.com.cn/problem/P2793）implemention
P4924（https://www.luogu.com.cn/problem/P4924）matrix_rotate|implemention|classical
P7043（https://www.luogu.com.cn/problem/P7043）implemention|observation

===================================CodeForces===================================
463C（https://codeforces.com/problemset/problem/463/C）diagonal|matrix
1676D（https://codeforces.com/contest/1676/problem/D）skill|diagonal|matrix
1703E（https://codeforces.com/contest/1703/problem/E）matrix|rotate
1722F（https://codeforces.com/contest/1722/problem/F）
1807F（https://codeforces.com/contest/1807/problem/F）implemention|classical
1850G（https://codeforces.com/contest/1850/problem/G）implemention|classical|matrix_direction
1006D（https://codeforces.com/contest/1006/problem/D）greedy|implemention|brute_force
1506F（https://codeforces.com/contest/1506/problem/F）implemention|odd_even
1560E（https://codeforces.com/contest/1560/problem/E）reverse_thinking|implemention
1976C（https://codeforces.com/contest/1976/problem/C）binary_search|implemention|inclusion_exclusion|reverse_thinking
608B（https://codeforces.com/problemset/problem/608/B）contribution_method|prefix_sum|implemention
1980F1（https://codeforces.com/contest/1980/problem/F1）brute_force|implemention
1979D（https://codeforces.com/contest/1979/problem/D）prefix_suffix|brute_force|implemention
1491C（https://codeforces.com/problemset/problem/1491/C）implemention|brain_teaser|fill_table
1990D（https://codeforces.com/problemset/problem/1990/D）implemention
1346C（https://codeforces.com/problemset/problem/1463/C）implemention
1151C（https://codeforces.com/problemset/problem/1151/C）inclusion_exclusion
1990C（https://codeforces.com/problemset/problem/1990/C）implemention

====================================AtCoder=====================================
ABC334B（https://atcoder.jp/contests/abc334/tasks/abc334_b）implemention|greedy|brute_force
ABC321E（https://atcoder.jp/contests/abc321/tasks/abc321_e）implemention|binary_tree|counter
ABC315D（https://atcoder.jp/contests/abc315/tasks/abc315_d）bfs|classical|implemention
ABC278D（https://atcoder.jp/contests/abc278/tasks/abc278_d）brain_teaser|classical
ABC279E（https://atcoder.jp/contests/abc279/tasks/abc279_e）prefix_suffix|implemention|brain_teaser|classical
ABC274D（https://atcoder.jp/contests/abc274/tasks/abc274_d）brute_force|implemention
ABC273D（https://atcoder.jp/contests/abc273/tasks/abc273_d）binary_search|implemention
ABC273E（https://atcoder.jp/contests/abc273/tasks/abc273_e）tree|implemention|implemention|classical
ABC272E（https://atcoder.jp/contests/abc272/tasks/abc272_e）brute_force|implemention|euler_series|classical
ABC270B（https://atcoder.jp/contests/abc270/tasks/abc270_b）brute_force|implemention
ABC253G（https://atcoder.jp/contests/abc253/tasks/abc253_g）inclusion_exclusion|prefix_sum|implemention|permutation|classical
ABC218C（https://atcoder.jp/contests/abc218/tasks/abc218_c）implemention|matrix_rotate
ABC359C（https://atcoder.jp/contests/abc359/tasks/abc359_c）implemention
ABC203E（https://atcoder.jp/contests/abc203/tasks/abc203_e）implemention
ABC375C（https://atcoder.jp/contests/abc375/tasks/abc375_c）implemention|matrix_rotate

=====================================AcWing=====================================
4318（https://www.acwing.com/problem/content/description/4321/）hash|greedy|implemention|construction

1（https://www.codechef.com/problems/MODE_PROBLEM）contribution_method

"""
import math
from collections import deque
from heapq import heappop, heappush

from src.basis.binary_search.template import BinarySearch
from src.basis.implemention.template import SpiralMatrix
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_1823(n: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-the-winner-of-the-circular-game/
        tag: joseph_circle
        """
        return SpiralMatrix.joseph_circle(n, k) + 1

    @staticmethod
    def cf_463c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/463/C
        tag: diagonal|matrix|odd_even|brain_teaser
        """
        n = ac.read_int()
        grid = [ac.read_list_ints() for _ in range(n)]
        left = [0] * 2 * n
        right = [0] * 2 * n
        for i in range(n):
            for j in range(n):
                left[i - j] += grid[i][j]
                right[i + j] += grid[i][j]

        ans1 = [-1, -1]
        ans2 = [[-1, -1], [-1, -1]]
        for i in range(n):
            for j in range(n):
                cur = left[i - j] + right[i + j] - grid[i][j]
                t = (i + j) & 1
                if cur > ans1[t]:
                    ans1[t] = cur
                    ans2[t] = [i + 1, j + 1]

        ac.st(sum(ans1))
        ac.lst(ans2[0] + ans2[1])
        return

    @staticmethod
    def lg_p1815(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1815
        tag: implemention
        """

        def check():
            lst = deque([[25, j] for j in range(11, 31)])
            dire = {"E": [0, 1], "S": [1, 0], "W": [0, -1], "N": [-1, 0]}
            m = 0
            for i, w in enumerate(s):
                m = i + 1
                x, y = lst[-1]
                a, b = dire[w]
                x += a
                y += b
                if not (1 <= x <= 50 and 1 <= y <= 50):
                    return f"The worm ran off the board on move {m}."
                if [x, y] in lst and [x, y] != lst[0]:
                    return f"The worm ran into itself on move {m}."
                lst.popleft()
                lst.append([x, y])
            return f"The worm successfully made all {m} moves."

        while True:
            s = ac.read_int()
            if not s:
                break
            s = ac.read_str()
            ac.st(check())
        return

    @staticmethod
    def lg_p2129(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2129
        tag: stack|pointer|implemention
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        mul = [1, 1]
        add = [0, 0]
        for lst in [ac.read_list_strs() for _ in range(m)][::-1]:
            if lst[0] == "x":
                mul[0] *= -1
                add[0] *= -1
            elif lst[0] == "y":
                mul[1] *= -1
                add[1] *= -1
            else:
                p, q = lst[1:]
                add[0] += int(p)
                add[1] += int(q)
        for x, y in nums:
            ac.lst([mul[0] * x + add[0], mul[1] * y + add[1]])
        return

    @staticmethod
    def lg_p3407(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3407
        tag: implemention
        """
        n, t, q = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        pre = [-math.inf] * n
        right = -math.inf
        sta = -math.inf
        for i in range(n):
            a, r = nums[i]
            if r == 1:
                right = a
                sta = -math.inf
            else:
                if right != -math.inf:
                    sta = (right + a) // 2
                    pre[i] = sta
                    right = -math.inf
                elif sta != -math.inf:
                    pre[i] = sta

        post = [math.inf] * n
        left = math.inf
        sta = math.inf
        for i in range(n - 1, -1, -1):
            a, r = nums[i]
            if r == 2:
                left = a
                sta = math.inf
            else:
                if left != math.inf:
                    sta = (left + a) // 2
                    post[i] = sta
                    left = math.inf
                elif sta != math.inf:
                    post[i] = sta

        for _ in range(q):
            i = ac.read_int() - 1
            a, r = nums[i]
            if r == 1:
                ac.st(min(a + t, post[i]))
            else:
                ac.st(max(a - t, pre[i]))
        return

    @staticmethod
    def lg_p5329(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5329
        tag: lexicographical_order|sort|brain_teaser|classical
        """
        n = ac.read_int()
        s = ac.read_str()
        ans = [0] * n
        i, j = 0, n - 1
        idx = 0
        for x in range(1, n):
            if s[x] > s[x - 1]:
                for y in range(x - 1, idx - 1, -1):
                    ans[j] = y + 1
                    j -= 1
                idx = x
            if s[x] < s[x - 1]:
                for y in range(idx, x):
                    ans[i] = y + 1
                    i += 1
                idx = x
        for x in range(idx, n):
            ans[i] = x + 1
            i += 1
        ac.lst(ans)
        return

    @staticmethod
    def lg_p6397(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6397
        tag: greedy|implemention|brain_teaser
        """
        k = ac.read_float()
        nums = [ac.read_float() for _ in range(ac.read_int())]
        pre = nums[0]
        ans = 0
        for num in nums[1:]:
            if num - ans <= pre + k <= num + ans:
                pre += k
            elif pre + k > num + ans:
                pre = max(pre, num + ans)
            else:
                gap = (num - ans - pre - k) / 2.0
                pre = num - ans - gap
                ans += gap
        ac.st(ans)
        return

    @staticmethod
    def lg_p8247(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8247
        tag: implemention|math|line_slope
        """
        m, n = ac.read_list_ints()
        start = [-1, -1]
        dct = []
        for i in range(m):
            lst = ac.read_str()
            for j in range(n):
                if lst[j] == "S":
                    start = [i, j]
                elif lst[j] == "K":
                    dct.append([i, j])
        a, b = start
        cnt = set()
        for i, j in dct:
            x, y = i - a, j - b
            if x == 0:
                y = 1 if y > 0 else -1
            else:
                g = math.gcd(abs(x), abs(y))
                x //= g
                y //= g
            cnt.add((x, y))
        ac.st(len(cnt))
        return

    @staticmethod
    def lg_p8611(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8611
        tag: implemention|classification_discussion|classical|brain_teaser
        """
        ac.read_int()
        nums = ac.read_list_ints()
        a = nums[0]
        x = y = 0
        for num in nums[1:]:
            if abs(num) > abs(a) and num < 0:
                y += 1
            elif abs(num) < abs(a) and num > 0:
                x += 1
        if a < 0:
            ans = 1 if not x else x + y + 1
        else:
            ans = 1 if not y else x + y + 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p9023(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9023
        tag: matrix_rotate|implemention|counter|odd_even|inclusion_exclusion
        """
        m = ac.read_int()
        n = ac.read_int()
        k = ac.read_int()
        row = [0] * (m + 1)
        col = [0] * (n + 1)
        for _ in range(k):
            lst = ac.read_list_strs()
            x = int(lst[1])
            if lst[0] == "R":
                row[x] += 1
                row[x] %= 2
            else:
                col[x] += 1
                col[x] %= 2
        cnt1 = sum(row)
        cnt2 = sum(col)
        ans = cnt1 * (n - cnt2) + cnt2 * (m - cnt1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p8895(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8895
        tag: implemention|counter|classical|freq
        """
        n, m, p = ac.read_list_ints()
        dp = [1] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i - 1] * 2 % p

        def check():
            while stack and not cnt[stack[0]]:
                heappop(stack)
            if ceil >= 3 or cnt[stack[0]] != 1:
                ac.st(0)
            else:
                even = freq[2]
                ac.st(dp[n - even * 2 - 1])
            return

        def add(a):
            nonlocal ceil
            heappush(stack, a)
            cnt[a] += 1
            if ceil < cnt[a]:
                ceil = cnt[a]
            freq[cnt[a]] += 1
            if cnt[a] > 1:
                freq[cnt[a] - 1] -= 1
            return

        def remove(a):
            nonlocal ceil
            freq[cnt[a]] -= 1
            if not freq[ceil]:
                ceil -= 1
            cnt[a] -= 1
            if cnt[a]:
                freq[cnt[a]] += 1
            return

        freq = [0] * (n + 1)
        cnt = [0] * (n + 1)
        ceil = 0
        nums = ac.read_list_ints()
        stack = []
        for num in nums:
            add(num)

        check()
        for _ in range(m):
            x, k = ac.read_list_ints()
            x -= 1
            remove(nums[x])
            nums[x] = k
            add(k)
            check()
        return

    @staticmethod
    def lg_p8884(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8884
        tag: classification_discussion|odd_even
        """
        n, m, c = ac.read_list_ints()
        cnt = [0, 0]
        for _ in range(c):
            i, j = ac.read_list_ints_minus_one()
            cnt[(i + j) % 2] += 1

        total = [0, 0]
        if m % 2 == 0 or n % 2 == 0:
            total[0] = total[1] = m * n // 2
        else:
            total[0] = m * n // 2 + 1
            total[1] = m * n // 2

        for _ in range(ac.read_int()):
            x1, y1, x2, y2, p = ac.read_list_ints_minus_one()
            p += 1
            cur = [0, 0]
            while p:
                lst = ac.read_list_ints()
                if not lst:
                    continue
                i, j = [x - 1 for x in lst]
                cur[(i + j) % 2] += 1
                p -= 1

            mm, nn = x2 - x1 + 1, y2 - y1 + 1
            cur_total = [0, 0]
            if (mm * nn) % 2 == 0:
                cur_total[0] = cur_total[1] = mm * nn // 2
            else:
                if (x1 + y1) % 2 == 0:
                    cur_total[0] = mm * nn // 2 + 1
                    cur_total[1] = mm * nn // 2
                else:
                    cur_total[1] = mm * nn // 2 + 1
                    cur_total[0] = mm * nn // 2

            if cur[0] <= cnt[0] and cur[1] <= cnt[1] \
                    and total[0] - cur_total[0] >= cnt[0] - cur[0] \
                    and total[1] - cur_total[1] >= cnt[1] - cur[1]:
                ac.yes()
            else:
                ac.no()

        return

    @staticmethod
    def ac_4318(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4321/
        tag: hash|greedy|implemention|construction|brain_teaser
        """
        x = y = 0
        ind = dict()
        ind["U"] = [-1, 0]
        ind["D"] = [1, 0]
        ind["L"] = [0, -1]
        ind["R"] = [0, 1]
        pre = {(0, 0)}
        for w in ac.read_str():
            cur = (x, y)
            x += ind[w][0]
            if (x, y) in pre:
                ac.no()
                return
            for a, b in [[-1, 0], [0, 1], [1, 0], [0, -1]]:
                if (x + a, y + b) in pre and (x + a, y + b) != cur:
                    ac.no()
                    return
            pre.add((x, y))
        ac.yes()
        return

    @staticmethod
    def abc_279e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc279/tasks/abc279_e
        tag: prefix_suffix|implemention|brain_teaser|classical
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints_minus_one()
        zero = 0
        pre = [zero]
        for i in range(m - 1):
            aa = a[i]
            if aa + 1 == zero:
                zero = aa
            elif aa == zero:
                zero = aa + 1
            pre.append(zero)

        ans = [pre[-1]]
        b = list(range(n))
        for i in range(m - 1, -1, -1):
            if i < m - 1:
                ans.append(b[pre[i]])
            aa = a[i]
            b[aa], b[aa + 1] = b[aa + 1], b[aa]

        for a in ans[::-1]:
            ac.st(a + 1)
        return

    @staticmethod
    def abc_273e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc273/tasks/abc273_e
        tag: tree|implemention|implemention|classical
        """
        q = ac.read_int()
        nums = ["-1"] * (q + 1)
        father = [-1] * (q + 1)
        ind = now = 0
        dct = dict()
        ans = []
        for _ in range(q):
            lst = ac.read_list_strs()
            if lst[0] == "ADD":
                ind += 1
                nums[ind] = lst[1]
                father[ind] = now
                now = ind
            elif lst[0] == "DELETE":
                if now:
                    now = father[now]
            elif lst[0] == "SAVE":
                dct[lst[1]] = now
            else:
                now = dct.get(lst[1], 0)
            ans.append(nums[now] if now else -1)
        ac.lst(ans)
        return

    @staticmethod
    def abc_272e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc272/tasks/abc272_e
        tag: brute_force|implemention|euler_series|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [set() for _ in range(m + 1)]
        for i in range(n):
            num = nums[i]
            low = max(0, (-num) // (i + 1))
            num += low * (i + 1)
            while low <= m and num <= n:
                dct[low].add(num)
                low += 1
                num += (i + 1)
        for i in range(1, m + 1):
            x = 0
            while x in dct[i]:
                x += 1
            ac.st(x)
        return

    @staticmethod
    def abc_270b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc270/tasks/abc270_b
        tag: brute_force|implemention
        """
        x, y, z = ac.read_list_ints()
        if x < 0:
            x, y, z = -x, -y, -z
        if y < 0 or y > x:
            ac.st(x)
        elif z > y:
            ac.st(-1)
        else:
            ac.st(abs(z) + abs(x - z))
        return

    @staticmethod
    def abc_253g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc253/tasks/abc253_g
        tag: inclusion_exclusion|prefix_sum|implemention|permutation|classical
        """
        n, ll, rr = ac.read_list_ints()

        def check(x):
            if x == 0:
                return list(range(n))
            pre = 0
            while x >= (n - pre - 1) >= 0:
                x -= (n - pre - 1)
                pre += 1
            nums = list(range(n - 1, n - pre - 1, -1)) + list(range(n - pre))
            if pre < n:
                start = pre
                for y in range(1, x + 1):
                    nums[start], nums[start + y] = nums[start + y], nums[start]
            return nums

        nums1 = check(ll - 1)
        nums2 = check(rr)
        dct = {num: i for i, num in enumerate(nums2)}
        ans = [0] * n
        for i in range(n):
            ans[dct[nums1[i]]] = i
        ac.lst([x + 1 for x in ans])
        return

    @staticmethod
    def abc_242d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc242/tasks/abc242_d
        tag: implemention|data_range|classical
        """
        s = ac.read_str()
        dct = {"A": "BC", "B": "CA", "C": "AB"}
        for _ in range(ac.read_int()):
            t, k = ac.read_list_ints()
            lst = []
            while t and k > 1:
                lst.append(k % 2)
                k = (k + 1) // 2
                t -= 1
            if t == 0:
                root = s[k - 1]
            else:
                t %= 3
                if s[0] == "A":
                    root = "ABC"[t]
                elif s[0] == "B":
                    root = "BCA"[t]
                else:
                    root = "CAB"[t]
            lst.reverse()
            for w in lst:
                root = dct[root][1 - w]
            ac.st(root)
        return

    @staticmethod
    def cf_1976c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1976/problem/C
        tag: binary_search|implemention|inclusion_exclusion|reverse_thinking
        """

        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            k = n + m + 1
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            pre_a = ac.accumulate(a)
            pre_b = ac.accumulate(b)
            lst = [min(a[i], b[i]) for i in range(k)]
            pre = ac.accumulate(lst)
            pre_cnt_a = ac.accumulate([int(a[i] > b[i]) for i in range(k)])
            pre_cnt_b = ac.accumulate([int(b[i] > a[i]) for i in range(k)])

            def compute_a(x):
                aa = pre_cnt_a[x + 1]
                if i <= x and a[i] > b[i]:
                    aa -= 1
                return aa

            def compute_b(x):
                bb = pre_cnt_b[x + 1]
                if i <= x and a[i] < b[i]:
                    bb -= 1
                return bb

            def check(x):
                return compute_a(x) >= n or compute_b(x) >= m

            ans = [0] * k
            for i in range(k):
                if n == 0:
                    ans[i] = pre_b[-1]- b[i]
                    continue
                if m == 0:
                    ans[i] = pre_a[-1] - a[i]
                    continue
                j = BinarySearch().find_int_left(0, k - 1, check)
                cur = pre_a[-1] + pre_b[-1] - a[i] - b[i]
                cur -= pre[j + 1]
                if i <= j:
                    cur += min(a[i], b[i])
                xx = compute_a(j)
                if xx == n:
                    cur -= pre_a[-1] - pre_a[j + 1]
                    if i > j:
                        cur += a[i]
                else:
                    cur -= pre_b[-1] - pre_b[j + 1]
                    if i > j:
                        cur += b[i]
                ans[i] = cur
            ac.lst(ans)
        return

    @staticmethod
    def cf_608b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/608/B
        tag: contribution_method|prefix_sum|implemention
        """
        a = ac.read_str()
        b = ac.read_str()
        n = len(a)
        m = len(b)
        pre = ac.accumulate([int(w) for w in b])
        ans = 0
        for i in range(n):
            low = i
            high = m - n + i
            tot = high - low + 1
            ans += pre[high + 1] - pre[low] if a[i] == "0" else tot - (pre[high + 1] - pre[low])
        ac.st(ans)
        return

    @staticmethod
    def cf_1980f1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1980/problem/F1
        tag: brute_force|implemention
        """
        for _ in range(ac.read_int()):
            m, n, k = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(k)]
            tmp = sorted(nums)
            lst = [(m + 1, n + 1)] + [tuple(tmp[-1])]
            xx, yy = tmp[-1]
            for x, y in tmp[::-1]:
                if y < yy and x == xx:
                    lst.pop()
                    lst.append((x, y))
                    xx, yy = lst[-1]
                    continue
                if y < yy and x < xx:
                    lst.append((x, y))
                    xx, yy = x, y
            lst.append((0, 0))
            lst.reverse()

            w = len(lst)
            ans = 0
            for i in range(w - 1):
                aa, bb = lst[i]
                cc, dd = lst[i + 1]
                ans += dd * (cc - aa)
            ans -= m + 1 + n
            res = [0] * k
            dct = {ls: i for i, ls in enumerate(lst)}
            for i in range(k):
                x, y = nums[i]
                if (x, y) in dct:
                    res[i] = 1
            ac.st(ans)
            ac.lst(res)
        return

    @staticmethod
    def cf_1979d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1979/problem/D
        tag: prefix_suffix|brute_force|implemention
        """

        def check():

            pre = ac.accumulate([int(w) for w in s])
            post = [0] * (n + 1)
            for i in range(n - 1, -1, -1):
                if i + k - 1 < n and pre[i + k] - pre[i] in [0, k]:
                    post[i] = post[i + k] + 1 if (i + k == n or s[i + k] != s[i]) else 1
            if post[0] == n // k:
                return n

            for p in range(1, n):
                left = n - p
                right = p
                ll = left // k
                if post[p] == ll:
                    rr = right // k
                    if post[0] >= rr:
                        left_rest = left % k
                        right_rest = right % k
                        if left_rest == 0 or right_rest == 0:
                            if s[p - 1] != s[n - 1]:
                                return p
                        else:
                            mid = pre[n] - pre[n - left_rest] + pre[p] - pre[p - right_rest]
                            if mid not in [0, k]:
                                continue
                            mid = "1" if mid > 0 else "0"
                            left_num = "a" if left < k else s[n - left_rest - 1]
                            right_num = "a" if right < k else s[p - right_rest - 1]
                            if mid != left_num and mid != right_num:
                                return p
                if post[p] >= n // k:
                    return p
            return -1

        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            s = ac.read_str()
            ac.st(check())
        return

    @staticmethod
    def lg_p4924(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4924
        tag: matrix_rotate|implemention|classical
        """
        n, m = ac.read_list_ints()
        grid = [[0] * n for _ in range(n)]
        nums = [ac.read_list_ints() for _ in range(m)]
        for i in range(n):
            for j in range(n):
                val = i * n + j + 1
                ii, jj = i, j
                for x, y, r, z in nums:
                    x -= 1
                    y -= 1
                    if x - r <= ii <= x + r and y - r <= jj <= y + r:
                        ii -= x - r
                        jj -= y - r
                        if z == 0:
                            ii, jj = jj, 2 * r - ii
                        else:
                            ii, jj = 2 * r - jj, ii
                        ii += x - r
                        jj += y - r
                grid[ii][jj] = val
        for g in grid:
            ac.lst(g)
        return"""
Algorithm：binary_search|interactive|game
Description：

====================================LeetCode====================================
xx（xxx）xxxxxxxxxxxxxxxxxxxx

=====================================LuoGu======================================
xx（xxx）xxxxxxxxxxxxxxxxxxxx

===================================CodeForces===================================
1479A（https://codeforces.com/problemset/problem/1479/A）interactive
1486C2（https://codeforces.com/problemset/problem/1486/C2）interactive
1503B（https://codeforces.com/problemset/problem/1503/B）interactive
1624F（https://codeforces.com/contest/1624/problem/F）binary_search|interactive
1713D（https://codeforces.com/contest/1713/problem/D）binary_search|interactive
1846F（https://codeforces.com/problemset/problem/1846/F）interactive
1697D（https://codeforces.com/contest/1697/problem/D）strictly_binary_search|interactive|find_int_right
1729E（https://codeforces.com/problemset/problem/1729/E）interactive
1762D（https://codeforces.com/problemset/problem/1762/D）interactive
1903E（https://codeforces.com/problemset/problem/1903/E）interactive
1918E（https://codeforces.com/contest/1918/problem/E）interactive|binary_search|quick_sort
1807E（https://codeforces.com/contest/1807/problem/E）interactive|binary_search
1520F2（https://codeforces.com/contest/1520/problem/F2）segment_tree|interactive
1624F（https://codeforces.com/contest/1624/problem/F）interactive|strictly_binary_search
1846F（https://codeforces.com/contest/1846/problem/F）interactive
1934C（https://codeforces.com/contest/1934/problem/C）interactive|brain_teaser
1937C（https://codeforces.com/contest/1937/problem/C）interactive|brain_teaser
1973D（https://codeforces.com/contest/1973/problem/D）interactive|brain_teaser
1556D（https://codeforces.com/problemset/problem/1556/D）interactive|bit_operation|classical
1839E（https://codeforces.com/problemset/problem/1839/E）bag_dp|interactive|game_dp
1363D（https://codeforces.com/problemset/problem/1363/D）interactive|strictly_binary_search
1207E（https://codeforces.com/problemset/problem/1207/E）interactive|construction|observation|brain_teaser|data_range|bit_operation
1534D（https://codeforces.com/problemset/problem/1534/D）interactive|tree|construction|odd_even
1407C（https://codeforces.com/problemset/problem/1407/C）interactive|observation
1621C（https://codeforces.com/problemset/problem/1621/C）interactive|permutation_circle|observation|construction
1451E2（https://codeforces.com/problemset/problem/1451/E2）interactive|bit_operation|data_range
1305D（https://codeforces.com/problemset/problem/1305/D）interactive|tree|implemention
1634D（https://codeforces.com/problemset/problem/1634/D）interactive|brain_teaser
1521C（https://codeforces.com/problemset/problem/1521/C）interactive|observation|brain_teaser
1780D（https://codeforces.com/problemset/problem/1780/D）interactive|bit_operation|classical

===================================AtCoder===================================
ABC313D（https://atcoder.jp/contests/abc313/tasks/abc313_d）interactive|brain_teaser
ABC305F（https://atcoder.jp/contests/abc305/tasks/abc305_f）interactive|brain_teaser|spanning_tree|dfs|back_trace
ABC282F（https://atcoder.jp/contests/abc282/tasks/abc282_f）brain_teaser|tree_array|interactive|classical
ABC269E（https://atcoder.jp/contests/abc269/tasks/abc269_e）binary_search_strictly|interactive|classical
ABC355E（https://atcoder.jp/contests/abc355/tasks/abc355_e）build_graph|shortest_path|brain_teaser

"""
import bisect
import random
import sys
from collections import deque


from src.basis.binary_search.template import BinarySearch
from src.data_structure.segment_tree.template import RangeAddPointGet
from src.search.dfs.template import UnWeightedTree
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def cf_1713d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1713/problem/D
        tag: binary_search|interactive
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = list(range(1, 2 ** n + 1))
            while len(nums) >= 4:
                n = len(nums)
                ans = []
                for i in range(0, n, 4):
                    a, b, c, d = nums[i], nums[i + 1], nums[i + 2], nums[i + 3]
                    x = ac.inter_ask(["?", a, c])
                    if x == 1:
                        y = ac.inter_ask(["?", a, d])
                        if y == 1:
                            ans.append(a)
                        else:
                            ans.append(d)
                    elif x == 2:
                        y = ac.inter_ask(["?", b, c])
                        if y == 1:
                            ans.append(b)
                        else:
                            ans.append(c)
                    else:
                        y = ac.inter_ask(["?", b, d])
                        if y == 1:
                            ans.append(b)
                        else:
                            ans.append(d)

                nums = ans[:]
            if len(nums) == 1:
                ac.inter_out(["!", nums[0]])
            else:
                a, b = nums[:]
                x = ac.inter_ask(["?", a, b])
                ac.inter_out(["!", a if x == 1 else b])
        return

    @staticmethod
    def cf_1697d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1697/problem/D
        tag: strictly_binary_search|interactive
        """
        n = ac.read_int()
        ans = [""] * n
        dct = dict()

        ac.lst(["?", 1, 1])
        sys.stdout.flush()
        w = ac.read_str()
        ans[0] = w
        dct[w] = 0

        pre = 1
        for i in range(1, n):
            ac.lst(["?", 2, 1, i + 1])
            sys.stdout.flush()
            cur = ac.read_int()
            if cur > pre:
                ac.lst(["?", 1, i + 1])
                sys.stdout.flush()
                w = ac.read_str()
                ans[i] = w
                dct[w] = i
                pre = cur
            else:
                lst = sorted(dct.values())
                m = len(lst)
                low, high = 0, m - 1
                while low < high:
                    mid = low + (high - low + 1) // 2
                    target = len(set(ans[lst[mid]:i]))
                    ac.lst(["?", 2, lst[mid] + 1, i + 1])
                    sys.stdout.flush()
                    cur = ac.read_int()
                    if cur == target:
                        low = mid
                    else:
                        high = mid - 1
                ans[i] = ans[lst[high]]
                dct[ans[i]] = i
        ac.lst(["!", "".join(ans)])
        sys.stdout.flush()
        return

    @staticmethod
    def cf_1918e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1918/problem/E
        tag: binary_search|interactive|quick_sort
        """

        ac.flush = True

        def query(x):
            ac.lst(["?", x + 1])
            cur = ac.read_str()
            if cur == ">":
                return 1
            elif cur == "<":
                return -1
            return 0

        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = [0] * n
            stack = [[1, n, list(range(n))]]
            while stack:
                left, right, ind = stack.pop()
                mid = ind[random.randint(0, len(ind) - 1)]
                while query(mid):
                    continue

                smaller = []
                bigger = []
                for i in ind:
                    if i == mid:
                        continue
                    if query(i) == 1:
                        bigger.append(i)
                    else:
                        smaller.append(i)
                    query(mid)
                nums[mid] = left + len(smaller)
                if left < nums[mid]:
                    stack.append([left, nums[mid] - 1, smaller])
                if nums[mid] < right:
                    stack.append([nums[mid] + 1, right, bigger])
            ac.lst(["!"] + nums)
        return

    @staticmethod
    def cf_1520f2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1520/problem/F2
        tag: segment_tree|interactive
        """
        n, t = ac.read_list_ints()
        tree = RangeAddPointGet(n)
        tree.build([-2 * t - 1] * n)
        for _ in range(t):
            k = ac.read_int()

            def check(x):
                res = tree.point_get(x - 1)
                if res < 0:
                    ac.lst(["?", 1, x])
                    cur = ac.read_int()
                    tree.range_add(x - 1, x - 1, cur - res)
                    res = cur
                return x - res >= k

            ans = BinarySearch().find_int_left(1, n, check)
            tree.range_add(ans - 1, n - 1, 1)
            ac.lst(["!", ans])
        return

    @staticmethod
    def cf_1937c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1937/problem/C
        tag: interactive|brain_teaser
        """
        ac.flush = True

        def ask(tmp):
            ac.lst(tmp)
            return ac.read_str()

        for _ in range(ac.read_int()):
            n = ac.read_int()
            zero = 0
            for i in range(1, n):
                x = ask(["?", zero, zero, i, i])
                if x == "<":
                    zero = i

            nex = 1 if zero == 0 else 0
            lst = [nex]
            for i in range(n):
                if i == nex or i == zero:
                    continue
                x = ask(["?", zero, lst[-1], zero, i])
                if x == "<":
                    lst = [i]
                elif x == "=":
                    lst.append(i)
            nex = lst[0]
            for i in lst[1:]:
                x = ask(["?", nex, nex, i, i])
                if x == ">":
                    nex = i
            ac.lst(["!", zero, nex])
        return

    @staticmethod
    def cf_1934c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1934/problem/C
        tag: interactive|brain_teaser
        """
        ac.flush = True

        def ask(lst):
            ac.lst(lst)
            return ac.read_int()

        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            a = ask(["?", 1, 1])
            b = ask(["?", m, 1])
            y = (a + 2 + b + 1 - m) // 2
            x = a + 2 - y
            if 1 <= x <= m and 1 <= y <= n and ask(["?", x, y]) == 0:
                ac.lst(["!", x, y])
                continue
            c = ask(["?", m, n])
            y = (n + b + 1 - c) // 2
            x = m + n - c - y
            ac.lst(["!", x, y])
        return

    @staticmethod
    def abc_305f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc305/tasks/abc305_f
        tag: interactive|brain_teaser|spanning_tree|dfs|back_trace
        """
        ac.flush = True
        n, m = ac.read_list_ints()
        parent = [-1] * (n + 1)
        dct = [deque() for _ in range(n + 1)]
        lst = ac.read_list_ints()
        dct[1] = deque(lst[1:])
        visit = [0] * (n + 1)
        visit[1] = 1
        stack = [1]
        while stack:
            x = stack[-1]
            while dct[x] and visit[dct[x][0]]:
                dct[x].popleft()
            if dct[x]:
                y = dct[x].popleft()
                parent[y] = x
                stack.append(y)
                visit[y] = 1
                ac.st(y)
                lst = ac.read_list_strs()
                if lst[0] == "OK":
                    return
                dct[y] = deque([int(w) for w in lst[1:]])
            else:
                x = stack.pop()
                y = parent[x]
                stack.append(y)
                ac.st(y)
                ac.read_list_strs()
        return

    @staticmethod
    def abc_282f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc282/tasks/abc282_f
        tag: brain_teaser|tree_array|interactive|classical
        """
        ac.flush = True
        n = ac.read_int()
        start = [[] for _ in range(n)]
        end = [[] for _ in range(n)]
        lst = []
        for i in range(n):
            lst.append((i, i))
            start[i].append(i)
            end[i].append(i)
            cnt = 1
            while i + cnt < n:
                lst.append((i, i + cnt))
                start[i].append(i + cnt)
                end[i + cnt].append(i)
                cnt *= 2
        dct = {(ls[0], ls[1]): i for i, ls in enumerate(lst)}
        ac.st(len(lst))
        for ls in lst:
            ac.lst([ls[0] + 1, ls[1] + 1])

        for _ in range(ac.read_int()):
            ll, rr = ac.read_list_ints_minus_one()
            mid_ll = start[ll][bisect.bisect_right(start[ll], rr) - 1]
            mid_rr = end[rr][bisect.bisect_left(end[rr], ll)]
            a = dct[(ll, mid_ll)]
            b = dct[(mid_rr, rr)]
            ac.lst([a + 1, b + 1])
        return

    @staticmethod
    def abc_269e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc269/tasks/abc269_e
        tag: binary_search_strictly|interactive|classical
        """
        ac.flush = True
        n = ac.read_int()

        def check1(x):
            ac.lst(["?"] + [1, x + 1, 1, n])
            cnt = ac.read_int()
            return cnt < x + 1

        def check2(x):
            ac.lst(["?"] + [1, n, 1, x + 1])
            cnt = ac.read_int()
            return cnt < x + 1

        row = BinarySearch().find_int_left(0, n - 1, check1)
        col = BinarySearch().find_int_left(0, n - 1, check2)
        ac.lst(["!", row + 1, col + 1])
        return

    @staticmethod
    def abc_355e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc355/tasks/abc355_e
        tag: build_graph|shortest_path|brain_teaser
        """
        ac.flush = True
        n, lll, rrr = ac.read_list_ints()
        rrr += 1
        m = 1 << n
        m += 10
        dct = [[] for _ in range(m)]
        for i in range(n + 10):
            for j in range(m + 10):
                if 0 <= (2 ** i) * j <= (2 ** i) * (j + 1) <= 2 ** n:
                    ll = (2 ** i) * j
                    rr = (2 ** i) * (j + 1)
                    dct[ll].append((i, j, rr))
                    dct[rr].append((i, j, ll))
                else:
                    break

        dis = [math.inf] * m
        stack = [lll]
        parent = [[] for _ in range(m)]
        dis[lll] = 0
        while stack:
            nex = []
            for x in stack:
                d = dis[x]
                for i, j, xx in dct[x]:
                    dj = d + 1
                    if dj < dis[xx]:
                        dis[xx] = dj
                        parent[xx] = [i, j, x]
                        nex.append(xx)
            stack = nex[:]
        x = rrr
        ans = 0
        while x != lll:
            i, j, xx = parent[x]
            ac.lst(["?", i, j])
            cur = ac.read_int()
            if xx < x:
                ans += cur
            else:
                ans += 100 - cur
            ans %= 100
            x = xx
        ac.lst(["!", ans])
        return

    @staticmethod
    def cf_1556d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1556/D
        tag: interactive|bit_operation|classical
        """
        ac.flush = True
        n, k = ac.read_list_ints()
        nums = [0] * n
        for i in range(n - 1):
            ac.lst(["and", i + 1, i + 2])
            a = ac.read_int()
            ac.lst(["or", i + 1, i + 2])
            b = ac.read_int()
            nums[i + 1] = a + b
        ac.lst(["and", 1, 3])
        a = ac.read_int()
        ac.lst(["or", 1, 3])
        b = ac.read_int()
        nums[0] = (nums[1] - nums[2] + a + b) // 2
        for i in range(1, n):
            nums[i] -= nums[i - 1]
        nums.sort()
        ac.lst(["finish"] + [nums[k - 1]])
        return

    @staticmethod
    def cf_1839e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1839/E
        tag: bag_dp|interactive|game_dp
        """
        ac.flush = True
        n = ac.read_int()
        nums = ac.read_list_ints()
        s = sum(nums)
        dp = [0] * (s // 2 + 1)
        dp[0] = 1
        pre = [[] for _ in range(s // 2 + 1)]
        for i in range(n):
            num = nums[i]
            for x in range(s // 2, num - 1, -1):
                if dp[x - num] and not dp[x]:
                    dp[x] = 1
                    pre[x] = pre[x - num][:] + [i]

        if s % 2 or not dp[s // 2] or n == 1:
            ac.st("First")
            ac.st(1)
            index = 0
            while True:
                i = ac.read_int()
                if i <= 0:
                    break
                x = min(nums[index], nums[i - 1])
                nums[index] -= x
                nums[i - 1] -= x
                for j in range(n):
                    if nums[j] > 0:
                        index = j
                        ac.st(j + 1)
                        break
            return

        color = [0] * n
        for c in pre[s // 2]:
            color[c] = 1

        ac.st("Second")

        while True:
            i = ac.read_int()
            if i <= 0:
                break
            c = color[i - 1]
            for j in range(n):
                if color[j] == 1 - c and nums[j] > 0 and j + 1 != i:
                    x = min(nums[j], nums[i - 1])
                    nums[j] -= x
                    nums[i - 1] -= x
                    ac.st(j + 1)
                    break
        return

    @staticmethod
    def cf_1621c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1621/C
        tag: interactive|permutation_circle|observation|construction
        """
        ac.flush = True
        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = [0] * n
            for i in range(n):
                if ans[i]:
                    continue
                ac.lst(["?", i + 1])
                a = ac.read_int()
                ac.lst(["?", i + 1])
                b = ac.read_int()
                ans[a - 1] = b
                while b != a:
                    ac.lst(["?", i + 1])
                    c = ac.read_int()
                    ans[b - 1] = c
                    b = c
            ac.lst(["!"] + ans)
        return

    @staticmethod
    def cf_1451e2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1451/E2
        tag: interactive|bit_operation|data_range
        """
        ac.flush = True
        n = ac.read_int()
        nums = [0] * n
        pre = [-1] * n
        pre[0] = 0
        lst = []
        for i in range(1, n):
            ac.lst(["XOR", 1, i + 1])
            nums[i] = ac.read_int()
            if pre[nums[i]] != -1:
                lst = [pre[nums[i]], i]
            pre[nums[i]] = i
        if lst:
            i, j = lst
            ac.lst(["AND", i + 1, j + 1])
            nums[0] = ac.read_int() ^ nums[i]
        else:
            i = pre[1]
            j = pre[n - 2]
            ac.lst(["AND", i + 1, 1])
            x = ac.read_int()
            ac.lst(["AND", j + 1, 1])
            y = ac.read_int()
            nums[0] = ((x >> 1) << 1) | (y & 1)
        for i in range(1, n):
            nums[i] ^= nums[0]
        ac.lst(["!"] + nums)
        return

    @staticmethod
    def cf_1305d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1305/D
        tag: interactive|tree|implemention
        """
        ac.flush = True
        n = ac.read_int()
        graph = UnWeightedTree(n)
        degree = [0] * n
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j)
            degree[i] += 1
            degree[j] += 1
        leaf = [i for i in range(n) if degree[i] == 1]
        while len(leaf) > 1:
            i, j = leaf.pop(), leaf.pop()
            ac.lst(['?', i + 1, j + 1])
            x = ac.read_int()
            if x == i + 1 or x == j + 1:
                ac.lst(["!", x])
                return
            for x in [i, j]:
                ind = graph.point_head[x]
                while ind:
                    j = graph.edge_to[ind]
                    degree[j] -= 1
                    if degree[j] == 1:
                        leaf.append(j)
                    ind = graph.edge_next[ind]
        ac.lst(["!", leaf[0] + 1])
        return

    @staticmethod
    def cf_1521c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1521/C
        tag: interactive|observation|brain_teaser
        """
        ac.flush = True
        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = [-1] * n
            for x in range(0, n, 2):
                if x + 1 < n:
                    ac.lst(["?", 2, x + 1, x + 2, 1])
                    res = ac.read_int()
                    if res == 1:
                        one = x
                        ans[x] = 1
                        break
                    elif res == 2:
                        ac.lst(["?", 2, x + 2, x + 1, 1])
                        res = ac.read_int()

                        if res == 1:
                            ans[x + 1] = 1
                            one = x + 1
                            break
            else:
                ans[n - 1] = 1
                one = n - 1
            for i in range(n):
                if i != one:
                    ac.lst(["?", 1, one + 1, i + 1, n - 1])
                    ans[i] = ac.read_int()
            ac.lst(["!"] + ans)
        return

    @staticmethod
    def cf_1780d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1780/D
        tag: interactive|bit_operation|classical
        """
        ac.flush = True
        for _ in range(ac.read_int()):
            m = ac.read_int()
            ans = i = 0
            while True:
                ac.lst(["-", 1 << i])
                n = ac.read_int()
                for _ in range(n - m + 1):
                    i += 1
                ans += 1 << i
                if n == i:
                    break
                m = n
            ac.lst(["!", ans])
        return
"""
Algorithm：md_vector
Description：

====================================LeetCode====================================

=====================================LuoGu======================================

===================================CodeForces===================================

====================================AtCoder=====================================

=====================================AcWing=====================================

"""


class Solution:
    def __init__(self):
        return
"""

Algorithm：observation
Description：observation|property|data_range

====================================LeetCode====================================

=====================================LuoGu======================================

===================================CodeForces===================================
1305C（https://codeforces.com/problemset/problem/1305/C）observation|property|data_range
1705D（https://codeforces.com/problemset/problem/1705/D）observation|property
1646C（https://codeforces.com/problemset/problem/1646/C）observation|data_range
1809D（https://codeforces.com/problemset/problem/1809/D）observation|data_range|construction
1749D（https://codeforces.com/problemset/problem/1749/D）observation|data_range
1185C2（https://codeforces.com/problemset/problem/1185/C2）data_range|bucket_cnt|greedy
1616C（https://codeforces.com/problemset/problem/1616/C）compute_slope|brute_force|observation|arithmetic_sequence
1239A（https://codeforces.com/problemset/problem/1239/A）fibonacci_array|linear_dp|observation
1889B（https://codeforces.com/problemset/problem/1889/B）observation|implemention
1332B（https://codeforces.com/problemset/problem/1332/B）observation|data_range|min_prime|data_range
1583C（https://codeforces.com/problemset/problem/1583/C）observation
1605C（https://codeforces.com/problemset/problem/1605/C）observation
1634B（https://codeforces.com/problemset/problem/1634/B）observation|odd_even|data_range
1687A（https://codeforces.com/problemset/problem/1687/A）observation|greedy
1548A（https://codeforces.com/problemset/problem/1548/A）observation|brain_teaser|implemention
1408D（https://codeforces.com/problemset/problem/1408/D）brute_force|liner_dp|greedy|brain_teaser|observation

====================================AtCoder=====================================




"""
from src.mathmatics.geometry.template import Geometry
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def cf_1185c2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1185/C2
        tag: data_range|bucket_cnt|greedy
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        cnt = [0] * 101
        ans = []
        pre = 0
        for num in nums:
            rest = m - pre
            cur = 0
            for x in range(100, 0, -1):
                if rest >= num:
                    break
                y = min(cnt[x], (num - rest + x - 1) // x)
                cur += y
                rest += y * x
            ans.append(cur)
            cnt[num] += 1
            pre += num
        ac.lst(ans)
        return

    @staticmethod
    def cf_1616c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1616/C
        tag: compute_slope|brute_force|observation|arithmetic_sequence
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            ans = n - 1
            gm = Geometry()
            for i in range(n):
                for j in range(i + 1, n):
                    cur = gm.compute_slope(nums[i], i, nums[j], j)
                    cnt = 2
                    for k in range(j + 1, n):
                        if gm.compute_slope(nums[i], i, nums[k], k) == cur:
                            cnt += 1
                    ans = min(ans, n - cnt)
            ac.st(ans)
        return

    @staticmethod
    def cf_1239a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1239/A
        tag: fibonacci_array|linear_dp|observation
        """
        mod = 10 ** 9 + 7
        m, n = ac.read_list_ints()
        ceil = max(m, n) + 10
        dp = [0] * ceil
        dp[0] = dp[1] = 1
        for i in range(2, ceil):
            dp[i] = (dp[i - 1] + dp[i - 2]) % mod
        ans = (dp[n] + dp[m] - 1) * 2 % mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1332b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1332/B
        tag: observation|data_range|min_prime|data_range
        """
        pf = PrimeFactor(1000)
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            lst = list(set([pf.min_prime[x] for x in nums]))
            dct = {num: i + 1 for i, num in enumerate(lst)}
            ans = [dct[pf.min_prime[x]] for x in nums]
            ac.st(len(dct))
            ac.lst(ans)
        return

    @staticmethod
    def main(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1408/D
        tag: brute_force|liner_dp|greedy|brain_teaser|observation
        """
        n, m = ac.read_list_ints()
        nums1 = [ac.read_list_ints() for _ in range(n)]
        nums2 = [ac.read_list_ints() for _ in range(m)]
        ceil = 10 ** 6 + 10
        right = [0] * ceil
        ans = 0
        for a, b in nums1:
            for c, d in nums2:
                if d >= b:
                    right[d - b] = max(right[d - b], c - a + 1)
                    ans = max(ans, d - b + 1)
        for i in range(ceil - 2, -1, -1):
            right[i] = max(right[i], right[i + 1])
            ans = min(ans, i + right[i])
        ac.st(ans)
        return

    @staticmethod
    def cf_1408d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1408/D
        tag: brute_force|liner_dp|greedy|brain_teaser|observation
        """
        n, m = ac.read_list_ints()
        nums1 = [ac.read_list_ints() for _ in range(n)]
        nums2 = [ac.read_list_ints() for _ in range(m)]
        ceil = 10 ** 6 + 10
        right = [0] * ceil
        ans = 0
        for a, b in nums1:
            for c, d in nums2:
                if d >= b:
                    right[d - b] = max(right[d - b], c - a + 1)
                    ans = max(ans, d - b + 1)
        for i in range(ceil - 2, -1, -1):
            right[i] = max(right[i], right[i + 1])
            ans = min(ans, i + right[i])
        ac.st(ans)
        return
"""
Algorithm：offline_query|sorting
Description：with the help of pointer and sorting for offline query

====================================LeetCode====================================
100110（https://leetcode.cn/contest/weekly-contest-372/problems/find-building-where-alice-and-bob-can-meet/）offline_query|sorting
1851（https://leetcode.cn/problems/minimum-interval-to-include-each-query）
2736（https://leetcode.cn/problems/maximum-sum-queries/description/）

=====================================LuoGu======================================
xx（xxx）xxxxxxxxxxxxxxxxxxxx

===================================CodeForces===================================

===================================AtCoder===================================
ABC245E（https://atcoder.jp/contests/abc245/tasks/abc245_e）sorted_list|offline_query

"""
from typing import List

from src.data_structure.sorted_list.template import SortedList
from src.utils.fast_io import FastIO
from tests.leetcode.template import max


class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_100110(heights: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/contest/weekly-contest-372/problems/find-building-where-alice-and-bob-can-meet/
        tag: offline_query|sorting
        """
        m = len(queries)
        for i in range(m):
            x, y = queries[i]
            queries[i] = (i, x, y, max(heights[x], heights[y]))
        queries.sort(key=lambda it: -it[-1])
        ans = [-1] * m

        n = len(heights)
        original = heights[:]
        heights = [(i, heights[i]) for i in range(n)]
        heights.sort(key=lambda it: -it[-1])
        j = 0
        lst = SortedList()
        for i, x, y, c in queries:
            if x < y and original[x] < original[y]:
                ans[i] = y
                continue
            if y < x and original[y] < original[x]:
                ans[i] = x
                continue
            if x == y:
                ans[i] = y
                continue
            while j < n and heights[j][1] > c:
                lst.add(heights[j][0])
                j += 1
            k = lst.bisect_right(max(x, y))
            if 0 <= k < len(lst):
                ans[i] = lst[k]
        return ans

    @staticmethod
    def abc_245e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc245/tasks/abc245_e
        tag: sorted_list|offline_query
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        c = ac.read_list_ints()
        d = ac.read_list_ints()
        ind1 = list(range(n))
        ind2 = list(range(m))
        ind1.sort(key=lambda it: -a[it])
        ind2.sort(key=lambda it: -c[it])
        lst = SortedList()
        j = 0
        for i in ind1:
            aa, bb = a[i], b[i]
            while j < m and c[ind2[j]] >= aa:
                lst.add(d[ind2[j]])
                j += 1
            if not lst or lst[-1] < bb:
                ac.no()
                break
            i = lst.bisect_left(bb)
            lst.pop(i)
        else:
            ac.yes()
        return
"""
Algorithm：speed_up|performance
Description：some skills or tricks for better performance


=====================================LuoGu======================================
P1188（https://www.luogu.com.cn/problem/P1188）slice

"""


class XXX:
    def __init__(self):
        return


class Solution:
    def __int__(self):
        return
"""
Algorithm：range_merge_to_disjoint|minimum_range_cover|counter|maximum_disjoint_range
Description：sometimes cooperation with diff_array or tree_array or segment_tree
minimum_point_cover_range|minimum_group_range_disjoint|maximum_point_cover_range|bipartite_graph

====================================LeetCode====================================
45（https://leetcode.cn/problems/jump-game-ii/）minimum_range_cover
452（https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/）greedy|maximum_disjoint_range
1326（https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/）range_merge_to_disjoint
1024（https://leetcode.cn/problems/video-stitching/）minimum_range_cover
1520（https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/）maximum_disjoint_range
1353（https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/）greedy|minimum_point_cover_range
2406（https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/）minimum_group_range_disjoint|greedy|diff_array|counter
435（https://leetcode.cn/problems/non-overlapping-intervals/）maximum_disjoint_range|greedy|binary_search|dp
763（https://leetcode.cn/problems/partition-labels/）range_merge_to_disjoint
6313（https://leetcode.cn/contest/biweekly-contest-99/problems/count-ways-to-group-overlapping-ranges/）range_merge_to_disjoint|fast_power|counter
2345（https://leetcode.cn/problems/finding-the-number-of-visible-mountains/）partial_order|range_include
757（https://leetcode.cn/problems/set-intersection-size-at-least-two/）greedy|minimum_point_cover_range
2589（https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/）greedy|minimum_point_cover_range
32（https://leetcode.cn/problems/t3fKg1/）greedy|minimum_point_cover_range
100311（https://leetcode.cn/problems/count-days-without-meetings）range_merge_to_disjoint

=====================================LuoGu======================================
P2082（https://www.luogu.com.cn/problem/P2082）range_merge_to_disjoint
P2434（https://www.luogu.com.cn/problem/P2434）range_merge_to_disjoint
P2970（https://www.luogu.com.cn/problem/P2970）maximum_disjoint_range|greedy|binary_search|dp
P6123（https://www.luogu.com.cn/problem/P6123）range_merge_to_disjoint
P2684（https://www.luogu.com.cn/problem/P2684）minimum_range_cover
P1233（https://www.luogu.com.cn/problem/P1233）partial_order|lis|range_include
P1496（https://www.luogu.com.cn/problem/P1496）range_merge_to_disjoint
P1668（https://www.luogu.com.cn/problem/P1668）minimum_range_cover
P2887（https://www.luogu.com.cn/problem/P2887）maximum_point_cover_range
P3661（https://www.luogu.com.cn/problem/P3661）greedy
P3737（https://www.luogu.com.cn/problem/P3737）greedy|range_cover
P5199（https://www.luogu.com.cn/problem/P5199）greedy|range_include
P1868（https://www.luogu.com.cn/problem/P1868）liner_dp|binary_search|maximum_disjoint_range
P2439（https://www.luogu.com.cn/problem/P2439）liner_dp|binary_search|maximum_disjoint_range
P1325（https://www.luogu.com.cn/problem/P1325）sort|greedy|minimum_range_cover

===================================CodeForces===================================
827A（https://codeforces.com/problemset/problem/827/A）range_merge_to_disjoint|greedy
652D（https://codeforces.com/problemset/problem/652/D）partial_order|range_include
1426D（https://codeforces.com/problemset/problem/1426/D）greedy|minimum_point_cover_range
1102E（https://codeforces.com/contest/1102/problem/E）range_merge_to_disjoint
1141F2（https://codeforces.com/contest/1141/problem/F2）prefix_sum|brute_force|maximum_disjoint_range

=====================================AcWing=====================================
112（https://www.acwing.com/problem/content/114/）greedy
4421（https://www.acwing.com/problem/content/4424/）minimum_range_cover

=====================================AtCoder=====================================
ABC256D（https://atcoder.jp/contests/abc256/tasks/abc256_d）range_merge_to_disjoint|classical
ABC225E（https://atcoder.jp/contests/abc225/tasks/abc225_e）greedy|geometry|brain_teaser|maximum_disjoint_range|custom_sort|classical

"""
import bisect
from collections import defaultdict, deque
from functools import cmp_to_key
from typing import List

from src.basis.range.template import Range
from src.data_structure.sorted_list.template import SortedList
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1496(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1496
        tag: range_merge_to_disjoint
        """
        n = ac.read_int()
        lst = []
        for _ in range(n):
            a, b = [int(w) for w in input().strip().split() if w]
            lst.append([a, b])
        ans = sum(b - a for a, b in Range().range_merge_to_disjoint(lst))
        ac.st(ans)
        return

    @staticmethod
    def lc_45(nums):
        """
        url: https://leetcode.cn/problems/jump-game-ii/
        tag: minimum_range_cover
        """
        n = len(nums)
        lst = [[i, min(n - 1, i + nums[i])] for i in range(n)]
        if n == 1:
            return 0
        return Range().minimum_range_cover(0, n - 1, lst)

    @staticmethod
    def lc_1326_1(n, ranges):
        """
        url: https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/
        tag: range_merge_to_disjoint
        """
        m = n + 1
        lst = []
        for i in range(m):
            lst.append([max(i - ranges[i], 0), i + ranges[i]])
        return Range().minimum_range_cover(0, n, lst, True)

    @staticmethod
    def lc_1326_2(n: int, ranges: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/
        tag: range_merge_to_disjoint
        """
        lst = []
        for i, r in enumerate(ranges):
            a, b = i - r, i + r
            a = a if a > 0 else 0
            b = b if b < n else n
            lst.append([a, b])
        return Range().minimum_interval_coverage(lst, n, True)

    @staticmethod
    def lc_1024_1(clips, time) -> int:
        """
        url: https://leetcode.cn/problems/video-stitching/
        tag: minimum_range_cover
        """
        return Range().minimum_range_cover(0, time, clips)

    @staticmethod
    def lc_1024_2(clips: List[List[int]], time: int) -> int:
        """
        url: https://leetcode.cn/problems/video-stitching/
        tag: minimum_range_cover
        """
        return Range().minimum_interval_coverage(clips, time, True)

    @staticmethod
    def lg_p2684(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2684
        tag: minimum_range_cover
        """
        n, t = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        ac.st(Range().minimum_range_cover(1, t, nums))
        return

    @staticmethod
    def lc_435(intervals):
        """
        url: https://leetcode.cn/problems/non-overlapping-intervals/
        tag: maximum_disjoint_range|greedy|binary_search|dp|classical
        """
        n = len(intervals)
        return n - Range().maximum_disjoint_range(intervals)

    @staticmethod
    def lc_763(s: str) -> List[int]:
        """
        url: https://leetcode.cn/problems/partition-labels/
        tag: range_merge_to_disjoint
        """
        dct = defaultdict(list)
        for i, w in enumerate(s):
            if len(dct[w]) >= 2:
                dct[w].pop()
            dct[w].append(i)
        lst = []
        for w in dct:
            lst.append([dct[w][0], dct[w][-1]])
        ans = Range().range_merge_to_disjoint(lst)
        return [y - x + 1 for x, y in ans]

    @staticmethod
    def lc_6313(ranges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges/
        tag: range_merge_to_disjoint|fast_power|counter
        """
        cnt = len(Range().range_merge_to_disjoint(ranges))
        mod = 10 ** 9 + 7
        return pow(2, cnt, mod)

    @staticmethod
    def cf_1102e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1102/problem/E
        tag: range_merge_to_disjoint
        """
        mod = 998244353
        n = ac.read_int()
        nums = ac.read_list_ints()
        dct = defaultdict(list)
        for i in range(n):
            dct[nums[i]].append(i)
        lst = [[dct[num][0], dct[num][-1]] for num in dct]
        ans = len(Range().range_merge_to_disjoint(lst))
        ac.st(pow(2, ans - 1, mod))
        return

    @staticmethod
    def cf_1426d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1426/D
        tag: greedy|minimum_point_cover_range|prefix_sum_hash
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ans = pre = 0
        dct = {pre}
        for num in nums:
            if pre + num in dct:
                ans += 1
                pre = num
                dct = {0, pre}
            else:
                pre += num
                dct.add(pre)
        ac.st(ans)
        return

    @staticmethod
    def ac_112(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/114/
        tag: greedy|range|rever_thinking|minimum_point_cover_range
        """
        n, d = ac.read_list_ints()
        lst = [ac.read_list_ints() for _ in range(n)]
        if any(abs(y) > d for _, y in lst):
            ac.st(-1)
            return
        for i in range(n):
            x, y = lst[i]
            r = (d * d - y * y) ** 0.5
            lst[i] = [x - r, x + r]
        ac.st(Range().minimum_point_cover_range(lst))
        return

    @staticmethod
    def lg_p1668(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1668
        tag: minimum_range_cover|classical
        """
        n, t = ac.read_list_ints()
        lst = [ac.read_list_ints() for _ in range(n)]
        ans = Range().minimum_range_cover(1, t, lst, False)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1668_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1668
        tag: minimum_range_cover
        """
        n, t = ac.read_list_ints()
        t -= 1
        lst = [ac.read_list_ints_minus_one() for _ in range(n)]
        ans = Range().minimum_range_cover(0, t, lst, False)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2887(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2887
        tag: maximum_point_cover_range|greedy|sorted_list|classical
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[1])
        pos = [ac.read_list_ints() for _ in range(m)]
        lst = SortedList([(x, c) for x, c in pos])
        ans = 0
        for floor, ceil in nums:
            i = lst.bisect_left((floor, 0))
            if 0 <= i < len(lst) and floor <= lst[i][0] <= ceil:
                x, c = lst.pop(i)
                ans += 1
                if c - 1:
                    lst.add((x, c - 1))
        ac.st(ans)
        return

    @staticmethod
    def lg_p3661(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3661
        tag: greedy|maximum_point_cover_range|classical
        """
        n, m = ac.read_list_ints()
        lst = SortedList([ac.read_int() for _ in range(n)])
        nums = [ac.read_list_ints() for _ in range(m)]
        nums.sort(key=lambda it: it[1])
        ans = 0
        for a, b in nums:
            i = lst.bisect_left(a)
            if 0 <= i < len(lst) and a <= lst[i] <= b:
                ans += 1
                lst.pop(i)
        ac.st(ans)
        return

    @staticmethod
    def lg_p3737(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3737
        tag: greedy|range|rever_thinking|minimum_point_cover_range
        """
        n, r = ac.read_list_ints()
        lst = []
        for i in range(n):
            x, y = ac.read_list_ints()
            if r * r < y * y:
                ac.st(-1)
                return
            d = (r * r - y * y) ** 0.5
            lst.append([x - d, x + d])
        ac.st(Range().minimum_point_cover_range(lst))
        return

    @staticmethod
    def lg_p5199(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5199
        tag: greedy|range_include|classical|partial_order
        """
        n = ac.read_int()
        nums = []
        for _ in range(n):
            x, y = ac.read_list_ints()
            nums.append([x - y, x + y])
        nums.sort(key=lambda it: [it[0], -it[1]])
        ans = 0
        pre = -math.inf
        for a, b in nums:
            if b > pre:
                ans += 1
                pre = b
        ac.st(ans)
        return

    @staticmethod
    def lc_1520(s: str) -> List[str]:
        """
        url: https://leetcode.cn/problems/maximum-number-of-non-overlapping-substrings/
        tag: maximum_disjoint_range
        """
        ind = defaultdict(deque)
        for i, w in enumerate(s):
            ind[w].append(i)

        lst = []
        for w in ind:
            x, y = ind[w][0], ind[w][-1]
            while True:
                x_pre, y_pre = x, y
                for v in ind:
                    i = bisect.bisect_right(ind[v], x)
                    j = bisect.bisect_left(ind[v], y) - 1
                    if 0 <= i <= j < len(ind[v]):
                        if ind[v][0] < x:
                            x = ind[v][0]
                        if ind[v][-1] > y:
                            y = ind[v][-1]
                if x == x_pre and y == y_pre:
                    break
            ind[w].appendleft(x)
            ind[w].append(y)
            lst.append([x, y])

        lst.sort(key=lambda ls: ls[1])
        ans = []
        for x, y in lst:
            if not ans or x > ans[-1][1]:
                ans.append([x, y])
        return [s[i: j + 1] for i, j in ans]

    @staticmethod
    def ac_4421(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4424/
        tag: minimum_range_cover
        """
        n, r = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = []
        for i in range(n):
            if nums[i]:
                a, b = i - r + 1, i + r - 1
                a = max(a, 0)
                lst.append([a, b])
        ans = Range().minimum_range_cover(0, n - 1, lst, False)
        ac.st(ans)
        return

    @staticmethod
    def abc_256d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc256/tasks/abc256_d
        tag: range_merge_to_disjoint|classical
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = Range().range_merge_to_disjoint(nums)
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def abc_225e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc225/tasks/abc225_e
        tag: greedy|geometry|brain_teaser|maximum_disjoint_range|custom_sort|classical
        """
        n = ac.read_int()
        points = [ac.read_list_ints() for _ in range(n)]
        line = []
        for x, y in points:
            if y == 1:
                low = (1, 0)
            else:
                low = (x, y - 1)
            if x == 1:
                high = (1, math.inf)
            else:
                high = (x - 1, y)
            line.append([low, high])

        def compare_(xx, yy):
            if xx[1][1] * yy[1][0] < yy[1][1] * xx[1][0]:
                return -1
            return 1

        line.sort(key=cmp_to_key(compare_))

        ans = 0
        pre = (1, 0)
        for low, high in line:
            if low[1] * pre[0] >= low[0] * pre[1]:
                ans += 1
                pre = high
        ac.st(ans)
        return
"""
Algorithm：divide_and_conquer|recursion|n-tree|pre_order|mid_order|post_order|iteration
Description：recursion|iteration

====================================LeetCode====================================
1545（https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/）recursion|implemention
894（https://leetcode.cn/problems/all-possible-full-binary-trees/）catalan_num|recursion|implemention
880（https://leetcode.cn/problems/decoded-string-at-index/）recursion|implemention
932（https://leetcode.cn/problems/beautiful-array/description/）recursion|divide_and_conquer|construction
889（https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/）recursion|divide_and_conquer|construction
1028（https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/description/）pre_order|recursion|construction|2-tree
100447（https://leetcode.com/problems/find-the-k-th-character-in-string-game-ii/）recursion|implemention|data_range|reverse_order

=====================================LuoGu======================================
P1911（https://www.luogu.com.cn/problem/P1911）4-tree|recursion|matrix
P5461（https://www.luogu.com.cn/problem/P5461）recursion|4-tree|matrix
P5551（https://www.luogu.com.cn/problem/P5551）pre_order|2-tree|recursion
P5626（https://www.luogu.com.cn/problem/P5626）divide_and_conquer|dp|merge_sort
P2907（https://www.luogu.com.cn/problem/P2907）recursion|implemention
P7673（https://www.luogu.com.cn/problem/P7673）mid_order|recursion|2-tree
P1228（https://www.luogu.com.cn/problem/P1228）4-tree|divide_and_conquer|recursion|matrix
P1185（https://www.luogu.com.cn/problem/P1185）2-tree|recursion
P2101（https://www.luogu.com.cn/problem/P2101）divide_and_conquer|greedy|classical
P5551（https://www.luogu.com.cn/problem/P5551）recursion

===================================CodeForces===================================
448C（https://codeforces.com/contest/448/problem/C）greedy|recursion|dp
1811D（https://codeforces.com/contest/1811/problem/D）recursion|fibonacci
559B（https://codeforces.com/problemset/problem/559/B）divide_and_conquer|implemention|string_hash
1400E（https://codeforces.com/problemset/problem/1400/E）divide_and_conquer|greedy|classical

===================================AcWing===================================
98（https://www.acwing.com/problem/content/100/）4-tree|recursion|matrix_rotate
93（https://www.acwing.com/problem/content/95/）recursion|comb|iteration
118（https://www.acwing.com/problem/content/120/）recursion

===================================AtCoder===================================
ABC350F（https://atcoder.jp/contests/abc350/tasks/abc350_f）implemention|divide_and_conquer|recursion|classical

"""
from functools import lru_cache
from itertools import combinations
from typing import Optional, List

from src.basis.tree_node.template import TreeNode
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_880(s: str, k: int) -> str:
        """
        url: https://leetcode.cn/problems/decoded-string-at-index/
        tag: recursion|implemention|iteration|classical
        """
        ans = ""
        while not ans:
            n = len(s)
            cur = 0
            for i in range(n):
                if s[i].isnumeric():
                    d = int(s[i])
                    if cur * d >= k:
                        s, k = s[:i], k % cur + cur * int(k % cur == 0)
                        break
                    cur *= d
                else:
                    if cur + 1 == k:
                        ans = s[i]
                        break
                    cur += 1
        return ans

    @staticmethod
    def lc_889(preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        """
        url: https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
        tag: recursion|divide_and_conquer|construction
        """
        tree = dict()
        m, n = len(preorder), len(postorder)
        stack = [(0, m - 1, 0, n - 1, 1)]
        ind = {val: i for i, val in enumerate(postorder)}
        while stack:
            i1, j1, i2, j2, i = stack.pop()
            if i >= 0:
                if i1 > j1:
                    continue
                root = preorder[i1]
                tree[i] = TreeNode(root)
                if i1 == j1:
                    continue
                stack.append((i1, j1, i2, j2, ~i))
                val = preorder[i1 + 1]
                x = ind[val]
                left_cnt = x - i2 + 1
                stack.append((i1 + 1, left_cnt + i1, i2, left_cnt + i2 - 1, i << 1))
                stack.append((left_cnt + i1 + 1, j1, left_cnt + i2, j2, (i << 1) | 1))
            else:
                i = ~i
                tree[i].left = tree.get(i << 1, None)
                tree[i].right = tree.get((i << 1) | 1, None)
        return tree[1]

    @lru_cache(None)
    def lc_894(self, n: int) -> List[Optional[TreeNode]]:
        """
        url: https://leetcode.cn/problems/all-possible-full-binary-trees/
        tag: catalan_number|recursion|implemention|classical|iteration
        """
        dp = [[] for _ in range(21)]
        dp[0] = []
        dp[1] = [TreeNode(0)]
        for i in range(2, 21):
            if i % 2 == 0:
                continue
            for j in range(1, i - 1):
                for left in dp[j]:
                    for right in dp[i - 1 - j]:
                        node = TreeNode(0)
                        node.left = left
                        node.right = right
                        dp[i].append(node)
        return dp[n]

    @staticmethod
    def lc_932(n: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/beautiful-array/description/
        tag: recursion|divide_and_conquer|construction
        """
        m = 1000
        dp = [[], [1]]
        for i in range(2, m + 1):
            left = (i + 1) // 2
            right = i - left
            dp.append([2 * x - 1 for x in dp[left]] + [2 * x for x in dp[right]])
        return dp[n]

    @staticmethod
    def lc_1028(traversal: str) -> Optional[TreeNode]:
        """
        url: https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/description/
        tag: pre_order|recursion|construction|2-tree
        """
        tree = dict()
        stack = [(traversal, 1, 1)]
        while stack:
            s, i, d = stack.pop()
            if i >= 0:
                if s.isnumeric():
                    tree[i] = TreeNode(int(s))
                    continue
                stack.append(("", ~i, d))
                sp = "-" * d
                m = len(s)
                lst = []
                for j in range(m - d - 1):
                    if s[j].isnumeric() and s[j + d + 1].isnumeric() and s[j + 1:j + d + 1] == sp:
                        lst.append(j + 1)
                tree[i] = TreeNode(int(s[:lst[0]]))
                if len(lst) == 1:
                    stack.append((s[lst[0] + d:], i << 1, d + 1))
                else:
                    stack.append((s[lst[0] + d:lst[1]], i << 1, d + 1))
                    stack.append((s[lst[1] + d:], (i << 1) | 1, d + 1))
            else:
                i = ~i
                tree[i].left = tree.get(i << 1, None)
                tree[i].right = tree.get((i << 1) | 1, None)
        return tree[1]

    @staticmethod
    def lc_1545(n: int, k: int) -> str:
        """
        url: https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/
        tag: recursion|implemention
        """
        ans = ""
        flag = 0
        while not ans:
            if n == 1:
                ans = "0"[k - 1]
            elif n == 2:
                ans = "011"[k - 1]
            else:
                length = (1 << n) - 1
                if k == (length + 1) // 2:
                    ans = "1"
                elif k < (length + 1) // 2:
                    n -= 1
                else:
                    flag = 1 - flag
                    n -= 1
                    k = length // 2 - (k - length // 2) + 1
        return ans if not flag else str(1 - int(ans))

    @staticmethod
    def lg_p1911(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1911
        tag: 4-tree|recursion|matrix
        """
        n, x, y = ac.read_list_ints()
        ans = [[-1] * (1 << n) for _ in range(1 << n)]
        x -= 1
        y -= 1
        ans[x][y] = 0
        ind = 1
        stack = [[0, 0, (1 << n) - 1, (1 << n) - 1, x, y]]
        while stack:
            x1, y1, x2, y2, x, y = stack.pop()
            if x1 == x2 - 1:
                for i in range(x1, x2 + 1):
                    for j in range(y1, y2 + 1):
                        if ans[i][j] == -1:
                            ans[i][j] = ind
                ind += 1
                continue
            x0 = x1 + (x2 - x1) // 2
            y0 = y1 + (y2 - y1) // 2
            rec = [[x1, y1, x0, y0], [x1, y0 + 1, x0, y2], [x0 + 1, y1, x2, y0], [x0 + 1, y0 + 1, x2, y2]]
            center = [[x0, y0], [x0, y0 + 1], [x0 + 1, y0], [x0 + 1, y0 + 1]]
            for i in range(4):
                if rec[i][0] <= x <= rec[i][2] and rec[i][1] <= y <= rec[i][3]:
                    stack.append(rec[i] + [x, y])
                else:
                    ans[center[i][0]][center[i][1]] = ind
                    stack.append(rec[i] + center[i])
            ind += 1
        dct = dict()
        ind = 1
        for i in range(1 << n):
            for j in range(1 << n):
                x = ans[i][j]
                if not x:
                    continue
                if x not in dct:
                    dct[x] = ind
                    ind += 1
                ans[i][j] = dct[x]
        for ls in ans:
            ac.lst(ls)
        return

    @staticmethod
    def cf_448c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/448/problem/C
        tag: greedy|recursion|dp|implemention
        """
        ac.read_int()
        nums = ac.read_list_ints()

        @ac.bootstrap
        def dfs(arr):
            m = len(arr)
            low = min(arr)
            cur = [num - low for num in arr]
            ans = low
            i = 0
            while i < m:
                if cur[i] == 0:
                    i += 1
                    continue
                j = i
                while j < m and cur[j] > 0:
                    j += 1
                ans += yield dfs(cur[i: j])
                i = j
            yield min(ans, m)

        ac.st(dfs(nums))
        return

    @staticmethod
    def ac_98(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/100/
        tag: 4-tree|recursion|matrix_rotate
        """
        for _ in range(ac.read_int()):
            n, a, b = ac.read_list_ints()
            a -= 1
            b -= 1

            def check(nn, mm):
                stack = [[nn, mm]]
                x = y = -1
                while stack:
                    if stack[-1][0] == 0:
                        x = y = 0
                        stack.pop()
                        continue
                    else:
                        nn, mm = stack[-1]
                        cc = 2 ** (2 * nn - 2)
                        if x != -1:
                            stack.pop()
                            z = mm // cc
                            length = 2 ** (nn - 1)
                            if z == 0:
                                x, y = y, x
                            elif z == 1:
                                x, y = x, y + length
                            elif z == 2:
                                x, y = x + length, y + length
                            else:
                                x, y = 2 * length - y - 1, length - x - 1
                        else:
                            stack.append([nn - 1, mm % cc])
                return x, y

            x1, y1 = check(n, a)
            x2, y2 = check(n, b)
            ans = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 * 10
            ans = int(ans) + int(ans - int(ans) >= 0.5)
            ac.st(ans)
        return

    @staticmethod
    def ac_93_1(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/95/
        tag: recursion|comb|iteration|back_trace
        """
        n, m = ac.read_list_ints()

        def dfs(i):
            if len(pre) == m:
                ac.lst(pre)
                return
            if i == n:
                return

            dfs(i + 1)
            pre.append(i + 1)
            dfs(i + 1)
            pre.pop()
            return

        pre = []
        dfs(0)
        return

    @staticmethod
    def ac_93_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/95/
        tag: recursion|comb|iteration
        """
        n, m = ac.read_list_ints()

        pre = []
        stack = [[0, 0]]
        while stack:
            i, state = stack.pop()
            if i >= 0:
                stack.append([~i, state])
                if len(pre) == m:
                    ac.lst(pre)
                    continue
                if i == n:
                    continue
                stack.append([i + 1, 0])
                pre.append(i + 1)
                stack.append([i + 1, 1])
            else:
                if state:
                    pre.pop()
        return

    @staticmethod
    def ac_93_3(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/95/
        tag: recursion|comb|iteration
        """
        n, m = ac.read_list_ints()
        for item in combinations(list(range(1, n + 1)), m):
            ac.lst(list(item))
        return

    @staticmethod
    def ac_118(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/120/
        tag: recursion
        """
        dp = [[["X"]]]
        for m in range(2, 8):
            n = 3 ** (m - 1)
            cur = [[" "] * n for _ in range(n)]
            k = 3 ** (m - 2)
            start = [[0, 0], [0, 2 * k], [k, k], [2 * k, 0], [2 * k, 2 * k]]
            for x, y in start:
                for i in range(x, x + k):
                    for j in range(y, y + k):
                        cur[i][j] = dp[-1][i - x][j - y]
            dp.append([ls[:] for ls in cur])
        while True:
            x = ac.read_int()
            if x == -1:
                break
            for ls in dp[x - 1]:
                ac.st("".join(ls))
            ac.st("-")
        return

    @staticmethod
    def abc_350f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc350/tasks/abc350_f
        tag: implemention|divide_and_conquer|recursion|classical
        """
        s = ac.read_str()
        n = len(s)
        right = [-1] * n
        stack = []
        for i in range(n):
            if s[i] == "(":
                stack.append(i)
            elif s[i] == ")":
                right[stack.pop()] = i

        pre = ac.accumulate([int(w not in "()") for w in s])
        ans = [""] * pre[-1]
        dct = dict()
        for i in range(26):
            dct[chr(ord("a") + i)] = chr(ord("A") + i)
            dct[chr(ord("A") + i)] = chr(ord("a") + i)
        stack = [(0, n - 1, 0, pre[-1] - 1, 0)]
        while stack:
            a, b, ll, rr, state = stack.pop()
            if right[a] == -1:
                if not state:
                    ans[ll] = s[a]
                    ll += 1
                else:
                    ans[rr] = dct[s[a]]
                    rr -= 1
                if a + 1 <= b and pre[b + 1] - pre[a + 1]:
                    stack.append((a + 1, b, ll, rr, state))
            else:
                bb = right[a]
                if a + 1 <= bb - 1:
                    cnt = pre[bb] - pre[a + 1]
                    if cnt:
                        if not state:
                            stack.append((a + 1, bb - 1, ll, ll + cnt - 1, state ^ 1))
                        else:
                            stack.append((a + 1, bb - 1, rr - cnt + 1, rr, state ^ 1))

                if bb + 1 <= b:
                    cnt = pre[b + 1] - pre[bb + 1]
                    if cnt:
                        if not state:
                            stack.append((bb + 1, b, rr - cnt + 1, rr, state))
                        else:
                            stack.append((bb + 1, b, ll, ll + cnt - 1, state))
        ac.st("".join(ans))
        return

    @staticmethod
    def cf_559b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/559/B
        tag: divide_and_conquer|implemention|string_hash
        """

        a = ac.read_str()
        b = ac.read_str()

        def check(s):
            def dfs(i, j):
                if (j - i + 1) % 2:
                    return s[i:j + 1]

                mid = i + (j - i + 1) // 2 - 1
                s1 = dfs(i, mid)
                s2 = dfs(mid + 1, j)
                return s1 + s2 if s1 < s2 else s2 + s1

            return dfs(0, len(s) - 1)

        ans = check(a) == check(b)
        ac.st("YES" if ans else "NO")
        return

    @staticmethod
    def lg_p2101(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2101
        tag: divide_and_conquer|greedy|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        def dfs(i, j):
            cur = j-i+1
            low = i
            for k in range(i, j + 1):
                if nums[k] < nums[low]:
                    low = k
            res = nums[low]
            for k in range(i, j + 1):
                nums[k] -= res
            cnt = 0
            for k in range(i, j + 1):
                if nums[k]:
                    cnt += 1
                else:
                    if cnt:
                        res += dfs(k - cnt, k - 1)
                    cnt = 0
            if cnt:
                res += dfs(j - cnt + 1, j)
            return min(res, cur)

        ans = dfs(0, n - 1)
        ac.st(ans)
        return

    @staticmethod
    def cf_1400e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1400/E
        tag: divide_and_conquer|greedy|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()  # MLE
        dp = [math.inf] * n * n

        sub = [[] for _ in range(n * n)]
        stack = [n - 1]
        while stack:
            val = stack.pop()
            if val >= 0:
                stack.append(~val)
                i, j = val // n, val % n
                low = i
                for k in range(i, j + 1):
                    if nums[k] < nums[low]:
                        low = k
                res = nums[low]
                for k in range(i, j + 1):
                    nums[k] -= res
                dp[val] = res

                cnt = 0
                for k in range(i, j + 1):
                    if nums[k]:
                        cnt += 1
                    else:
                        if cnt:
                            stack.append((k - cnt) * n + k - 1)
                            sub[val].append((k - cnt) * n + k - 1)
                        cnt = 0
                if cnt:
                    stack.append((j - cnt + 1) * n + j)
                    sub[val].append((j - cnt + 1) * n + j)
            else:
                val = ~val
                i, j = val // n, val % n
                for y in sub[val]:
                    dp[val] += dp[y]
                dp[val] = min(dp[val], j - i + 1)
        ans = dp[n - 1]
        ac.st(ans)
        return
"""
Algorithm：serialization|deserialization
Description：2-tree|n-tree|tree_hash|tree_to_str|tree_serialization|tree_deserialization

====================================LeetCode====================================
428（https://leetcode.cn/problems/serialize-and-deserialize-n-ary-tree/）n-tree|tree_serialization
297（https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/）tree_deserialization
449（https://leetcode.cn/problems/serialize-and-deserialize-bst/）tree_deserialization

=====================================LuoGu======================================
xx（xxx）xxx

===================================CodeForces===================================
xx（xxx）xxx

"""


class Solution:
    def __int__(self):
        return
"""

Algorithm：stack|rbs|regular_bracket_subsequence|deque
Description：implemention|monotonic_stack|maximum_stack|minimum_stack

====================================LeetCode====================================
2197（https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/）math|stack|implemention
394（https://leetcode.cn/problems/decode-string/）decode|stack
1096（https://leetcode.cn/problems/brace-expansion-ii/）stack|decode
2116（https://leetcode.cn/problems/check-if-a-parentheses-string-can-be-valid/）stack|greedy|bracket
857（https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/）greedy|sort|brute_force|heapq
2542（https://leetcode.cn/problems/maximum-subsequence-score/）sort|brute_force|heapq
2813（https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/）brain_teaser|sort|brute_force|function
2462（https://leetcode.cn/problems/total-cost-to-hire-k-workers/）heapq|greedy|implemention
1705（https://leetcode.cn/problems/maximum-number-of-eaten-apples/）heapq|greedy|implemention
1750（https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/description/）stack|implemention
2296（https://leetcode.cn/problems/design-a-text-editor/description/）stack|implemention

=====================================LuoGu======================================
P1944（https://www.luogu.com.cn/problem/P1944）regular_bracket_subsequence|longest
P2201（https://www.luogu.com.cn/problem/P2201）stack|implemention|pointer|prefix_sum|max_prefix_sum
P4387（https://www.luogu.com.cn/problem/P4387）implemention|stack|stack|deque
P7674（https://www.luogu.com.cn/problem/P7674）stack|implemention
P3719（https://www.luogu.com.cn/problem/P3719）string|stack
P1974（https://www.luogu.com.cn/problem/P1974）greedy|deque|implemention
P3551（https://www.luogu.com.cn/problem/P3551）stack|counter|pointer
P3719（https://www.luogu.com.cn/problem/P3719）stack|implemention
P2776（https://www.luogu.com.cn/problem/P2776）stack|implemention

===================================CodeForces===================================
5C（https://codeforces.com/problemset/problem/5/C）regular_bracket_subsequence|counter|longest
1095E（https://codeforces.com/problemset/problem/1095/E）regular_bracket|counter|prefix_suffix|brute_force
343B（https://codeforces.com/problemset/problem/343/B）observation

====================================AtCoder=====================================
ARC074B（https://atcoder.jp/contests/abc062/tasks/arc074_b）heapq|prefix_suffix
ABC283B（https://atcoder.jp/contests/abc283/tasks/abc283_d）stack
ABC243D（https://atcoder.jp/contests/abc243/tasks/abc243_d）data_range|big_number|stack|implemention|binary_tree|classical

=====================================AcWing=====================================
128（https://www.acwing.com/problem/content/130/）heapq|stack|implemention
129（https://www.acwing.com/problem/content/131/）catalan_number|stack|implemention
132（https://www.acwing.com/problem/content/134/）deque
4865（https://www.acwing.com/problem/content/4868/）stack|implemention
5136（https://www.acwing.com/problem/content/description/5139/）stack|reverse_order|implemention

"""
import heapq
import math
from collections import defaultdict, deque
from heapq import heappush, heappop
from itertools import permutations
from typing import List

from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_2542(nums1: List[int], nums2: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-subsequence-score/
        tag: sort|brute_force|heapq
        """
        n = len(nums1)
        ind = list(range(n))
        ind.sort(key=lambda it: -nums2[it])
        ans = 0
        stack = []
        pre = 0
        for i in ind:
            heapq.heappush(stack, nums1[i])
            pre += nums1[i]
            if len(stack) > k:
                pre -= heapq.heappop(stack)
            if len(stack) == k:
                if pre * nums2[i] > ans:
                    ans = pre * nums2[i]
        return ans

    @staticmethod
    def lc_2462(costs: List[int], k: int, candidates: int) -> int:
        """
        url: https://leetcode.cn/problems/total-cost-to-hire-k-workers/
        tag: heapq|greedy|implemention
        """
        n = len(costs)
        visit = [0] * n
        pre = [[costs[i], i] for i in range(candidates)]
        post = [[costs[i], i] for i in range(n - candidates, n)]
        heapq.heapify(pre)
        heapq.heapify(post)
        pre_ind = candidates
        post_ind = n - candidates - 1
        ans = 0
        for _ in range(k):
            while pre and visit[pre[0][1]]:
                heapq.heappop(pre)
            while len(pre) < candidates and pre_ind < n:
                if not visit[pre_ind]:
                    heapq.heappush(pre, [costs[pre_ind], pre_ind])
                pre_ind += 1

            while post and visit[post[0][1]]:
                heapq.heappop(post)
            while len(post) < candidates and post_ind >= 0:
                if not visit[post_ind]:
                    heapq.heappush(post, [costs[post_ind], post_ind])
                post_ind -= 1

            if pre and post:
                if pre[0][0] <= post[0][0]:
                    c, i = heapq.heappop(pre)
                else:
                    c, i = heapq.heappop(post)
            elif pre:
                c, i = heapq.heappop(pre)
            else:
                c, i = heapq.heappop(post)
            visit[i] = 1
            ans += c
        return ans

    @staticmethod
    def lc_2813(items: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/
        tag: brain_teaser|sort|brute_force|function|greedy|classical
        """
        items.sort(reverse=True)
        ans = cnt = pre = tp = 0
        dct = defaultdict(list)
        stack = []
        for p, c in items:
            if cnt == k:
                while stack and len(dct[stack[-1]]) == 1:
                    stack.pop()
                if not stack:
                    break
                pre -= dct[stack.pop()].pop()
            else:
                cnt += 1
            pre += p
            dct[c].append(p)
            if len(dct[c]) == 1:
                tp += 1
            stack.append(c)
            if pre + tp * tp > ans:
                ans = pre + tp * tp
        return ans

    @staticmethod
    def lc_1705(apples: List[int], days: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-eaten-apples/
        tag: heapq|greedy|implemention
        """
        n = len(apples)
        ans = i = 0
        stack = []
        while i < n or stack:
            if i < n and apples[i]:
                heappush(stack, [i + days[i] - 1, apples[i]])
            while stack and (stack[0][0] < i or not stack[0][1]):
                heappop(stack)
            if stack:
                stack[0][1] -= 1
                ans += 1
            i += 1
        return ans

    @staticmethod
    def lc_2197(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/
        tag: math|stack|implemention
        """
        stack = []
        for num in nums:
            stack.append(num)
            while len(stack) >= 2:
                g = math.gcd(stack[-1], stack[-2])
                if g > 1:
                    stack[-2] = stack[-1] * stack[-2] // g
                    stack.pop()
                else:
                    break
        return stack

    @staticmethod
    def lc_857(quality: List[int], wage: List[int], k: int) -> float:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/
        tag: greedy|sort|brute_force|heapq
        """
        n = len(quality)
        ind = list(range(n))
        ind.sort(key=lambda it: wage[it] / quality[it])
        ans = math.inf
        pre = 0
        stack = []
        for i in ind:
            heapq.heappush(stack, -quality[i])
            pre += quality[i]
            if len(stack) > k:
                pre += heapq.heappop(stack)
            if len(stack) == k:
                cur = pre * wage[i] / quality[i]
                if cur < ans:
                    ans = cur
        return ans

    @staticmethod
    def cf_1095e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1095/E
        tag: regular_bracket|counter|prefix_suffix
        """
        n = ac.read_int()
        s = ac.read_str()
        post = [math.inf] * (n + 1)
        post[-1] = 0
        x = 0
        for i in range(n - 1, -1, -1):
            if s[i] == ")":
                x += 1
            else:
                x -= 1
            if x < 0:
                break
            post[i] = x

        ans = x = 0
        for i in range(n):
            if s[i] == "(" and x >= 1 and x - 1 == post[i + 1]:
                ans += 1
            elif s[i] == ")" and x >= 0 and x + 1 == post[i + 1]:
                ans += 1
            if s[i] == "(":
                x += 1
            else:
                x -= 1
            if x < 0:
                break
        ac.st(ans)
        return

    @staticmethod
    def arc_074b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc062/tasks/arc074_b
        tag: heapq|prefix_suffix|brute_force
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [-math.inf] * (3 * n + 1)
        stack = []
        s = 0
        for i in range(3 * n):
            s += nums[i]
            heappush(stack, nums[i])
            if len(stack) > n:
                s -= heappop(stack)
            if i >= n - 1:
                pre[i] = s

        post = [-math.inf] * (3 * n + 1)
        stack = []
        s = 0
        for i in range(3 * n - 1, -1, -1):
            s -= nums[i]
            heappush(stack, -nums[i])
            if len(stack) > n:
                s -= heappop(stack)
            if 3 * n - i >= n:
                post[i] = s
        ans = max(pre[i] + post[i + 1] for i in range(n - 1, 2 * n + 1))
        ac.st(ans)
        return

    @staticmethod
    def cf_5c(s):
        """
        url: https://codeforces.com/problemset/problem/5/C
        tag: regular_bracket_subsequence|counter|longest
        """
        stack = [["", -1]]
        ans = cnt = 0
        n = len(s)
        for i in range(n):
            if s[i] == "(":
                stack.append([s[i], i])
            else:
                if stack[-1][0] != "(":
                    stack = [["", i]]
                else:
                    stack.pop()
                    cur = i - stack[-1][1]
                    if cur > ans:
                        ans = cur
                        cnt = 1
                    elif cur == ans:
                        cnt += 1
        if not ans:
            cnt = 1
        return [ans, cnt]

    @staticmethod
    def ac_128(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/130/
        tag: heapq|stack|implemention|classical
        """
        pre = []
        post = []
        pre_sum = [0]
        pre_ceil = [-math.inf]
        for _ in range(ac.read_int()):
            lst = ac.read_list_strs()
            if lst[0] == "I":
                pre.append(int(lst[1]))
                pre_sum.append(pre_sum[-1] + int(lst[1]))
                pre_ceil.append(max(pre_ceil[-1], pre_sum[-1]))
            elif lst[0] == "D":
                if pre:
                    pre.pop()
                    pre_sum.pop()
                    pre_ceil.pop()
            elif lst[0] == "L":
                if pre:
                    post.append(pre.pop())
                    pre_sum.pop()
                    pre_ceil.pop()
            elif lst[0] == "R":
                if post:
                    x = post.pop()
                    pre.append(x)
                    pre_sum.append(pre_sum[-1] + x)
                    pre_ceil.append(max(pre_ceil[-1], pre_sum[-1]))
            else:
                ac.st(pre_ceil[int(lst[1])])
        return

    @staticmethod
    def ac_129_1(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/131/
        tag: catalan_number|stack|implemention
        """
        n = ac.read_int()
        m = min(5, n)

        pre = list(range(1, n + 1))

        def check(lst):
            lst = deque(lst)
            stack = []
            for num in pre:
                stack.append(num)
                while stack and stack[-1] == lst[0]:
                    stack.pop()
                    lst.popleft()
            return not stack

        cnt = 0
        for item in permutations(list(range(n - m + 1, n + 1)), m):
            cur = list(range(1, n - m + 1)) + list(item)
            if check(cur):
                ac.st("".join(str(x) for x in cur))
                cnt += 1
            if cnt == 20:
                break
        return

    @staticmethod
    def ac_129_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/131/
        tag: catalan_number|stack|implemention
        """
        def dfs(i):
            nonlocal cnt, post, pre
            if cnt >= 20:
                return
            if i == n:
                cnt += 1
                ac.st("".join(str(x) for x in res))
                return

            if pre:
                res.append(pre.pop())
                dfs(i + 1)
                pre.append(res.pop())

            if post:
                pre.append(post.popleft())
                dfs(i)
                post.appendleft(pre.pop())
            return

        n = ac.read_int()
        post = deque(list(range(1, n + 1)))
        res = []
        pre = []
        cnt = 0
        dfs(0)
        return

    @staticmethod
    def ac_129_3(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/131/
        tag: catalan_number|stack|implemention
        """
        n = ac.read_int()
        cnt = 0
        stack = [[[], [], 0]]
        while stack and cnt < 20:
            pre, res, ind = stack.pop()
            if len(res) == n:
                cnt += 1
                ac.st("".join(str(x) for x in res))
            else:
                if ind + 1 <= n:
                    stack.append([pre + [ind + 1], res[:], ind + 1])
                if pre:
                    stack.append([pre[:-1], res + [pre[-1]], ind])
        return

    @staticmethod
    def lg_p1974(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1974
        tag: greedy|deque|implemention
        """
        n = ac.read_int()
        stack = deque([1] * n)
        while len(stack) >= 2:
            a, b = stack.popleft(), stack.popleft()
            stack.append(a * b + 1)
        ac.st(stack[0])
        return

    @staticmethod
    def lg_p3719(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3719
        tag: stack|implemention
        """
        s = ac.read_str()
        stack = []
        for w in s:
            if w != ")":
                stack.append(w)
            else:
                pre = ""
                while stack and stack[-1] != "(":
                    w = stack.pop()
                    pre += w
                stack.pop()
                x = max(len(t) for t in pre.split("|"))
                stack.append("a" * x)

        pre = "".join(stack)
        x = max(len(t) for t in pre.split("|"))
        ac.st(x)
        return

    @staticmethod
    def ac_4865(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4868/
        tag: stack|implemention
        """
        m = ac.read_int()
        lst = ac.read_list_strs()
        n = len(lst)
        if n != m * 2 - 1:
            ac.st("Error occurred")
            return
        if m == 1:
            ac.st("int")
            return

        stack = []
        for i in range(n):
            if lst[i] == "int":
                stack.append([[i, i], "int"])
                while len(stack) >= 3 and [ls[1] for ls in stack[-3:]] == ["pair", "int", "int"]:
                    lst[stack[-1][0][1]] += ">"
                    lst[stack[-2][0][1]] += ","
                    lst[stack[-2][0][0]] = "<" + lst[stack[-2][0][0]]
                    stack[-3][0][1] = stack[-1][0][1]
                    stack[-3][1] = "int"
                    stack.pop()
                    stack.pop()
            else:
                stack.append([[i, i], "pair"])

        if len(stack) > 1:
            ac.st("Error occurred")
            return
        ac.st("".join(lst))
        return

    @staticmethod
    def ac_5136(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/5139/
        tag: stack|reverse_order|implemention|greedy
        """
        s = ac.read_str()
        n = len(s)
        ans = [0] * n
        right = 0
        post = deque()
        for i in range(n - 1, -1, -1):
            if s[i] == "#":
                post.append(i)
            elif s[i] == "(":
                if right:
                    right -= 1
                else:
                    if not post:
                        ac.st(-1)
                        return
                    ans[post[0]] += 1
            else:
                right += 1
            while len(post) >= 2 and ans[post[0]]:
                post.popleft()
        while post and ans[post[0]]:
            post.popleft()
        if post or right:
            ac.st(-1)
            return
        for i in range(n):
            if s[i] == "#":
                ac.st(ans[i])
        return

    @staticmethod
    def abc_243d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc243/tasks/abc243_d
        tag: data_range|big_number|stack|implemention|binary_tree|classical
        """
        n, x = ac.read_list_ints()
        s = ac.read_str()
        pre = []
        while x > 1:
            pre.append("L" if x % 2 == 0 else "R")
            x //= 2
        pre.reverse()
        for w in s:
            if w == "L":
                pre.append(w)
            elif w == "R":
                pre.append(w)
            else:
                pre.pop()
        for w in pre:
            if w == "L":
                x *= 2
            elif w == "R":
                x = x * 2 + 1
            else:
                x //= 2
        ac.st(x)
        return"""
Algorithm：ternary_search|TriPartPackTriPart|gradient_descent|hill_climbing
Description：used to find function extremum solutions with at most one peak or valley point in an interval

=====================================LuoGu======================================
1515（https://leetcode.cn/problems/best-position-for-a-service-centre/）tripartite_pack_tripartite|convex_function_minimum|gradient_descent|hill_climbing

=====================================LuoGu======================================
P3382（https://www.luogu.com.cn/problem/P3382）ternary_search|ceil
P1883（https://www.luogu.com.cn/problem/P1883）ternary_search|floor

===================================CodeForces===================================
939E（https://codeforces.com/problemset/problem/939/E）greedy|two_pointers|ternary_search|ceil
439D（https://codeforces.com/problemset/problem/439/D）ternary_search
1730B（https://codeforces.com/contest/1730/problem/B）ternary_search
1355E（https://codeforces.com/problemset/problem/1355/E）ternary_search|classical|greedy
1389D（https://codeforces.com/problemset/problem/1389/D）ternary_search|brute_force|implemention|greedy
1374E2（https://codeforces.com/problemset/problem/1374/E2）ternary_search|two_pointers|brute_force|classical
1999G2（https://codeforces.com/problemset/problem/1999/G2）ternary_search|interactive|classical
578C（https://codeforces.com/problemset/problem/578/C）ternary_search|linear_dp|prefix_sum|classical

====================================AtCoder=====================================
ABC130F（https://atcoder.jp/contests/abc130/tasks/abc130_f）ternary_search|floor|high_precision
ABC279D（https://atcoder.jp/contests/abc279/tasks/abc279_d）ternary_search|high_precision|classical
ABC240F（https://atcoder.jp/contests/abc240/tasks/abc240_f）implemention|ternary_search|binary_search|brute_force|classical


"""
import bisect
import math
import random
from collections import defaultdict
from decimal import Decimal
from typing import List

from src.basis.ternary_search.template import TernarySearch, TriPartPackTriPart
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_130f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc130/tasks/abc130_f
        tag: ternary_search|floor|high_precision
        """
        n = ac.read_int()
        ind = {"L": [-1, 0], "R": [1, 0], "U": [0, 1], "D": [0, -1]}
        dct_x = defaultdict(lambda: [math.inf, -math.inf])
        dct_y = defaultdict(lambda: [math.inf, -math.inf])
        for _ in range(n):
            x, y, d = ac.read_list_strs()
            x = int(x)
            y = int(y)

            a, b = dct_x[d]
            a = a if a < x else x
            b = b if b > x else x
            dct_x[d] = [a, b]

            a, b = dct_y[d]
            a = a if a < y else y
            b = b if b > y else y
            dct_y[d] = [a, b]

        lst_x = []
        for d in ind:
            if dct_x[d][0] < math.inf:
                for x in dct_x[d]:
                    lst_x.append([x, ind[d][0]])

        lst_y = []
        for d in ind:
            if dct_y[d][0] < math.inf:
                for y in dct_y[d]:
                    lst_y.append([y, ind[d][1]])

        def check(t):
            dis_x = [xx + t * aa for xx, aa in lst_x]
            dis_y = [xx + t * aa for xx, aa in lst_y]
            x_low = min(dis_x)
            x_high = max(dis_x)
            y_low = min(dis_y)
            y_high = max(dis_y)
            return (x_high - x_low) * (y_high - y_low)

        ans = TernarySearch().find_floor_value_float(check, 0, 10 ** 8, error=1e-10, high_precision=True)
        ac.st(ans)
        return

    @staticmethod
    def lg_1883(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1883
        tag: ternary_search|floor
        """
        t = ac.read_int()

        for _ in range(t):
            n = ac.read_int()
            nums = [ac.read_list_ints() for _ in range(n)]

            def fun(x):
                return max(a * x * x + b * x + c for a, b, c in nums)

            ans = TernarySearch().find_floor_value_float(fun, 0, 1000)
            ans = ac.round_5(ans * 10 ** 4)
            ans /= 10 ** 4
            ac.st("%.4f" % ans)
        return

    @staticmethod
    def lg_p3382(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3382
        tag: ternary_search|ceil
        """
        n, l, r = ac.read_list_floats()
        n = int(n)
        lst = ac.read_list_floats()
        lst.reverse()

        def check(x):
            res = lst[0]
            mul = 1
            for i in range(1, n + 1):
                mul *= x
                res += mul * lst[i]
            return res

        ans = TernarySearch().find_ceil_point_float(check, l, r)
        ac.st(ans)
        return

    @staticmethod
    def cf_439d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/439/D
        tag: ternary_search
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        a.sort()
        b.sort()

        pre_a = [0] * (n + 1)
        for i in range(n):
            pre_a[i + 1] = pre_a[i] + a[i]

        pre_b = [0] * (m + 1)
        for i in range(m):
            pre_b[i + 1] = pre_b[i] + b[i]

        floor = min(a)
        ceil = max(b)
        if floor >= ceil:
            ac.st(0)
            return

        def check(xx):
            ii = bisect.bisect_right(a, xx)
            cost = ii * xx - pre_a[ii]

            ii = bisect.bisect_left(b, xx)
            cost += pre_b[-1] - pre_b[ii] - (m - ii) * xx
            return cost

        point = int(TernarySearch().find_floor_point_float(check, floor, ceil, 1))

        ans = math.inf
        for x in [-1, 0, 1]:
            if floor <= point + x <= ceil:
                ans = min(ans, check(point + x))
        ac.st(ans)
        return

    @staticmethod
    def cf_939e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/939/E
        tag: greedy|two_pointers|ternary_search|ceil
        """
        nums = []
        pre = [0]

        def check(xx):
            return nums[-1] - (pre[xx] + nums[-1]) / (xx + 1)

        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if len(lst) == 2:
                nums.append(lst[1])
                pre.append(pre[-1] + nums[-1])
            else:
                n = len(nums)
                x = TernarySearch().find_ceil_point_int(check, 0, n - 1)
                ans = -math.inf
                for y in [x - 1, x, x + 1, x + 2]:
                    if 0 <= y <= n - 1:
                        ans = max(ans, check(y))
                ac.st(ans)
        return

    @staticmethod
    def cf_1730b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1730/problem/B
        tag: ternary_search
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            x = ac.read_list_ints()
            t = ac.read_list_ints()

            def check(x0):
                return max(t[i] + abs(x[i] - x0) for i in range(n))

            ans = TernarySearch().find_floor_point_float(check, min(x), max(x), 1e-8)
            ac.st(ans)
        return

    @staticmethod
    def lc_1515_1(stack: List[List[int]]) -> float:
        """
        url: https://leetcode.cn/problems/best-position-for-a-service-centre/
        tag: tripartite_pack_tripartite|convex_function_minimum|gradient_descent|hill_climbing
        """

        def target(x, y):
            return sum([math.sqrt((x - p[0]) ** 2 + (y - p[1]) ** 2) for p in stack])

        low_x = min([p[0] for p in stack])
        high_x = max([p[0] for p in stack])
        low_y = min([p[1] for p in stack])
        high_y = max([p[1] for p in stack])
        _, _, ans = TriPartPackTriPart().find_floor_point_float(target, low_x, high_x, low_y, high_y)
        return ans ** 2

    @staticmethod
    def lc_1515_2(positions: List[List[int]]) -> float:
        """
        url: https://leetcode.cn/problems/best-position-for-a-service-centre/
        tag: tripartite_pack_tripartite|convex_function_minimum|gradient_descent|hill_climbing
        """
        eps = 1e-10
        alpha = 1.0
        decay = 0.001
        n = len(positions)
        batch_size = n
        x = sum(pos[0] for pos in positions) / n
        y = sum(pos[1] for pos in positions) / n

        while True:
            x_pre, y_pre = x, y
            random.shuffle(positions)
            for i in range(0, n, batch_size):
                dx = dy = 0.0
                j = i + batch_size if i + batch_size < n else n
                for k in range(i, j):
                    pos = positions[k]
                    dx += (x - pos[0]) / ((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1]) + eps) ** 0.5
                    dy += (y - pos[1]) / ((x - pos[0]) * (x - pos[0]) + (y - pos[1]) * (y - pos[1]) + eps) ** 0.5
                x -= alpha * dx
                y -= alpha * dy
            alpha *= (1 - decay)
            if ((x - x_pre) * (x - x_pre) + (y - y_pre) * (y - y_pre)) ** 0.5 < eps:
                break

        ans = sum(((x - x0) * (x - x0) + (y - y0) * (y - y0)) ** 0.5 for x0, y0 in positions)
        return ans

    @staticmethod
    def lc_1515_3(positions: List[List[int]]) -> float:
        """
        url: https://leetcode.cn/problems/best-position-for-a-service-centre/
        tag: tripartite_pack_tripartite|convex_function_minimum|gradient_descent|hill_climbing
        """
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        eps = 1e-6
        step = 1.0
        decay = 0.8
        n = len(positions)

        x = sum(pos[0] for pos in positions) / n
        y = sum(pos[1] for pos in positions) / n

        def get_dis(xc, yc):
            return sum(((xc - x0) * (xc - x0) + (yc - y0) * (yc - y0)) ** 0.5 for x0, y0 in positions)

        while step > eps:
            for dx, dy in dirs:
                x_next = x + step * dx
                y_next = y + step * dy
                if get_dis(x_next, y_next) < get_dis(x, y):
                    x, y = x_next, y_next
                    break
            else:
                step *= (1.0 - decay)
        return get_dis(x, y)

    @staticmethod
    def abc_279d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc279/tasks/abc279_d
        tag: ternary_search|high_precision|classical
        """
        a, b = ac.read_list_ints()

        def check(x):
            if x < 0:
                return math.inf
            return x * b + a / (1 + x) ** 0.5

        y = TernarySearch().find_floor_point_int(check, 0, a)
        y = int(y)
        ans = min(Decimal(check(x)) for x in range(y - 5, y + 6))
        ac.st(ans)
        return

    @staticmethod
    def abc_240f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc240/tasks/abc240_f
        tag: implemention|ternary_search|binary_search|brute_force|classical
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(n)]
            ans = nums[0][0]
            pre = 0
            pre_pre = 0

            def check(s):
                return pre_pre + pre * s + s * (s + 1) * x // 2

            for x, y in nums:
                ans = max(ans, pre_pre + pre + x)
                if x < 0:
                    ceil = TernarySearch().find_ceil_point_int(check, 1, y)
                    for ss in range(ceil - 5, ceil + 5):
                        if 1 <= ss <= y:
                            ans = max(ans, check(ss))
                pre_pre = pre_pre + pre * y + y * (y + 1) * x // 2
                pre += x * y
                ans = max(ans, pre_pre)
            ac.st(ans)
        return

    @staticmethod
    def cf_1355e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1355/E
        tag: ternary_search|classical|greedy
        """
        n, a, r, m = ac.read_list_ints()
        h = ac.read_list_ints()

        h.sort()
        pre = ac.accumulate(h)

        def check(x):
            i = bisect.bisect_left(h, x)
            low = x * i - pre[i]
            high = pre[-1] - pre[i] - (n - i) * x
            y = min(low, high)
            res = y * min(m, a + r)
            res += (low - y) * a + (high - y) * r
            return res

        mid = TernarySearch().find_floor_point_int(check, 0, max(h))
        ans = min(check(x) for x in range(mid - 5, mid + 5) if x >= 0)
        ac.st(ans)
        return

    @staticmethod
    def cf_1389d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1389/D
        tag: ternary_search|brute_force|implemention|greedy
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            l1, r1 = ac.read_list_ints()
            l2, r2 = ac.read_list_ints()

            if l1 > l2:
                l1, l2, r1, r2 = l2, l1, r2, r1

            def check(xx):
                gap = (l2 - r1) * xx
                cost = gap
                kk = k
                cur = min(xx * (r2 - l1), kk)
                kk -= cur
                cost += cur
                return cost + 2 * kk

            if r1 <= l2:
                x = TernarySearch().find_floor_point_int(check, 1, n)
                ans = min(check(y) for y in range(x - 5, x + 5) if 1 <= y <= n)
            else:
                zero = min(r1, r2) - max(l1, l2)
                one = r2 - l2 + r1 - l1 - 2 * zero
                one *= n
                zero *= n
                k -= min(k, zero)
                x = min(k, one)
                ans = x
                k -= x
                ans += k * 2
            ac.st(ans)
        return

    @staticmethod
    def cf_1374e2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1374/E2
        tag: ternary_search|two_pointers|brute_force|classical
        """
        n, m, k = ac.read_list_ints()
        aa = []
        bb = []
        cc = []
        dd = []
        for ii in range(n):
            t, a, b = ac.read_list_ints()
            if a == b == 1:
                cc.append((t, ii + 1))
            elif a:
                aa.append((t, ii + 1))
            elif b:
                bb.append((t, ii + 1))
            else:
                dd.append((t, ii + 1))
        ma = len(aa)
        mb = len(bb)
        mc = len(cc)
        md = len(dd)
        aa.sort()
        bb.sort()
        cc.sort()
        dd.sort()

        pre_a = ac.accumulate([a[0] for a in aa])
        pre_b = ac.accumulate([b[0] for b in bb])
        pre_c = ac.accumulate([c[0] for c in cc])

        aa.append((math.inf, 0))
        bb.append((math.inf, 0))
        dd.append((math.inf, 0))

        lst = []
        for xx in range(0, min(m, mc) + 1):
            val = xx
            rest = ma + mb + md
            if val < k:
                if ma < k - val or mb < k - val:
                    continue
                val += (k - val) * 2
                rest -= 2 * (k - val)
                if val > m:
                    continue
            if val + rest < m:
                continue
            lst.append(xx)
        if not lst:
            ac.st(-1)
            return

        def compute(x):
            cur = pre_c[x]
            cnt = x
            ia = ib = i = 0
            if x < k:
                cnt += 2 * (k - x)
                cur += pre_a[k - x] + pre_b[k - x]
                ia = ib = k - x
            for _ in range(m - cnt):
                if ia < ma and aa[ia][0] <= bb[ib][0] and aa[ia][0] <= dd[i][0]:
                    cur += aa[ia][0]
                    ia += 1
                elif ib < mb and bb[ib][0] <= aa[ia][0] and bb[ib][0] <= dd[i][0]:
                    cur += bb[ib][0]
                    ib += 1
                elif i < md and dd[i][0] <= bb[ib][0] and dd[i][0] <= aa[ia][0]:
                    cur += dd[i][0]
                    i += 1
            return cur, ia, ib, x, i

        def check(x):
            return compute(x)[0]

        y = TernarySearch().find_floor_point_int(check, lst[0], lst[-1])

        ans = []
        for yy in range(y - 5, y + 5):
            if lst[0] <= yy <= lst[-1]:
                res = compute(yy)
                if not ans or res < ans:
                    ans = res
        ac.st(ans[0])
        index = [a[1] for a in aa[:ans[1]]] + [b[1] for b in bb[:ans[2]]] + [c[1] for c in cc[:ans[3]]] + [d[1] for d in
                                                                                                           dd[:ans[4]]]
        ac.lst(index)
        return

    @staticmethod
    def cf_1999g2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1999/G2
        tag: ternary_search|interactive|classical
        """
        ac.flush = True
        for _ in range(ac.read_int()):
            left = 2
            right = 999
            while left < right - 2:
                diff = (right - left) // 3
                mid1 = left + diff
                mid2 = left + 2 * diff
                ac.lst(["?", mid1, mid2])
                res = ac.read_int()
                if res == mid1 * mid2:
                    left = mid2 + 1
                elif res == mid1 * (mid2 + 1):
                    left = mid1 + 1
                    right = mid2
                else:
                    right = mid1
            for x in range(left, right):
                ac.lst(["?", x, x])
                if ac.read_int() == (x + 1) * (x + 1):
                    ac.lst(["!", x])
                    break
            else:
                ac.lst(["!", right])
        return

    @staticmethod
    def cf_578c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/578/C
        tag: ternary_search|linear_dp|prefix_sum|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()

        def check(x):
            high = -math.inf
            low = math.inf
            pre_high = pre_low = 0
            for num in nums:
                pre_high += num - x
                pre_low += num - x
                low = min(pre_low, low)
                high = max(pre_high, high)
                pre_high = max(pre_high, 0)
                pre_low = min(pre_low, 0)

            return max(abs(high), abs(low))

        ans = TernarySearch().find_floor_point_float(check, -10000, 10000, 1e-12)
        ac.st(check(ans))
        return
"""
Algorithm：n-tree|pre_order|post_order|mid_order
Description：

====================================LeetCode====================================
94（https://leetcode.cn/problems/binary-tree-inorder-traversal/description/）mid_order
144（https://leetcode.cn/problems/binary-tree-preorder-traversal/description/）pre_order
145（https://leetcode.cn/problems/binary-tree-postorder-traversal/）post_order
105（https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/）pre_order|in_order|construction|classical
106（https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/）in_order|post_order|construction|classical

=====================================AcWing=====================================
19（https://www.acwing.com/problem/content/description/31/）mid_order

=====================================AtCoder=====================================
ABC255F（https://atcoder.jp/contests/abc255/tasks/abc255_f）pre_order|in_order|construction|classical


"""
from typing import List, Optional

from src.basis.tree_node.template import TreeNode, TreeOrder
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_145(root: Optional[TreeNode]) -> List[int]:
        """
        url: https://leetcode.cn/problems/binary-tree-postorder-traversal/
        tag: post_order
        """
        return TreeOrder().post_order(root)

    @staticmethod
    def lc_94(root: Optional[TreeNode]) -> List[int]:
        """
        url: https://leetcode.cn/problems/binary-tree-inorder-traversal/description/
        tag: mid_order
        """
        return TreeOrder().in_order(root)

    @staticmethod
    def lc_144(root: Optional[TreeNode]) -> List[int]:
        """
        url: https://leetcode.cn/problems/binary-tree-preorder-traversal/description/
        tag: pre_order
        """
        return TreeOrder().pre_order(root)

    @staticmethod
    def ac_19(q):
        """
        url: https://www.acwing.com/problem/content/description/31/
        tag: mid_order
        """
        x = q
        while q.father:
            q = q.father

        ans = []
        stack = [[q, 1]] if q else []
        while stack:
            node, state = stack.pop()
            if state:
                if node.right:
                    stack.append([node.right, 1])
                stack.append([node, 0])
                if node.left:
                    stack.append([node.left, 1])
            else:
                ans.append(node)

        i = ans.index(x)
        if i == len(ans) - 1:
            return
        return ans[i + 1]


    @staticmethod
    def abc_255f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc255/tasks/abc255_f
        tag: pre_order|in_order|construction|classical
        """
        n = ac.read_int()
        pre_order = ac.read_list_ints_minus_one()

        in_order = ac.read_list_ints_minus_one()
        if pre_order[0] != 0:
            ac.st(-1)
            return

        ind = {num: i for i, num in enumerate(in_order)}
        stack = [(0, n - 1, 0, n - 1, 0)]
        sub = [[0, 0] for _ in range(n)]
        while stack:
            x1, y1, x2, y2, fa = stack.pop()
            if y1 - x1 != y2 - x2:
                ac.st(-1)
                return
            if x1 == y1:
                if pre_order[x1] != in_order[x2]:
                    ac.st(-1)
                    return
                continue
            if not x2 <= ind[pre_order[x1]] <= y2:
                ac.st(-1)
                return
            x0 = ind[pre_order[x1]]
            left_cnt = x0 - x2
            right_cnt = y2 - x0
            if left_cnt:
                sub[pre_order[fa]][0] = pre_order[x1 + 1] + 1
                stack.append((x1 + 1, x1 + left_cnt, x2, x0 - 1, x1 + 1))
            if right_cnt:
                sub[pre_order[fa]][1] = pre_order[x1 + left_cnt + 1] + 1
                stack.append((x1 + left_cnt + 1, y1, x0 + 1, y2, x1 + left_cnt + 1))
        for w in sub:
            ac.lst(w)
        return"""
Algorithm：two_pointers|fast_slow_pointers|bucket_counter|tree_pointers
Description：sliding_window|two_pointers|center_extension_method

====================================LeetCode====================================
167（https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/）two_pointers
259（https://leetcode.cn/problems/3sum-smaller/）two_pointers|counter|brute_force
2444（https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/）same_direction|two_pointers|counter
2398（https://leetcode.cn/problems/maximum-number-of-robots-within-budget/）same_direction|two_pointers|sorted_list|sliding_window
2302（https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/）same_direction|two_pointers|pointer|counter
2301（https://leetcode.cn/problems/match-substring-after-replacement/）brute_force|two_pointers
2106（https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/）two_pointers
6293（https://leetcode.cn/problems/count-the-number-of-good-subarrays/）two_pointers|counter
16（https://leetcode.cn/problems/3sum-closest/）tree_pointers
15（https://leetcode.cn/problems/3sum/）two_pointers
2422（https://leetcode.cn/problems/range_merge_to_disjoint-operations-to-turn-array-into-a-palindrome/）opposite_direction|two_pointers|greedy
2524（https://leetcode.cn/problems/maximum-frequency-score-of-a-subarray/）sliding_window|mod|power
239（https://leetcode.cn/problems/sliding-window-maximum/）sliding_window
2447（https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/）sliding_window|gcd
2654（https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/）sliding_window|gcd
1163（https://leetcode.cn/problems/last-substring-in-lexicographical-order/）minimum_expression|two_pointers
2555（https://leetcode.cn/problems/maximize-win-from-two-segments/description/）same_direction|two_pointers|liner_dp
992（https://leetcode.cn/problems/subarrays-with-k-different-integers/）tree_pointers|fast_slow_pointers
2747（https://leetcode.cn/problems/count-zero-request-servers/）offline_query|tree_pointers|fast_slow_pointers
2516（https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/）reverse_thinking|inclusion_exclusion|two_pointers
1537（https://leetcode.cn/problems/get-the-maximum-score/description/）two_pointers|liner_dp|topological_sorting
1712（https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/description/）three_pointers|fast_slow_pointers
948（https://leetcode.cn/problems/bag-of-tokens/）two_pointers|greedy
2953（https://leetcode.cn/problems/count-complete-substrings/）two_pointers|brute_force
100424（https://leetcode.com/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/）two_pointers|brute_force

=====================================LuoGu======================================
P2381（https://www.luogu.com.cn/problem/P2381）circular_array|sliding_window|two_pointers
P3353（https://www.luogu.com.cn/problem/P3353）sliding_window|two_pointers
P3662（https://www.luogu.com.cn/problem/P3662）sliding_window|sub_consequence_sum
P4995（https://www.luogu.com.cn/problem/P4995）sort|greedy|two_pointers|implemention
P2207（https://www.luogu.com.cn/problem/P2207）greedy|same_direction|two_pointers
P7542（https://www.luogu.com.cn/problem/P7542）bucket_counter|two_pointers
P4653（https://www.luogu.com.cn/problem/P4653）greedy|sort|two_pointers
P3029（https://www.luogu.com.cn/problem/P3029）two_pointers
P5583（https://www.luogu.com.cn/problem/P5583）two_pointers
P6465（https://www.luogu.com.cn/problem/P6465）sliding_window|two_pointers|counter


===================================CodeForces===================================
1328D（https://codeforces.com/problemset/problem/1328/D）circular_array|sliding_window|odd_even
1333C（https://codeforces.com/problemset/problem/1333/C）two_pointers|prefix_sum
1381A2（https://codeforces.com/problemset/problem/1381/A2）two_pointers|implemention|reverse_array|greedy
1611F（https://codeforces.com/contest/1611/problem/F）two_pointers|classical
1413C（https://codeforces.com/problemset/problem/1413/C）two_pointers
1494C（https://codeforces.com/problemset/problem/1494/C）two_pointers|three_pointers|brute_force|observation

====================================AtCoder=====================================
ARC100B（https://atcoder.jp/contests/abc102/tasks/arc100_b）two_pointers|brute_force
ABC337F（https://atcoder.jp/contests/abc337/tasks/abc337_f）two_pointers|implemention|greedy
ABC353C（https://atcoder.jp/contests/abc353/tasks/abc353_c）two_pointers|brute_force

=====================================AcWing=====================================
4217（https://www.acwing.com/problem/content/4220/）two_pointers|sliding_window

"""
import math
from collections import Counter, defaultdict
from functools import reduce
from itertools import accumulate
from math import gcd, math.inf
from operator import add
from typing import List

from src.basis.two_pointers.template import SlidingWindowAggregation
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def lg_p4653(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4653
        tag: greedy|sort|two_pointers|brain_teaser
        """
        n = ac.read_int()

        nums1 = []
        nums2 = []
        for _ in range(n):
            x, y = ac.read_list_floats()
            nums1.append(x)
            nums2.append(y)
        nums1.sort(reverse=True)
        nums2.sort(reverse=True)
        nums1 = list(accumulate(nums1, add))
        nums2 = list(accumulate(nums2, add))

        ans = i = j = 0
        while i < n and j < n:
            if nums1[i] < nums2[j]:
                ans = max(ans, nums1[i] - i - j - 2)
                i += 1
            else:
                ans = max(ans, nums2[j] - i - j - 2)
                j += 1
        ac.st("%.4f" % ans)
        return

    @staticmethod
    def lc_16(nums, target):
        """
        url: https://leetcode.cn/problems/3sum-closest/
        tag: tree_pointers|classical
        """
        n = len(nums)
        nums.sort()
        ans = nums[0] + nums[1] + nums[2]
        for i in range(n - 2):
            j, k = i + 1, n - 1
            x = nums[i]
            while j < k:
                cur = x + nums[j] + nums[k]
                ans = ans if abs(target - ans) < abs(target - cur) else cur
                if cur > target:
                    k -= 1
                elif cur < target:
                    j += 1
                else:
                    return target
        return ans

    @staticmethod
    def lc_15(nums):
        """
        url: https://leetcode.cn/problems/3sum/
        tag: two_pointers|classical
        """
        nums.sort()
        n = len(nums)
        ans = set()
        for i in range(n - 2):
            j, k = i + 1, n - 1
            x = nums[i]
            while j < k:
                cur = x + nums[j] + nums[k]
                if cur > 0:
                    k -= 1
                elif cur < 0:
                    j += 1
                else:
                    ans.add((x, nums[j], nums[k]))
                    j += 1
                    k -= 1
        return [list(a) for a in ans]

    @staticmethod
    def lc_259(nums: List[int], target: int) -> int:
        """
        url: https://leetcode.cn/problems/3sum-smaller/
        tag: two_pointers|counter|brute_force
        """
        nums.sort()
        n = len(nums)
        ans = 0
        for i in range(n - 2):
            x = nums[i]
            j, k = i + 1, n - 1
            while j < k:
                cur = x + nums[j] + nums[k]
                if cur < target:
                    ans += k - j
                    j += 1
                else:
                    k -= 1
        return ans

    @staticmethod
    def lc_239(nums: List[int], k: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/sliding-window-maximum/
        tag: sliding_window
        """
        n = len(nums)
        swa = SlidingWindowAggregation(-math.inf, max)
        ans = []
        for i in range(n):
            swa.append(nums[i])
            if i >= k - 1:
                ans.append(swa.query())
                swa.popleft()
        return ans

    @staticmethod
    def lc_2516(s: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right/
        tag: reverse_thinking|inclusion_exclusion|two_pointers
        """
        cnt = Counter(s)
        n = len(s)
        if any(cnt[w] < k for w in "abc"):
            return -1
        ans = 0
        dct = defaultdict(int)
        j = 0
        for i in range(n):
            while j < n and cnt[s[j]] - dct[s[j]] - 1 >= k:
                dct[s[j]] += 1
                j += 1
            if j - i > ans:
                ans = j - i
            dct[s[i]] -= 1
        return n - ans

    @staticmethod
    def lc_2555(prize_positions: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximize-win-from-two-segments/description/
        tag: same_direction|two_pointers|liner_dp
        """
        n = len(prize_positions)

        pre = [0] * n
        pre_max = [0] * (n + 1)
        ans = 0
        i = 0
        for j in range(n):
            while prize_positions[j] - prize_positions[i] > k:
                i += 1
            pre[j] = j - i + 1
            ans = max(ans, pre[j] + pre_max[i])
            pre_max[j + 1] = max(pre_max[j], pre[j])
        return ans

    @staticmethod
    def lc_2747(n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/count-zero-request-servers/
        tag: offline_query|tree_pointers|fast_slow_pointers
        """
        m = len(queries)
        ans = [0] * m
        ind = list(range(m))
        ind.sort(key=lambda it: queries[it])
        logs.sort(key=lambda it: it[1])
        i1 = i2 = 0
        k = len(logs)
        dct = dict()
        for j in ind:
            left = queries[j] - x
            right = queries[j]
            while i2 < k and logs[i2][1] <= right:
                dct[logs[i2][0]] = dct.get(logs[i2][0], 0) + 1
                i2 += 1
            while i1 < k and logs[i1][1] < left:
                dct[logs[i1][0]] -= 1
                if not dct[logs[i1][0]]:
                    del dct[logs[i1][0]]
                i1 += 1
            ans[j] = n - len(dct)
        return ans

    @staticmethod
    def lc_2654(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/
        tag: sliding_window|gcd
        """
        if gcd(*nums) != 1:
            return -1
        if 1 in nums:
            return len(nums) - nums.count(1)

        swa = SlidingWindowAggregation(0, gcd)
        res, n = math.inf, len(nums)
        for i in range(n):
            swa.append(nums[i])
            while swa and swa.query() == 1:
                res = res if res < swa.size else swa.size
                swa.popleft()
        return res - 1 + len(nums) - 1

    @staticmethod
    def lc_992(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/subarrays-with-k-different-integers/
        tag: tree_pointers|fast_slow_pointers|classical
        """
        n = len(nums)
        ans = j1 = j2 = 0
        pre1 = dict()
        pre2 = dict()
        for i in range(n):
            while j1 < n and len(pre1) < k:
                pre1[nums[j1]] = pre1.get(nums[j1], 0) + 1
                j1 += 1

            while j2 < n and (len(pre2) < k or nums[j2] in pre2):
                pre2[nums[j2]] = pre2.get(nums[j2], 0) + 1
                j2 += 1

            if len(pre1) == k:
                ans += j2 - j1 + 1
            pre1[nums[i]] -= 1
            if not pre1[nums[i]]:
                pre1.pop(nums[i])
            pre2[nums[i]] -= 1
            if not pre2[nums[i]]:
                pre2.pop(nums[i])
        return ans

    @staticmethod
    def lc_1163(s: str) -> str:
        """
        url: https://leetcode.cn/problems/last-substring-in-lexicographical-order/
        tag: minimum_expression|two_pointers|classical
        """
        i, j, n = 0, 1, len(s)
        while j < n:
            k = 0
            while j + k < n and s[i + k] == s[j + k]:
                k += 1
            if j + k < n and s[i + k] < s[j + k]:
                i, j = j, j + 1 if j + 1 > i + k + 1 else i + k + 1
            else:
                j = j + k + 1
        return s[i:]

    @staticmethod
    def lc_1537(nums1: List[int], nums2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/get-the-maximum-score/description/
        tag: two_pointers|liner_dp|topological_sort
        """
        mod = 10 ** 9 + 7
        m, n = len(nums1), len(nums2)
        i = j = pre1 = pre2 = 0
        while i < m and j < n:
            if nums1[i] < nums2[j]:
                pre1 += nums1[i]
                i += 1
            elif nums1[i] > nums2[j]:
                pre2 += nums2[j]
                j += 1
            else:
                pre1 += nums1[i]
                pre2 += nums2[j]
                pre1 = pre2 = pre1 if pre1 > pre2 else pre2
                i += 1
                j += 1
        pre1 += sum(nums1[i:])
        pre2 += sum(nums2[j:])
        return max(pre1, pre2) % mod

    @staticmethod
    def lc_1712(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/description/
        tag: three_pointers|fast_slow_pointers
        """
        mod = 10 ** 9 + 7
        ans = 0
        pre = list(accumulate(nums, initial=0))
        j1 = j2 = 0
        n = len(nums)
        for i in range(n):
            while j1 <= i or (j1 < n and pre[j1 + 1] - pre[i + 1] < pre[i + 1]):
                j1 += 1
            while j2 < j1 or (j2 < n - 1 and pre[-1] - pre[j2 + 1] >= pre[j2 + 1] - pre[i + 1]):
                j2 += 1
            if j2 >= j1:
                ans += j2 - j1
        return ans % mod

    @staticmethod
    def lc_2447(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/
        tag: sliding_window|gcd
        """
        n = len(nums)
        e = reduce(math.lcm, nums + [k])
        e *= 2

        swa1 = SlidingWindowAggregation(e, gcd)
        ans = j1 = j2 = 0
        swa2 = SlidingWindowAggregation(e, gcd)
        for i in range(n):

            if j1 < i:
                swa1 = SlidingWindowAggregation(e, gcd)
                j1 = i
            if j2 < i:
                swa2 = SlidingWindowAggregation(e, gcd)
                j2 = i

            while j1 < n and swa1.query() > k:
                swa1.append(nums[j1])
                j1 += 1
                if swa1.query() == k:
                    break

            while j2 < n and gcd(swa2.query(), nums[j2]) >= k:
                swa2.append(nums[j2])
                j2 += 1

            if swa1.query() == k:
                ans += j2 - j1 + 1

            swa1.popleft()
            swa2.popleft()
        return ans

    @staticmethod
    def lg_p5583(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5583
        tag: two_pointers
        """
        n, m, d = ac.read_list_ints()
        nums = ac.read_list_ints()
        cnt = dict()
        for num in nums:
            cnt[num] = cnt.get(num, 0) + 1
        nums = [ac.read_list_ints() for _ in range(n)]
        flag = 0
        ans = [-1]
        not_like = math.inf
        power = -math.inf
        cur_cnt = defaultdict(int)
        cur_power = cur_not_like = j = 0
        for i in range(n):
            while j < n and (flag < len(cnt) or all(num in cnt for num in nums[j][2:])):
                cur_power += nums[j][0]
                for num in nums[j][2:]:
                    cur_cnt[num] += 1
                    if cur_cnt[num] == 1 and num in cnt:
                        flag += 1
                    if num not in cnt:
                        cur_not_like += 1
                j += 1
            if flag == len(cnt):
                if cur_not_like < not_like or (cur_not_like == not_like and cur_power > power):
                    not_like = cur_not_like
                    power = cur_power
                    ans = [i + 1, j]
            cur_power -= nums[i][0]
            for num in nums[i][2:]:
                cur_cnt[num] -= 1
                if cur_cnt[num] == 0 and num in cnt:
                    flag -= 1
                if num not in cnt:
                    cur_not_like -= 1
        ac.lst(ans)
        return

    @staticmethod
    def lg_p6465(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6465
        tag: sliding_window|two_pointers|counter
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = ac.read_list_ints()
            m = m if m > 2 else 2
            ans = j = s = 0
            cnt = dict()
            for i in range(n):
                x = nums[i]
                if i and x == nums[i - 1]:
                    cnt = dict()
                    s = 0
                    j = i
                    continue
                while j <= i - m + 1:
                    y = nums[j]
                    cnt[y] = cnt.get(y, 0) + 1
                    s += 1
                    j += 1
                ans += s - cnt.get(x, 0)
            ac.st(ans)
        return

    @staticmethod
    def ac_4217(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4220/
        tag: two_pointers|sliding_window
        """
        n = ac.read_int()
        s = ac.read_str()
        a, b = ac.read_list_ints()
        ans = math.inf
        j = 0
        ind = dict()
        ind["U"] = [0, 1]
        ind["D"] = [0, -1]
        ind["L"] = [-1, 0]
        ind["R"] = [1, 0]
        lst = [0, 0]
        for w in s:
            lst[0] += ind[w][0]
            lst[1] += ind[w][1]

        def check():
            rest = [lst[0] - pre[0], lst[1] - pre[1]]
            return abs(rest[0] - a) + abs(rest[1] - b) == j - i

        pre = [0, 0]
        for i in range(n):
            while j < n and not check():
                w = ind[s[j]]
                pre[0] += w[0]
                pre[1] += w[1]
                j += 1
            if check() and j - i < ans:
                ans = j - i
            pre[0] -= ind[s[i]][0]
            pre[1] -= ind[s[i]][1]
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_337f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc337/tasks/abc337_f
        tag: two_pointers|implemention|greedy
        """
        n, m, k = ac.read_list_ints()
        cnt = [0] * (n + 1)
        nums = ac.read_list_ints()
        for num in nums:
            cnt[num] += 1
        j = 0
        color = 0
        cur = dict()
        tot = 0
        for i in range(n):
            while color < m and j < i + n:
                cur[nums[j]] = cur.get(nums[j], 0) + 1
                if k > 1:
                    if cur[nums[j]] == 1:
                        tot += min(cnt[nums[j]], k)
                        color += 1
                    elif cur[nums[j]] % k == 1:
                        color += 1
                        x = cur[nums[j]] // k
                        tot += min(k, cnt[nums[j]] - x * k)
                else:
                    tot += 1
                    color += 1
                j += 1
            ac.st(tot)
            nums.append(nums[i])
            if k > 1:
                cur[nums[i]] -= 1
                if cur[nums[i]] % k == 0:
                    x = cur[nums[i]] // k
                    color -= 1
                    tot -= min(k, cnt[nums[i]] - x * k)
            else:
                cur[nums[i]] -= 1

                color -= 1
                tot -= 1
        return

    @staticmethod
    def cf_1494c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1494/C
        tag: two_pointers|three_pointers|brute_force|observation
        """
        for _ in range(ac.read_int()):
            ac.read_list_ints()
            a = ac.read_list_ints()
            b = ac.read_list_ints()

            def check(lst1, lst2):
                m, n = len(lst1), len(lst2)
                cur = set(lst1)
                cnt = sum(x in cur for x in lst2)
                res = cnt
                j = k = 0
                for i in range(n):
                    cnt -= lst2[i] in cur
                    while j < m and lst1[j] <= lst2[i]:
                        j += 1
                    while k <= i and lst2[k] < lst2[i] - j+1:
                        k += 1
                    res = max(res, cnt+i-k+1)
                return res

            ans = check(sorted([x for x in a if x > 0]), sorted([x for x in b if x > 0]))
            ans += check(sorted([-x for x in a if -x > 0]), sorted([-x for x in b if -x > 0]))
            ac.st(ans)
        return
"""
Algorithm：sort|bubble_sort|merge_sort(minimum_num_comparisons)|quick_sort(expected_fast)|custom_sort
Description：reverse_order_pair

====================================LeetCode====================================
164（https://leetcode.cn/problems/maximum-gap/）bucket_sort
179（https://leetcode.cn/problems/largest-number/）custom_sort|maximum
912（https://leetcode.cn/problems/sort-an-array/）quick_sort
1585（https://leetcode.cn/problems/check-if-string-is-transformable-with-substring-sort-operations/）bubble_sort|implemention
45（https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/）custom_sort|minimum
2412（https://leetcode.cn/problems/minimum-money-required-before-transactions/）custom_sort|greedy
1665（https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/）custom_sort|greedy|sorting
100391（https://leetcode.cn/problems/minimum-amount-of-damage-dealt-to-bob/）greedy|custom_sort|classical

=====================================LuoGu======================================
P2310（https://www.luogu.com.cn/problem/P2310）sorting
P4378（https://www.luogu.com.cn/problem/P4378）brute_force|bubble_sort
P6243（https://www.luogu.com.cn/problem/P6243）greedy|custom_sort
P1774（https://www.luogu.com.cn/problem/P1774）merge_sort|reverse_order_pair
P1908（https://www.luogu.com.cn/problem/P1908）tree_array|reverse_order_pair
P1177（https://www.luogu.com.cn/problem/P1177）quick_sort

===================================CodeForces===================================
922D（https://codeforces.com/problemset/problem/922/D）greedy|custom_sort
1983D（https://codeforces.com/problemset/problem/1983/D）inverse_pair|observation|brain_teaser
632C（https://codeforces.com/problemset/problem/632/C）custom_sort|greedy|classical

====================================AtCoder=====================================
ABC042B（https://atcoder.jp/contests/abc042/tasks/abc042_b）custom_sort
ABC268F（https://atcoder.jp/contests/abc268/tasks/abc268_f）custom_sort|classical
ABC225F（https://atcoder.jp/contests/abc225/tasks/abc225_f）linear_dp|cmp_to_key|custom_sort|brain_teaser|reverse_order

=====================================AcWing=====================================
113（https://www.acwing.com/problem/content/description/115/）custom_sort

"""
import random
from functools import cmp_to_key
from typing import List

from src.basis.various_sort.template import VariousSort
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_912(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/sort-an-array/
        tag: quick_sort
        """
        n = len(nums)
        stack = [(0, n - 1)]
        while stack:
            left, right = stack.pop()
            mid = nums[random.randint(left, right)]
            i, j = left, right
            while i <= j:
                while nums[i] < mid:
                    i += 1
                while nums[j] > mid:
                    j -= 1
                if i <= j:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            if left < j:
                stack.append((left, j))
            if i < right:
                stack.append((i, right))
        return nums

    @staticmethod
    def ac_113(compare, n):
        """
        url: https://www.acwing.com/problem/content/description/115/
        tag: custom_sort
        """

        def compare_(x, y):
            if compare(x, y):
                return -1
            return 1

        nums = list(range(1, n + 1))
        nums.sort(key=cmp_to_key(compare_))
        return nums

    @staticmethod
    def abc_042b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc042/tasks/abc042_b
        tag: custom_sort|classical
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_str() for _ in range(n)]

        def compare(a, b):
            if a + b < b + a:
                return -1
            elif a + b > b + a:
                return 1
            return 0

        nums.sort(key=cmp_to_key(compare))
        ac.st("".join(nums))
        return

    @staticmethod
    def lc_179(nums: List[int]) -> str:
        """
        url: https://leetcode.cn/problems/largest-number/
        tag: custom_sort|maximum|classical
        """

        def compare(a, b):
            if int(a + b) > int(b + a):
                return -1
            elif int(a + b) < int(b + a):
                return 1
            return 0

        nums = [str(x) for x in nums]
        nums.sort(key=cmp_to_key(compare))
        return str(int("".join(nums)))

    @staticmethod
    def lg_1177(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1177
        tag: quick_sort
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        stack = [(0, n - 1)]
        while stack:
            left, right = stack.pop()
            mid = nums[random.randint(left, right)]
            i, j = left, right
            while i <= j:
                while nums[i] < mid:
                    i += 1
                while nums[j] > mid:
                    j -= 1
                if i <= j:
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            if left < j:
                stack.append((left, j))
            if i < right:
                stack.append((i, right))
        ac.lst(nums)
        return

    @staticmethod
    def lc_1665(tasks: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/
        tag: custom_sort|greedy|classical
        """

        def compare(aa, bb):
            a1, m1 = aa
            a2, m2 = bb
            s12 = m1 if m1 > a1 + m2 else a1 + m2
            s21 = m2 if m2 > a2 + m1 else a2 + m1
            if s12 < s21:
                return -1
            elif s12 > s21:
                return 1
            return 0

        tasks.sort(key=cmp_to_key(compare))
        ans = cur = 0
        for a, m in tasks:
            if cur < m:
                ans += m - cur
                cur = m
            cur -= a
        return ans

    @staticmethod
    def lc_2412(transactions: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-money-required-before-transactions/
        tag: custom_sort|greedy|classical
        """

        def check(it):
            cos, cash = it[:]
            if cos > cash:
                return [-1, cash]
            return [1, -cos]

        transactions.sort(key=check)
        ans = cur = 0
        for a, b in transactions:
            if cur < a:
                ans += a - cur
                cur = a
            cur += b - a
        return ans

    @staticmethod
    def lg_p1908(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1908
        tag: tree_array|reverse_order_pair|P1774
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ans = VariousSort().range_merge_to_disjoint_sort_inverse_pair(nums)
        ac.st(ans)
        return

    @staticmethod
    def abc_268f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc268/tasks/abc268_f
        tag: custom_sort|classical
        """

        def compare(i, j):
            cnt1 = cnt[i]
            cnt2 = cnt[j]
            s1 = cnt1[0] * cnt2[1]
            s2 = cnt2[0] * cnt1[1]
            if s1 > s2:
                return -1
            if s1 < s2:
                return 1
            return 0

        n = ac.read_int()
        words = [ac.read_str().replace("X", "0") for _ in range(n)]
        cnt = []
        score = []
        for word in words:
            cur = [0] * 2
            ss = cc = 0
            for w in word:
                if w == "0":
                    cur[0] += 1
                    cc += 1
                else:
                    cur[1] += int(w)
                    ss += cc * int(w)
            score.append(ss)
            cnt.append(cur[:])
        ind = list(range(n))
        ind.sort(key=cmp_to_key(compare))
        ans = post = 0
        for x in range(n - 1, -1, -1):
            ans += cnt[ind[x]][0] * post
            post += cnt[ind[x]][1]
        ac.st(ans + sum(score))
        return

    @staticmethod
    def abc_225f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc225/tasks/abc225_f
        tag: linear_dp|cmp_to_key|custom_sort|brain_teaser|reverse_order
        """
        n, k = ac.read_list_ints()

        def compare_(x, y):
            if x + y < y + x:
                return -1
            return 1

        words = [ac.read_str() for _ in range(n)]
        words.sort(key=cmp_to_key(compare_))

        dp = [chr(ord("z") + 1) for _ in range(k + 1)]
        dp[0] = ""
        for i in range(n - 1, -1, -1):
            word = words[i]
            ndp = dp[:]
            for j in range(1, k + 1):
                ndp[j] = min(ndp[j], word + dp[j - 1])
            dp = ndp[:]
        ac.st(dp[-1])
        return

    @staticmethod
    def lc_100391(power: int, damage: List[int], health: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-amount-of-damage-dealt-to-bob/
        tag: greedy|custom_sort|classical
        """
        n = len(damage)

        def compare(i, j):
            hi, di = health[i], damage[i]
            hj, dj = health[j], damage[j]
            s1 = dj * t[i]
            s2 = di * t[j]
            if s1 < s2:
                return -1
            if s1 > s2:
                return 1
            return 0

        t = [(h + power - 1) // power for h in health]
        ind = list(range(n))
        ind.sort(key=cmp_to_key(compare))

        ans = 0
        tot = sum(damage)
        for k in ind:
            ans += tot * ((health[k] + power - 1) // power)
            tot -= damage[k]
        return ans

    @staticmethod
    def cf_1983d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1983/D
        tag: inverse_pair|observation|brain_teaser
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            if sorted(a) != sorted(b) or VariousSort().range_merge_to_disjoint_sort_inverse_pair(
                    a) % 2 != VariousSort().range_merge_to_disjoint_sort_inverse_pair(b) % 2:
                ac.no()
                continue
            ac.yes()
        return

    @staticmethod
    def cf_632c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/632/C
        tag: custom_sort|greedy|classical
        """
        n = ac.read_int()

        words = [ac.read_str() for _ in range(n)]

        def compare(wi, wj):
            if wi + wj < wj + wi:
                return -1
            return 1

        words.sort(key=cmp_to_key(compare))

        ans = "".join(words)
        ac.st(ans)
        return
"""
Algorithm：use xor of random seed as key of mapping
Ability：speed up and avoid hash crush
Reference：https://judge.yosupo.jp/problem/associative_array


===================================CodeForces===================================
1665B（https://codeforces.com/contest/1665/problem/B）hash|xor_random_seed
1702C（https://codeforces.com/contest/1702/problem/C）hash|xor_random_seed
1676F（https://codeforces.com/contest/1676/problem/F）hash|dp|sort
776C（https://codeforces.com/problemset/problem/776/C）prefix_sum|hash|random_seed|random_xor
1188B（https://codeforces.com/problemset/problem/1188/B）hash|math|classical

================================Library Checker================================
1（https://judge.yosupo.jp/problem/associative_array）hash|xor_random_seed


"""
from collections import Counter

from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """template question of associative array"""
        pre = dict()
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 0:
                k, v = lst[1:]
                pre[k ^ ac.random_seed] = v
            else:
                ac.st(pre.get(lst[1] ^ ac.random_seed, 0))
        return

    @staticmethod
    def cf_1655b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1665/problem/B
        tag: hash|xor_random_seed
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            cur = max(Counter([x ^ ac.random_seed for x in nums]).values())
            ans = 0
            while cur < n:
                ans += 1
                other = cur
                x = min(n - cur, other)
                ans += x
                cur += x
                other -= x
            ac.st(ans)
        return

    @staticmethod
    def cf_1702c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1702/problem/C
        tag: hash|xor_random_seed
        """
        def solve():
            ac.read_str()
            n, k = ac.read_list_ints()
            u = ac.read_list_ints()
            start = dict()
            end = dict()
            for i, x in enumerate(u):
                if x ^ ac.random_seed not in start:
                    start[x ^ ac.random_seed] = i
                end[x ^ ac.random_seed] = i
            for _ in range(k):
                a, b = ac.read_list_ints()
                if (a ^ ac.random_seed in start
                        and b ^ ac.random_seed in end
                        and start[a ^ ac.random_seed] < end[b ^ ac.random_seed]):
                    ac.yes()
                else:
                    ac.no()
            return

        for _ in range(ac.read_int()):
            solve()
        return

    @staticmethod
    def cf_776c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/776/C
        tag: prefix_sum|hash|random_seed|random_xor
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        ceil = 10 ** 15
        val = []
        x = 1
        for _ in range(64):
            val.append(x)
            x *= k
            if abs(x) > ceil:
                break
        val = set(val)
        ans = x = 0
        pre = dict()
        ac.get_random_seed()
        pre[x ^ ac.random_seed] = 1
        for num in nums:
            x += num
            for v in val:
                ans += pre.get((x - v) ^ ac.random_seed, 0)
            pre[x ^ ac.random_seed] = pre.get(x ^ ac.random_seed, 0) + 1
        ac.st(ans)
        return

    @staticmethod
    def cf_1188b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1188/B
        tag: hash|math|classical
        """
        n, p, k = ac.read_list_ints()
        cnt = dict()
        ac.get_random_seed()
        nums = ac.read_list_ints()
        ans = 0
        for num in nums:
            cur = ((num ** 4 - k * num) % p) ^ ac.random_seed
            ans += cnt.get(cur, 0)
            cnt[cur] = cnt.get(cur, 0) + 1
        ac.st(ans)
        return
"""
Algorithm：bit_set|implemention|range_state|range_reverse
Description：

====================================LeetCode====================================
2569（https://leetcode.cn/problems/handling-sum-queries-after-update/）segment_tree|range_reverse|bit_set
100320（https://leetcode.cn/problems/maximum-total-reward-using-operations-ii）bit_set|classical

=====================================LuoGu======================================
xx（xxx）x

===================================CodeForces===================================
242E（https://codeforces.com/contest/242/problem/E）range_or_sum|range_xor_sum|SegBitSet

====================================AtCoder=====================================
ARC087B（https://atcoder.jp/contests/abc082/tasks/arc087_b）brain_teaser|bfs|bit_set
ABC147E（https://atcoder.jp/contests/abc147/tasks/abc147_e）matrix_dp|bit_set

=====================================AcWing=====================================
5037（https://www.acwing.com/problem/content/5040/）CF242E|range_or_sum|range_xor_sum|SegBitSet

"""
from typing import List

from src.data_structure.bit_set.template import SegBitSet
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def arc_087b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc082/tasks/arc087_b
        tag: brain_teaser|bfs|bit_set
        """
        s = ac.read_str()
        x, y = ac.read_list_ints()
        ls = [len(t) for t in s.split("T")]
        pre_x = 1 << (ls[0] + 8000)
        for d in ls[2::2]:
            pre_x = (pre_x >> d) | (pre_x << d)

        pre_y = 1 << 8000
        for d in ls[1::2]:
            pre_y = (pre_y >> d) | (pre_y << d)
        ac.st("Yes" if pre_x & (1 << (x + 8000)) and pre_y & (1 << (y + 8000)) else "No")
        return

    @staticmethod
    def lc_2569(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/handling-sum-queries-after-update/
        tag: segment_tree|range_reverse|bit_set
        """
        ans = []
        n = len(nums1)
        tree = SegBitSet(n)
        for i in range(n):
            if nums1[i]:
                tree.update(i, i)

        s = sum(nums2)
        for op, x, y in queries:
            if op == 1:
                tree.update(x, y)
            elif op == 2:
                s += x * tree.query(0, n - 1)
            else:
                ans.append(s)
        return ans

    @staticmethod
    def abc_147e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc147/tasks/abc147_e
        tag: matrix_dp|bit_set
        """
        m, n = ac.read_list_ints()
        grid_a = [ac.read_list_ints() for _ in range(m)]
        grid_b = [ac.read_list_ints() for _ in range(m)]
        pre = [0 for _ in range(n)]
        tmp = abs(grid_a[0][0] - grid_b[0][0])
        offset = 6401
        pre[0] = (1 << (offset - tmp)) | (1 << (offset + tmp))
        for i in range(m):
            cur = [0 for _ in range(n)]
            if not i:
                cur[0] = pre[0]
            for j in range(n):
                tmp = abs(grid_a[i][j] - grid_b[i][j])
                if i:
                    cur[j] |= (pre[j] << tmp) | (pre[j] >> tmp)
                if j:
                    cur[j] |= (cur[j - 1] << tmp) | (cur[j - 1] >> tmp)
            pre = cur[:]

        ans = offset
        val = 1
        x = 0
        while val <= pre[-1]:
            if val & pre[-1]:
                if abs(x - offset) < ans:
                    ans = abs(x - offset)
            val <<= 1
            x += 1
        ac.st(ans)
        return

    @staticmethod
    def ac_5037_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/5040/
        tag: CF242E|range_or_sum|range_xor_sum|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        tree = [SegBitSet(n) for _ in range(22)]
        for i in range(n):
            x = nums[i]
            for j in range(22):
                if x & (1 << j):
                    tree[j].update(i, i)

        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr = lst[1:]
                ll -= 1
                rr -= 1
                ans = sum((1 << j) * tree[j].query(ll, rr) for j in range(22))
                ac.st(ans)
            else:
                ll, rr, xx = lst[1:]
                ll -= 1
                rr -= 1
                for j in range(22):
                    if (1 << j) & xx:
                        tree[j].update(ll, rr)
        return

    @staticmethod
    def lc_100320(values: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-total-reward-using-operations-ii
        tag: bit_set|classical
        """
        ans = 1
        for num in sorted(values):
            ans |= (ans & ((1 << num) - 1)) << num
        return ans.bit_length() - 1
"""

Algorithm：linked_list|double_linked_list|union_find_right_root|union_left
Description：


====================================LeetCode====================================
2617（https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/）bfs|double_linked_list
2612（https://leetcode.cn/problems/minimum-reverse-operations/）bfs|double_linked_list
1562（https://leetcode.cn/problems/find-latest-group-of-size-m/）union_find|double_linked_list
2382（https://leetcode.cn/problems/maximum-segment-sum-after-removals/）reverse_thinking|double_linked_list|union_find
2289（https://leetcode.cn/problems/steps-to-make-array-non-decreasing/description/）monotonic_stack|liner_dp|bfs|linked_list

====================================NewCoder===================================
49888C（https://ac.nowcoder.com/acm/contest/49888/C）double_linked_list

=====================================LuoGu======================================
P5462（https://www.luogu.com.cn/problem/P5462）double_linked_list|greedy|lexicographical_order|deque
P6155（https://www.luogu.com.cn/problem/P6155）sort|greedy|union_find_right_root

===================================CodeForces===================================
1154E（https://codeforces.com/contest/1154/problem/E）double_linked_list|union_find_left|union_find_right
1922D（https://codeforces.com/problemset/problem/1922/D）double_linked_list|bfs|classical|brain_teaser|implemention

====================================AtCoder=====================================
ABC344E（https://atcoder.jp/contests/abc344/tasks/abc344_e）linked_list
ABC237D（https://atcoder.jp/contests/abc237/tasks/abc237_d）double_linked_list|implemention|classical
ABC225D（https://atcoder.jp/contests/abc225/tasks/abc225_d）linked_list

=====================================AcWing=====================================
136（https://www.acwing.com/problem/content/138/）linked_list|reverse_thinking
4943（https://www.acwing.com/problem/content/description/4946/）bfs|linked_list
5034（https://www.acwing.com/problem/content/5037/）heapq|greedy|linked_list

"""
import heapq
from collections import deque
from typing import List

from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1154e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1154/problem/E
        tag: double_linked_list
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = [0] * n
        pre = [i - 1 for i in range(n)]
        nex = [i + 1 for i in range(n)]
        ind = [0] * n
        for i in range(n):
            ind[nums[i] - 1] = i

        step = 1
        for num in range(n - 1, -1, -1):
            i = ind[num]
            if ans[i]:
                continue
            ans[i] = step
            left, right = pre[i], nex[i]
            for _ in range(k):
                if left != -1:
                    ans[left] = step
                    left = pre[left]
                else:
                    break
            for _ in range(k):
                if right != n:
                    ans[right] = step
                    right = nex[right]
                else:
                    break
            if left >= 0:
                nex[left] = right
            if right < n:
                pre[right] = left
            step = 3 - step
        ac.st("".join(str(x) for x in ans))
        return

    @staticmethod
    def nc_49888c_1(ac=FastIO()):
        """
        url: https://ac.nowcoder.com/acm/contest/49888/C
        tag: double_linked_list
        """
        n, k = ac.read_list_ints()
        pre = list(range(-1, n + 1))
        post = list(range(1, n + 3))
        assert len(pre) == len(post) == n + 2
        for _ in range(k):
            op, x = ac.read_list_ints()
            if op == 1:
                a = pre[x]
                b = post[x]
                if 1 <= b <= n:
                    pre[b] = a
                if 1 <= a <= n:
                    post[a] = b
                pre[x] = post[x] = -1
            else:
                ac.st(pre[x])
        return

    @staticmethod
    def nc_49888c_2(ac=FastIO()):
        """
        url: https://ac.nowcoder.com/acm/contest/49888/C
        tag: double_linked_list|union_find_root_left
        """
        n, k = ac.read_list_ints()
        uf = UnionFind(n + 1)
        for _ in range(k):
            op, x = ac.read_list_ints()
            if op == 1:
                uf.union(x - 1, x)
            else:
                ac.st(uf.find(x - 1))
        return

    @staticmethod
    def lc_2289(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/steps-to-make-array-non-decreasing/description/
        tag: monotonic_stack|liner_dp|bfs|linked_list
        """
        n = len(nums)
        post = list(range(1, n + 1))
        nums.append(10 ** 9 + 7)
        stack = [i - 1 for i in range(1, n) if nums[i - 1] > nums[i]]
        ans = 0
        visit = [0] * n
        while stack:
            ans += 1
            for i in stack[::-1]:
                if nums[i] > nums[post[i]]:
                    visit[post[i]] = 1
                    post[i] = post[post[i]]
            stack = [i for i in stack if not visit[i] and nums[i] > nums[post[i]]]
        return ans

    @staticmethod
    def lc_2617_1(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/
        tag: bfs|double_linked_list|classical|reverse_order|reverse_thinking|tree_array|segment_tree|flatten
        """
        m, n = len(grid), len(grid[0])
        dis = [[math.inf] * n for _ in range(m)]
        row_nex = [list(range(1, n + 1)) for _ in range(m)]
        col_nex = [list(range(1, m + 1)) for _ in range(n)]
        stack = deque([[0, 0]])
        dis[0][0] = 1

        while stack:
            i, j = stack.popleft()
            d = dis[i][j]
            x = grid[i][j]
            if x == 0:
                continue

            nex = row_nex[i]
            y = nex[j]
            lst = []
            while y <= j + x and 0 <= y < n:
                if dis[i][y] == math.inf:
                    dis[i][y] = d + 1
                    if i == m - 1 and y == n - 1:
                        return d + 1
                    stack.append([i, y])
                lst.append(y)
                y = nex[y]
            for w in lst:
                nex[w] = y

            nex = col_nex[j]
            y = nex[i]
            lst = []
            while y <= i + x and 0 <= y < m:
                if dis[y][j] == math.inf:
                    dis[y][j] = d + 1
                    if y == m - 1 and j == n - 1:
                        return d + 1
                    stack.append([y, j])
                lst.append(y)
                y = nex[y]
            for w in lst:
                nex[w] = y

        ans = dis[-1][-1]
        return ans if ans < math.inf else -1

    @staticmethod
    def lc_2617_2(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/
        tag: bfs|double_linked_list|classical|reverse_order|reverse_thinking|tree_array|segment_tree|flatten
        """
        m, n = len(grid), len(grid[0])
        dis = [[math.inf] * n for _ in range(m)]
        row = [UnionFind(n + 1) for _ in range(m)]
        col = [UnionFind(m + 1) for _ in range(n)]
        stack = deque([[0, 0]])
        dis[0][0] = 1

        while stack:
            i, j = stack.popleft()
            d = dis[i][j]
            x = grid[i][j]
            if x == 0:
                continue

            uf = row[i]
            p = uf.find(j)
            while p <= x + j and p <= n - 1:
                if dis[i][p] == math.inf:
                    dis[i][p] = d + 1
                    stack.append([i, p])
                    if i == m - 1 and p == n - 1:
                        return d + 1
                uf.union(p, p + 1)
                p = uf.find(p)

            uf = col[j]
            p = uf.find(i)
            while p <= x + i and p <= m - 1:
                if dis[p][j] == math.inf:
                    dis[p][j] = d + 1
                    stack.append([p, j])
                    if p == m - 1 and j == n - 1:
                        return d + 1
                uf.union(p, p + 1)
                p = uf.find(p)
        ans = dis[-1][-1]
        return ans if ans < math.inf else -1

    @staticmethod
    def ac_136(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/138/
        tag: linked_list|reverse_thinking
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ind = list(range(n))
        ind.sort(key=lambda it: nums[it])
        dct = {nums[i]: i for i in range(n)}
        pre = [-1] * n
        post = [-1] * n
        for i in range(1, n):
            a, b = ind[i - 1], ind[i]
            post[a] = b
            pre[b] = a
        ans = []
        for x in range(n - 1, 0, -1):
            num = nums[x]
            i = dct[num]
            a = pre[i]
            b = post[i]
            if a != -1 and b != -1:
                if abs(num - nums[a]) < abs(num - nums[b]) or (
                        abs(num - nums[a]) == abs(num - nums[b]) and nums[a] < nums[b]):
                    ans.append([abs(num - nums[a]), a + 1])
                else:
                    ans.append([abs(num - nums[b]), b + 1])
                post[a] = b
                pre[b] = a
            elif a != -1:
                ans.append([abs(num - nums[a]), a + 1])
                post[a] = post[i]
            else:
                ans.append([abs(num - nums[b]), b + 1])
                pre[b] = pre[i]
        for i in range(n - 2, -1, -1):
            ac.lst(ans[i])
        return

    @staticmethod
    def lg_p5462(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5462
        tag: double_linked_list|greedy|lexicographical_order|deque|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [-1] * (n + 1)
        post = [-1] * (n + 1)
        for i in range(n):
            if i:
                pre[nums[i]] = nums[i - 1]
            if i + 1 < n:
                post[nums[i]] = nums[i + 1]

        visit = [0] * (n + 1)
        ans = []
        for num in range(n, 0, -1):
            if visit[num] or post[num] == -1:
                continue
            visit[num] = visit[post[num]] = 1
            ans.extend([num, post[num]])
            x, y = pre[num], post[post[num]]
            if x != -1:
                post[x] = y
            if y != -1:
                pre[y] = x
        ac.lst(ans)
        return

    @staticmethod
    def lg_p6155(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6155
        tag: sort|greedy|union_find_right_root|classical
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        a.sort(reverse=True)
        mod = 2 ** 64
        b.sort()
        cnt = []
        pre = {}
        for num in a:
            y = num
            lst = [num]
            while y in pre:
                lst.append(y)
                y = pre[y]
            lst.append(y)
            for x in lst:
                pre[x] = y + 1
            cnt.append(y - num)
        cnt.sort(reverse=True)
        ans = sum(cnt[i] * b[i] for i in range(n))
        ac.st(ans % mod)
        return

    @staticmethod
    def lc_1562(arr: List[int], m: int) -> int:
        """
        url: https://leetcode.cn/problems/find-latest-group-of-size-m/
        tag: union_find|double_linked_list
        """
        n = len(arr)
        left = [-1] * n
        right = [-1] * n
        cnt = [0] * (n + 1)
        ans = -1
        for x, i in enumerate(arr):
            i -= 1
            if i - 1 >= 0 and left[i - 1] != -1:
                if i + 1 < n and right[i + 1] != -1:
                    start = left[i - 1]
                    end = right[i + 1]
                    cnt[i - start] -= 1
                    cnt[end - i] -= 1
                    cnt[end - start + 1] += 1
                    right[start] = end
                    left[end] = start
                else:
                    start = left[i - 1]
                    cnt[i - start] -= 1
                    end = i
                    cnt[end - start + 1] += 1
                    right[start] = end
                    left[end] = start
            elif i + 1 < n and right[i + 1] != -1:
                start = i
                end = right[i + 1]
                cnt[end - i] -= 1
                cnt[end - start + 1] += 1
                right[start] = end
                left[end] = start
            else:
                left[i] = right[i] = i
                cnt[1] += 1

            if cnt[m]:
                ans = x + 1
        return ans

    @staticmethod
    def ac_4943(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4946/
        tag: bfs|linked_list|classical
        """
        m, n, k = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        x1, y1, x2, y2 = ac.read_list_ints_minus_one()

        dis = [[math.inf] * n for _ in range(m)]
        row_nex = [list(range(1, n + 1)) for _ in range(m)]
        row_pre = [list(range(-1, n - 1)) for _ in range(m)]
        col_nex = [list(range(1, m + 1)) for _ in range(n)]
        col_pre = [list(range(-1, m - 1)) for _ in range(n)]
        stack = deque([[x1, y1]])
        dis[x1][y1] = 0

        while stack:
            i, j = stack.popleft()
            d = dis[i][j]
            pre = row_pre[i]
            nex = row_nex[i]
            y = nex[j]
            lst = []
            while y <= j + k and 0 <= y < n and grid[i][y] == ".":
                if dis[i][y] == math.inf:
                    dis[i][y] = d + 1
                    stack.append([i, y])
                lst.append(y)
                y = nex[y]
            for w in lst:
                nex[w] = y
                pre[w] = pre[j]

            pre = row_pre[i]
            nex = row_nex[i]
            y = pre[j]
            lst = []
            while j - y <= k and 0 <= y < n and grid[i][y] == ".":
                if dis[i][y] == math.inf:
                    dis[i][y] = d + 1
                    stack.append([i, y])
                lst.append(y)
                y = pre[y]
            for w in lst:
                pre[w] = y
                nex[w] = nex[j]

            pre = col_pre[j]
            nex = col_nex[j]
            y = nex[i]
            lst = []
            while y <= i + k and 0 <= y < m and grid[y][j] == ".":
                if dis[y][j] == math.inf:
                    dis[y][j] = d + 1
                    stack.append([y, j])
                lst.append(y)
                y = nex[y]
            for w in lst:
                nex[w] = y
                pre[w] = pre[i]

            pre = col_pre[j]
            nex = col_nex[j]
            y = pre[i]
            lst = []
            while i - y <= k and 0 <= y < m and grid[y][j] == ".":
                if dis[y][j] == math.inf:
                    dis[y][j] = d + 1
                    stack.append([y, j])
                lst.append(y)
                y = pre[y]
            for w in lst:
                pre[w] = y
                nex[w] = nex[i]

        ans = dis[x2][y2]
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def ac_5034(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/5037/
        tag: heapq|greedy|linked_list
        """
        n = ac.read_int()
        s = ac.read_str()
        nums = ac.read_list_ints()
        post = list(range(1, n + 1))
        pre = list(range(-1, n - 1))
        stack = []
        for i in range(n - 1):
            if s[i] != s[i + 1]:
                heapq.heappush(stack, [abs(nums[i + 1] - nums[i]), i, i + 1])

        ans = []
        visit = [0] * n
        while stack:
            _, i, j = heapq.heappop(stack)
            if not visit[i] and not visit[j]:
                visit[i] = 1
                visit[j] = 1
                ans.append([i + 1, j + 1])

                y = post[j]
                while y < n and visit[y]:
                    y = post[y]

                x = pre[i]
                while x >= 0 and visit[x]:
                    x = pre[x]
                if x != -1:
                    post[x] = y
                if y != n:
                    pre[y] = x
                if x != -1 and y != n and s[x] != s[y]:
                    heapq.heappush(stack, [abs(nums[x] - nums[y]), x, y])

            else:
                continue
        ac.st(len(ans))
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def abc_237d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc237/tasks/abc237_d
        tag: double_linked_list|implemention|classical
        """
        n = ac.read_int()
        pre = [-1] * (n + 3)
        post = [-1] * (n + 3)
        post[n + 1] = 0
        pre[0] = n + 1
        post[0] = n + 2
        pre[n + 2] = 0
        s = ac.read_str()
        for i in range(1, n + 1):
            if s[i - 1] == "L":
                pre[i] = pre[i - 1]
                post[pre[i - 1]] = i
                pre[i - 1] = i
                post[i] = i - 1
            else:
                post[i] = post[i - 1]
                pre[post[i - 1]] = i
                post[i - 1] = i
                pre[i] = i - 1
        ans = [n + 1]
        while ans[-1] != n + 2:
            ans.append(post[ans[-1]])
        ac.lst(ans[1:-1])
        return

    @staticmethod
    def cf_1922d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1922/D
        tag: double_linked_list|bfs|classical|brain_teaser|implemention
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            n += 1
            a = [0] + ac.read_list_ints()
            d = [math.inf] + ac.read_list_ints()
            pre = list(range(-1, n - 1))
            post = list(range(1, n + 1))
            pre[0] = post[n - 1] = 0
            ans = []
            f = [0] * n
            stack = set(range(1, n))
            for _ in range(n - 1):
                y = set()
                for x in stack:
                    if a[pre[x]] + a[post[x]] > d[x]:
                        y.add(x)
                        f[x] = 1
                ans.append(len(y))
                stack = set()
                for u in y:
                    pre[post[u]] = pre[u]
                    post[pre[u]] = post[u]
                    if not f[pre[u]]:
                        stack.add(pre[u])
                    if not f[post[u]]:
                        stack.add(post[u])
            ac.lst(ans)
        return
"""
Algorithm：list_node|linked_list
Description：

====================================LeetCode====================================
6914（https://leetcode.cn/contest/weekly-contest-358/problems/double-a-number-represented-as-a-linked-list/）linked_list

"""
from typing import Optional

from src.data_structure.list_node.template import ListNode, ListNodeOperation


class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_6914_1(head: Optional[ListNode]) -> Optional[ListNode]:
        """
        url: https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/
        tag: linked_list
        """
        lno = ListNodeOperation()
        lst = lno.node_to_lst(head)[::-1]

        nums = []
        x = 0
        for num in lst:
            x += num * 2
            nums.append(x % 10)
            x = 1 if x >= 10 else 0
        if x:
            nums.append(x)

        nums.reverse()
        return lno.lst_to_node(nums)

    @staticmethod
    def lc_6914_2(head: Optional[ListNode]) -> Optional[ListNode]:
        """
        url: https://leetcode.cn/contest/weekly-contest-358/problems/double-a-number-represented-as-a-linked-list/
        tag: linked_list
        """
        lno = ListNodeOperation()
        num = lno.node_to_num(head) * 2
        return lno.num_to_node(num)
"""
Algorithm：deque|monotonic_queue|monotonic_queue
Description：sliding_window|monotonic

====================================LeetCode====================================
239（https://leetcode.cn/problems/sliding-window-maximum/）sliding_window_maximum
1696（https://leetcode.cn/problems/jump-game-vi/）monotonic_queue|dp
862（https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/description/）prefix_sum|monotonic_queue|dp
1425（https://leetcode.cn/problems/constrained-subsequence-sum/）monotonic_queue|dp


====================================LeetCode====================================
1918D（https://codeforces.com/contest/1918/problem/D）binary_search|greedy|monotonic_queue
1941E（https://codeforces.com/contest/1941/problem/E）monotonic_queue|dp
1976D（https://codeforces.com/contest/1796/problem/D）monotonic_queue|brain_teaser|classical|prefix_min|array_implemention
514D（https://codeforces.com/problemset/problem/514/D）monotonic_queue|two_pointers

=====================================LuoGu======================================
P2251（https://www.luogu.com.cn/problem/P2251）sliding_window_minimum
P2032（https://www.luogu.com.cn/problem/P2032）sliding_window_maximum
P1750（https://www.luogu.com.cn/problem/P1750）pointer|sliding_window|stack|queue
P2311（https://www.luogu.com.cn/problem/P2311）sliding_window
P7175（https://www.luogu.com.cn/problem/P7175）monotonic_queue|implemention
P7793（https://www.luogu.com.cn/problem/P7793）monotonic_queue
P2216（https://www.luogu.com.cn/problem/P2216）sliding_window|sub_matrix
P1886（https://www.luogu.com.cn/problem/P1886）sliding_window
P1725（https://www.luogu.com.cn/problem/P1725）monotonic_queue|pointer|sliding_window|liner_dp
P2827（https://www.luogu.com.cn/problem/P2827）monotonic_queue
P3800（https://www.luogu.com.cn/problem/P3800）monotonic_queue|matrix_dp
P1016（https://www.luogu.com.cn/problem/P1016）monotonic_queue|greedy|implemention
P1714（https://www.luogu.com.cn/problem/P1714）prefix_sum|sliding_window
P2629（https://www.luogu.com.cn/problem/P2629）circular_array|prefix_sum|sliding_window
P3522（https://www.luogu.com.cn/problem/P3522）monotonic_stack
P3957（https://www.luogu.com.cn/problem/P3957）binary_search|monotonic_queue|dp
P4085（https://www.luogu.com.cn/problem/P4085）two_pointers|monotonic_queue|sliding_window
P4392（https://www.luogu.com.cn/problem/P4392）sliding_window|monotonic_queue


=====================================AtCoder=====================================
ABC334F（https://atcoder.jp/contests/abc334/tasks/abc334_f）linear_dp|monotonic_queue|classical


=====================================AcWing=====================================
133（https://www.acwing.com/problem/content/135/）monotonic_queue
135（https://www.acwing.com/problem/content/137/）monotonic_queue

"""
from collections import deque
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.data_structure.monotonic_queue.template import PriorityQueue
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1725(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1725
        tag: monotonic_queue|pointer|sliding_window|liner_dp
        """
        n, low, high = ac.read_list_ints()
        n += 1
        nums = ac.read_list_ints()
        dp = [-math.inf] * n
        dp[0] = nums[0]
        j = 0
        stack = deque()
        for i in range(1, n):
            while stack and stack[0][0] < i - high:
                stack.popleft()
            while j < n and j <= i - low:
                while stack and stack[-1][1] <= dp[j]:
                    stack.pop()
                stack.append([j, dp[j]])
                j += 1
            if stack:
                dp[i] = stack[0][1] + nums[i]
        ans = max(dp[x] for x in range(n) if x + high >= n)
        ac.st(ans)
        return

    @staticmethod
    def lc_239_1(nums: List[int], k: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/sliding-window-maximum/
        tag: sliding_window_maximum
        """
        return PriorityQueue().sliding_window(nums, k)

    @staticmethod
    def lc_239_2(nums: List[int], k: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/sliding-window-maximum/
        tag: sliding_window_maximum|array_implemention
        """
        n = len(nums)
        ind = [0] * (n + 1)
        val = [0] * (n + 1)
        j1 = 1
        j2 = 0
        ans = []
        for i in range(n):
            while j1 <= j2 and ind[j1] < i - k + 1:
                j1 += 1
            while j2 >= j1 and val[j2] < nums[i]:
                j2 -= 1
            j2 += 1
            ind[j2] = i
            val[j2] = nums[i]
            if i >= k - 1:
                ans.append(val[j1])
        return ans

    @staticmethod
    def lc_862(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/description/
        tag: prefix_sum|monotonic_queue|dp
        """
        n = len(nums)
        stack = deque([0])
        ind = deque([-1])
        pre = 0
        ans = n + 1
        for i in range(n):
            pre += nums[i]
            while stack and stack[0] <= pre - k:
                stack.popleft()
                j = ind.popleft()
                if i - j < ans:
                    ans = i - j
            while stack and stack[-1] >= pre:
                stack.pop()
                ind.pop()
            stack.append(pre)
            ind.append(i)
        return ans if ans < n + 1 else -1

    @staticmethod
    def lg_p2032(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2032
        tag: sliding_window_maximum
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = PriorityQueue().sliding_window(nums, k)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p2251(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2251
        tag: sliding_window_minimum
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = PriorityQueue().sliding_window(nums, m, "min")
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p2216(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2216
        tag: sliding_window|sub_matrix|classical|matrix_deque|monotonic_queue
        """
        m, n, k = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]

        ceil = [[0] * n for _ in range(m)]
        floor = [[0] * n for _ in range(m)]
        pq = PriorityQueue()
        for i in range(m):
            ceil[i] = pq.sliding_window_all(grid[i], k, "max")
            floor[i] = pq.sliding_window_all(grid[i], k, "min")
        for j in range(n):
            lst = pq.sliding_window_all([ceil[i][j] for i in range(m)], k, "max")
            for i in range(m):
                ceil[i][j] = lst[i]
            lst = pq.sliding_window_all([floor[i][j] for i in range(m)], k, "min")
            for i in range(m):
                floor[i][j] = lst[i]
        ans = ceil[k - 1][k - 1] - floor[k - 1][k - 1]
        for i in range(k - 1, m):
            for j in range(k - 1, n):
                ans = min(ans, ceil[i][j] - floor[i][j])
        ac.st(ans)
        return

    @staticmethod
    def lg_p1886(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1886
        tag: sliding_window
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans1 = []
        ans2 = []
        ceil = deque()
        floor = deque()
        for i in range(n):
            while ceil and ceil[0] < i - k + 1:
                ceil.popleft()
            while ceil and nums[ceil[-1]] <= nums[i]:
                ceil.pop()
            ceil.append(i)

            while floor and floor[0] < i - k + 1:
                floor.popleft()
            while floor and nums[floor[-1]] >= nums[i]:
                floor.pop()
            floor.append(i)

            if i >= k - 1:
                ans1.append(nums[floor[0]])
                ans2.append(nums[ceil[0]])
        ac.lst(ans1)
        ac.lst(ans2)
        return

    @staticmethod
    def lg_p3800(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3800
        tag: monotonic_queue|matrix_dp
        """
        m, n, k, t = ac.read_list_ints()
        dct = [dict() for _ in range(m)]
        for _ in range(k):
            x, y, val = ac.read_list_ints()
            x -= 1
            y -= 1
            dct[x][y] = val

        dp = [[0] * n for _ in range(2)]
        pre = 0
        for i in range(m):
            cur = 1 - pre
            stack = deque()
            ind = 0
            for j in range(n):
                while stack and stack[0][0] < j - t:
                    stack.popleft()
                while ind < n and ind <= j + t:
                    while stack and stack[-1][1] <= dp[pre][ind]:
                        stack.pop()
                    stack.append([ind, dp[pre][ind]])
                    ind += 1
                dp[cur][j] = dct[i].get(j, 0) + stack[0][1]
            pre = cur
        ac.st(max(dp[pre]))
        return

    @staticmethod
    def ac_133(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/135/
        tag: monotonic_queue
        """
        n, m, q, u, v, t = ac.read_list_ints()
        nums1 = ac.read_list_ints()
        nums1 = deque(sorted(nums1, reverse=True))
        nums2 = deque()
        nums3 = deque()
        delta = 0
        ans1 = []
        ans2 = []
        for i in range(1, m + 1):
            a = nums1[0] + delta if nums1 else -math.inf
            b = nums2[0] + delta if nums2 else -math.inf
            c = nums3[0] + delta if nums3 else -math.inf
            if a >= b and a >= c:
                x = a
                nums1.popleft()
                x1 = x * u // v
                nums2.append(x1 - delta - q)
                nums3.append(x - x1 - delta - q)
            elif b >= c and b >= a:
                x = b
                nums2.popleft()
                x1 = x * u // v
                nums2.append(x1 - delta - q)
                nums3.append(x - x1 - delta - q)
            else:
                x = c
                nums3.popleft()
                x1 = x * u // v
                nums2.append(x1 - delta - q)
                nums3.append(x - x1 - delta - q)
            delta += q
            if i % t == 0:
                ans1.append(x)

        ind = 0
        while nums1 or nums2 or nums3:
            a = nums1[0] + delta if nums1 else -math.inf
            b = nums2[0] + delta if nums2 else -math.inf
            c = nums3[0] + delta if nums3 else -math.inf
            if a >= b and a >= c:
                x = a
                nums1.popleft()
            elif b >= c and b >= a:
                x = b
                nums2.popleft()
            else:
                x = c
                nums3.popleft()
            ind += 1
            if ind % t == 0:
                ans2.append(x)
        ac.lst(ans1)
        ac.lst(ans2)
        return

    @staticmethod
    def lg_p1016(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1016
        tag: monotonic_queue|greedy|implemention|classical
        """
        d1, c, d2, p, n = ac.read_list_floats()
        n = int(n)
        nums = [[0, p]] + [ac.read_list_floats() for _ in range(n)] + [[d1, 0]]
        nums.sort()
        stack = deque([[p, c]])
        ans = 0
        in_stack = c
        n = len(nums)
        for i in range(1, n):
            dis = nums[i][0] - nums[i - 1][0]
            if in_stack * d2 < dis:
                ac.st("No Solution")
                return
            while dis:
                x = min(dis / d2, stack[0][1])
                ans += x * stack[0][0]
                dis -= x * d2
                stack[0][1] -= x
                in_stack -= x
                if not stack[0][1]:
                    stack.popleft()
            cur_p = nums[i][1]
            while stack and stack[-1][0] >= cur_p:
                in_stack -= stack.pop()[1]
            stack.append([cur_p, c - in_stack])
            in_stack = c
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p1714(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1714
        tag: prefix_sum|sliding_window
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = max(nums)
        pre = 0
        stack = deque([[-1, 0]])
        for i in range(n):
            pre += nums[i]
            while stack and stack[0][0] <= i - m - 1:
                stack.popleft()
            while stack and stack[-1][1] >= pre:
                stack.pop()
            stack.append([i, pre])
            if stack:
                ans = max(ans, pre - stack[0][1])
        ac.st(ans)
        return

    @staticmethod
    def lg_p2629(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2629
        tag: circular_array|prefix_sum|sliding_window|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = pre = 0
        stack = deque([(0, 0)])
        lst = [0]
        for i in range(1, n * 2):
            pre += nums[i % n]
            while stack and stack[0][0] <= i - n:
                stack.popleft()
            while stack and stack[-1][1] >= pre:
                stack.pop()
            stack.append((i, pre))
            if i >= n:
                if stack[0][1] >= lst[i - n]:
                    ans += 1
            if i <= n:
                lst.append(pre)
        ac.st(ans)
        return

    @staticmethod
    def lg_p3957(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3957
        tag: binary_search|monotonic_queue|dp
        """
        n, d, k = ac.read_list_ints()
        dis = [0]
        score = [0]
        for _ in range(n):
            x, s = ac.read_list_ints()
            dis.append(x)
            score.append(s)
        n += 1

        def check(g):
            dp = [-math.inf] * n
            stack = deque()
            dp[0] = score[0]
            floor = max(1, d - g)
            ceil = d + g
            j = 0
            for i in range(1, n):
                while stack and stack[0][1] < dis[i] - ceil:
                    stack.popleft()
                while j < n and dis[i] - dis[j] >= floor:
                    if dis[i] - dis[j] > ceil:
                        j += 1
                        continue
                    while stack and stack[-1][0] <= dp[j]:
                        stack.pop()
                    stack.append([dp[j], dis[j]])
                    j += 1
                if stack:
                    dp[i] = stack[0][0] + score[i]
                    if dp[i] >= k:
                        return True
            return False

        ans = BinarySearch().find_int_left(0, dis[-1], check)
        ac.st(ans if check(ans) else -1)
        return

    @staticmethod
    def lg_p4085(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4085
        tag: two_pointers|monotonic_queue|sliding_window
        """
        n, m = ac.read_list_ints()
        f = []
        s = []
        for i in range(n):
            a, b = ac.read_list_ints()
            f.append(a)
            s.append(b)

        ans = math.inf
        stack = deque([])
        j = pre = 0
        for i in range(n):
            while stack and stack[0][0] < i:
                stack.popleft()
            while j < n and pre < m:
                pre += f[j]
                while stack and stack[-1][1] <= s[j]:
                    stack.pop()
                stack.append([j, s[j]])
                j += 1
            if pre >= m:
                ans = min(ans, stack[0][1])
            pre -= f[i]
        ac.st(ans)
        return

    @staticmethod
    def lg_p4392(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4392
        tag: sliding_window|monotonic_queue
        """
        n, m, c = ac.read_list_ints()
        ceil = deque()
        floor = deque()
        nums = ac.read_list_ints()
        ans = False
        for i in range(n):

            while ceil and ceil[0] <= i - m:
                ceil.popleft()
            while floor and floor[0] <= i - m:
                floor.popleft()

            while ceil and nums[ceil[-1]] <= nums[i]:
                ceil.pop()
            ceil.append(i)

            while floor and nums[floor[-1]] >= nums[i]:
                floor.pop()
            floor.append(i)

            if i >= m - 1 and nums[ceil[0]] - nums[floor[0]] <= c:
                ac.st(i - m + 2)
                ans = True
        if not ans:
            ac.st("NONE")
        return

    @staticmethod
    def cf_1918d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1918/problem/D
        tag: binary_search|greedy|monotonic_queue
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            pre = ac.accumulate(nums)

            def check(x):
                dp = [math.inf] * (n + 1)
                dp[0] = 0
                stack = deque([0])
                for i in range(n):
                    while stack and pre[i] - pre[stack[0]] > x:
                        stack.popleft()
                    dp[i + 1] = dp[stack[0]] + nums[i]
                    while stack and dp[stack[-1]] > dp[i + 1]:
                        stack.pop()
                    stack.append(i + 1)
                    if dp[i + 1] <= x and pre[-1] - pre[i + 1] <= x:
                        return True
                return False

            ans = BinarySearch().find_int_left(0, sum(nums), check)
            ac.st(ans)
        return

    @staticmethod
    def abc_334f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc334/tasks/abc334_f
        tag: linear_dp|monotonic_queue|classical
        """
        n, k = ac.read_list_ints()
        sx, sy = ac.read_list_ints()
        lst = [[0, 0]] + [ac.read_list_ints() for _ in range(n)]

        def dis(x1, y1, x2, y2):
            return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

        pre = [0] * (n + 1)
        for i in range(2, n + 1):
            pre[i] = pre[i - 1] + dis(lst[i - 1][0], lst[i - 1][1], lst[i][0], lst[i][1])

        dis0 = [math.inf] + [dis(sx, sy, x, y) for x, y in lst[1:]]
        stack = deque([0])
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        for i in range(1, n + 1):
            while stack and i - stack[0] > k:
                stack.popleft()
            j = stack[0]
            dp[i] = dp[j] + dis0[j + 1] - pre[j + 1] + dis0[i] + pre[i]
            while (stack and i < n and dp[i] + dis0[i + 1] - pre[i + 1]
                   < dp[stack[-1]] + dis0[stack[-1] + 1] - pre[stack[-1] + 1]):
                stack.pop()
            stack.append(i)
        ac.st(dp[-1])
        return

    @staticmethod
    def cf_1796d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1796/problem/D
        tag: monotonic_queue|brain_teaser|classical|prefix_min|array_implemention
        """
        for _ in range(ac.read_int()):
            n, k, x = ac.read_list_ints()
            if x < 0:
                x = -x
                k = n - k
            nums = ac.read_list_ints()
            nums = [num - x for num in nums]

            # > k
            ans = pre = 0
            pre_min = [0] * (n + 1)
            pre_min[0] = 0
            for i in range(n):
                pre += nums[i]
                if i >= k:
                    ans = max(ans, pre - pre_min[i - k] + 2 * k * x)
                pre_min[i + 1] = min(pre_min[i], pre)

            # <= k
            ind = [-1] * (n + 1)
            val = [0] * (n + 1)  # array_implemention
            j1 = j2 = 0
            pre = 0
            for i in range(n):
                pre += nums[i] + 2 * x
                while j1 <= j2 and i - ind[j1] > k:
                    j1 += 1
                while j2 >= j1 and val[j2] > pre:
                    j2 -= 1
                j2 += 1
                ind[j2] = i
                val[j2] = pre
                ans = max(ans, pre - val[j1])
            ac.st(ans)
        return

    @staticmethod
    def cf_514d_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/514/D
        tag: monotonic_queue|two_pointers
        """
        n, m, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = j = 0
        res = []
        stack = [deque() for _ in range(m)]
        for i in range(n):
            for x in range(m):
                while stack[x] and stack[x][-1][1] < nums[i][x]:
                    stack[x].pop()
                stack[x].append((i, nums[i][x]))
            while sum(st[0][1] for st in stack if st) > k:
                for x in range(m):
                    if j == stack[x][0][0]:
                        stack[x].popleft()
                j += 1
            if i - j + 1 > ans:
                ans = i - j + 1
                res = [st[0][1] for st in stack]
        if not res:
            res = [0] * m
        ac.lst(res)
        return

    @staticmethod
    def cf_514d_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/514/D
        tag: monotonic_queue|two_pointers
        """
        n, m, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = j = 0
        res = []
        ind = [[0] * (n + 1) for _ in range(m)]
        val = [[0] * (n + 1) for _ in range(m)]
        j1 = [1] * m
        j2 = [0] * m
        for i in range(n):
            for x in range(m):
                while j2[x] >= j1[x] and val[x][j2[x]] < nums[i][x]:
                    j2[x] -= 1
                j2[x] += 1
                ind[x][j2[x]] = i
                val[x][j2[x]] = nums[i][x]
            while j <= i and sum(val[x][j1[x]] for x in range(m)) > k:
                for x in range(m):
                    if ind[x][j1[x]] == j:
                        j1[x] += 1
                j += 1
            if i - j + 1 > ans:
                ans = i - j + 1
                res = [val[x][j1[x]] for x in range(m)]
        if not res:
            res = [0] * m
        ac.lst(res)
        return
"""
Algorithm：monotonic_stack|contribution_method
Description：prefix_suffix|maximum|minimum|second_maximum

====================================LeetCode====================================
85（https://leetcode.cn/problems/maximal-rectangle/）brute_force|monotonic_stack|matrix
316（https://leetcode.cn/problems/remove-duplicate-letters/）monotonic_stack|hash|counter
321（https://leetcode.cn/problems/create-maximum-number/）brute_force|monotonic_stack
1081（https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/）monotonic_stack|hash|counter
2334（https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/）sort|brute_force|contribution_method
2262（https://leetcode.cn/problems/total-appeal-of-a-string/）prefix_suffix|monotonic_stack
2355（https://leetcode.cn/problems/maximum-number-of-books-you-can-take/）monotonic_stack|liner_dp
255（https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/）monotonic_stack|pre_order
654（https://leetcode.cn/problems/maximum-binary-tree/）monotonic_stack
1130（https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/）monotonic_stack|interval_dp
1504（https://leetcode.cn/problems/count-submatrices-with-all-ones/）brute_force|monotonic_stack|counter|sub_matrix
1673（https://leetcode.cn/problems/find-the-most-competitive-subsequence/）monotonic_stack|greedy
1776（https://leetcode.cn/problems/car-fleet-ii/）monotonic_stack|union_find|linked_list|implemention
1840（https://leetcode.cn/problems/maximum-building-height/）monotonic_stack|greedy|prefix_suffix|implemention
1944（https://leetcode.cn/problems/number-of-visible-people-in-a-queue/）reverse_thinking|monotonic_stack
1950（https://leetcode.cn/problems/maximum-of-minimum-values-in-all-subarrays/）monotonic_stack
2030（https://leetcode.cn/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/）monotonic_stack|greedy|lexicographical_order
2104（https://leetcode.cn/problems/sum-of-subarray-ranges/）monotonic_stack|contribution_method
2282（https://leetcode.cn/problems/number-of-people-that-can-be-seen-in-a-grid/）monotonic_stack
2289（https://leetcode.cn/problems/steps-to-make-array-non-decreasing/）monotonic_stack|implemention
907（https://leetcode.cn/problems/sum-of-subarray-minimums/）monotonic_stack|implemention
2454（https://leetcode.cn/problems/next-greater-element-iv/description/）monotonic_stack|post_second_larger
2866（https://leetcode.cn/problems/beautiful-towers-ii/）monotonic_stack|greedy
3113（https://leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/）brute_force|teo_pointer|monotonic_stack|classical）

=====================================LuoGu======================================
P1950（https://www.luogu.com.cn/problem/P1950）brute_force|monotonic_stack|sub_matrix|counter
P1901（https://www.luogu.com.cn/problem/P1901）monotonic_stack
P2866（https://www.luogu.com.cn/problem/P2866）monotonic_stack
P2947（https://www.luogu.com.cn/problem/P2947）monotonic_stack
P4147（https://www.luogu.com.cn/problem/P4147）brute_force|monotonic_stack|sub_matrix|area
P5788（https://www.luogu.com.cn/problem/P5788）monotonic_stack
P7314（https://www.luogu.com.cn/problem/P7314）brute_force|monotonic_stack|pre_larger|post_larger
P7399（https://www.luogu.com.cn/problem/P7399）monotonic_stack|greedy
P7410（https://www.luogu.com.cn/problem/P7410）inclusion_exclusion|monotonic_stack|counter
P7762（https://www.luogu.com.cn/problem/P7762）monotonic_stack|greedy|sort|contribution_method|area
P1578（https://www.luogu.com.cn/problem/P1578）monotonic_stack|discretization|brute_force|sub_matrix|area
P3467（https://www.luogu.com.cn/problem/P3467）greedy|monotonic_stack
P1191（https://www.luogu.com.cn/problem/P1191）monotonic_stack|sub_matrix|counter
P1323（https://www.luogu.com.cn/problem/P1323）heapq|monotonic_stack|lexicographical_order|greedy
P2422（https://www.luogu.com.cn/problem/P2422）monotonic_stack|prefix_sum
P3467（https://www.luogu.com.cn/problem/P3467）monotonic_stack
P6404（https://www.luogu.com.cn/problem/P6404）monotonic_stack|sub_matrix|counter
P6503（https://www.luogu.com.cn/problem/P6503）monotonic_stack|counter|contribution_method
P6510（https://www.luogu.com.cn/problem/P6510）monotonic_stack|sparse_table|hash|binary_search
P6801（https://www.luogu.com.cn/problem/P6801）monotonic_stack|sub_matrix|counter
P8094（https://www.luogu.com.cn/problem/P8094）monotonic_stack|pre_larger|post_larger

===================================CodeForces===================================
1795E（https://codeforces.com/problemset/problem/1795/E）monotonic_stack|liner_dp|greedy|counter|brute_force|prefix_suffix|dp
1313C2（https://codeforces.com/problemset/problem/1313/C2）monotonic_stack|liner_dp
1454F（https://codeforces.com/contest/1454/problem/F）monotonic_stack|brute_force
1092D2（https://codeforces.com/contest/1092/problem/D2）monotonic_stack|implemention
1092D1（https://codeforces.com/contest/1092/problem/D1）brain_teaser|greedy|implemention
1506G（https://codeforces.com/contest/1506/problem/G）monotonic_stack|greedy|classical
1919D（https://codeforces.com/problemset/problem/1919/D）brain_teaser|monotonic_stack|construction
1299C（https://codeforces.com/problemset/problem/1299/C）monotonic_stack|convex|brain_teaser|greedy|construction
1407D（https://codeforces.com/problemset/problem/1407/D）array_implemention|monotonic_stack|linear_dp|classical

====================================AtCoder=====================================
ABC140E（https://atcoder.jp/contests/abc140/tasks/abc140_e）monotonic_stack|pre_pre_larger|post_post_larger
ABC336D（https://atcoder.jp/contests/abc336/tasks/abc336_d）monotonic_stack|linear_dp
ABC311G（https://atcoder.jp/contests/abc311/tasks/abc311_g）brute_force|prefix_sum|monotonic_stack|classical
ABC299G（https://atcoder.jp/contests/abc299/tasks/abc299_g）monotonic_stack|greedy|implemention|classical
ABC359E（https://atcoder.jp/contests/abc359/tasks/abc359_e）monotonic_stack|implemention|classical

=====================================AcWing=====================================
131（https://www.acwing.com/problem/content/133/）monotonic_stack|sub_matrix
152（https://www.acwing.com/problem/content/description/154/）monotonic_stack|sub_matrix
3780（https://www.acwing.com/problem/content/description/3783/）monotonic_stack|greedy|linear_dp|construction

"""
import bisect
import heapq
from collections import defaultdict, Counter
from typing import List

from src.basis.diff_array.template import PreFixSumMatrix
from src.data_structure.monotonic_stack.template import Rectangle
from src.data_structure.sparse_table.template import SparseTable
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_140e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc140/tasks/abc140_e
        tag: monotonic_stack|pre_pre_larger|post_post_larger|classical|contribution_method
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        post = [-1] * n
        post2 = [-1] * n
        stack1 = []
        stack2 = []
        for i in range(n):
            while stack2 and stack2[0][0] < nums[i]:
                post2[heapq.heappop(stack2)[1]] = i
            while stack1 and nums[stack1[-1]] < nums[i]:
                j = stack1.pop()
                post[j] = i
                heapq.heappush(stack2, [nums[j], j])
            stack1.append(i)

        pre = [-1] * n
        pre2 = [-1] * n
        stack1 = []
        stack2 = []
        for i in range(n - 1, -1, -1):
            while stack2 and stack2[0][0] < nums[i]:
                pre2[heapq.heappop(stack2)[1]] = i
            while stack1 and nums[stack1[-1]] < nums[i]:
                j = stack1.pop()
                pre[j] = i
                heapq.heappush(stack2, [nums[j], j])
            stack1.append(i)

        # action_scope
        ans = 0
        for i in range(n):
            if pre[i] == -1:
                left_0 = i
                left_1 = 0
            else:
                left_0 = i - pre[i] - 1
                if pre2[i] == -1:
                    left_1 = pre[i] + 1
                else:
                    left_1 = pre[i] - pre2[i]

            if post[i] == -1:
                right_0 = n - 1 - i
                right_1 = 0
            else:
                right_0 = post[i] - i - 1
                if post2[i] == -1:
                    right_1 = n - 1 - post[i] + 1
                else:
                    right_1 = post2[i] - post[i]
            cnt = left_1 * (right_0 + 1) + right_1 * (left_0 + 1)
            ans += cnt * nums[i]
        ac.st(ans)
        return

    @staticmethod
    def ac_131(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/133/
        tag: monotonic_stack|sub_matrix
        """
        while True:
            lst = ac.read_list_ints()
            if lst[0] == 0:
                break
            n = lst.pop(0)
            post = [n - 1] * n
            pre = [0] * n
            stack = []
            for i in range(n):
                while stack and lst[stack[-1]] > lst[i]:
                    post[stack.pop()] = i - 1
                if stack:
                    pre[i] = stack[-1] + 1
                stack.append(i)
            ans = max(lst[i] * (post[i] - pre[i] + 1) for i in range(n))
            ac.st(ans)
        return

    @staticmethod
    def lc_2454(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/next-greater-element-iv/description/
        tag: monotonic_stack|post_second_larger
        """
        n = len(nums)
        ans = [-1] * n
        stack1 = []
        stack2 = []
        for i in range(n):
            while stack2 and stack2[0][0] < nums[i]:
                ans[heapq.heappop(stack2)[1]] = nums[i]
            while stack1 and nums[stack1[-1]] < nums[i]:
                j = stack1.pop()
                heapq.heappush(stack2, [nums[j], j])
            stack1.append(i)
        return ans

    @staticmethod
    def lc_2866(max_heights: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/beautiful-towers-ii/
        tag: monotonic_stack|greedy
        """
        n = len(max_heights)
        pre = [0] * (n + 1)
        stack = []
        s = 0
        for i in range(n):
            h = max_heights[i]
            c = 1
            while stack and stack[-1][0] >= h:
                v, cc = stack.pop()
                c += cc
                s -= v * cc
            s += h * c
            pre[i + 1] = s
            stack.append([h, c])

        post = [0] * (n + 1)
        stack = []
        s = 0
        for i in range(n - 1, -1, -1):
            h = max_heights[i]
            c = 1
            while stack and stack[-1][0] >= h:
                v, cc = stack.pop()
                c += cc
                s -= v * cc
            s += h * c
            post[i] = s
            stack.append([h, c])

        return max(pre[i + 1] + post[i] - max_heights[i] for i in range(n))

    @staticmethod
    def lg_p1191(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1191
        tag: monotonic_stack|sub_matrix|counter|classical
        """
        n = ac.read_int()
        pre = [0] * n
        ans = 0
        for _ in range(n):
            s = ac.read_str()
            right = [n - 1] * n
            left = [0] * n
            stack = []
            for j in range(n):
                if s[j] == "W":
                    pre[j] += 1
                else:
                    pre[j] = 0
                while stack and pre[stack[-1]] > pre[j]:
                    right[stack.pop()] = j - 1
                if stack:
                    left[j] = stack[-1] + 1
                stack.append(j)
            ans += sum(pre[j] * (right[j] - j + 1) * (j - left[j] + 1) for j in range(n))
        ac.st(ans)
        return

    @staticmethod
    def lg_p1323(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1323
        tag: heapq|monotonic_stack|lexicographical_order|greedy
        """
        k, m = ac.read_list_ints()
        dct = set()
        ans = []
        stack = [1]
        while len(ans) < k:
            num = heapq.heappop(stack)
            if num in dct:
                continue
            ans.append(num)
            dct.add(num)
            heapq.heappush(stack, 2 * num + 1)
            heapq.heappush(stack, 4 * num + 5)

        res = "".join(str(x) for x in ans)
        ac.st(res)
        rem = m
        stack = []
        for w in res:
            while stack and rem and w > stack[-1]:
                stack.pop()
                rem -= 1
            stack.append(w)
        stack = stack[rem:]
        ac.st(int("".join(stack)))
        return

    @staticmethod
    def lg_p2422(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2422
        tag: monotonic_stack|prefix_sum
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        lst = ac.accumulate(nums)
        post = [n - 1] * n
        pre = [0] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] > nums[i]:
                post[stack.pop()] = i - 1
            if stack:
                pre[i] = stack[-1] + 1
            stack.append(i)
        ans = max(nums[i] * (lst[post[i] + 1] - lst[pre[i]]) for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def lg_p3467(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3467
        tag: monotonic_stack|classical
        """
        n = ac.read_int()
        nums = [ac.read_list_ints()[1] for _ in range(n)]
        stack = []
        ans = 0
        for i in range(n):
            while stack and nums[stack[-1]] >= nums[i]:
                j = stack.pop()
                if nums[j] == nums[i]:
                    ans += 1
            stack.append(i)
        ac.st(n - ans)
        return

    @staticmethod
    def lg_p1578(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1578
        tag: monotonic_stack|discretization|brute_force|sub_matrix|area
        """
        m, n = ac.read_list_ints()
        q = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(q)]
        node_col = [[] for _ in range(n + 1)]
        for x, y in nums:
            node_col[y].append(x)

        y_axis = sorted(set([y for _, y in nums] + [0, n]), reverse=True)
        ans = 0
        col = [n] * (m + 1)
        x_axis = sorted(set([x for x, _ in nums] + [0, m]))
        k = len(x_axis)
        for y in y_axis:
            height = [col[x] - y for x in x_axis]
            left = [0] * k
            right = [k - 1] * k
            stack = []
            for i in range(k):
                while stack and height[stack[-1]] > height[i]:
                    right[stack.pop()] = i
                if stack:
                    left[i] = stack[-1]
                stack.append(i)

            for i in range(k):
                cur = height[i] * (x_axis[right[i]] - x_axis[left[i]])
                ans = ans if ans > cur else cur

            for x in node_col[y]:
                col[x] = y
        # special case judge
        ceil = max(x_axis[i + 1] - x_axis[i] for i in range(k - 1))
        if ceil * n > ans:
            ans = ceil * n
        ac.st(ans)
        return

    @staticmethod
    def lc_255(preorder: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/
        tag: monotonic_stack|pre_order|classical
        """
        pre_max = -math.inf
        n = len(preorder)
        stack = []
        for i in range(n):
            if preorder[i] < pre_max:
                return False
            while stack and preorder[stack[-1]] < preorder[i]:
                cur = preorder[stack.pop()]
                pre_max = pre_max if pre_max > cur else cur
            stack.append(i)
        return True

    @staticmethod
    def lc_85(matrix: List[List[str]]) -> int:
        """
        url: https://leetcode.cn/problems/maximal-rectangle/
        tag: brute_force|monotonic_stack|matrix
        """
        m, n = len(matrix), len(matrix[0])
        pre = [0] * n
        ans = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == "1":
                    pre[j] += 1
                else:
                    pre[j] = 0
            ans = max(ans, Rectangle().compute_area(pre))
        return ans

    @staticmethod
    def lg_p4147(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4147
        tag: brute_force|monotonic_stack|sub_matrix|area
        """
        n, m = ac.read_list_ints()
        pre = [0] * m
        ans = 0
        for _ in range(n):
            lst = ac.read_list_strs()
            for i in range(m):
                if lst[i] == "F":
                    pre[i] += 1
                else:
                    pre[i] = 0
            ans = max(ans, Rectangle().compute_area(pre))
        ac.st(3 * ans)
        return

    @staticmethod
    def lg_p1950(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1950
        tag: brute_force|monotonic_stack|sub_matrix|counter
        """
        m, n = ac.read_list_ints()
        ans = 0
        pre = [0] * n
        for _ in range(m):
            s = ac.read_str()
            for j in range(n):
                if s[j] == ".":
                    pre[j] += 1
                else:
                    pre[j] = 0
            ans += Rectangle().compute_number(pre)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6404(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6404
        tag: monotonic_stack|sub_matrix|counter
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        ans = 0
        rt = Rectangle()
        pre = [[0, 0] for _ in range(n)]
        for i in range(m):
            for j in range(n):
                if pre[j][0] == grid[i][j]:
                    pre[j][1] += 1
                else:
                    pre[j] = [grid[i][j], 1]

            lst = [pre[0][1]]
            num = pre[0][0]
            for x, c in pre[1:]:
                if x == num:
                    lst.append(c)
                else:
                    ans += rt.compute_number(lst)
                    lst = [c]
                    num = x
            ans += rt.compute_number(lst)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6503(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6503
        tag: monotonic_stack|counter|contribution_method
        """
        m = ac.read_int()
        nums = [ac.read_int() for _ in range(m)]
        left = [0] * m
        right = [m - 1] * m
        stack = []
        for i in range(m):
            while stack and nums[stack[-1]] < nums[i]:
                right[stack.pop()] = i - 1
            if stack:
                left[i] = stack[-1] + 1
            stack.append(i)
        ans = sum((right[i] - i + 1) * nums[i] * (i - left[i] + 1) for i in range(m))

        left = [0] * m
        right = [m - 1] * m
        stack = []
        for i in range(m):
            while stack and nums[stack[-1]] > nums[i]:
                right[stack.pop()] = i - 1
            if stack:
                left[i] = stack[-1] + 1
            stack.append(i)
        ans -= sum((right[i] - i + 1) * nums[i] * (i - left[i] + 1) for i in range(m))
        ac.st(ans)
        return

    @staticmethod
    def lg_p6510(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6510
        tag: monotonic_stack|sparse_table|hash|binary_search|classical
        """
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        post = [n - 1] * n
        stack = []
        dct = defaultdict(list)
        for i in range(n):
            while stack and nums[stack[-1]] >= nums[i]:
                post[stack.pop()] = i - 1
            stack.append(i)
            dct[nums[i]].append(i)
        st = SparseTable(nums)
        ans = 0
        for i in range(n):
            x = st.query(i + 1, post[i] + 1)
            if x == nums[i]:
                continue
            j = bisect.bisect_left(dct[x], i)
            ans = max(ans, dct[x][j] - i + 1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6801(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6801
        tag: monotonic_stack|sub_matrix|counter
        """

        def compute(x, y):
            return x * (x + 1) * y * (y + 1) // 4

        ans = 0
        mod = 10 ** 9 + 7
        n = ac.read_int()
        h = ac.read_list_ints()
        w = ac.read_list_ints()

        stack = []
        for i in range(n):
            ww, hh = w[i], h[i]
            while stack and stack[-1][1] >= hh:
                www, hhh = stack.pop()
                if stack and stack[-1][1] >= hh:
                    max_h = stack[-1][1]
                    ans += compute(www, hhh) - compute(www, max_h)
                    ans %= mod
                    stack[-1][0] += www
                else:
                    ww += www
                    ans += compute(www, hhh) - compute(www, hh)
                    ans %= mod
            stack.append([ww, hh])

        ww, hh = stack.pop()
        while stack:
            www, hhh = stack.pop()
            ans += compute(ww, hh) - compute(ww, hhh)
            ans %= mod
            ww += www
            hh = hhh
        ans += compute(ww, hh)
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p8094(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8094
        tag: monotonic_stack|pre_larger|post_larger
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = 0
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] < nums[i]:
                ans += i - stack.pop() + 1
            if stack:
                ans += i - stack[-1] + 1
            stack.append(i)
        ac.st(ans)
        return

    @staticmethod
    def lc_316(s: str) -> str:
        """
        url: https://leetcode.cn/problems/remove-duplicate-letters/
        tag: monotonic_stack|hash|counter
        """
        cnt = Counter(s)
        in_stack = defaultdict(int)
        stack = []
        for w in s:
            if not in_stack[w]:
                while stack and stack[-1] > w and cnt[stack[-1]]:
                    in_stack[stack.pop()] = 0
                stack.append(w)
                in_stack[w] = 1
            cnt[w] -= 1
        return "".join(stack)

    @staticmethod
    def lc_907(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/sum-of-subarray-minimums/
        tag: monotonic_stack|implemention|contribution_method|classical
        """
        mod = 10 ** 9 + 7
        n = len(nums)
        post = [n - 1] * n
        pre = [0] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] <= nums[i]:
                post[stack.pop()] = i - 1
            if stack:
                pre[i] = stack[-1] + 1
            stack.append(i)
        return sum(nums[i] * (i - pre[i] + 1) * (post[i] - i + 1) for i in range(n)) % mod

    @staticmethod
    def lc_1081(s: str) -> str:
        """
        url: https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/
        tag: monotonic_stack|hash|counter
        """
        cnt = Counter(s)
        in_stack = defaultdict(int)
        stack = []
        for w in s:
            if not in_stack[w]:
                while stack and stack[-1] > w and cnt[stack[-1]]:
                    in_stack[stack.pop()] = 0
                stack.append(w)
                in_stack[w] = 1
            cnt[w] -= 1
        return "".join(stack)

    @staticmethod
    def lc_1673(nums: List[int], k: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/find-the-most-competitive-subsequence/
        tag: monotonic_stack|greedy
        """
        n = len(nums)
        rem = n - k
        stack = []
        for num in nums:
            while stack and stack[-1] > num and rem:
                rem -= 1
                stack.pop()
            stack.append(num)
        return stack[:k]

    @staticmethod
    def lc_1840(n: int, restrictions: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-building-height/
        tag: monotonic_stack|greedy|prefix_suffix|implemention
        """
        restrictions.sort()
        stack = [[1, 0]]
        for idx, height in restrictions:
            if height - stack[-1][1] >= idx - stack[-1][0]:
                continue
            while idx - stack[-1][0] <= stack[-1][1] - height:
                stack.pop()
            stack.append([idx, height])

        height = stack[-1][1] + n - stack[-1][0]
        for i in range(len(stack) - 1):
            tmp = (stack[i + 1][0] - stack[i][0] + stack[i][1] + stack[i + 1][1]) // 2
            height = height if height > tmp else tmp
        return height

    @staticmethod
    def lc_2262(s: str) -> int:
        """
        url: https://leetcode.cn/problems/total-appeal-of-a-string/
        tag: prefix_suffix|monotonic_stack
        """
        n = len(s)
        pre = defaultdict(lambda: -1)
        ans = 0
        for i in range(n):
            ans += (i - pre[s[i]]) * (n - i)
            pre[s[i]] = i
        return ans

    @staticmethod
    def lc_2355(books: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-books-you-can-take/
        tag: monotonic_stack|liner_dp
        """
        n = len(books)
        dp = [0] * n
        stack = []
        for i in range(n):

            while stack and stack[-1][0] >= books[i] - i:
                stack.pop()

            end = books[i]
            size = i + 1 if not stack else i - stack[-1][1]
            size = size if size < end else end
            cur = (end + end - size + 1) * size // 2

            dp[i] = dp[stack[-1][1]] + cur if stack else cur
            stack.append([books[i] - i, i])
        return max(dp)

    @staticmethod
    def cf_1313c2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1313/C2
        tag: monotonic_stack|liner_dp|specific_plan
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [0] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] > nums[i]:
                stack.pop()
            if not stack:
                pre[i] = nums[i] * (i + 1)
            else:
                pre[i] = pre[stack[-1]] + nums[i] * (i - stack[-1])
            stack.append(i)

        post = [0] * n
        stack = []
        for i in range(n - 1, -1, -1):
            while stack and nums[stack[-1]] > nums[i]:
                stack.pop()
            if not stack:
                post[i] = nums[i] * (n - i)
            else:
                post[i] = post[stack[-1]] + nums[i] * (stack[-1] - i)
            stack.append(i)

        ceil = max(pre[i] + post[i] - nums[i] for i in range(n))
        for i in range(n):
            if pre[i] + post[i] - nums[i] == ceil:
                for j in range(i + 1, n):
                    nums[j] = min(nums[j], nums[j - 1])
                for j in range(i - 1, -1, -1):
                    nums[j] = min(nums[j], nums[j + 1])
                ac.lst(nums)
                break
        return

    @staticmethod
    def cf_1795e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1795/E
        tag: monotonic_stack|liner_dp|greedy|counter|brute_force|prefix_suffix|dp
        """
        for _ in range(ac.read_int()):

            def check():
                res = [0] * n
                stack = []
                for i in range(n):
                    while stack and nums[stack[-1]] - stack[-1] > nums[i] - i:
                        stack.pop()
                    if not stack:
                        k = min(i, nums[i] - 1)
                        res[i] = k * (nums[i] - 1 + nums[i] - k) // 2
                    else:
                        k = min(i - stack[-1] - 1, nums[i] - 1)
                        res[i] = k * (nums[i] - 1 + nums[i] - k) // 2 + nums[stack[-1]] + res[stack[-1]]
                    stack.append(i)
                return res

            n = ac.read_int()
            nums = ac.read_list_ints()
            pre = check()
            nums.reverse()
            post = check()
            ans = sum(nums) - max(pre[i] + post[n - 1 - i] for i in range(n))
            ac.st(ans)
        return

    @staticmethod
    def lc_1130(arr: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/
        tag: monotonic_stack|interval_dp|classical
        """
        stack = [math.inf]
        res = 0
        for num in arr:
            while stack and stack[-1] <= num:
                cur = stack.pop(-1)
                res += min(stack[-1] * cur, cur * num)
            stack.append(num)
        m = len(stack)
        for i in range(m - 2, 0, -1):
            res += stack[i] * stack[i + 1]
        return res

    @staticmethod
    def lc_1504(mat: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/count-submatrices-with-all-ones/
        tag: brute_force|monotonic_stack|counter|sub_matrix
        """
        m, n = len(mat), len(mat[0])
        ans = 0
        rec = Rectangle()
        pre = [0] * n
        for j in range(m):
            for k in range(n):
                if mat[j][k]:
                    pre[k] += 1
                else:
                    pre[k] = 0
            ans += rec.compute_number(pre)
        return ans

    @staticmethod
    def ac_3780(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3783/
        tag: monotonic_stack|greedy|linear_dp|construction|CF1313C2
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [0] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] > nums[i]:
                stack.pop()
            if not stack:
                pre[i] = nums[i] * (i + 1)
            else:
                pre[i] = pre[stack[-1]] + nums[i] * (i - stack[-1])
            stack.append(i)

        post = [0] * n
        stack = []
        for i in range(n - 1, -1, -1):
            while stack and nums[stack[-1]] > nums[i]:
                stack.pop()
            if not stack:
                post[i] = nums[i] * (n - i)
            else:
                post[i] = post[stack[-1]] + nums[i] * (stack[-1] - i)
            stack.append(i)

        ceil = max(pre[i] + post[i] - nums[i] for i in range(n))
        for i in range(n):
            if pre[i] + post[i] - nums[i] == ceil:
                for j in range(i + 1, n):
                    nums[j] = min(nums[j], nums[j - 1])
                for j in range(i - 1, -1, -1):
                    nums[j] = min(nums[j], nums[j + 1])
                ac.lst(nums)
                break
        return

    @staticmethod
    def lc_1944(heights: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/number-of-visible-people-in-a-queue/
        tag: reverse_thinking|monotonic_stack
        """
        n = len(heights)
        ans = [0] * n
        stack = [heights[-1]]
        for i in range(n - 2, -1, -1):
            cur = 0
            while stack and stack[-1] < heights[i]:
                cur += 1
                stack.pop()
            if stack:
                cur += 1
            stack.append(heights[i])
            ans[i] = cur
        return ans

    @staticmethod
    def abc_336d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc336/tasks/abc336_d
        tag: monotonic_stack|linear_dp
        """

        def check():
            res = [0] * n
            stack = []
            for i in range(n):
                while stack and nums[stack[-1]] - stack[-1] >= nums[i] - i:
                    stack.pop()
                if not stack:
                    k = min(i + 1, nums[i])
                    res[i] = k
                else:
                    k = res[stack[-1]] + i - stack[-1]
                    res[i] = k
                stack.append(i)
            return res

        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = check()
        nums.reverse()
        post = check()
        ans = max(min(pre[i], post[n - 1 - i]) for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def cf_1506g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1506/problem/G
        tag: monotonic_stack|greedy|classical
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            cnt = Counter(s)
            stack = []
            in_stack = set()
            for w in s:
                while stack and stack[-1] <= w and cnt[stack[-1]] and w not in in_stack:
                    in_stack.discard(stack.pop())
                if w not in in_stack:
                    stack.append(w)
                    in_stack.add(w)
                cnt[w] -= 1
            ac.st("".join(stack))
        return

    @staticmethod
    def abc_311g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc311/tasks/abc311_g
        tag: brute_force|prefix_sum|monotonic_stack|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        ans = 0
        lst = []
        for g in grid:
            lst.extend(g)
        pre = PreFixSumMatrix(grid)

        for num in set(lst):
            cur = [[int(x == num) for x in g] for g in grid]
            pre2 = PreFixSumMatrix(cur)
            height = [0] * n
            for i in range(m):
                for j in range(n):
                    if grid[i][j] >= num:
                        height[j] += 1
                    else:
                        height[j] = 0

                width = Rectangle().compute_width(height)
                for j in range(n):
                    if height[j]:
                        ll, rr = width[j]
                        xa, ya = i - height[j] + 1, ll
                        xb, yb = i, rr
                        if pre2.query(xa, ya, xb, yb):
                            ans = max(ans, pre.query(xa, ya, xb, yb) * num)
        ac.st(ans)
        return

    @staticmethod
    def abc_299g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc299/tasks/abc299_g
        tag: monotonic_stack_greedy|implemention|classical
        """
        ac.read_list_ints()
        nums = ac.read_list_ints()
        cnt = Counter(nums)
        in_stack = defaultdict(int)
        stack = []
        for w in nums:
            if not in_stack[w]:
                while stack and stack[-1] > w and cnt[stack[-1]]:
                    in_stack[stack.pop()] = 0
                stack.append(w)
                in_stack[w] = 1
            cnt[w] -= 1
        ac.lst(stack)
        return

    @staticmethod
    def lc_3113(nums: List[int]) -> int:
        """
        url: https://leetcode.com/problems/find-the-number-of-subarrays-where-boundary-elements-are-maximum/
        tag: brute_force|teo_pointer|monotonic_stack|classical
        """

        n = len(nums)
        post = [n] * n
        stack = []
        for i in range(n):
            while stack and nums[i] > nums[stack[-1]]:
                post[stack.pop()] = i
            stack.append(i)
        ans = 0
        dct = defaultdict(list)
        for i, num in enumerate(nums):
            dct[num].append(i)
        for num in dct:
            lst = dct[num]
            j = 0
            m = len(lst)
            for i in range(m):
                if j < i:
                    j = i
                while j + 1 < m and post[lst[i]] >= lst[j + 1]:
                    j += 1
                ans += j - i + 1
        return ans

    @staticmethod
    def cf_1919d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1919/D
        tag: brain_teaser|monotonic_stack|construction
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            if nums.count(0) != 1:
                ac.st("NO")
                continue
            pre_smaller = [-1] * n
            stack = []
            for i in range(n):
                while stack and nums[i] <= nums[stack[-1]]:
                    stack.pop()
                if stack:
                    pre_smaller[i] = stack[-1]
                stack.append(i)

            post_smaller = [-1] * n
            stack = []
            for i in range(n - 1, -1, -1):
                while stack and nums[i] <= nums[stack[-1]]:
                    stack.pop()
                if stack:
                    post_smaller[i] = stack[-1]
                stack.append(i)
            for i in range(n):
                if nums[i]:
                    if pre_smaller[i] != -1 and nums[pre_smaller[i]] == nums[i] - 1:
                        continue
                    if post_smaller[i] != -1 and nums[post_smaller[i]] == nums[i] - 1:
                        continue
                    ac.st("NO")
                    break
            else:
                ac.st("YES")
        return

    @staticmethod
    def cf_1299c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1299/C
        tag: monotonic_stack|convex|brain_teaser|greedy|construction
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        stack = [(a[0], 0, 0)]
        for i in range(1, n):
            stack.append((a[i], i, i))
            while len(stack) >= 2:
                s1, l1, r1 = stack[-2]
                s2, l2, r2 = stack[-1]
                if s1 * (r2 - l2 + 1) >= s2 * (r1 - l1 + 1):
                    stack.pop()
                    stack.pop()
                    stack.append((s1 + s2, l1, r2))
                else:
                    break
        for ss, ll, rr in stack:
            ans = ss / (rr - ll + 1)
            for _ in range(rr - ll + 1):
                ac.st(ans)
        return

    @staticmethod
    def cf_1407d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1407/D
        tag: array_implemention|monotonic_stack|linear_dp|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [-1] * (n + 1)
        ceil = [-1] * (n + 1)
        floor = [-1] * (n + 1)
        j1 = j2 = 0
        for i in range(n):
            dp[i + 1] = dp[i] + 1
            while j1 > 0 and nums[ceil[j1]] <= nums[i]:
                x = nums[ceil[j1]]
                j1 -= 1
                if j1 and min(nums[ceil[j1]], nums[i]) > x:
                    dp[i + 1] = min(dp[i + 1], dp[ceil[j1] + 1] + 1)
            while j2 > 0 and nums[floor[j2]] >= nums[i]:
                x = nums[floor[j2]]
                j2 -= 1
                if j2 and max(nums[floor[j2]], nums[i]) < x:
                    dp[i + 1] = min(dp[i + 1], dp[floor[j2] + 1] + 1)
            j1 += 1
            j2 += 1
            ceil[j1] = i
            floor[j2] = i
        ac.st(dp[n])
        return
"""
Algorithm：heapq|monotonic_queue|huffman_tree
Description：greedy

====================================LeetCode====================================
630（https://leetcode.cn/problems/course-schedule-iii/）delay_heapq|greedy
2454（https://leetcode.cn/problems/next-greater-element-iv/）heapq|post_second_larger|hash|SortedList
2402（https://leetcode.cn/problems/meeting-rooms-iii/）heapq|implemention|counter
2386（https://leetcode.cn/problems/find-the-k-sum-of-an-array/）heapq|brain_teaser
2163（https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/）prefix_suffix|brute_force
1792（https://leetcode.cn/problems/maximum-average-pass-ratio/）greedy
295（https://leetcode.cn/problems/find-median-from-data-stream/）heapq|median
2542（https://leetcode.cn/problems/maximum-subsequence-score/）greedy|sort|brute_force|heapq
2263（https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/）heapq|greedy

=====================================LuoGu======================================
P1168（https://www.luogu.com.cn/problem/P1168）heapq|median
P1801（https://www.luogu.com.cn/problem/P1801）heapq
P2085（https://www.luogu.com.cn/problem/P2085）math|heapq
P1631（https://www.luogu.com.cn/problem/P1631）heapq|pointer
P4053（https://www.luogu.com.cn/problem/P4053）delay_heapq|greedy
P1878（https://www.luogu.com.cn/problem/P1878）hash|heapq|implemention
P3620（https://www.luogu.com.cn/problem/P3620）greedy|heapq|double_linked_list
P2168（https://www.luogu.com.cn/problem/P2168）huffman_tree|heapq|greedy
P2278（https://www.luogu.com.cn/problem/P2278）heapq|implemention
P1717（https://www.luogu.com.cn/problem/P1717）brute_force|heapq|greedy
P1905（https://www.luogu.com.cn/problem/P1905）heapq|greedy
P2409（https://www.luogu.com.cn/problem/P2409）heapq
P2949（https://www.luogu.com.cn/problem/P2949）heapq|greedy|implemention|delay_heapq|lazy_heapq
P6033（https://www.luogu.com.cn/problem/P6033）greedy|deque
P4597（https://www.luogu.com.cn/problem/P4597）heapq|greedy

=====================================CodeForces=====================================
1837F（https://codeforces.com/problemset/problem/1837/F）binary_search|priority_queue|implemention|greedy|nlognlogn

=====================================AtCoder=====================================
ABC325D（https://atcoder.jp/contests/abc325/tasks/abc325_d）heapq|greedy|implemention|classical
ABC250G（https://atcoder.jp/contests/abc250/tasks/abc250_g）regret_heapq|greedy|brain_teaser|classical
ABC212D（https://atcoder.jp/contests/abc212/tasks/abc212_d）implemention|inclusion_exclusion|stack

=====================================AcWing=====================================
146（https://www.acwing.com/problem/content/description/148/）heapq
147（https://www.acwing.com/problem/content/description/149/）greedy|heapq|double_linked_list
148（https://www.acwing.com/problem/content/150/）greedy|heapq|huffman_tree
149（https://www.acwing.com/problem/content/description/151/）huffman_tree|heapq|greedy

=====================================CodeChef=====================================
1（https://www.codechef.com/problems/OKLAMA）priority_queue|greedy|implemention|math|brain_teaser|induction_method

"""

import heapq
from collections import deque, defaultdict
from heapq import heappushpop, heappush, heappop, heapify
from typing import List

from src.data_structure.priority_queue.template import MedianFinder, HeapqMedian
from src.data_structure.sorted_list.template import SortedList
from src.data_structure.tree_array.template import PointAddRangeSum
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_2454_1(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/next-greater-element-iv/
        tag: heapq|post_second_larger|hash|SortedList|classical|bucket
        """
        n = len(nums)
        dct = defaultdict(list)
        for i in range(n):
            dct[nums[i]].append(i)
        lst = SortedList()
        ans = [-1] * n
        for num in sorted(dct, reverse=True):
            for i in dct[num]:
                j = lst.bisect_left(i)
                if 0 <= j + 1 < len(lst):
                    ans[i] = nums[lst[j + 1]]
            for i in dct[num]:
                lst.add(i)
        return ans

    @staticmethod
    def lc_2454_2(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/next-greater-element-iv/
        tag: heapq|post_second_larger|hash|SortedList
        """
        n = len(nums)
        ans = [-1] * n
        mono_stack = []
        small_stack = []
        for i in range(n):
            while small_stack and small_stack[0][0] < nums[i]:
                ans[heapq.heappop(small_stack)[1]] = nums[i]

            while mono_stack and nums[mono_stack[-1]] < nums[i]:
                j = mono_stack.pop()
                heapq.heappush(small_stack, [nums[j], j])
            mono_stack.append(i)

        return ans

    @staticmethod
    def lg_1168(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1168
        tag: heapq|median
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        arr = MedianFinder()
        for i in range(n):
            arr.add_num(nums[i])
            if i % 2 == 0:
                ac.st(arr.find_median())
        return

    @staticmethod
    def lc_1792(classes, extra_students):
        """
        url: https://leetcode.cn/problems/maximum-average-pass-ratio/
        tag: greedy|math|classical
        """
        stack = []
        for p, t in classes:
            heapq.heappush(stack, [p / t - (p + 1) / (t + 1), p, t])
        for _ in range(extra_students):
            r, p, t = heapq.heappop(stack)
            p += 1
            t += 1
            heapq.heappush(stack, [p / t - (p + 1) / (t + 1), p, t])
        return sum(p / t for _, p, t in stack) / len(classes)

    @staticmethod
    def lc_630(courses: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/course-schedule-iii/
        tag: delay_heapq|greedy|regret_heapq|classical
        """
        courses.sort(key=lambda x: x[1])
        stack = []
        day = 0
        for duration, last in courses:
            if day + duration <= last:
                day += duration
                heapq.heappush(stack, -duration)
            else:
                if stack and -stack[0] > duration:
                    day += heapq.heappop(stack) + duration
                    heapq.heappush(stack, -duration)
        return len(stack)

    @staticmethod
    def ac_146(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/148/
        tag: heapq|classical|dp|greedy|pointer
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            pre = sorted(ac.read_list_ints())
            for _ in range(m - 1):
                cur = ac.read_list_ints()
                cur.sort()
                stack = [(pre[0] + cur[j], 0, j) for j in range(n)]
                heapify(stack)
                nex = []
                for _ in range(n):
                    val, i, j = heappop(stack)
                    nex.append(val)
                    if i + 1 < n:
                        heappush(stack, (pre[i + 1] + cur[j], i + 1, j))
                pre = nex[:]
            ac.lst(pre)
        return

    @staticmethod
    def ac_147(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/149/
        tag: greedy|heapq|double_linked_list|classical|hard
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]

        diff = [math.inf] + [nums[i + 1] - nums[i] for i in range(n - 1)] + [math.inf]
        stack = [[diff[i], i] for i in range(1, n)]
        heapq.heapify(stack)
        pre = [i - 1 for i in range(n + 1)]
        post = [i + 1 for i in range(n + 1)]
        pre[0] = 0
        post[n] = n

        ans = 0
        delete = [0] * (n + 1)
        while k:
            val, i = heapq.heappop(stack)
            if delete[i]:
                continue
            ans += diff[i]

            left = diff[pre[i]]
            right = diff[post[i]]
            new = left + right - diff[i]
            diff[i] = new
            delete[pre[i]] = 1
            delete[post[i]] = 1

            pre[i] = pre[pre[i]]
            post[pre[i]] = i

            post[i] = post[post[i]]
            pre[post[i]] = i
            heapq.heappush(stack, [new, i])
            k -= 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p2168(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2168
        tag: huffman_tree|heapq|greedy
        """
        n, k = ac.read_list_ints()
        stack = [[ac.read_int(), 0] for _ in range(n)]
        heapq.heapify(stack)
        while (len(stack) - 1) % (k - 1) != 0:
            heapq.heappush(stack, [0, 0])
        ans = 0
        while len(stack) > 1:
            cur = 0
            dep = 0
            for _ in range(k):
                val, d = heapq.heappop(stack)
                cur += val
                dep = max(dep, d)
            ans += cur
            heapq.heappush(stack, [cur, dep + 1])
        ac.st(ans)
        ac.st(stack[0][1])
        return

    @staticmethod
    def lg_p1631(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1631
        tag: heapq|pointer|classical
        """
        n = ac.read_int()
        nums1 = ac.read_list_ints()
        nums2 = ac.read_list_ints()
        stack = [(nums1[0] + nums2[j], 0, j) for j in range(n)]
        heapq.heapify(stack)
        ans = []
        for _ in range(n):
            val, i, j = heapq.heappop(stack)
            ans.append(val)
            if i + 1 < n:
                heapq.heappush(stack, (nums1[i + 1] + nums2[j], i + 1, j))
        ac.lst(ans)
        return

    @staticmethod
    def lg_p4053(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4053
        tag: delay_heapq|greedy|regret_heapq|LC630
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[1])
        pre = 0
        stack = []
        for a, b in nums:
            if pre + a <= b:
                heapq.heappush(stack, -a)
                pre += a
            else:
                if stack and -a > stack[0]:
                    pre += heapq.heappop(stack)
                    pre += a
                    heapq.heappush(stack, -a)
        ac.st(len(stack))
        return

    @staticmethod
    def lg_p2085(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2085
        tag: math|heapq
        """
        n, m = ac.read_list_ints()
        stack = []
        for _ in range(n):
            a, b, c = ac.read_list_ints()
            stack.append((a + b + c, 1, a, b, c))
        heapify(stack)
        ans = []
        while len(ans) < m:
            val, x, a, b, c = heapq.heappop(stack)
            ans.append(val)
            x += 1
            heapq.heappush(stack, (a * x * x + b * x + c, x, a, b, c))
        ac.lst(ans)
        return

    @staticmethod
    def lg_p2278(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2278
        tag: heapq|implemention
        """
        now = []
        ans = []
        stack = []
        pre = 0
        while True:
            lst = ac.read_list_ints()
            if not lst:
                break

            while now and now[-1] <= lst[1]:
                ans.append([now[0], now[-1]])
                pre = now[-1]
                if stack:
                    level, reach, need, idx = heapq.heappop(stack)
                    now = [idx, reach, need, -level, max(pre, reach) + need]
                else:
                    now = []

            if not now and stack:
                level, reach, need, idx = heapq.heappop(stack)
                now = [idx, reach, need, -level, max(pre, reach) + need]

            if now and now[3] >= lst[-1]:
                idx, reach, need, level = lst
                heapq.heappush(stack, (-level, reach, need, idx))
            elif now:
                idx, reach, need, level, end = now
                heapq.heappush(stack, (-level, reach, end - lst[1], idx))
                idx, reach, need, level = lst
                now = [idx, reach, need, level, max(pre, reach) + need]
            else:
                idx, reach, need, level = lst
                now = [idx, reach, need, level, max(pre, reach) + need]

        while stack:
            ans.append([now[0], now[-1]])
            pre = now[-1]
            level, reach, need, idx = heapq.heappop(stack)
            now = [idx, reach, need, -level, max(pre, reach) + need]
        ans.append([now[0], now[-1]])
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def lg_p1717(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1717
        tag: brute_force|heapq|greedy
        """
        ans = 0
        n = ac.read_int()
        h = ac.read_int() * 60
        f = ac.read_list_ints()
        d = ac.read_list_ints()
        t = [0] + ac.read_list_ints()
        for i in range(n):
            tm = sum(t[:i + 1]) * 5
            stack = [[-f[j], j] for j in range(i + 1)]
            heapq.heapify(stack)
            cur = 0
            while tm + 5 <= h and stack:
                val, j = heapq.heappop(stack)
                val = -val
                cur += val
                tm += 5
                if val - d[j] > 0:
                    heapq.heappush(stack, [-val + d[j], j])
            ans = max(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1905(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1905
        tag: heapq|greedy
        """
        ac.read_int()
        p = ac.read_int()
        lst = ac.read_list_ints()
        ans = [[0] for _ in range(p)]
        stack = [(ans[i][0], i) for i in range(p)]
        lst.sort(reverse=True)
        for num in lst:
            d, i = heapq.heappop(stack)
            ans[i][0] += num
            ans[i].append(num)
            heapq.heappush(stack, (ans[i][0], i))
        for a in ans:
            ac.lst(a[1:])
        return

    @staticmethod
    def lg_p2409(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2409
        tag: heapq
        """
        n, k = ac.read_list_ints()
        pre = sorted(ac.read_list_ints()[1:])[:k]
        for _ in range(n - 1):
            cur = sorted(ac.read_list_ints()[1:])[:k]
            m = len(cur)
            stack = [(pre[0] + cur[j], 0, j) for j in range(m)]
            heapify(stack)
            nex = []
            while len(nex) < k and stack:
                val, i, j = heappop(stack)
                nex.append(val)
                if i + 1 < len(pre):
                    heappush(stack, (pre[i + 1] + cur[j], i + 1, j))
            pre = nex[:]
        ac.lst(pre)
        return

    @staticmethod
    def lg_p2949(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2949
        tag: heapq|greedy|implemention|delay_heapq|lazy_heapq|regret_heapq
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[0])
        ans = 0
        stack = []
        for d, p in nums:
            heapq.heappush(stack, p)
            ans += p
            if len(stack) > d:
                ans -= heapq.heappop(stack)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6033(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6033
        tag: greedy|priority_queue|classical
        """
        ac.read_int()
        pre = deque(sorted(ac.read_list_ints()))
        post = deque()
        ans = 0
        while len(pre) + len(post) > 1:
            if not pre:
                cur = post.popleft() + post.popleft()
                ans += cur
                post.append(cur)
                continue
            if not post:
                cur = pre.popleft() + pre.popleft()
                ans += cur
                post.append(cur)
                continue
            if pre[0] < post[0]:
                a = pre.popleft()
            else:
                a = post.popleft()
            if pre and (not post or pre[0] < post[0]):
                b = pre.popleft()
            else:
                b = post.popleft()
            ans += a + b
            post.append(a + b)
        ac.st(ans)
        return

    @staticmethod
    def lc_2263(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/
        tag: heapq|greedy
        """

        def helper(lst: List[int]) -> int:
            res, pq = 0, []
            for num in lst:
                if not pq:
                    heappush(pq, -num)
                else:
                    pre = -pq[0]
                    if pre > num:
                        res += pre - num
                        heappushpop(pq, -num)
                    heappush(pq, -num)
            return res

        return min(helper(nums), helper(nums[::-1]))

    @staticmethod
    def lc_2386(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-the-k-sum-of-an-array/
        tag: heapq|brain_teaser|dijkstra|classical|hard
        """
        n = len(nums)
        tot = 0
        for i in range(n):
            if nums[i] >= 0:
                tot += nums[i]
            else:
                nums[i] = -nums[i]
        nums.sort()

        stack = [(-tot, 0)]
        for _ in range(k - 1):
            pre, i = heappop(stack)
            if i < n:
                heapq.heappush(stack, (pre + nums[i], i + 1))
                if i:
                    heapq.heappush(stack, (pre + nums[i] - nums[i - 1], i + 1))
        return -stack[0][0]

    @staticmethod
    def lc_24_1(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/5TxKeK/description/
        tag: heapq_median|brain_teaser|classical|median_greedy
        """
        mod = 1000000007
        n = len(nums)
        nums = [nums[i] - i for i in range(n)]
        median = HeapqMedian(nums[0])
        ans = [0]
        lst = [nums[0]]
        for num in nums[1:]:
            median.add(num)
            lst.append(num)
            cur = (median.mid * len(median.left) - median.left_sum)
            cur += (median.right_sum - median.mid * len(median.right))
            ans.append(cur % mod)
        return ans

    @staticmethod
    def lc_24_2(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/5TxKeK/description/
        tag: heapq_median|brain_teaser|classical|median_greedy|tree_array|sorted_list
        """
        mod = 1000000007
        n = len(nums)
        nums = [nums[i] - i + n for i in range(n)]
        lst = SortedList()
        ans = []
        ceil = max(nums)
        tree_cnt = PointAddRangeSum(ceil)
        tree_sum = PointAddRangeSum(ceil)
        for num in nums:
            lst.add(num)
            tree_cnt.point_add(num, 1)
            tree_sum.point_add(num, num)
            x = lst[len(lst) // 2]
            cur = 0
            if x - 1 >= 1:
                cur += tree_cnt.range_sum(1, x - 1) * x - tree_sum.range_sum(1, x - 1)
            if x + 1 <= ceil:
                cur += tree_sum.range_sum(x + 1, ceil) - tree_cnt.range_sum(x + 1, ceil) * x
            ans.append(cur % mod)
        return ans

    @staticmethod
    def abc_250g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc250/tasks/abc250_g
        tag: regret_heapq|greedy|brain_teaser|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ans = 0
        stack = []
        for num in nums:
            if stack and num > stack[0]:
                ans += num - heappop(stack)
                heappush(stack, num)
            heappush(stack, num)
        ac.st(ans)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/OKLAMA
        tag: priority_queue|greedy|implemention|math|brain_teaser|induction_method
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()
            ans = [0] * n
            big = []
            small = []
            ans[0] = nums[0]
            big_sum = 0
            small_sum = 0
            for i in range(n):
                if len(big) <= len(small):
                    heappush(big, nums[i])
                    big_sum += nums[i]
                else:
                    heappush(small, -nums[i])
                    small_sum += nums[i]
                if (i + 1) % 2 and i >= 2:
                    pre = (i + 1) // 2

                    while small and big and -small[0] > big[0]:
                        x = -heappop(small)
                        small_sum -= x
                        big_sum += x
                        heappush(big, x)

                        x = heappop(big)
                        big_sum -= x
                        small_sum += x
                        heappush(small, -x)

                    while len(small) > pre:
                        x = -heappop(small)
                        small_sum -= x
                        big_sum += x
                        heappush(big, x)
                    while len(small) < pre:
                        x = heappop(big)
                        big_sum -= x
                        small_sum += x
                        heappush(small, -x)

                    ans[i] = big_sum - small_sum
            res = [ans[q] for q in ac.read_list_ints_minus_one()]
            ac.lst(res)
        return

    @staticmethod
    def abc_212d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc212/tasks/abc212_d
        tag: implemention|inclusion_exclusion|stack
        """
        stack = []
        cur = 0
        q = ac.read_int()
        val = [0] * (q + 1)
        for i in range(q):
            tmp = ac.read_list_ints()
            if tmp[0] == 1:
                x = tmp[1]
                heapq.heappush(stack, x - cur)
            elif tmp[0] == 2:
                cur += tmp[1]
            else:
                x = heapq.heappop(stack)
                ac.st(x + cur)
            val[i] = cur
        return

    @staticmethod
    def cf_1837e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1837/F
        tag: binary_search|priority_queue|implemention|greedy|nlognlogn
        """
        for _ in range(ac.read_int()):  # TLE
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()

            def check(x):
                stack = []
                s = 0
                for i, num in enumerate(nums):
                    if s + num <= x:
                        heappush(stack, -num)
                        s += num
                    elif stack and -stack[0] > num:
                        s += stack[0]
                        heappushpop(stack, -num)
                        s += num
                    pre[i + 1] = len(stack)
                    if pre[i + 1] >= k:
                        return True

                s = 0
                stack = []
                for i in range(n - 1, -1, -1):
                    num = nums[i]
                    if s + num <= x:
                        heappush(stack, -num)
                        s += num
                    elif stack and -stack[0] > num:
                        s += stack[0]
                        heappushpop(stack, -num)
                        s += num
                    if pre[i] + len(stack) >= k:
                        return True
                return False

            pre = [0] * (n + 1)

            low = 0
            high = sum(nums)
            while low < high:
                mid = low + (high - low) // 2
                if check(mid):
                    high = mid
                else:
                    low = mid + 1
            ac.st(low)
        return"""
Algorithm：segment_tree|bisect_left
Description：range_sum|range_min|range_add|range_change|range_max|dynamic_segment_tree|defaultdict

====================================LeetCode====================================
218（https://leetcode.cn/problems/the-skyline-problem/solution/by-liupengsay-isfo/）segment_tree|RangeChangeRangeMax
2286（https://leetcode.cn/problems/booking-concert-tickets-in-groups/）segment_tree|RangeAddRangeSumMaxMin
2407（https://leetcode.cn/problems/longest-increasing-subsequence-ii/）segment_tree|RangeAddRangeMax|linear_dp
2158（https://leetcode.cn/problems/amount-of-new-area-painted-each-day/）segment_tree|RangeAddRangeSum
2589（https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/）segment_tree|greedy|bisect_left
732（https://leetcode.cn/problems/my-calendar-iii/）dynamic_segment_tree
1851（https://leetcode.cn/problems/minimum-interval-to-include-each-query/）segment_tree|RangeChangeRangeMin|offline_query|monotonic_queue
2213（https://leetcode.cn/problems/longest-substring-of-one-repeating-character/）segment_tree|sub_consequence|range_query|range_merge
2276（https://leetcode.cn/problems/count-integers-in-intervals/）dynamic_segment_tree|union_find_range|SortedList
1340（https://leetcode.cn/problems/jump-game-v/）segment_tree|linear_dp
2940（https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/）segment_tree|bisect_left
2569（https://leetcode.cn/problems/handling-sum-queries-after-update/）segment_tree|range_reverse|bit_set
3003（https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations）segment_tree|bisect_left|range_or|point_set
1622（https://leetcode.cn/problems/fancy-sequence/）segment_tree|range_affine|range_sum
100314（https://leetcode.cn/problems/block-placement-queries/）point_set|range_max_non_emp_con_sub_sum
100306（https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements）point_set|range_max_sub_sum_alter

=====================================LuoGu======================================
P2846（https://www.luogu.com.cn/problem/P2846）segment_tree|range_reverse|range_sum
P2572（https://www.luogu.com.cn/problem/P2572）segment_tree|range_reverse|range_sum
P2574（https://www.luogu.com.cn/problem/P2574）segment_tree|range_change|range_sum|range_cover
P3130（https://www.luogu.com.cn/problem/P3130）range_add|range_sum|range_min
P3870（https://www.luogu.com.cn/problem/P3870）segment_tree|range_reverse|range_sum
P5057（https://www.luogu.com.cn/problem/P5057）segment_tree|range_reverse|range_sum
P3372（https://www.luogu.com.cn/problem/P3372）RangeAddRangeSumMaxMin
P2880（https://www.luogu.com.cn/problem/P2880）RangeAddRangeSumMaxMin
P1904（https://www.luogu.com.cn/problem/P1904）segment_tree|RangeAscendRangeMax
P1438（https://www.luogu.com.cn/problem/P1438）diff_array|RangeAddRangeSumMaxMin|segment_tree
P1253（https://www.luogu.com.cn/problem/P1253）range_add|range_change|segment_tree|range_sum
P3373（https://www.luogu.com.cn/problem/P3373）range_add|range_mul|segment_tree|range_sum|RangeAffineRangeSum
P4513（https://www.luogu.com.cn/problem/P4513）segment_tree|range_change|range_merge|sub_consequence
P1471（https://www.luogu.com.cn/problem/P1471）math|segment_tree|RangeAddRangeSum
P6492（https://www.luogu.com.cn/problem/P6492）segment_tree|range_change|range_merge|sub_consequence
P4145（https://www.luogu.com.cn/problem/P4145）math|segment_tree|RangeAddRangeSum
P1558（https://www.luogu.com.cn/problem/P1558）segment_tree|RangeSetRangeOr
P3740（https://www.luogu.com.cn/problem/P3740）discretization|segment_tree|RangeChangeRangeSum
P4588（https://www.luogu.com.cn/problem/P4588）segment_tree|RangeChangeRangeMul
P6627（https://www.luogu.com.cn/problem/P6627）segment_tree|range_xor
P8081（https://www.luogu.com.cn/problem/P8081）diff_array|counter|action_scope|segment_tree|RangeSetRangeOr
P8812（https://www.luogu.com.cn/problem/P8812）segment_tree|RangeDescendRangeMin
P8856（https://www.luogu.com.cn/problem/solution/P8856）segment_tree|RangeAddRangeSumMaxMin
P1972（https://www.luogu.com.cn/problem/P1972）point_add|range_sum|tree_array|offline_query
P5848（https://www.luogu.com.cn/problem/P5848）segment_tree|range_set|range_pre_max_sum|dynamic
P2824（https://www.luogu.com.cn/problem/P2824）segment_tree|range_sort|implemention|brain_teaser|range_set|range_sum|classical
P3097（https://www.luogu.com.cn/problem/P3097）point_set|range_max_sub_sum_alter
P2846（https://www.luogu.com.cn/problem/P2846）range_reverse|range_bit_count

===================================CodeForces===================================
482B（https://codeforces.com/problemset/problem/482/B）segment_tree|RangeOrRangeAnd
380C（https://codeforces.com/problemset/problem/380/C）segment_tree|range_merge|sub_consequence|bracket
52C（https://codeforces.com/problemset/problem/52/C）segment_tree|circular_array|range_add|range_min
438D（https://codeforces.com/problemset/problem/438/D）segment_tree|range_sum|mod|RangeChangeRangeSumMaxMin
558E（https://codeforces.com/contest/558/problem/E）alphabet|segment_tree|sorting
343D（https://codeforces.com/problemset/problem/343/D）dfs_order|segment_tree
242E（https://codeforces.com/problemset/problem/242/E）segment_tree|RangeReverseRangeBitCount
987C（https://codeforces.com/problemset/problem/987/C）brute_force|segment_tree|prefix_suffix
1216F（https://codeforces.com/contest/1216/problem/F）segment_tree|linear_dp|monotonic_queue
1665E（https://codeforces.com/contest/1665/problem/E）segment_tree
1478E（https://codeforces.com/contest/1478/problem/E）RangeSetRangeSumMinMax|backward_thinking|implemention
1679E（https://codeforces.com/contest/1679/problem/B）RangeSetRangeSumMinMax|range_change|range_sum
85D（https://codeforces.com/contest/85/problem/D）segment_tree|point_add|range_sum
474E（https://codeforces.com/contest/474/problem/E）segment_tree|point_set|range_max_index|linear_dp|classical
920F（https://codeforces.com/problemset/problem/920/F）union_find|all_factor_cnt|range_sum|point_add
438D（https://codeforces.com/contest/438/problem/D）segment_tree|point_set|range_mod|range_sum|classical|limited_operation
1187D（https://codeforces.com/problemset/problem/1187/D）segment_tree|point_set|range_min|classical
914D（https://codeforces.com/contest/914/problem/D）segment_tree|point_set|range_gcd
1567E（https://codeforces.com/problemset/problem/1567/E）segment_tree|point_set|range_ascend_sub_cnt
522D（https://codeforces.com/problemset/problem/522/D）segment_tree|point_set|range_min|offline_query
703D（https://codeforces.com/problemset/problem/703/D）segment_tree|point_add|range_xor|offline_query
1208D（https://codeforces.com/problemset/problem/1208/D）segment_tree|reverse_thinking|construction|point_set|range_sum_bisect_left
558E（https://codeforces.com/problemset/problem/558/E）segment_tree|range_set|range_sum|alphabet
1157D（https://codeforces.com/contest/1557/problem/D）segment_tree|range_ascend|range_max_index|dp
1114F（https://codeforces.com/problemset/problem/1114/F）segment_tree|range_set|range_sum|range_mul
292E（https://codeforces.com/problemset/problem/292/E）segment_tree|range_set|point_get
1881G（https://codeforces.com/contest/1881/problem/G）segment_tree|range_add|range_palindrome
915E（https://codeforces.com/problemset/problem/915/E）segment_tree|range_set|range_sum|dynamic
877E（https://codeforces.com/problemset/problem/877/E）segment_tree|range_reverse|dfs_order|range_bit_count
1108E2（https://codeforces.com/contest/1108/problem/E2）segment_tree|range_add|range_min|prefix_suffix|bryte_force|brain_teaser
1234D（https://codeforces.com/contest/1234/problem/D）segment_tree|point_set|range_or
1538E（https://codeforces.com/contest/1538/problem/E）implemention|segment_tree|merge
1741F（https://codeforces.com/contest/1741/problem/F）segment_tree|discretization|range_add|range_sum|bisect_left|bisect_right
242E（https://codeforces.com/contest/242/problem/E）segment_tree|range_xor|range_reverse|range_sum|range_bit_count
1982F（https://codeforces.com/contest/1982/problem/F）point_set|pre_max|post_min|pre_min|implemention|bisect_left|bisect_right
620E（https://codeforces.com/problemset/problem/620/E）range_set|range_or|dfs_order
1420C2（https://codeforces.com/problemset/problem/1420/C2）point_set|range_max_sub_sum_alter_signal|greedy
1859D（https://codeforces.com/problemset/problem/1859/D）range_ascend|range_max|implemention
1555E（https://codeforces.com/problemset/problem/1555/E）brain_teaser|build_graph|segment_tree|range_add|range_min|two_pointers
2001D（https://codeforces.com/contest/2001/problem/D）segment_tree|point_set|range_max|range_max_bisect_right
786B（https://codeforces.com/contest/786/problem/B）segment_tree_opt_build_graph|dijkstra|classical

====================================AtCoder=====================================
ABC332F（https://atcoder.jp/contests/abc332/tasks/abc332_f）RangeAffineRangeSum
ABC287G（https://atcoder.jp/contests/abc287/tasks/abc287_g）segment_tree|range_sum|dynamic|offline
ABC327F（https://atcoder.jp/contests/abc327/tasks/abc327_f）segment_tree|range_add|range_max
ABC285F（https://atcoder.jp/contests/abc285/tasks/abc285_f）segment_tree|point_add|range_sum|range_ascend_sub_cnt|point_set
ABC339E（https://atcoder.jp/contests/abc339/tasks/abc339_e）segment_tree|linear_dp
ABC341E（https://atcoder.jp/contests/abc341/tasks/abc341_e）segment_tree|range_reverse|range_alter
ABC322F（https://atcoder.jp/contests/abc322/tasks/abc322_f）segment_tree|range_set_reverse|range_longest_con_sub
ABC340E（https://atcoder.jp/contests/abc340/tasks/abc340_e）segment_tree|range_add|range_sum
ABC338E（https://atcoder.jp/contests/abc338/tasks/abc338_e）segment_tree|brain_teaser|range_descend|range_min|stack
ABC343F（https://atcoder.jp/contests/abc343/tasks/abc343_f）segment_tree|point_set|range_max|range_second
ABC320E（https://atcoder.jp/contests/abc320/tasks/abc320_e）segment_tree|point_set|range_min|range_min_bisect_left
ABC309F（https://atcoder.jp/contests/abc309/tasks/abc309_f）partial_order|range_descend|range_min
ABC307E（https://atcoder.jp/contests/abc307/tasks/abc307_e）circular_array|linear_dp|segment_tree|range_add|range_mul
ABC307F（https://atcoder.jp/contests/abc307/tasks/abc307_f）segment_tree|range_max_bisect_left|dijkstra
ABC346G（https://atcoder.jp/contests/abc346/tasks/abc346_g）contribution_method|segment_tree|range_add|range_sum
ABC292H（https://atcoder.jp/contests/abc292/tasks/abc292_h）segment_tree|range_add|range_max_bisect_left
ABC253F（https://atcoder.jp/contests/abc253/tasks/abc253_f）offline_query|data_range|limited_operation|brain_teaser|preprocess|classical
ABC237G（https://atcoder.jp/contests/abc237/tasks/abc237_g）segment_tree|range_sort|implemention|brain_teaser|range_set|range_sum|classical
ABC223F（https://atcoder.jp/contests/abc223/tasks/abc223_f）segment_tree|point_set|range_set|pre_sum_max
ABC356F（https://atcoder.jp/contests/abc356/tasks/abc356_f）union_find|union_find_left|union_find_right|segment_tree|sorted_list
ABC357F（https://atcoder.jp/contests/abc357/tasks/abc357_f）segment_tree|range_add|range_mul_sum
ABC360F（https://atcoder.jp/contests/abc360/tasks/abc360_f）range_add|scan_line|range_max|range_max_bisect_left
ABC369G（https://atcoder.jp/contests/abc369/tasks/abc369_g）dfs_order|range_add|range_max|implemention
ABC194E（https://atcoder.jp/contests/abc194/tasks/abc194_e）point_set|pre_min|post_min|bisect_right

=====================================AcWing=====================================
3805（https://www.acwing.com/problem/content/3808/）RangeAddRangeMin

=====================================LibraryChecker=====================================
1（https://judge.yosupo.jp/problem/range_affine_point_get）RangeAffineRangeSum
2（https://judge.yosupo.jp/problem/range_affine_range_sum）RangeAffineRangeSum
3（https://judge.yosupo.jp/problem/point_set_range_composite）PointSetRangeComposite
4（https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/A）PointSetRangeSum
5（https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/B）segment_tree|point_set|range_min
6（https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/C）segment_tree|point_set|range_min_count
7（https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A）segment_tree|point_set|range_max_sub_sum
8（https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/B）segment_tree|point_set|range_sum_bisect_left
9（https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/C）segment_tree|point_set|range_max_bisect_left
10（https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D）segment_tree|point_set|range_max_bisect_left_with_ind
11（https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/A）segment_tree|point_set|range_sum|inversion
12（https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/B）segment_tree|point_set|range_sum|inversion|bisect_left
13（https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/C）segment_tree|point_set|range_sum|range_include
14（https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/D）segment_tree|point_set|range_sum|range_include|reverse_thinking|include_exclude
15（https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/E）segment_tree|range_add|point_get
16（https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/A）segment_tree|point_set|range_sum
17（https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/B）segment_tree|matrix_build|range_mul
18（https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/C）segment_tree|point_set|range_inverse
19（https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/D）segment_tree|point_set|range_or
20（https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A）segment_tree|range_add|point_get
21（https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A）segment_tree|range_ascend|point_get
22（https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A）segment_tree|range_set|point_get
23（https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/E）segment_tree|bisect_left|brute_force|classical|range_min|point_set
24（https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/A）segment_tree|range_add|range_min
25（https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/B）segment_tree|range_affine|range_sum
26（https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/C）segment_tree|range_or|range_and
27（https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/D）segment_tree|range_add|range_sum
28（https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/E）segment_tree|range_set|range_min
29（https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/F）segment_tree|range_set|range_sum
30（https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/A）segment_tree|range_set|range_max_non_emp_con_sub_sum
31（https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/B）segment_tree|range_reverse|range_bit_count_bisect_left
32（https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/C）segment_tree|range_add|range_max|bisect_left
33（https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/A）segment_tree|range_change_add|range_sum
34（https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/B）segment_tree|diff_array|range_add|point_get|range_sum
35（https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/C）segment_tree|range_set|range_seg_count_length
36（https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/D）segment_tree|range_add|range_weighted_sum
37（https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E）segment_tree|range_chmin_chmax|point_get
38（https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/F）segment_tree_dynamic|range_set|range_sum_bisect_left

1（https://www.codechef.com/problems/SPR）reverse_order|brute_force|implemention|range_add|range_min
2（https://www.codechef.com/problems/KPRODSUM）range_mul|range_mul

"""
import bisect
import random
from collections import defaultdict, Counter, deque
from functools import lru_cache
from heapq import heappush, heappop
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.data_structure.segment_tree.template import RangeAscendRangeMax, RangeDescendRangeMin, \
    RangeAddRangeSumMinMax, RangeRevereRangeBitCount, RangeSetRangeOr, \
    RangeAddRangeAvgDev, \
    RangeSetRangeSumMinMaxDynamic, PointSetRangeLongestSubSame, \
    RangeOrRangeAnd, RangeSetRangeSumMinMax, RangeKthSmallest, RangeSetRangeMaxNonEmpConSubSum, \
    RangeAffineRangeSum, PointSetRangeComposite, RangeLongestRegularBrackets, \
    RangeXorUpdateRangeXorQuery, PointSetRangeLongestAlter, \
    RangeSqrtRangeSum, RangeSetReverseRangeSumLongestConSub, PointSetRangeOr, PointSetRangeSum, PointSetRangeMin, \
    PointSetRangeMinCount, PointSetRangeMaxSubSum, PointSetRangeMax, RangeAddPointGet, MatrixBuildRangeMul, \
    PointSetRangeInversion, RangeSetPointGet, RangeAscendPointGet, RangeSetAddRangeSumMinMax, \
    RangeSetRangeSegCountLength, RangeAddRangeWeightedSum, RangeChminChmaxPointGet, RangeSetPreSumMaxDynamicDct, \
    PointAddRangeSum1Sum2, PointAddRangeSumMod5, PointSetRangeMaxIndex, RangeModPointSetRangeSum, PointSetRangeGcd, \
    PointSetRangeAscendSubCnt, PointSetRangeNotExistABC, RangeAscendRangeMaxIndex, RangeMulRangeMul, \
    RangeSetRangeSumMinMaxDynamicDct, RangeSetPreSumMaxDynamic, RangeRevereRangeAlter, \
    PointSetRangeMaxSecondCnt, PointSetRangeXor, RangeAddMulRangeSum, RangeAddRangeMinCount, RangeSetPreSumMax, \
    PointSetRangeMaxSubSumAlter, RangeAddRangeMulSum, LazySegmentTree, PointSetPreMaxPostMin, PointSetPreMinPostMin, \
    PointSetRangeMaxSubSumAlterSignal, RangeAddRangeConSubPalindrome, RangeOrRangeOr, SegmentTreeOptBuildGraphZKW
from src.data_structure.sorted_list.template import SortedList
from src.data_structure.tree_array.template import PointAddRangeSum, PointXorRangeXor
from src.data_structure.zkw_segment_tree.template import LazySegmentTree as LazySegmentTreeZKW
from src.graph.dijkstra.template import Dijkstra
from src.graph.union_find.template import UnionFind
from src.mathmatics.number_theory.template import PrimeSieve
from src.mathmatics.prime_factor.template import AllFactorCnt, PrimeFactor
from src.search.dfs.template import DFS
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_2213(s: str, word: str, indices: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/longest-substring-of-one-repeating-character/
        tag: segment_tree|sub_consequence|range_query|range_merge
        """
        n = len(s)
        tree = PointSetRangeLongestSubSame(n, [ord(w) - ord("a") for w in s])
        ans = []
        for i, w in zip(indices, word):
            ans.append(tree.point_set_rang_longest_sub_same(i, ord(w) - ord("a")))
        return ans

    @staticmethod
    def library_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/range_affine_point_get
        tag: RangeAffineRangeSum
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        mod = 998244353
        tree = RangeAffineRangeSum(n, mod)
        tree.build(nums)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 0:
                ll, rr, b, c = lst[1:]
                tree.range_affine(ll, rr - 1, (b << 32) | c)
            else:
                i = lst[1]
                ac.st(tree.range_sum(i, i))
        return

    @staticmethod
    def library_check_2(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/range_affine_range_sum
        tag: RangeAffineRangeSum
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        mod = 998244353
        tree = RangeAffineRangeSum(n, mod)
        tree.build(nums)
        ans = []
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 0:
                ll, rr, b, c = lst[1:]
                tree.range_affine(ll, rr - 1, (b << 32) | c)
            else:
                ll, rr = lst[1:]
                ans.append(str(tree.range_sum(ll, rr - 1)))
        print("\n".join(ans))
        return

    @staticmethod
    def library_3(ac=FastIO()):
        n, q = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        m = 32
        mod = 998244353
        tree = PointSetRangeComposite(n, mod, m)
        tree.build([(c << m) | d for c, d in nums])
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 0:
                p, c, d = lst[1:]
                tree.point_set(p, p, (c << m) | d)
            else:
                ll, rr, x = lst[1:]
                val = tree.range_composite(ll, rr - 1)
                mul, add = val >> m, val & tree.mask
                ac.st((mul * x + add) % mod)
        return

    @staticmethod
    def lc_2569(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/handling-sum-queries-after-update/
        tag: segment_tree|range_reverse|bit_set
        """
        n = len(nums1)
        tree = RangeRevereRangeBitCount(n)
        tree.build(nums1)
        ans = []
        s = sum(nums2)
        for op, x, y in queries:
            if op == 1:
                tree.range_reverse(x, y)
            elif op == 2:
                s += tree.range_bit_count(0, n - 1) * x
            else:
                ans.append(s)
        return ans

    @staticmethod
    def lg_p1904(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1904
        tag: segment_tree|RangeAscendRangeMax
        """
        high = 10 ** 4
        segment = RangeAscendRangeMax(high)
        segment.build([0] * high)
        nums = set()
        while True:
            s = ac.read_str()
            if not s:
                break
            x, h, y = [int(w) for w in s.split() if w]
            nums.add(x)
            nums.add(y)
            segment.range_ascend(x, y - 1, h)
        nums = sorted(list(nums))
        n = len(nums)
        height = [segment.range_max(num, num) for num in nums]
        ans = []
        pre = -1
        for i in range(n):
            if height[i] != pre:
                ans.extend([nums[i], height[i]])
                pre = height[i]
        ac.lst(ans)
        return

    @staticmethod
    def cf_1216f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1216/problem/F
        tag: segment_tree|dp|monotonic_queue
        """
        n, k = ac.read_list_ints()
        s = ac.read_str()
        tree = RangeDescendRangeMin(n)
        for i in range(n):
            if s[i] == "1":
                left = max(0, i - k)
                right = min(n - 1, i + k)
                pre = tree.range_min(left - 1, i - 1) if left else 0
                cur = pre + i + 1
                tree.range_descend(i, right, cur)
            else:
                pre = tree.range_min(i - 1, i - 1) if i else 0
                cur = pre + i + 1
                tree.range_descend(i, i, cur)
        ac.st(tree.range_min(n - 1, n - 1))
        return

    @staticmethod
    def cf_1478e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1478/problem/E
        tag: RangeSetRangeSumMinMax|backward_thinking|implemention
        """
        for _ in range(ac.read_int()):
            def check():
                n, q = ac.read_list_ints()
                s = [int(w) for w in ac.read_str()]
                t = [int(w) for w in ac.read_str()]
                queries = [ac.read_list_ints_minus_one() for _ in range(q)]
                queries.reverse()
                tree = RangeSetRangeSumMinMax(n)
                tree.build(t)
                for ll, rr in queries:
                    cur_sum = tree.range_sum(ll, rr)
                    if cur_sum < rr - ll + 1 - cur_sum:
                        tree.range_set(ll, rr, 0)
                    elif cur_sum > rr - ll + 1 - cur_sum:
                        tree.range_set(ll, rr, 1)
                    else:
                        ac.no()
                        return
                if tree.get() == s:
                    ac.yes()
                else:
                    ac.no()
                return

            check()
        return

    @staticmethod
    def cf_1665e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1665/problem/E
        tag: segment_tree|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            tree = RangeKthSmallest(n, 31)
            tree.build(nums)
            for _ in range(ac.read_int()):
                ll, rr = ac.read_list_ints_minus_one()
                lst = tree.range_kth_smallest(ll, rr)
                ans = math.inf
                m = len(lst)
                for i in range(m):
                    x = lst[i]
                    if x > ans:
                        break
                    for j in range(i + 1, m):
                        y = lst[j]
                        if x > ans:
                            break
                        ans = min(ans, x | y)
                ac.st(ans)
        return

    @staticmethod
    def lc_218(buildings: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/the-skyline-problem/
        tag: segment_tree|RangeChangeRangeMax
        """
        pos = set()
        for left, right, _ in buildings:
            pos.add(left)
            pos.add(right)
        lst = sorted(list(pos))
        n = len(lst)
        dct = {x: i for i, x in enumerate(lst)}

        segment = RangeAscendRangeMax(n)
        segment.build([0] * n)
        for left, right, height in buildings:
            segment.range_ascend(dct[left], dct[right] - 1, height)

        pre = -1
        ans = []
        for pos in lst:
            h = segment.range_max(dct[pos], dct[pos])
            if h != pre:
                ans.append([pos, h])
                pre = h
        return ans

    @staticmethod
    def cf_380c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/380/C
        tag: segment_tree|range_merge|sub_consequence|bracket
        """
        s = ac.read_str()
        n = len(s)
        tree = RangeLongestRegularBrackets(n)
        tree.build(s)
        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints_minus_one()
            ac.st(tree.range_longest_regular_brackets(x, y))
        return

    @staticmethod
    def lg_p3372(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3372
        tag: RangeAddRangeSumMaxMin
        """
        n, m = ac.read_list_ints()
        segment = RangeAddRangeSumMinMax(n)
        segment.build(ac.read_list_ints())

        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y, k = lst[1:]
                segment.range_add(x - 1, y - 1, k)
            else:
                x, y = lst[1:]
                ac.st(segment.range_sum(x - 1, y - 1))
        return

    @staticmethod
    def lg_p3870(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3870
        tag: segment_tree|range_reverse|range_sum
        """
        n, m = ac.read_list_ints()
        segment = RangeRevereRangeBitCount(n)

        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 0:
                x, y = lst[1:]
                segment.range_reverse(x - 1, y - 1)
            else:
                x, y = lst[1:]
                ac.st(segment.range_bit_count(x - 1, y - 1))
        return

    @staticmethod
    def lg_p1438(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1438
        tag: diff_array|RangeAddRangeSumMaxMin|segment_tree
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        segment = RangeAddRangeSumMinMax(n)

        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y, k, d = lst[1:]
                if x == y:
                    segment.range_add(x - 1, x - 1, k)
                    if y <= n - 1:
                        segment.range_add(y, y, -k)
                else:
                    segment.range_add(x - 1, x - 1, k)
                    segment.range_add(x, y - 1, d)
                    cnt = y - x
                    if y <= n - 1:
                        segment.range_add(y, y, -cnt * d - k)
            else:
                x = lst[1]
                ac.st(segment.range_sum(0, x - 1) + nums[x - 1])
        return

    @staticmethod
    def lg_p1253(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1253
        tag: range_add|range_change|segment_tree|range_sum
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = RangeSetAddRangeSumMinMax(n, 1 << 32)
        tree.build(nums)
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y, k = lst[1:]
                tree.range_set_add(x - 1, y - 1, (k, 0))
                for i in range(x - 1, y):
                    nums[i] = k
            elif lst[0] == 2:
                x, y, k = lst[1:]
                tree.range_set_add(x - 1, y - 1, (-math.inf, k))
                for i in range(x - 1, y):
                    nums[i] += k
            else:
                x, y = lst[1:]
                ac.st(tree.range_max(x - 1, y - 1))
        return

    @staticmethod
    def lg_p3373(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3373
        tag: range_add|range_mul|segment_tree|range_sum|RangeAffineRangeSum
        """
        n, q, mod = ac.read_list_ints()
        tree = RangeAffineRangeSum(n, mod)
        nums = ac.read_list_ints()
        tree.build(nums)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y, k = lst[1:]
                tree.range_affine(x - 1, y - 1, k << 32)
            elif lst[0] == 2:
                x, y, k = lst[1:]
                tree.range_affine(x - 1, y - 1, (1 << 32) | k)
            else:
                x, y = lst[1:]
                ans = tree.range_sum(x - 1, y - 1)
                ac.st(ans)
        return

    @staticmethod
    def lg_p4513(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4513
        tag: segment_tree|range_change|range_merge|sub_consequence
        """
        n, m = ac.read_list_ints()
        segment = RangeSetRangeMaxNonEmpConSubSum(n, 1000)
        segment.build([ac.read_int() for _ in range(n)])
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                a, b = lst[1:]
                a, b = min(a, b), max(a, b)
                ans = segment.range_max_non_emp_con_sub_sum(a - 1, b - 1)
                ac.st(ans)
            else:
                a, s = lst[1:]
                segment.point_set(a - 1, s)
        return

    @staticmethod
    def lg_p1471(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1471
        tag: math|segment_tree|RangeAddRangeSum
        """
        n, m = ac.read_list_ints()
        tree = RangeAddRangeAvgDev(n)
        tree.build(ac.read_list_floats())
        for _ in range(m):
            lst = ac.read_list_floats()
            if lst[0] == 1:
                x, y, k = lst[1:]
                x = int(x)
                y = int(y)
                tree.range_add(x - 1, y - 1, k)
            elif lst[0] == 2:
                x, y = lst[1:]
                x = int(x)
                y = int(y)
                ans = tree.range_avg_dev(x - 1, y - 1)[0]
                ac.st("%.4f" % ans)
            else:
                x, y = lst[1:]
                x = int(x)
                y = int(y)
                ans = tree.range_avg_dev(x - 1, y - 1)[1]
                ac.st("%.4f" % ans)
        return

    @staticmethod
    def lg_p6627(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6627
        tag: segment_tree|range_xor|discretization
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nodes = {0, -10 ** 9 - 1, 10 ** 9 + 1}
        for lst in nums:
            for va in lst[1:-1]:
                nodes.add(va)
                nodes.add(va - 1)
                nodes.add(va + 1)
        nodes = sorted(list(nodes))
        n = len(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        tree = RangeXorUpdateRangeXorQuery(n)
        arr = [0] * n
        for lst in nums:
            if lst[0] == 1:
                a, b, w = lst[1:]
                if a > b:
                    a, b = b, a
                tree.range_xor_update(ind[a], ind[b], w)
            elif lst[0] == 2:
                a, w = lst[1:]
                arr[ind[a]] ^= w
            else:
                a, w = lst[1:]
                tree.range_xor_update(0, n - 1, w)
                arr[ind[a]] ^= w
        ans = math.inf
        res = -math.inf
        nums = tree.get()
        for i in range(n):
            val = arr[i] ^ nums[i]
            if val > res or (
                    val == res and (abs(ans) > abs(nodes[i]) or (abs(ans) == abs(nodes[i]) and nodes[i] > ans))):
                res = val
                ans = nodes[i]
        ac.lst([res, ans])
        return

    @staticmethod
    def lg_p6492(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6492
        tag: segment_tree|range_change|range_merge|sub_consequence
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeLongestAlter(n)
        for _ in range(q):
            i = ac.read_int() - 1
            ac.st(tree.point_set_range_longest_alter(i, i))
        return

    @staticmethod
    def lg_p4145(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4145
        tag: math|segment_tree|RangeAddRangeSum
        """
        n = ac.read_int()
        tree = RangeSqrtRangeSum(n)
        tree.build(ac.read_list_ints())
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            a, b = [int(w) - 1 for w in lst[1:]]
            if a > b:
                a, b = b, a
            if lst[0] == 0:
                tree.range_sqrt(a, b)
            else:
                ac.st(tree.range_sum(a, b))
        return

    @staticmethod
    def lc_2940(heights: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet/
        tag: segment_tree_binary_search|static_range
        """
        n = len(heights)
        tree = RangeAscendRangeMax(n)
        tree.build(heights)
        ans = []
        for ll, rr in queries:
            if ll > rr:
                ll, rr = rr, ll
            if heights[ll] < heights[rr]:
                ans.append(rr)
                continue
            if ll == rr:
                ans.append(ll)
                continue
            if rr == n - 1:
                ans.append(-1)
                continue
            h = heights[ll] if heights[ll] > heights[rr] else heights[rr]
            left = tree.range_max_bisect_left(rr + 1, n - 1, h + 1)
            ans.append(left)
        return ans

    @staticmethod
    def lg_p2574(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2574
        tag: segment_tree|range_reverse|range_sum
        """
        n, m = ac.read_list_ints()
        tree = RangeRevereRangeBitCount(n)
        tree.build([int(w) for w in ac.read_str()])

        for _ in range(m):
            op, left, right = ac.read_list_ints()
            if not op:
                tree.range_reverse(left - 1, right - 1)
            else:
                ac.st(tree.range_bit_count(left - 1, right - 1))
        return

    @staticmethod
    def lg_2572(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2572
        tag: segment_tree|range_reverse|range_sum
        """
        n, m = ac.read_list_ints()
        tree = RangeSetReverseRangeSumLongestConSub(n)
        tree.build(ac.read_list_ints())
        ans = []
        for _ in range(m):
            lst = ac.read_list_ints()
            left, right = lst[1:]
            if left > right:
                left, right = right, left
            if lst[0] <= 2:
                tree.range_set_reverse(left, right, lst[0])
            elif lst[0] == 3:
                ans.append(str(tree.range_sum(left, right)))
            else:
                ans.append(str(tree.range_longest_con_sub(left, right)))
        ac.st("\n".join(ans))
        return

    @staticmethod
    def lg_p1558(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1558
        tag: segment_tree|RangeSetRangeOr
        """
        n, t, q = ac.read_list_ints()
        tree = RangeSetRangeOr(n)
        tree.range_set(0, n - 1, 1)
        for _ in range(q):
            lst = ac.read_list_strs()
            if lst[0] == "C":
                a, b, c = [int(w) for w in lst[1:]]
                if a > b:
                    a, b = b, a
                tree.range_set(a - 1, b - 1, 1 << (c - 1))
            else:
                a, b = [int(w) for w in lst[1:]]
                if a > b:
                    a, b = b, a
                ac.st(bin(tree.range_or(a - 1, b - 1)).count("1"))
        return

    @staticmethod
    def lg_p3740(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3740
        tag: discretization|segment_tree|RangeChangeRangeSum
        """
        n, m = ac.read_list_ints()
        nums = []
        while len(nums) < m * 2:
            nums.extend(ac.read_list_ints())
        nums = [nums[2 * i:2 * i + 2] for i in range(m)]
        nodes = set()
        nodes.add(1)
        nodes.add(n)
        for a, b in nums:
            nodes.add(a)
            nodes.add(b)
            nodes.add(b + 1)
        nodes = list(sorted(nodes))
        ind = {num: i for i, num in enumerate(nodes)}

        n = len(nodes)
        tree = RangeSetRangeSumMinMax(n)
        tree.build([0] * n)
        for i in range(m):
            a, b = nums[i]
            tree.range_set(ind[a], ind[b], i + 1)

        ans = tree.get()
        ac.st(len(set(c for c in ans if c)))
        return

    @staticmethod
    def lg_p4588(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4588
        tag: segment_tree|PointSetRangeComposite
        """
        for _ in range(ac.read_int()):
            n, mod = ac.read_list_ints()
            m = 32
            tree = PointSetRangeComposite(n, mod, m)
            tree.build([1 << m for _ in range(n)])
            for i in range(n):
                op, x = ac.read_list_ints()
                if op == 1:
                    tree.point_set(i, i, x << m)
                else:
                    tree.point_set(x - 1, x - 1, 1 << m)
                val = tree.range_composite(0, n - 1)
                ac.st((val >> m) % mod)
        return

    @staticmethod
    def lg_p8081(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8081
        tag: diff_array|counter|action_scope|segment_tree|RangeSetRangeOr
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        tree = RangeSetRangeSumMinMax(n)
        pre = 0
        ceil = 0
        for i in range(n):
            if nums[i] < 0:
                pre += 1
            else:
                if pre:
                    ceil = max(ceil, pre)
                    low, high = i - 3 * pre, i - pre - 1
                    if high >= 0:
                        tree.range_set(max(0, low), high, 1)
                pre = 0
        if pre:
            ceil = max(ceil, pre)
            low, high = n - 3 * pre, n - pre - 1
            if high >= 0:
                tree.range_set(max(0, low), high, 1)

        ans = tree.range_sum(0, n - 1)
        pre = 0
        res = 0
        for i in range(n):
            if nums[i] < 0:
                pre += 1
            else:
                if pre == ceil:
                    low, high = i - 4 * pre, i - 3 * pre - 1
                    low = max(low, 0)
                    if low <= high:
                        res = max(res, high - low + 1 - tree.range_sum(low, high))
                pre = 0
        if pre == ceil:
            low, high = n - 4 * pre, n - 3 * pre - 1
            low = max(low, 0)
            if low <= high:
                res = max(res, high - low + 1 - tree.range_sum(low, high))
        ac.st(ans + res)
        return

    @staticmethod
    def lg_p8812(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8812
        tag: segment_tree|RangeDescendRangeMin|discretization
        """
        n, m = ac.read_list_ints()
        goods = [[] for _ in range(n)]
        for _ in range(m):
            s, t, p, c = ac.read_list_ints()
            for _ in range(c):
                a, b = ac.read_list_ints()
                a -= 1
                goods[a].append([1, 10 ** 9 + 1, b])
                b = b * p // 100
                goods[a].append([s, t, b])

        for i in range(n):
            nodes = {0, 10 ** 9 + 1}
            for s, t, _ in goods[i]:
                nodes.add(s - 1)
                nodes.add(s)
                nodes.add(t)
                nodes.add(t + 1)
            nodes = sorted(list(nodes))
            ind = {node: i for i, node in enumerate(nodes)}
            k = len(ind)
            tree = RangeDescendRangeMin(k)
            for s, t, b in goods[i]:
                tree.range_descend(ind[s], ind[t], b)
            res = []
            for x in range(k):
                val = tree.range_min(x, x)
                if val == math.inf:
                    continue
                if not res or res[-1][2] != val:
                    res.append([nodes[x], nodes[x], val])
                else:
                    res[-1][1] = nodes[x]

            goods[i] = [r[:] for r in res]

        nodes = {0, 10 ** 9 + 1}
        for i in range(n):
            for s, t, _ in goods[i]:
                nodes.add(s)
                nodes.add(t)
        nodes = sorted(list(nodes))
        ind = {node: i for i, node in enumerate(nodes)}
        k = len(ind)
        diff = [0] * k
        for i in range(n):
            for s, t, b in goods[i]:
                diff[ind[s]] += b
                if ind[t] + 1 < k:
                    diff[ind[t] + 1] -= b
        diff = ac.accumulate(diff)[2:]
        ac.st(min(diff))
        return

    @staticmethod
    def cf_482b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/482/B
        tag: segment_tree|RangeOrRangeAnd
        """
        n, m = ac.read_list_ints()
        tree = RangeOrRangeAnd(n)
        nums = [ac.read_list_ints_minus_one() for _ in range(m)]
        for a, b, c in nums:
            if c != -1:
                tree.range_or(a, b, c + 1)
        if all(tree.range_and(a, b) == c + 1 for a, b, c in nums):
            ac.yes()
            ac.lst(tree.get())
        else:
            ac.no()
        return

    @staticmethod
    def cf_987c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/987/C
        tag: brute_force|segment_tree|prefix_suffix
        """
        n = ac.read_int()
        s = ac.read_list_ints()
        c = ac.read_list_ints()
        ind = {num: i for i, num in enumerate(sorted(list(set(s + c + [0] + [10 ** 9 + 1]))))}
        m = len(ind)
        post = [math.inf] * n
        tree = RangeDescendRangeMin(m)
        for i in range(n - 1, -1, -1):
            tree.range_descend(ind[s[i]], ind[s[i]], c[i])
            post[i] = tree.range_min(ind[s[i]] + 1, m - 1)

        ans = math.inf
        tree = RangeDescendRangeMin(m)
        for i in range(n):
            if 1 <= i <= n - 2:
                cur = c[i] + tree.range_min(0, ind[s[i]] - 1) + post[i]
                ans = min(ans, cur)
            tree.range_descend(ind[s[i]], ind[s[i]], c[i])
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lc_1851(intervals: List[List[int]], queries: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/minimum-interval-to-include-each-query/
        tag: segment_tree|RangeChangeRangeMin|offline_query|monotonic_queue
        """
        port = []
        for inter in intervals:
            port.extend(inter)
        port.extend(queries)
        lst = sorted(list(set(port)))

        ind = {num: i for i, num in enumerate(lst)}
        ceil = len(lst)
        tree = RangeDescendRangeMin(ceil)
        for a, b in intervals:
            tree.range_descend(ind[a], ind[b], b - a + 1)
        ans = [tree.range_min(ind[num], ind[num]) for num in queries]
        return [x if x != math.inf else -1 for x in ans]

    @staticmethod
    def lc_1340(nums: List[int], d: int) -> int:
        """
        url: https://leetcode.cn/problems/jump-game-v/
        tag: segment_tree|linear_dp
        """
        n = len(nums)
        post = [n - 1] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] <= nums[i]:
                post[stack.pop()] = i - 1
            stack.append(i)

        pre = [0] * n
        stack = []
        for i in range(n - 1, -1, -1):
            while stack and nums[stack[-1]] <= nums[i]:
                pre[stack.pop()] = i + 1
            stack.append(i)

        dct = defaultdict(list)
        for i, num in enumerate(nums):
            dct[num].append(i)
        tree = RangeAscendRangeMax(n)
        tree.build([0] * n)
        for num in sorted(dct):
            cur = []
            for i in dct[num]:
                left, right = pre[i], post[i]
                if left < i - d:
                    left = i - d
                if right > i + d:
                    right = i + d
                x = tree.range_max(left, right)
                cur.append([x + 1, i])

            for x, i in cur:
                tree.range_ascend(i, i, x)
        return tree.range_max(0, n - 1)

    @staticmethod
    def abc_332f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc332/tasks/abc332_f
        tag: RangeAffineRangeSum
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        mod = 998244353
        tree = RangeAffineRangeSum(n, mod)
        tree.build(nums)
        for _ in range(m):
            ll, rr, xx = ac.read_list_ints()
            length = rr - ll + 1
            mul = ((length - 1) * pow(length, -1, mod)) % mod
            add = (xx * pow(length, -1, mod)) % mod
            tree.range_affine(ll - 1, rr - 1, (mul << 32) | add)
        ac.lst(tree.get())
        return

    @staticmethod
    def ac_3805(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3808/
        tag: RangeAddRangeMin
        """
        n = ac.read_int()
        tree = RangeAddRangeSumMinMax(n)
        tree.build(ac.read_list_ints())
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if len(lst) == 2:
                ll, r = lst
                if ll <= r:
                    ac.st(tree.range_min(ll, r))
                else:
                    ans1 = tree.range_min(ll, n - 1)
                    ans2 = tree.range_min(0, r)
                    ac.st(min(ans1, ans2))
            else:
                ll, r, d = lst
                if ll <= r:
                    tree.range_add(ll, r, d)
                else:
                    tree.range_add(ll, n - 1, d)
                    tree.range_add(0, r, d)
        return

    @staticmethod
    def ac_5037_1(ac=FastIO()):

        n = ac.read_int()
        nums = ac.read_list_ints()
        tree = [RangeRevereRangeBitCount(n) for _ in range(22)]
        for j in range(22):
            lst = [1 if nums[i] & (1 << j) else 0 for i in range(n)]
            tree[j].build(lst)
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr = lst[1:]
                ll -= 1
                rr -= 1
                ans = sum((1 << j) * tree[j].range_bit_count(ll, rr) for j in range(22))
                ac.st(ans)
            else:
                ll, rr, xx = lst[1:]
                ll -= 1
                rr -= 1
                for j in range(22):
                    if (1 << j) & xx:
                        tree[j].range_reverse(ll, rr)

        return

    @staticmethod
    def lc_2276_1():
        """
        url: https://leetcode.cn/problems/count-integers-in-intervals/
        tag: dynamic_segment_tree|union_find_range|SortedList
        """

        class CountIntervals:
            def __init__(self):
                self.n = 10 ** 9 + 7
                self.segment_tree = RangeSetRangeSumMinMaxDynamic(self.n)

            def add(self, left: int, right: int) -> None:
                self.segment_tree.range_set(left, right, 1)

            def count(self) -> int:
                return self.segment_tree.cover[1]

        return CountIntervals

    @staticmethod
    def lc_2276_2():
        """
        url: https://leetcode.cn/problems/count-integers-in-intervals/
        tag: dynamic_segment_tree|union_find_range|SortedList
        """

        class CountIntervals:

            def __init__(self):
                self.lst = SortedList()
                self.cover = 0

            def add(self, left: int, right: int) -> None:
                x = self.lst.bisect_left((left, left))
                if x - 1 >= 0 and self.lst[x - 1][1] >= left:
                    x -= 1

                while 0 <= x < len(self.lst) and not (self.lst[x][0] > right or self.lst[x][1] < left):
                    a, b = self.lst.pop(x)
                    left = left if left < a else a
                    right = right if right > b else b
                    self.cover -= b - a + 1
                self.cover += right - left + 1
                self.lst.add((left, right))

            def count(self) -> int:
                return self.cover

        return CountIntervals

    @staticmethod
    def lc_2286():
        """
        url: https://leetcode.cn/problems/booking-concert-tickets-in-groups/
        tag: segment_tree|RangeAddRangeSumMaxMin
        """

        class BookMyShow:

            def __init__(self, n: int, m: int):
                self.n = n
                self.m = m
                self.tree = RangeAddRangeSumMinMax(n)
                self.cnt = [0] * n
                self.null = SortedList(list(range(n)))

            def gather(self, k: int, max_row: int) -> List[int]:
                max_row += 1
                low = self.tree.range_min(0, max_row - 1)
                if self.m - low < k:
                    return []

                y = self.tree.range_min_bisect_left(self.m - k)
                self.cnt[y] += k
                self.tree.range_add(y, y, k)
                if self.cnt[y] == self.m:
                    self.null.discard(y)
                return [y, self.cnt[y] - k]

            def scatter(self, k: int, max_row: int) -> bool:
                max_row += 1
                s = self.tree.range_sum(0, max_row - 1)
                if self.m * max_row - s < k:
                    return False
                while k:
                    x = self.null[0]
                    rest = k if k < self.m - self.cnt[x] else self.m - self.cnt[x]
                    k -= rest
                    self.cnt[x] += rest
                    self.tree.range_add(x, x, rest)
                    if self.cnt[x] == self.m:
                        self.null.pop(0)
                return True

        return BookMyShow

    @staticmethod
    def lc_3003(s: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximize-the-number-of-partitions-after-operations
        tag: segment_tree|bisect_left|range_or|point_set
        """
        n = len(s)
        s = [ord(w) - ord("a") for w in s]
        tree = PointSetRangeOr(n)
        tree.build([1 << w for w in s])

        pre_ind = [-1] * n
        pre_cnt = [0] * n
        ind = [-1]
        pre = set()
        for i in range(n):
            pre_ind[i] = ind[-1]
            pre_cnt[i] = len(ind) - 1
            if s[i] not in pre and len(pre) == k:
                ind.append(i - 1)
                pre = set()
            pre.add(s[i])
        ind.append(n - 1)

        post_cnt = [0] * (n + 1)
        post = dict()
        j = n - 1
        for i in range(n - 1, -1, -1):
            post[s[i]] = post.get(s[i], 0) + 1
            while len(post) > k:
                post[s[j]] -= 1
                if not post[s[j]]:
                    post.pop(s[j])
                j -= 1
            post_cnt[i] = post_cnt[j + 1] + 1

        ans = post_cnt[0]
        for i in range(n):
            xx = s[i]
            for j in range(26):
                if j == xx or (i + 1 < n and s[i + 1] == j) or (i and s[i - 1] == j):
                    continue
                tree.point_set(i, 1 << j)
                cur_ind = pre_ind[i] + 1
                cur = pre_cnt[i]
                while cur_ind <= i:
                    jj = tree.range_or_bisect_right(cur_ind, n - 1, k)
                    cur += 1
                    cur_ind = jj + 1
                cur += post_cnt[cur_ind]
                if cur > ans:
                    ans = cur
            tree.point_set(i, 1 << xx)
        return ans

    @staticmethod
    def library_check_4(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/A
        tag: segment_tree|point_set|range_sum
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeSum(n)
        tree.build(ac.read_list_ints())
        for _ in range(q):
            op, x, y = ac.read_list_ints()
            if op == 1:
                tree.point_set(x, y)
            else:
                ans = tree.range_sum(x, y - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_5(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/B
        tag: segment_tree|point_set|range_min
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeMin(n, math.inf)
        tree.build(ac.read_list_ints())
        for _ in range(q):
            op, x, y = ac.read_list_ints()
            if op == 1:
                tree.point_set(x, y)
            else:
                ans = tree.range_min(x, y - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_6(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/1/practice/contest/273169/problem/C
        tag: segment_tree|point_set|range_min_count
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeMinCount(n, 0)
        nums = ac.read_list_ints()
        tree.build(nums)
        ac.get_random_seed()
        for _ in range(q):
            op, x, y = ac.read_list_ints()
            if op == 1:
                tree.point_set(x, y)
            else:
                ans = tree.range_min_count(x, y - 1)
                ac.lst(ans)
        return

    @staticmethod
    def library_check_7(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A
        tag: segment_tree|point_set|range_max_sub_sum
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeMaxSubSum(n, 0)
        nums = ac.read_list_ints()
        tree.build(nums)
        ans = tree.cover[1]
        ac.st(max(ans, 0))
        for _ in range(q):
            x, y = ac.read_list_ints()
            ans = tree.point_set_range_max_sub_sum(x, y)
            ac.st(max(ans, 0))
        return

    @staticmethod
    def library_check_8(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/B
        tag: segment_tree|point_set|range_sum_bisect_left
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeSum(n, 0)
        nums = ac.read_list_ints()
        tree.build(nums)
        for _ in range(q):
            x, y = ac.read_list_ints()
            if x == 1:
                nums[y] = 1 - nums[y]
                tree.point_set(y, nums[y])
            else:
                ans = tree.range_sum_bisect_left(y + 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_9(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/C
        tag: segment_tree|point_set|range_max_bisect_left
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeMax(n, 0)
        tree.build(ac.read_list_ints())

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                i, v = lst[1:]
                tree.point_set(i, v)
            else:
                x = lst[1]
                ans = tree.range_max_bisect_left(0, n - 1, x) if tree.cover[1] >= x else -1
                ac.st(ans)
        return

    @staticmethod
    def library_check_10(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D
        tag: segment_tree|point_set|range_max_bisect_left
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeMax(n)
        tree.build(ac.read_list_ints())
        for _ in range(q):
            op, x, y = ac.read_list_ints()
            if op == 1:
                tree.point_set(x, y)
            else:
                ans = tree.range_max_bisect_left(y, n - 1, x)
                ac.st(ans)
        return

    @staticmethod
    def library_check_11(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/A
        tag: segment_tree|point_set|range_sum|inversion
        """
        n = ac.read_int()
        tree = PointSetRangeSum(n, 0)
        nums = ac.read_list_ints_minus_one()
        ans = [0] * n
        for j in range(n):
            i = nums[j]
            ans[j] = tree.range_sum(i, n - 1)
            tree.point_set(i, 1)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_12(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/B
        tag: segment_tree|point_set|range_sum|inversion|bisect_left
        """
        n = ac.read_int()
        tree = PointSetRangeSum(n, 0)
        tree.build([1] * n)
        nums = ac.read_list_ints()
        ans = [0] * n
        for j in range(n - 1, -1, -1):
            i = nums[j]
            ans[j] = tree.range_sum_bisect_left(tree.cover[1] - i) + 1
            tree.point_set(ans[j] - 1, 0)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_13(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/C
        tag: segment_tree|point_set|range_sum|range_include
        """
        n = ac.read_int()
        nums = ac.read_list_ints_minus_one()
        tree = PointSetRangeSum(2 * n, 0)
        ans = [0] * n
        pre = [-1] * n
        for j in range(2 * n):
            i = nums[j]
            if pre[i] == -1:
                pre[i] = j
                continue
            ans[i] = tree.range_sum(pre[i], j)
            tree.point_set(pre[i], 1)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_14(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/D
        tag: segment_tree|point_set|range_sum|range_include|reverse_thinking|include_exclude
        """
        n = ac.read_int()
        nums = ac.read_list_ints_minus_one()
        tree = PointSetRangeSum(2 * n, 0)
        ans = [0] * n
        pre = [-1] * n
        for j in range(2 * n):
            i = nums[j]
            if pre[i] == -1:
                pre[i] = j
                continue
            ans[i] = (j - pre[i] - 1) - 2 * tree.range_sum(pre[i], j)
            tree.point_set(pre[i], 1)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_15(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/E
        tag: segment_tree|range_add|point_get
        """
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/E
        tag: segment_tree|range_add|point_get
        """
        n, q = ac.read_list_ints()
        tree = RangeAddPointGet(n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, vv = lst[1:]
                tree.range_add(ll, rr - 1, vv)
            else:
                ans = tree.point_get(lst[1])
                ac.st(ans)
        return

    @staticmethod
    def library_check_16(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/A
        tag: segment_tree|point_set|range_sum
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        odd = PointSetRangeSum(n)
        lst = [nums[i] if i % 2 else 0 for i in range(n)]
        odd.build(lst)

        even = PointSetRangeSum(n)
        lst = [nums[i] if i % 2 == 0 else 0 for i in range(n)]
        even.build(lst)

        for _ in range(ac.read_int()):
            op, x, y = ac.read_list_ints()
            if op == 0:
                if (x - 1) % 2:
                    odd.point_set(x - 1, y)
                else:
                    even.point_set(x - 1, y)
            else:
                odd_sum = odd.range_sum(x - 1, y - 1)
                even_sum = even.range_sum(x - 1, y - 1)
                ans = odd_sum - even_sum if (x - 1) % 2 else even_sum - odd_sum
                ac.st(ans)
        return

    @staticmethod
    def library_check_17(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/B
        tag: segment_tree|matrix_build|range_mul
        """
        r, n, m = ac.read_list_ints()
        nums = []
        for _ in range(n):
            for _ in range(2):
                nums.extend(ac.read_list_ints())
            ac.read_str()

        tree = MatrixBuildRangeMul(n, 0, r)
        tree.matrix_build(nums)

        for _ in range(m):
            ll, rr = ac.read_list_ints_minus_one()
            ans = tree.range_mul(ll, rr)
            ac.lst((ans[0], ans[1]))
            ac.lst((ans[2], ans[3]))
            ac.st("")
        return

    @staticmethod
    def library_check_18(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/C
        tag: segment_tree|point_set|range_inverse
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeInversion(n, 40)
        tree.build(ac.read_list_ints_minus_one())

        for _ in range(q):
            op, x, y = ac.read_list_ints_minus_one()
            if op == 0:
                ans = tree.range_inverse(x, y)
                ac.st(ans)
            else:
                tree.point_set(x, y)
        return

    @staticmethod
    def library_check_19(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/D
        tag: segment_tree|point_set|range_or
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeOr(n)
        tree.build([1 << x for x in ac.read_list_ints_minus_one()])

        for _ in range(q):
            op, x, y = ac.read_list_ints_minus_one()
            if op == 0:
                ans = tree.range_or(x, y)
                ac.st(bin(ans).count("1"))
            else:
                tree.point_set(x, x, 1 << y)
        return

    @staticmethod
    def library_check_20(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A
        tag: segment_tree|range_add|point_get
        """
        n, q = ac.read_list_ints()
        tree = RangeAddPointGet(n)

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, v = lst[1:]
                tree.range_add(ll, rr - 1, v)
            else:
                ans = tree.point_get(lst[1])
                ac.st(ans)
        return

    @staticmethod
    def library_check_21(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A
        tag: segment_tree|range_ascend|point_get
        """
        n, q = ac.read_list_ints()
        tree = RangeAscendPointGet(n)

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, v = lst[1:]
                tree.range_ascend(ll, rr - 1, v)
            else:
                ans = tree.point_get(lst[1])
                ac.st(ans)
        return

    @staticmethod
    def library_check_22(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/1/practice/contest/279634/problem/A
        tag: segment_tree|range_set|point_get
        """
        n, q = ac.read_list_ints()
        tree = RangeSetPointGet(n)
        tree.build([0] * n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, v = lst[1:]
                tree.range_set(ll, rr - 1, v)
            else:
                ans = tree.point_get(lst[1])
                ac.st(ans)
        return

    @staticmethod
    def library_check_23(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/4/practice/contest/274684/problem/E
        tag: segment_tree|bisect_left|brute_force|classical|range_min|point_set
        """
        n, q = ac.read_list_ints()
        tree = PointSetRangeMin(n, math.inf)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                i, h = lst[1:]
                tree.point_set(i, h)
            else:
                ll, rr, p = lst[1:]
                ans = 0
                while ll <= rr - 1:
                    x = tree.range_min_bisect_left(ll, rr - 1, p)
                    if x == -1:
                        break
                    ll = x
                    tree.point_set(ll, math.inf)
                    ans += 1
                ac.st(ans)
        return

    @staticmethod
    def library_check_24(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/A
        tag: segment_tree|range_add|range_min
        """
        n, q = ac.read_list_ints()
        tree = RangeAddRangeSumMinMax(n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, v = lst[1:]
                tree.range_add(ll, rr - 1, v)
            else:
                ll, rr = lst[1:]
                ans = tree.range_min(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_25(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/B
        tag: segment_tree|range_affine|range_sum
        """
        n, q = ac.read_list_ints()
        mod = 10 ** 9 + 7
        tree = RangeAffineRangeSum(n, mod)
        tree.build([1] * n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, b = lst[1:]
                tree.range_affine(ll, rr - 1, (b << 32))
            else:
                ll, rr = lst[1:]
                ans = tree.range_sum(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_26(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/C
        tag: segment_tree|range_or|range_and
        """
        n, q = ac.read_list_ints()
        tree = RangeOrRangeAnd(n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, b = lst[1:]
                tree.range_or(ll, rr - 1, b)
            else:
                ll, rr = lst[1:]
                ans = tree.range_and(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_27(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/D
        tag: segment_tree|range_add|range_sum
        """
        n, q = ac.read_list_ints()
        tree = RangeAddRangeSumMinMax(n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, b = lst[1:]
                tree.range_add(ll, rr - 1, b)
            else:
                ll, rr = lst[1:]
                ans = tree.range_sum(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_28(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/E
        tag: segment_tree|range_set|range_min
        """
        n, q = ac.read_list_ints()
        tree = RangeSetRangeSumMinMax(n)
        tree.build([0] * n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, b = lst[1:]
                tree.range_set(ll, rr - 1, b)
            else:
                ll, rr = lst[1:]
                ans = tree.range_min(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_29(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/2/practice/contest/279653/problem/F
        tag: segment_tree|range_set|range_sum
        """
        n, q = ac.read_list_ints()
        tree = RangeSetRangeSumMinMax(n)
        tree.build([0] * n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, b = lst[1:]
                tree.range_set(ll, rr - 1, b)
            else:
                ll, rr = lst[1:]
                ans = tree.range_sum(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_30(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/A
        tag: segment_tree|range_set|range_max_non_emp_con_sub_sum
        """
        n, q = ac.read_list_ints()
        tree = RangeSetRangeMaxNonEmpConSubSum(n)
        tree.build([0] * n)
        for _ in range(q):
            ll, rr, v = ac.read_list_ints()
            tree.range_set(ll, rr - 1, v)
            ans = max(tree.cover[1], 0)
            ac.st(ans)
        return

    @staticmethod
    def library_check_31(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/B
        tag: segment_tree|range_reverse|range_bit_count_bisect_left
        """
        n, m = ac.read_list_ints()
        tree = RangeRevereRangeBitCount(n)
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr = lst[1:]
                tree.range_reverse(ll, rr - 1)
            else:
                ans = tree.range_bit_count_bisect_left(lst[1] + 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_32(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/3/practice/contest/280799/problem/C
        tag: segment_tree|range_add|range_max|bisect_left
        """
        n, m = ac.read_list_ints()
        tree = RangeAddRangeSumMinMax(n)
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, v = lst[1:]
                tree.range_add(ll, rr - 1, v)
            else:
                x, ll = lst[1:]
                ans = tree.range_max_bisect_left(ll, n - 1, x)
                ac.st(ans)
        return

    @staticmethod
    def library_check_33(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/A
        tag: segment_tree|range_change_add|range_sum
        """
        n, q = ac.read_list_ints()
        tree = RangeSetAddRangeSumMinMax(n, 1)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, v = lst[1:]
                tree.range_set_add(ll, rr - 1, (v, 0))
            elif lst[0] == 2:
                ll, rr, v = lst[1:]
                tree.range_set_add(ll, rr - 1, (-tree.initial, v))
            else:
                ll, rr = lst[1:]
                ans = tree.range_sum(ll, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_34(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/B
        tag: segment_tree|diff_array|range_add|point_get|range_sum
        """
        n, q = ac.read_list_ints()
        tree = RangeAddPointGet(n)
        diff = RangeAddRangeSumMinMax(n + 1)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, a, d = lst[1:]
                tree.range_add(ll - 1, rr - 1, a)
                if ll <= rr - 1:
                    diff.range_add(ll, rr - 1, d)
                    diff.range_add(rr, rr, -d * (rr - ll))
            else:
                ans = diff.range_sum(0, lst[1] - 1) + tree.point_get(lst[1] - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_35(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/C
        tag: segment_tree|range_set|range_seg_count_length
        """
        q = ac.read_int()
        n = 10 ** 6 + 10
        tree = RangeSetRangeSegCountLength(n)
        base = 5 * 10 ** 5
        for _ in range(q):
            lst = ac.read_list_strs()
            ll, d = [int(w) for w in lst[1:]]
            ll += base
            rr = ll + d - 1
            if lst[0] == "W":
                tree.range_set(ll, rr, 0)
            else:
                tree.range_set(ll, rr, 1)
            ac.lst([tree.cover[1], tree.sum[1]])
        return

    @staticmethod
    def library_check_36(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/D
        tag: segment_tree|range_add|range_weighted_sum
        """
        n, q = ac.read_list_ints()
        tree = RangeAddRangeWeightedSum(n)
        tree.build(ac.read_list_ints())
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, d = lst[1:]
                tree.range_add(ll - 1, rr - 1, d)
            else:
                ll, rr = lst[1:]
                ans = tree.range_weighted_sum(ll - 1, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def library_check_37(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/E
        tag: segment_tree|range_chmin_chmax|point_get
        """
        n, q = ac.read_list_ints()
        tree = RangeChminChmaxPointGet(n, 0, 10 ** 5)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, hh = lst[1:]
                tree.range_chmin_chmax(ll, rr, hh, tree.high_initial)
            else:
                ll, rr, hh = lst[1:]
                tree.range_chmin_chmax(ll, rr, tree.low_initial, hh)
        ans = tree.get()
        ac.st("\n".join(str(x) for x in ans))
        return

    @staticmethod
    def library_check_38(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/5/4/practice/contest/280801/problem/F
        tag: segment_tree_dynamic|range_set|range_sum_bisect_left
        """
        n = ac.read_int()
        tree = RangeSetPreSumMaxDynamicDct(n, 10 ** 5, -1 << 32)
        while True:
            lst = ac.read_list_strs()
            if lst[0] == "I":
                ll, rr, hh = [int(w) for w in lst[1:]]
                tree.range_set(ll - 1, rr - 1, hh)
            elif lst[0] == "Q":
                hh = int(lst[1])
                ans = tree.range_pre_sum_max_bisect_left(hh)
                ac.st(ans)
            else:
                break
        return

    @staticmethod
    def abc_287g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc287/tasks/abc287_g
        tag: segment_tree|range_sum|dynamic|offline
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        q = ac.read_int()
        queries = [ac.read_list_ints() for _ in range(q)]
        nodes = set()
        for a, _ in nums:
            nodes.add(a)
        for lst in queries:
            if lst[0] == 1:
                nodes.add(lst[2])
        nodes = sorted(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        n = len(nodes)
        tree = PointAddRangeSum1Sum2(n)
        for a, b in nums:
            tree.point_add(ind[a], (b, a * b))
        for lst in queries:
            if lst[0] == 1:
                x, y = lst[1:]
                x -= 1
                a, b = nums[x]
                tree.point_add(ind[a], (-b, -b * a))
                nums[x][0] = y
                a, b = nums[x]
                tree.point_add(ind[a], (b, b * a))
            elif lst[0] == 2:
                x, y = lst[1:]
                x -= 1
                a, b = nums[x]
                tree.point_add(ind[a], (-b, -b * a))
                nums[x][1] = y
                a, b = nums[x]
                tree.point_add(ind[a], (b, b * a))
            else:
                x = lst[1]
                tot = tree.cover1[1]
                if tot < x:
                    ac.st(-1)
                else:
                    rest, c, i = tree.range_sum2_bisect_left(tot - x)
                    rest += c * nodes[i]
                    ac.st(tree.cover2[1] - rest)
        return

    @staticmethod
    def cf_85d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/85/problem/D
        tag: segment_tree|point_add|range_sum
        """
        n = ac.read_int()
        queries = [ac.read_list_strs() for _ in range(n)]
        nodes = {0}
        for lst in queries:
            if lst[0] != "sum":
                nodes.add(int(lst[1]))
        nodes = sorted(nodes)
        m = len(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        tree = PointAddRangeSumMod5(m)
        for lst in queries:
            if lst[0] == "add":
                x = int(lst[1])
                tree.point_add(ind[x], (1, x))
            elif lst[0] == "del":
                x = int(lst[1])
                tree.point_add(ind[x], (-1, -x))
            else:
                ans = tree.cover[1][3]
                ac.st(ans)
        return

    @staticmethod
    def cf_52c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/52/problem/C
        tag: segment_tree|circular_array|range_add|range_min
        """
        n = ac.read_int()  # math.inf = 1 << 64
        tree = RangeAddRangeSumMinMax(n)
        tree.build(ac.read_list_ints())
        tot = 0
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if len(lst) == 2:
                x, y = lst
                ans = math.inf
                for a, b in [(x, y)] if x <= y else [(x, n - 1), (0, y)]:
                    cur = tree.range_min(a, b)
                    ans = min(ans, cur)
                ac.st(ans + tot)
            else:
                x, y, v = lst
                if x <= y:
                    tree.range_add(x, y, v)
                else:
                    tot += v
                    if y + 1 <= x - 1:
                        tree.range_add(y + 1, x - 1, -v)
        return

    @staticmethod
    def cf_474e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/474/problem/E
        tag: segment_tree|point_set|range_max_index|linear_dp|classical
        """
        n, d = ac.read_list_ints()
        nums = ac.read_list_ints()
        nodes = sorted(set(nums))
        dct = {num: i for i, num in enumerate(nodes)}
        m = len(nodes)
        tree = PointSetRangeMaxIndex(m)
        pre = [-1] * n
        for x, num in enumerate(nums):
            cur_val = 0
            cur_ind = -1
            i = bisect.bisect_right(nodes, num - d) - 1
            if i >= 0:
                val, ind = tree.range_max_index(0, i)
                if val > cur_val:
                    cur_val = val
                    cur_ind = ind
            i = bisect.bisect_left(nodes, num + d)
            if i < m:
                val, ind = tree.range_max_index(i, m - 1)
                if val > cur_val:
                    cur_val = val
                    cur_ind = ind
            pre[x] = cur_ind
            tree.point_set_index(dct[num], x, cur_val + 1)

        ans, ind = tree.range_max_index(0, m - 1)
        lst = [ind]
        while pre[lst[-1]] != -1:
            lst.append(pre[lst[-1]])
        lst.reverse()
        ac.st(ans)
        ac.lst([x + 1 for x in lst])
        return

    @staticmethod
    def ac_246(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/246/
        tag: segment_tree|range_change|range_merge|sub_consequence
        """
        n, m = ac.read_list_ints()
        segment = RangeSetRangeMaxNonEmpConSubSum(n, 1001)
        segment.build(ac.read_list_ints())
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                a, b = lst[1:]
                a, b = min(a, b), max(a, b)
                ans = segment.range_max_non_emp_con_sub_sum(a - 1, b - 1)
                ac.st(ans)
            else:
                a, s = lst[1:]
                segment.point_set(a - 1, s)
        return

    @staticmethod
    def cf_920f_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/920/F
        tag: union_find|all_factor_cnt|range_sum|point_add
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        uf = UnionFind(n + 1)
        at = AllFactorCnt(10 ** 6)
        tree = PointAddRangeSum(n)
        tree.build(nums)
        for i in range(m):
            op, ll, rr = ac.read_list_ints_minus_one()
            if op == 0:
                ll = uf.find(ll)
                while ll <= rr:
                    pre = nums[ll]
                    nums[ll] = at.all_factor_cnt[pre]
                    cur = nums[ll]
                    if cur < pre:
                        tree.point_add(ll + 1, cur - pre)
                    if cur <= 2:
                        uf.union_right(ll, ll + 1)
                        ll = uf.find(ll + 1)
                    else:
                        ll += 1
            else:
                ans = tree.range_sum(ll + 1, rr + 1)
                ac.st(ans)
        return

    @staticmethod
    def cf_438d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/438/problem/D
        tag: segment_tree|point_set|range_mod|range_sum|classical|limited_operation
        """
        n, q = ac.read_list_ints()
        tree = RangeModPointSetRangeSum(n)  # TLE
        tree.build(ac.read_list_ints())
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ans = tree.range_sum(lst[1] - 1, lst[2] - 1)
                ac.st(ans)
            elif lst[0] == 2:
                tree.range_mod(lst[1] - 1, lst[2] - 1, lst[3])
            else:
                tree.point_set(lst[1] - 1, lst[2])
        return

    @staticmethod
    def cf_1187d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1187/D
        tag: segment_tree|point_set|range_min|classical
        """
        for _ in range(ac.read_int()):

            def check():
                n = ac.read_int()
                a = ac.read_list_ints()
                b = ac.read_list_ints()
                if Counter(a) != Counter(b):
                    ac.no()
                    return
                tree = PointSetRangeMin(n, n + 1)
                tree.build(a)
                dct = [deque() for _ in range(n + 1)]
                for i in range(n):
                    dct[a[i]].append(i)
                for i in range(n):
                    x = b[i]
                    j = dct[x].popleft()
                    if tree.range_min(0, j) != x:
                        ac.no()
                        return
                    tree.point_set(j, n + 1)
                ac.yes()
                return

            check()
        return

    @staticmethod
    def cf_914d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/914/problem/D
        tag: segment_tree|point_set|range_gcd
        """
        n = ac.read_int()
        tree = PointSetRangeGcd(n)
        tree.build(ac.read_list_ints())
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, rr, xx = lst[1:]
                ans = tree.range_gcd_check(ll - 1, rr - 1, xx)
                ac.st("YES" if ans else "NO")
            else:
                ll, xx = lst[1:]
                tree.point_set(ll - 1, xx)
        return

    @staticmethod
    def cf_1567e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1567/E
        tag: segment_tree|point_set|range_ascend_sub_cnt
        """
        _, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = PointSetRangeAscendSubCnt(nums)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                ll, xx = lst[1:]
                tree.point_set(ll - 1, xx)
            else:
                ll, rr = lst[1:]
                ans = tree.range_ascend_sub_cnt(ll - 1, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def cf_522d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/522/D
        tag: segment_tree|point_set|range_min|offline_query
        """
        ac.get_random_seed()
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = PointSetRangeMin(n, n)
        queries = [[] for _ in range(n)]
        for i in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            queries[rr].append((i, ll))
        ans = [-1] * q

        pre = [-1] * n
        dct = dict()
        for i in range(n):
            if nums[i] ^ ac.random_seed in dct:
                pre[i] = dct[nums[i] ^ ac.random_seed]
            dct[nums[i] ^ ac.random_seed] = i

        for rr in range(n):
            if pre[rr] != -1:
                tree.point_set(pre[rr], rr - pre[rr])
            for i, ll in queries[rr]:
                cur = tree.range_min(ll, rr)
                if cur < n:
                    ans[i] = cur
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p1972(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1972
        tag: point_add|range_sum|tree_array|offline_query
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        q = ac.read_int()
        queries = [[] for _ in range(n)]
        for i in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            queries[rr].append((i, ll))

        ans = [0] * q
        tree = PointAddRangeSum(n)
        tree.build([1] * n)
        pre = dict()
        for rr in range(n):
            if nums[rr] in pre:
                tree.point_add(pre[nums[rr]] + 1, -1)
            pre[nums[rr]] = rr
            for i, ll in queries[rr]:
                ans[i] = tree.range_sum(ll + 1, rr + 1)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_703d_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/703/D
        tag: segment_tree|point_add|range_xor|offline_query
        """
        ac.get_random_seed()
        n = ac.read_int()
        nums = ac.read_list_ints()
        q = ac.read_int()
        queries = [[] for _ in range(n)]
        for i in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            queries[rr].append((i, ll))

        ans = [0] * q
        tree = PointSetRangeXor(n)
        tree.build(nums)
        pre_xor = [0] * (n + 1)

        pre = dict()
        for rr in range(n):
            pre_xor[rr + 1] = pre_xor[rr] ^ nums[rr]
            if nums[rr] ^ ac.random_seed in pre:
                tree.point_set(pre[nums[rr] ^ ac.random_seed], 0)
            pre[nums[rr] ^ ac.random_seed] = rr
            for i, ll in queries[rr]:
                ans[i] = tree.range_xor(ll, rr) ^ pre_xor[rr + 1] ^ pre_xor[ll]
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_703d_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/703/D
        tag: segment_tree|point_xor|range_xor|offline_query
        """
        ac.get_random_seed()
        n = ac.read_int()
        nums = ac.read_list_ints()
        q = ac.read_int()
        queries = [[] for _ in range(n)]
        for i in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            queries[rr].append((i, ll))

        ans = [0] * q
        tree = PointXorRangeXor(n)
        tree.build(nums)
        pre_xor = [0] * (n + 1)

        pre = dict()
        for rr in range(n):
            pre_xor[rr + 1] = pre_xor[rr] ^ nums[rr]
            if nums[rr] ^ ac.random_seed in pre:
                tree.point_xor(pre[nums[rr] ^ ac.random_seed], nums[rr])
            pre[nums[rr] ^ ac.random_seed] = rr
            for i, ll in queries[rr]:
                ans[i] = tree.range_xor(ll, rr) ^ pre_xor[rr + 1] ^ pre_xor[ll]
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_1609e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1609/E
        tag: segment_tree|point_set|range_cover
        """
        n, q = ac.read_list_ints()
        s = ac.read_str()
        tree = PointSetRangeNotExistABC(n)
        tree.build(s)
        for _ in range(q):
            ll, s = ac.read_list_strs()
            ans = tree.point_set(int(ll) - 1, s)
            ac.st(ans)
        return

    @staticmethod
    def abc_285f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc285/tasks/abc285_f
        tag: segment_tree|point_add|range_sum|range_ascend_sub_cnt|point_set
        """
        n = ac.read_int()
        tree = PointSetRangeAscendSubCnt([ord(w) - ord("a") for w in ac.read_str()])
        tree_cnt = [PointAddRangeSum(n) for _ in range(26)]
        for x in range(n):
            tree_cnt[tree.lst[x]].point_add(x + 1, 1)

        for _ in range(ac.read_int()):

            def check():
                lst = ac.read_list_strs()
                if lst[0] == '1':
                    i, w = int(lst[1]) - 1, ord(lst[2]) - ord("a")
                    tree_cnt[tree.lst[i]].point_add(i + 1, -1)
                    tree.point_set(i, w)
                    tree_cnt[tree.lst[i]].point_add(i + 1, 1)
                else:
                    ll, rr = [int(w) - 1 for w in lst[1:]]
                    ans = tree.range_ascend_sub_cnt(ll, rr)
                    length = rr - ll + 1
                    if ans == length * (length + 1) // 2:
                        if all(tree_cnt[i].range_sum(ll + 1, rr + 1) == tree_cnt[i].range_sum(1, n) for i in
                               range(tree.lst[ll] + 1, tree.lst[rr])):
                            ac.yes()
                            return
                    ac.no()
                return

            check()
        return

    @staticmethod
    def cf_1208d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1208/D
        tag: segment_tree|reverse_thinking|construction|point_set|range_sum_bisect_left
        """
        n = ac.read_int()
        tree = PointSetRangeSum(n)
        tree.build(list(range(1, n + 1)))
        pre = ac.read_list_ints()
        ans = [0] * n
        for i in range(n - 1, -1, -1):
            ind = tree.range_sum_bisect_right(pre[i])
            ans[i] = ind + 1
            tree.point_set(ind, 0)
        ac.lst(ans)
        return

    @staticmethod
    def abc_327f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc327/tasks/abc327_f
        tag: segment_tree|range_add|range_max
        """
        n, d, w = ac.read_list_ints()
        d -= 1
        w -= 1
        m = 2 * 10 ** 5
        pos = [[] for _ in range(m + 1)]
        for _ in range(n):
            t, x = ac.read_list_ints()
            pos[x].append(t)
        tree = RangeAddRangeSumMinMax(m + 1)
        ans = 0
        for s in range(w):
            for t in pos[s]:
                low = max(t, d)
                high = min(m, t + d)
                tree.range_add(low, high, 1)
        for s in range(m + 1 - w):
            for t in pos[s + w]:
                low = max(t, d)
                high = min(m, t + d)
                tree.range_add(low, high, 1)
            ans = max(ans, tree.ceil[1])
            for t in pos[s]:
                low = max(t, d)
                high = min(m, t + d)
                tree.range_add(low, high, -1)
        ac.st(ans)
        return

    @staticmethod
    def cf_558e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/558/E
        tag: segment_tree|range_set|range_sum|alphabet
        """
        n, q = ac.read_list_ints()
        s = ac.read_str()  # TLE
        tree = [RangeSetRangeSumMinMax(n, 0) for _ in range(26)]
        for i in range(n):
            x = ord(s[i]) - ord("a")
            tree[x].range_set(i, i, 1)

        for _ in range(q):
            ll, rr, k = ac.read_list_ints()
            ll -= 1
            rr -= 1
            cnt = [tree[i].range_sum(ll, rr) for i in range(26)]
            if k == 0:
                for i in range(26):
                    if cnt[i]:
                        tree[i].range_set(ll, rr, 0)
                for i in range(25, -1, -1):
                    if cnt[i]:
                        tree[i].range_set(ll, ll + cnt[i] - 1, 1)
                        ll += cnt[i]
            else:
                for i in range(26):
                    if cnt[i]:
                        tree[i].range_set(ll, rr, 0)
                for i in range(26):
                    if cnt[i]:
                        tree[i].range_set(ll, ll + cnt[i] - 1, 1)
                        ll += cnt[i]
        ans = [""] * n
        for i in range(26):
            lst = tree[i].get()
            for j in range(n):
                if lst[j]:
                    ans[j] = chr(i + ord("a"))
        ac.st("".join(ans))
        return

    @staticmethod
    def cf_1557d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1557/problem/D
        tag: segment_tree|range_ascend|range_max_index|dp
        """
        m, n = ac.read_list_ints()
        queries = [ac.read_list_ints() for _ in range(n)]
        nodes = set()
        row = [[] for _ in range(m + 1)]
        for i, ll, rr in queries:
            nodes.add(ll)
            nodes.add(rr)
            row[i].append((ll, rr))
        nodes = sorted(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        k = len(ind)
        tree = RangeAscendRangeMaxIndex(k, 0)
        dp = [0] * (m + 1)
        pre = [0] * (m + 1)
        for i in range(1, m + 1):
            cur = 0
            cur_ind = 0
            for ll, rr in row[i]:
                res = tree.range_max_index(ind[ll], ind[rr])
                if res[0] > cur:
                    cur, cur_ind = res
            dp[i] = cur + 1
            pre[i] = cur_ind
            for ll, rr in row[i]:
                tree.range_ascend(ind[ll], ind[rr], i, cur + 1)
        x = dp.index(max(dp))
        lst = [x]
        while pre[lst[-1]]:
            lst.append(pre[lst[-1]])
        ac.st(m - len(lst))
        dct = set(lst)
        ac.lst([x for x in range(1, m + 1) if x not in dct])
        return

    @staticmethod
    def cf_1114f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1114/F
        tag: segment_tree|range_set|range_sum|range_mul
        """
        primes = PrimeSieve().eratosthenes_sieve(300)
        ind = {p: i for i, p in enumerate(primes)}
        mod = 10 ** 9 + 7  # MLE
        pf = PrimeFactor(300)
        m = len(ind)
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree_or = RangeOrRangeOr(n)
        tree_mul = RangeMulRangeMul(n, mod)
        tree_mul.build(nums)
        for i in range(n):
            for p, _ in pf.prime_factor[nums[i]]:
                tree_or.range_or(i, i, 1 << ind[p])
        pp = dict()
        for p in primes:
            pp[p] = pow(p, -1, mod)

        for _ in range(q):
            lst = ac.read_list_strs()
            if lst[0] == "MULTIPLY":
                ll, rr, x = [int(w) for w in lst[1:]]
                tree_mul.range_mul_update(ll - 1, rr - 1, x)
                for p, _ in pf.prime_factor[x]:
                    tree_or.range_or(ll - 1, rr - 1, 1 << ind[p])
            else:
                ll, rr = [int(w) for w in lst[1:]]
                ans = tree_mul.range_mul_query(ll - 1, rr - 1)
                val = tree_or.range_or_query(ll - 1, rr - 1)
                for i in range(m):
                    if (val >> i) & 1:
                        ans *= (primes[i] - 1)
                        ans *= pp[primes[i]]
                ac.st(ans % mod)
        return

    @staticmethod
    def cf_292e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/292/E
        tag: segment_tree|range_set|point_get
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        tree = RangeSetPointGet(n, -n)
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y, k = lst[1:]
                x -= 1
                y -= 1
                tree.range_set(y, y + k - 1, -y + x)
            else:
                x = lst[1] - 1
                y = tree.point_get(x)
                if y == -n:
                    ac.st(b[x])
                else:
                    i = x + tree.point_get(x)
                    ac.st(a[i])
        return

    @staticmethod
    def cf_1881g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1881/problem/G
        tag: segment_tree|range_add|range_con_sub_palindrome
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            tree = RangeAddRangeConSubPalindrome(n)
            s = [ord(w) - ord("a") for w in ac.read_str()]
            tree.build(s)
            for _ in range(m):
                lst = ac.read_list_ints()
                if lst[0] == 1:
                    ll, rr, x = lst[1:]
                    tree.range_add(ll - 1, rr - 1, x % 26)
                else:
                    ll, rr = lst[1:]
                    ans = tree.range_con_sub_palindrome(ll - 1, rr - 1)
                    ac.st("YES" if not ans else "NO")
        return

    @staticmethod
    def lc_1622_1():
        """
        url: https://leetcode.cn/problems/fancy-sequence/
        tag: segment_tree|range_affine|range_sum
        """

        class Fancy:

            def __init__(self):
                n = 10 ** 5
                self.ind = 0
                self.mod = 10 ** 9 + 7
                self.tree = RangeAffineRangeSum(n, self.mod)
                return

            def append(self, val: int) -> None:
                self.ind += 1
                self.tree.range_affine(self.ind - 1, self.ind - 1, (1 << 32) | val)
                return

            def addAll(self, inc: int) -> None:
                if self.ind:
                    self.tree.range_affine(0, self.ind - 1, (1 << 32) | inc)
                return

            def multAll(self, m: int) -> None:
                if self.ind:
                    self.tree.range_affine(0, self.ind - 1, m << 32)
                return

            def getIndex(self, idx: int) -> int:
                if idx >= self.ind:
                    return -1
                return self.tree.range_sum(idx, idx) % self.mod

        return Fancy

    @staticmethod
    def lc_1622_2():
        """
        url: https://leetcode.cn/problems/fancy-sequence/
        tag: segment_tree|range_affine|range_sum
        """

        class Fancy:

            def __init__(self):
                self.lst = []
                self.add = 0
                self.mul = 1
                self.mod = 10 ** 9 + 7

            @lru_cache(None)
            def ppow(self, a):
                return pow(a, -1, self.mod)

            def append(self, val: int) -> None:
                self.lst.append((val - self.add) * self.ppow(self.mul))

            def addAll(self, inc: int) -> None:
                self.add = (self.add + inc) % self.mod

            def multAll(self, m: int) -> None:
                self.add = (self.add * m) % self.mod
                self.mul = (self.mul * m) % self.mod

            def getIndex(self, idx: int) -> int:
                if idx >= len(self.lst):
                    return -1
                return (self.lst[idx] * self.mul + self.add) % self.mod

        return Fancy

    @staticmethod
    def cf_915e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/915/E
        tag: segment_tree|range_set|range_sum|dynamic
        """
        n, q = [ac.read_int() for _ in range(2)]
        tree = RangeSetRangeSumMinMaxDynamicDct(n + 1, 4 * 10 ** 5, -1)
        tree.range_set(1, n, 1)
        for _ in range(q):
            ll, rr, k = ac.read_list_ints()
            if k == 1:
                tree.range_set(ll, rr, 0)
            else:
                tree.range_set(ll, rr, 1)
            ac.st(tree.cover[1])
        return

    @staticmethod
    def lg_p5848(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5848
        tag: segment_tree|range_set|range_pre_max_sum|dynamic
        """
        n = ac.read_int()
        tree = RangeSetPreSumMaxDynamic(n, -math.inf)
        while True:
            lst = ac.read_list_strs()
            if lst[0] == "I":
                ll, rr, hh = [int(w) for w in lst[1:]]
                tree.range_set(ll - 1, rr - 1, hh)
            elif lst[0] == "Q":
                hh = int(lst[1])
                ans = tree.range_pre_sum_max_bisect_left(hh)
                ac.st(ans)
            else:
                break
        return

    @staticmethod
    def cf_877e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/877/E
        tag: segment_tree|range_reverse|dfs_order|range_bit_count
        """
        n = ac.read_int()
        parent = [-1] + ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        for i in range(1, n):
            dct[parent[i]].append(i)
        start, end = DFS().gen_bfs_order_iteration(dct, 0)
        tree = RangeRevereRangeBitCount(n)
        lst = ac.read_list_ints()
        nums = [0] * n
        for i in range(n):
            nums[start[i]] = lst[i]
        tree.build(nums)
        for _ in range(ac.read_int()):
            lst = ac.read_list_strs()
            if lst[0] == "get":
                x = int(lst[1]) - 1
                ans = tree.range_bit_count(start[x], end[x])
                ac.st(ans)
            else:
                x = int(lst[1]) - 1
                tree.range_reverse(start[x], end[x])
        return

    @staticmethod
    def cf_1108e2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1108/problem/E2
        tag: segment_tree|range_add|range_min|prefix_suffix|bryte_force|brain_teaser
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = [ac.read_list_ints_minus_one() for _ in range(m)]

        tree = RangeAddRangeSumMinMax(n)
        tree.build(nums)
        cur_min = nums[:]
        tmp = sorted(lst, key=lambda it: it[1])
        j = 0
        for i in range(n):
            while j < m and tmp[j][1] < i:
                a, b = tmp[j]
                tree.range_add(a, b, -1)
                j += 1

            if i:
                cur = tree.range_min(0, i - 1)
                if cur < cur_min[i]:
                    cur_min[i] = cur

        tmp = sorted(lst, key=lambda it: -it[0])
        tree = RangeAddRangeSumMinMax(n)
        tree.build(nums)
        j = 0
        for i in range(n - 1, -1, -1):
            while j < m and tmp[j][0] > i:
                a, b = tmp[j]
                tree.range_add(a, b, -1)
                j += 1
            if i + 1 < n:
                cur = tree.range_min(i + 1, n - 1)
                if cur < cur_min[i]:
                    cur_min[i] = cur
        cur_min = [nums[i] - cur_min[i] for i in range(n)]
        ans = max(cur_min)
        res = cur_min.index(ans)
        ac.st(ans)
        tmp = [i + 1 for i in range(m) if not lst[i][0] <= res <= lst[i][1]]
        ac.st(len(tmp))
        ac.lst(tmp)
        return

    @staticmethod
    def cf_1234d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1234/problem/D
        tag: segment_tree|point_set|range_or
        """
        s = [1 << (ord(w) - ord("a")) for w in ac.read_str()]
        n = len(s)
        tree = PointSetRangeOr(n)
        tree.build(s)
        for _ in range(ac.read_int()):
            lst = ac.read_list_strs()
            if lst[0] == "1":
                pos, w = lst[1:]
                tree.point_set(int(pos) - 1, 1 << (ord(w) - ord("a")))
            else:
                ll, rr = lst[1:]
                ans = tree.range_or(int(ll) - 1, int(rr) - 1)
                ac.st(bin(ans).count("1"))
        return

    @staticmethod
    def cf_1741f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1741/problem/F
        tag: segment_tree|discretization|range_add|range_sum|bisect_left|bisect_right
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            color = [[] for _ in range(n)]
            nodes = {0, 10 ** 9}
            for i in range(n):
                ll, rr, c = ac.read_list_ints()
                color[c - 1].append((i, ll, rr))
                nodes.add(ll)
                nodes.add(rr)
            nodes = sorted(nodes)
            ind = {num: i for i, num in enumerate(nodes)}
            ans = [math.inf] * n
            m = len(nodes)
            diff = [0] * m
            for i in range(n):
                for _, ll, rr in color[i]:
                    diff[ind[ll]] += 1
                    if ind[rr] + 1 < m:
                        diff[ind[rr] + 1] -= 1
            for i in range(1, m):
                diff[i] += diff[i - 1]
            tree = RangeAddRangeSumMinMax(m)
            tree.build(diff)

            for i in range(n):
                for j, ll, rr in color[i]:
                    tree.range_add(ind[ll], ind[rr], -1)
                for j, ll, rr in color[i]:
                    if tree.range_sum(ind[ll], ind[rr]):
                        ans[j] = 0
                    else:
                        x = tree.range_sum_bisect_right_non_zero(ind[ll])

                        if x < math.inf:
                            ans[j] = min(ans[j], ll - nodes[x])
                        x = tree.range_sum_bisect_left_non_zero(ind[rr])
                        if x < math.inf:
                            ans[j] = min(ans[j], nodes[x] - rr)

                for j, ll, rr in color[i]:
                    tree.range_add(ind[ll], ind[rr], 1)

            ac.lst(ans)
        return

    @staticmethod
    def abc_341e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc341/tasks/abc341_e
        tag: segment_tree|range_reverse|range_alter
        """
        n, q = ac.read_list_ints()
        tree = RangeRevereRangeAlter(n)
        tree.build([int(w) for w in ac.read_str()])
        for _ in range(q):
            lst = ac.read_list_ints()
            ll, rr = lst[1:]
            if lst[0] == 1:
                tree.range_reverse(ll - 1, rr - 1)
            else:
                ans = tree.range_alter_query(ll - 1, rr - 1)
                ac.st("Yes" if ans else "No")
        return

    @staticmethod
    def abc_322f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc322/tasks/abc322_f
        tag: segment_tree|range_set_reverse|range_longest_con_sub
        """
        n, q = ac.read_list_ints()  # TLE
        tree = RangeSetReverseRangeSumLongestConSub(n)
        tree.build([int(w) for w in ac.read_str()])
        for _ in range(q):
            lst = ac.read_list_ints()
            ll, rr = lst[1:]
            if lst[0] == 1:
                tree.range_set_reverse(ll - 1, rr - 1, 2)
            else:
                ans = tree.range_longest_con_sub(ll - 1, rr - 1)
                ac.st(ans)
        return

    @staticmethod
    def abc_343f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc343/tasks/abc343_f
        tag: segment_tree|point_set|range_max|range_second
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = PointSetRangeMaxSecondCnt(n)
        tree.build(nums)
        for _ in range(q):
            op, x, y = ac.read_list_ints()
            if op == 1:
                x -= 1
                nums[x] = y
                tree.point_set(x, y)
            else:
                ans = tree.range_max_second_cnt(x - 1, y - 1)[-1]
                ac.st(ans)
        return

    @staticmethod
    def abc_320e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc320/tasks/abc320_e
        tag: segment_tree|point_set|range_min|range_min_bisect_left
        """
        n, m = ac.read_list_ints()
        tree = PointSetRangeMin(n, 0)
        ans = [0] * n
        for _ in range(m):
            t, w, s = ac.read_list_ints()
            i = tree.range_min_bisect_left(0, n - 1, t)
            if i != -1:
                ans[i] += w
                tree.point_set(i, t + s)
        ac.flatten(ans)
        return

    @staticmethod
    def abc_309f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc309/tasks/abc309_f
        tag: partial_order|range_descend|range_min
        """
        n = ac.read_int()
        nodes = set()
        dct = [ac.read_list_ints() for _ in range(n)]
        for x, y, z in dct:
            nodes.add(x)
            nodes.add(y)
            nodes.add(z)
        ind = {num: i for i, num in enumerate(sorted(nodes))}
        m = len(ind)
        dct = [sorted([ind[w] for w in ls]) for ls in dct]
        ind = defaultdict(list)
        for x, y, z in dct:
            ind[x].append((y, z))
        tree = RangeDescendRangeMin(m)
        for x in sorted(ind):
            for y, z in ind[x]:
                if y:
                    pre = tree.range_min(0, y - 1)
                    if pre < z:
                        ac.yes()
                        return
            for y, z in ind[x]:
                tree.range_descend(y, y, z)
        ac.no()
        return

    @staticmethod
    def abc_307e_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc307/tasks/abc307_e
        tag: circular_array|linear_dp|segment_tree|range_add|range_mul
        """
        mod = 998244353
        n, m = ac.read_list_ints()
        if n == 2:
            ans = m * (m - 1) % mod
        else:
            tree = RangeAddMulRangeSum(m, mod)
            tree.range_add_mul(0, 0, 1, "add")
            for _ in range(n - 1):
                tot = tree.range_sum(0, m - 1)
                tree.range_add_mul(0, m - 1, -1, "mul")
                tree.range_add_mul(0, m - 1, tot, "add")
            tot = tree.range_sum(0, m - 1)
            tot -= tree.range_sum(0, 0)
            ans = tot * m % mod
        ac.st(ans)
        return

    @staticmethod
    def abc_307e_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc307/tasks/abc307_e
        tag: circular_array|linear_dp|segment_tree|range_add|range_mul
        """
        mod = 998244353
        n, m = ac.read_list_ints()
        if n == 2:
            ans = m * (m - 1) % mod
        else:
            zero = 1
            tot = 1
            for _ in range(n - 1):
                tot, zero = (m * tot - tot) % mod, (tot - zero) % mod
            ans = (tot - zero) * m % mod
        ac.st(ans)
        return

    @staticmethod
    def abc_307f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc307/tasks/abc307_f
        tag: segment_tree|range_max_bisect_left|dijkstra
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            u -= 1
            v -= 1
            dct[u].append((v, w))
            dct[v].append((u, w))
        ac.read_int()
        nums = ac.read_list_ints_minus_one()
        d = ac.read_int()
        x = [0] + ac.read_list_ints()
        tree = RangeAddRangeSumMinMax(d + 1)
        tree.build(x)

        dis = [(math.inf, 0) for _ in range(n)]
        for i in nums:
            dis[i] = (0, 0)
        stack = [(0, 0, i) for i in nums]
        while stack:
            dd, pre, i = heappop(stack)
            if dis[i] < (dd, pre):
                continue
            if dd >= d + 1:
                continue
            for j, w in dct[i]:
                if pre + w <= x[dd]:
                    dj = dd
                    nex_pre = pre + w
                    if (dj, nex_pre) < dis[j]:
                        dis[j] = (dj, nex_pre)
                        heappush(stack, (dj, nex_pre, j))
                else:
                    ind = tree.range_max_bisect_left(dd + 1, d, w)
                    nex_pre = w
                    if ind != -1:
                        dj = ind
                        if (dj, nex_pre) < dis[j]:
                            dis[j] = (dj, nex_pre)
                            heappush(stack, (dj, nex_pre, j))
        for d in dis:
            if d[0] < math.inf:
                ac.st(d[0])
            else:
                ac.st(-1)
        return

    @staticmethod
    def abc_346g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc346/tasks/abc346_g
        tag: contribution_method|segment_tree|range_add|range_sum
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dct = defaultdict(lambda: [-1])
        ans = 0
        tree = RangeAddRangeMinCount(n)
        tree.build([0] * n)
        for i in range(n):
            x = nums[i]
            if len(dct[x]) > 1:
                ll, rr = dct[x][-2] + 1 if dct[x][-2] != -1 else 0, dct[x][-1]
                tree.range_add(ll, rr, -1)
                ll, rr = dct[x][-1] + 1, i
                tree.range_add(ll, rr, 1)
            else:
                tree.range_add(0, i, 1)
            dct[x].append(i)
            floor, cnt = tree.range_min_count(0, n - 1)
            ans += n if floor > 0 else n - cnt
        ac.st(ans)
        return

    @staticmethod
    def abc_292h(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc292/tasks/abc292_h
        tag: segment_tree|range_add|range_max_bisect_left
        """
        n, b, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre = ac.accumulate(nums)
        tree = RangeAddRangeSumMinMax(n)
        tree.build([pre[i] - i * b for i in range(1, n + 1)])
        for _ in range(q):
            c, x = ac.read_list_ints()
            c -= 1
            y = nums[c]
            tree.range_add(c, n - 1, x - y)
            nums[c] = x
            res = tree.range_max_bisect_left(0, n - 1, 0)
            if res == -1:
                res = n - 1
            ans = tree.range_sum(res, res) / (res + 1) + b
            ac.st(ans)
        return

    @staticmethod
    def abc_253f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc253/tasks/abc253_f
        tag: offline_query|data_range|limited_operation|brain_teaser|preprocess|classical
        """
        _, _, q = ac.read_list_ints()
        n = m = 2 * 10 ** 5 + 10
        post = [[] for _ in range(q)]
        queries = [ac.read_list_ints() for _ in range(q)]
        row = [[] for _ in range(n + 1)]
        for ind in range(q - 1, -1, -1):
            if queries[ind][0] == 3:
                i, j = queries[ind][1:]
                row[i].append(j)
            elif queries[ind][0] == 2:
                i = queries[ind][1]
                for j in row[i]:
                    post[ind].append(j)
                row[i] = []
        pre = defaultdict(int)
        row_val = [0] * (n + 1)
        tree = RangeAddPointGet(m + 1)
        for ind in range(q):
            lst = queries[ind]
            if lst[0] == 1:
                ll, rr, x = lst[1:]
                tree.range_add(ll, rr, x)
            elif lst[0] == 2:
                i, x = lst[1:]
                for j in post[ind]:
                    pre[(i, j)] = tree.point_get(j)
                row_val[i] = x
            else:
                i, j = lst[1:]
                ans = row_val[i] + tree.point_get(j) - pre[(i, j)]
                ac.st(ans)
        return

    @staticmethod
    def abc_237g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc237/tasks/abc237_g
        tag: segment_tree|range_sort|implemention|brain_teaser|range_set|range_sum|classical
        """
        n, q, x = ac.read_list_ints()
        x -= 1
        p = ac.read_list_ints_minus_one()
        ans = p.index(x)
        lst = [int(num >= x) for num in p]
        tree = RangeSetRangeSumMinMax(n)
        tree.build(lst)
        for _ in range(q):
            op, ll, rr = ac.read_list_ints_minus_one()
            cnt1 = tree.range_sum(ll, rr)
            cnt0 = rr - ll + 1 - cnt1
            if op == 0:
                if cnt1:
                    tree.range_set(rr - cnt1 + 1, rr, 1)
                if cnt0:
                    tree.range_set(ll, ll + cnt0 - 1, 0)
                if ll <= ans <= rr:
                    ans = rr - cnt1 + 1
            else:
                if cnt0:
                    tree.range_set(rr - cnt0 + 1, rr, 0)
                if cnt1:
                    tree.range_set(ll, ll + cnt1 - 1, 1)
                if ll <= ans <= rr:
                    ans = ll + cnt1 - 1
        ac.st(ans + 1)
        return

    @staticmethod
    def lg_p2824(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2824
        tag: segment_tree|range_sort|implemention|brain_teaser|range_set|range_sum|classical
        """
        n, q = ac.read_list_ints()  # TLE
        p = ac.read_list_ints_minus_one()
        queries = [ac.read_list_ints_minus_one() for _ in range(q)]
        pos = ac.read_int() - 1
        tree = RangeSetRangeSumMinMax(n, 2)

        def check(x):
            for i in range(4 * n):
                tree.cover[i] = 0
                tree.lazy_tag[i] = tree.initial
            lst = [int(num >= x) for num in p]
            tree.build(lst)
            for op, ll, rr in queries:
                cnt1 = tree.range_sum(ll, rr)
                cnt0 = rr - ll + 1 - cnt1
                if op == -1:
                    if cnt1:
                        tree.range_set(rr - cnt1 + 1, rr, 1)
                    if cnt0:
                        tree.range_set(ll, ll + cnt0 - 1, 0)
                else:
                    if cnt0:
                        tree.range_set(rr - cnt0 + 1, rr, 0)
                    if cnt1:
                        tree.range_set(ll, ll + cnt1 - 1, 1)
            return tree.point_get(pos) == 1

        ans = BinarySearch().find_int_right(0, n - 1, check) + 1
        ac.st(ans)
        return

    @staticmethod
    def abc_223f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc223/tasks/abc223_f
        tag: segment_tree|point_set|range_set|pre_sum_max
        """
        n, q = ac.read_list_ints()
        s = [1 if w == ")" else -1 for w in ac.read_str()]
        tree = RangeSetPreSumMax(n)
        tree.build(s)
        for _ in range(q):
            op, ll, rr = ac.read_list_ints_minus_one()
            if op == 0:
                if s[ll] != s[rr]:
                    tree.range_set(ll, ll, s[ll] * (-1))
                    tree.range_set(rr, rr, s[rr] * (-1))
                    s[ll], s[rr] = s[rr], s[ll]
            else:
                if (rr - ll + 1) % 2 == 0 and tree.range_pre_sum_max_range(ll, rr) == tree.range_sum(ll, rr) == 0:
                    ac.yes()
                else:
                    ac.no()
        return

    @staticmethod
    def lc_100314(queries: List[List[int]]) -> List[bool]:
        """
        url: https://leetcode.cn/problems/block-placement-queries/
        tag: point_set|range_max_non_emp_con_sub_sum
        """
        ceil = 0
        for ls in queries:
            ceil = max(ceil, ls[1])
        ceil += 10
        ceil *= 2
        tree = RangeSetRangeMaxNonEmpConSubSum(ceil, ceil)
        nums = [0] * ceil
        for i in range(1, ceil, 2):
            nums[i] = 1
        tree.build(nums)
        ans = []
        for ls in queries:
            if ls[0] == 1:
                x = ls[1] * 2
                tree.point_set(x, -ceil)
            else:
                x = ls[1]
                res = tree.range_max_non_emp_con_sub_sum(0, x * 2)
                ans.append(res >= ls[2])
        return ans

    @staticmethod
    def lc_100306(nums: List[int], queries: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-sum-of-subsequence-with-non-adjacent-elements
        tag: point_set|range_max_sub_sum_alter
        """
        mod = 10 ** 9 + 7
        ans = 0
        n = len(nums)
        nums = [max(x, 0) for x in nums]
        tree = PointSetRangeMaxSubSumAlter(n)
        tree.build(nums)
        for pos, x in queries:
            x = max(x, 0)
            ans += tree.point_set_range_max_sub_sum(pos, x)
            ans %= mod
        return ans

    @staticmethod
    def lg_p3097(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3097
        tag: point_set|range_max_sub_sum_alter
        """
        n, q = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        tree = PointSetRangeMaxSubSumAlter(n)
        tree.build(nums)
        ans = 0
        for _ in range(q):
            pos, x = ac.read_list_ints()
            ans += tree.point_set_range_max_sub_sum(pos - 1, x)
        ac.st(ans)
        return

    @staticmethod
    def abc_356f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc356/tasks/abc356_f
        tag: union_find|union_find_left|union_find_right|segment_tree|sorted_list
        """
        q, k = ac.read_list_ints()
        lst = SortedList()

        nums = [ac.read_list_ints() for _ in range(q)]
        ind = sorted(set([x for _, x in nums]))
        dct = {num: i for i, num in enumerate(ind)}
        m = len(dct)
        pre = set()

        left = RangeSetPointGet(m)
        left.build(list(range(m)))
        right = RangeSetPointGet(m)
        right.build(list(range(m)))
        cnt = PointSetRangeSum(m)

        for tmp in nums:
            x = tmp[1]
            if tmp[0] == 1:
                if x in pre:
                    pre.discard(x)
                    lst.discard(x)
                    cnt.point_set(dct[x], 0)
                    ll, rr = left.point_get(dct[x]), right.point_get(dct[x])
                    i = lst.bisect_left(x)
                    if not (0 <= i - 1 < i < len(lst) and lst[i] - lst[i - 1] <= k):
                        if dct[x] + 1 <= rr:
                            left.range_set(dct[x] + 1, rr, dct[x] + 1)
                        if ll <= dct[x] - 1:
                            right.range_set(ll, dct[x] - 1, dct[x] - 1)
                        left.range_set(dct[x], dct[x], dct[x])
                        right.range_set(dct[x], dct[x], dct[x])

                else:
                    pre.add(x)
                    lst.add(x)
                    cnt.point_set(dct[x], 1)
                    i = lst.bisect_left(x)
                    if 0 <= i - 1 < i + 1 < len(lst) and lst[i + 1] - lst[i] <= k and lst[i] - lst[i - 1] <= k:
                        ll = left.point_get(dct[lst[i - 1]])
                        rr = right.point_get(dct[lst[i + 1]])
                        left.range_set(ll, rr, ll)
                        right.range_set(ll, rr, rr)
                    elif i + 1 < len(lst) and lst[i + 1] - lst[i] <= k:
                        rr = right.point_get(dct[lst[i + 1]])
                        left.range_set(dct[x], rr, dct[x])
                        right.range_set(dct[x], rr, rr)
                    elif i - 1 >= 0 and lst[i] - lst[i - 1] <= k:
                        ll = left.point_get(dct[lst[i - 1]])
                        right.range_set(ll, dct[x], dct[x])
                        left.range_set(ll, dct[x], ll)
            else:
                ll, rr = left.point_get(dct[x]), right.point_get(dct[x])
                ans = cnt.range_sum(ll, rr)
                ac.st(ans)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/SPR
        tag: reverse_order|brute_force|implemention|range_add|range_min
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            a = ac.read_list_ints()
            h = ac.read_list_ints()
            pre = [0] * (n + 1)
            cur = 0
            pre[0] = 1
            for i in range(n):
                cur += h[i]
                if cur <= a[i]:
                    pre[i + 1] = 1
                else:
                    break
            if pre[-1]:
                ac.st("YES")
                continue
            for i in range(n):
                if pre[i] and a[-1] - a[i] <= 2 * k:
                    ac.st("YES")
                    break
            else:
                tree = RangeAddRangeSumMinMax(n)
                tree.build([a[i] for i in range(n)])
                tree.range_add(n - 1, n - 1, -h[n - 1])
                pre_sum = ac.accumulate(h)
                j = n - 1
                for i in range(n - 2, -1, -1):
                    while j >= 0 and a[i] - a[j] <= 2 * k:
                        j -= 1
                    if pre[j + 1] and tree.range_min(i + 1, n - 1) - pre_sum[j + 1] >= 0:
                        ac.st("YES")
                        break
                    tree.range_add(i, n - 1, -h[i])
                else:
                    ac.st("NO")
        return

    @staticmethod
    def abc_357f_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc357/tasks/abc357_f
        tag: segment_tree|range_add|range_mul_sum
        """
        n, q = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        mod = 998244353
        tree = RangeAddRangeMulSum(n, mod)
        tree.build([(x, y) for x, y in zip(a, b)])
        for _ in range(q):
            lst = ac.read_list_ints_minus_one()
            if lst[0] == 0:
                ll, rr, x = lst[1:]
                x += 1
                tree.range_add_mul(ll, rr, x, 1)
            elif lst[0] == 1:
                ll, rr, x = lst[1:]
                x += 1
                tree.range_add_mul(ll, rr, x, 2)
            else:
                ll, rr = lst[1:]
                ans = tree.range_sum(ll, rr)
                ac.st(ans % mod)
        return

    @staticmethod
    def abc_357f_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc357/tasks/abc357_f
        tag: segment_tree|range_add|range_mul_sum
        """
        mod = 998244353

        def combine(a, b):
            return (a[0] + b[0]) % mod, (a[1] + b[1]) % mod, (a[2] + b[2]) % mod

        def merge_tag(a, b):
            return (a[0] + b[0]) % mod, (a[1] + b[1]) % mod

        def merge_cover(cover, val, length):
            cover0, cover1, cover2 = cover
            if val[0]:
                cover2 += val[0] * cover1
                cover0 += val[0] * length
            if val[1]:
                cover2 += val[1] * cover0
                cover1 += val[1] * length
            return cover0 % mod, cover1 % mod, cover2 % mod

        def num_to_cover(num):
            return num[0] % mod, num[1] % mod, (num[0] * num[1]) % mod

        cover_initial = (0, 0, 0)
        tag_initial = (0, 0)
        n, q = ac.read_list_ints()
        nums1 = ac.read_list_ints()
        nums2 = ac.read_list_ints()
        tree = LazySegmentTree(n, combine, cover_initial, merge_cover, merge_tag, tag_initial, num_to_cover)
        tree.build([(a, b) for a, b in zip(nums1, nums2)])
        for _ in range(q):
            lst = ac.read_list_ints_minus_one()
            if lst[0] < 2:
                ll, rr, xx = lst[1:]
                tree.range_update(ll, rr, (0, xx + 1) if lst[0] == 1 else (xx + 1, 0))
            else:
                ll, rr = lst[1:]
                ans = tree.range_query(ll, rr)[2] % mod
                ac.st(ans)
        return

    @staticmethod
    def abc_357f_3(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc357/tasks/abc357_f
        tag: segment_tree|range_add|range_mul_sum
        """
        mod = 998244353

        def combine(a, b):
            return (a[0] + b[0]) % mod, (a[1] + b[1]) % mod, (a[2] + b[2]) % mod

        def merge_tag(a, b):
            return (a[0] + b[0]) % mod, (a[1] + b[1]) % mod

        def merge_cover(cover, val, length):
            cover0, cover1, cover2 = cover
            if val[0]:
                cover2 += val[0] * cover1
                cover0 += val[0] * length
            if val[1]:
                cover2 += val[1] * cover0
                cover1 += val[1] * length
            return cover0 % mod, cover1 % mod, cover2 % mod

        def num_to_cover(num):
            return num[0] % mod, num[1] % mod, (num[0] * num[1]) % mod

        cover_initial = (0, 0, 0)
        tag_initial = (0, 0)
        n, q = ac.read_list_ints()
        nums1 = ac.read_list_ints()
        nums2 = ac.read_list_ints()
        tree = LazySegmentTreeZKW(n, combine, cover_initial, merge_cover, merge_tag, tag_initial, num_to_cover)
        tree.build([(a, b) for a, b in zip(nums1, nums2)])
        for _ in range(q):
            lst = ac.read_list_ints_minus_one()
            if lst[0] < 2:
                ll, rr, xx = lst[1:]
                tree.range_update(ll, rr, (0, xx + 1) if lst[0] == 1 else (xx + 1, 0))
            else:
                ll, rr = lst[1:]
                ans = tree.range_query(ll, rr)[2] % mod
                ac.st(ans)
        return

    @staticmethod
    def cc_2(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/KPRODSUM
        tag: range_mul|range_mul
        """

        for _ in range(ac.read_int()):
            n, k, m = ac.read_list_ints()
            nums = ac.read_list_ints()

            tree = RangeMulRangeMul(n, m)
            tree.build(nums)
            ans = post = 0
            for i in range(n - 1, -1, -1):
                ans += nums[i] * (1 + post) % m
                ans %= m
                post = nums[i] * (1 + post) % m
                if i + k - 1 < n:
                    post -= tree.range_mul_query(i, i + k - 1)
                    post %= m
                ans %= m
            ac.st(ans)
        return

    @staticmethod
    def cf_242e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/242/problem/E
        tag: segment_tree|range_xor|range_reverse|range_sum|range_bit_count
        """
        debug = 0
        if debug:
            n = 10 ** 5
            nums = [random.randint(0, 10 ** 6) for _ in range(n)]
            q = 5 * 10 ** 4
            queries = []
            for _ in range(q):
                op = random.randint(0, 1)
                ll = random.randint(1, n)
                rr = random.randint(ll, n)
                xx = -1
                if op == 2:
                    xx = random.randint(1, 10 ** 6)
                queries.append([op, ll, rr] if op == 1 else [op, ll, rr, xx])
        else:
            n = ac.read_int()
            nums = ac.read_list_ints()
            q = ac.read_int()
            queries = [ac.read_list_ints() for _ in range(q)]

        ans = [0] * q
        tree = RangeRevereRangeBitCount(n)
        for j in range(22):
            tree.build([1 if (nums[i] >> j) & 1 else 0 for i in range(n)])
            for i in range(q):
                lst = queries[i]
                if lst[0] == 1:
                    ll, rr = lst[1:]
                    ll -= 1
                    rr -= 1
                    ans[i] += (1 << j) * tree.range_bit_count(ll, rr)
                else:
                    ll, rr, xx = lst[1:]
                    ll -= 1
                    rr -= 1
                    if (xx >> j) & 1:
                        tree.range_reverse(ll, rr)
        for i in range(q):
            if queries[i][0] == 1:
                ac.st(ans[i])
        return

    @staticmethod
    def cf_1982f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1982/problem/F
        tag: point_set|pre_max|post_min|pre_min|implemention|bisect_left|bisect_right
        """

        for _ in range(ac.read_int()):  # TLE
            n = ac.read_int() + 2
            nums = [-math.inf] + ac.read_list_ints() + [math.inf]

            tree = PointSetPreMaxPostMin(n)
            tree.build(nums)

            low = PointSetPreMinPostMin(n)
            low.build([1 if not i or nums[i] >= nums[i - 1] else 0 for i in range(n)])

            def query_rr():
                ind = low.bisect_left_post_min(1)
                v = tree.pre_max(ind)
                r = tree.bisect_left_post_min(ind, v)
                return r

            def query_ll():
                ind = low.bisect_right_pre_min(1)
                v = tree.post_min(ind)
                l = tree.bisect_right_pre_max(ind, v)
                return l

            if low.post[1]:
                ac.lst([-1, -1])
            else:
                ll = query_ll()
                rr = query_rr()
                ac.lst([ll, rr])
            for _ in range(ac.read_int()):
                pos, val = ac.read_list_ints()
                nums[pos] = val
                tree.point_set(pos, val)
                if pos:
                    if nums[pos] >= nums[pos - 1]:
                        low.point_set(pos, 1)
                    else:
                        low.point_set(pos, 0)
                if pos + 1 < n:
                    if nums[pos + 1] >= nums[pos]:
                        low.point_set(pos + 1, 1)
                    else:
                        low.point_set(pos + 1, 0)

                if low.post[1]:
                    ac.lst([-1, -1])
                else:
                    ll = query_ll()
                    rr = query_rr()
                    ac.lst([ll, rr])
        return

    @staticmethod
    def cf_620e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/620/E
        tag: range_set|range_or|dfs_order
        """
        n, q = ac.read_list_ints()
        c = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        start, end = DFS().gen_bfs_order_iteration(dct, 0)
        dfn = [0] * n
        for i in range(n):
            dfn[start[i]] = i
        tree = RangeSetRangeOr(n)
        tree.build([1 << c[dfn[i]] for i in range(n)])
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                v, c = lst[1], lst[2]
                tree.range_set(start[v - 1], end[v - 1], 1 << c)
            else:
                v = lst[1]
                ans = tree.range_or(start[v - 1], end[v - 1])
                ac.st(ans.bit_count())
        return

    @staticmethod
    def abc_360f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc360/tasks/abc360_f
        tag: range_add|scan_line|range_max|range_max_bisect_left
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ceil = 10 ** 9
        nodes = [0, ceil]
        right = defaultdict(list)
        left = defaultdict(int)
        for ll, rr in nums:
            for x in [ll, rr]:
                for y in [-1, 0, 1]:
                    nodes.append(x + y)
            right[ll].append(rr)
            left[rr] += 1

        nodes = sorted(set(nodes))
        ind = {num: i for i, num in enumerate(nodes)}
        m = len(ind)
        tree = RangeAddRangeSumMinMax(m)
        diff = [0] * m
        for ll, rr in nums:
            if ll + 1 <= rr - 1:
                diff[ind[ll + 1]] += 1
                diff[ind[rr - 1] + 1] -= 1
        tree.build(ac.accumulate(diff)[1:])

        ans = [0, 1]
        res = 0
        for x in nodes:
            for rr in right[x]:
                if x + 1 <= rr - 1:
                    tree.range_add(ind[x + 1], ind[rr - 1], -1)
            if left[x]:
                tree.range_add(ind[x + 1], m - 1, -left[x])
            post = tree.range_max(ind[x] + 1, m - 1) if ind[x] + 1 <= m - 1 else 0
            if post > res and 0 <= x <= ceil:
                j = tree.range_max_bisect_left(ind[x] + 1, m - 1, post)
                if 0 <= x < nodes[j] <= ceil:
                    res = post
                    ans = [x, nodes[j]]
            for rr in right[x]:
                tree.range_add(ind[rr + 1], m - 1, 1)
        ac.lst(ans)
        return

    @staticmethod
    def cf_1420c2_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1420/C2
        tag: point_set|range_max_sub_sum_alter_signal|greedy
        """
        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            nums = ac.read_list_ints()  # TLE
            tree = PointSetRangeMaxSubSumAlterSignal(n)
            tree.build(nums)
            ac.st(tree.cover[1])
            for _ in range(q):
                ll, rr = ac.read_list_ints_minus_one()
                a, b = nums[ll], nums[rr]
                if a != b:
                    nums[ll], nums[rr] = b, a
                    tree.point_set_range_max_sub_sum(ll, b)
                    ans = tree.point_set_range_max_sub_sum(rr, a)
                    ac.st(ans)
        return

    @staticmethod
    def cf_1420c2_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1420/C2
        tag: point_set|range_max_sub_sum_alter_signal|greedy
        """

        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            nums = ac.read_list_ints() + [0]
            n += 1
            ans = 0
            for i in range(n - 1):
                if nums[i] > nums[i + 1]:
                    ans += nums[i] - nums[i + 1]
            ac.st(ans)
            for _ in range(q):
                ll, rr = ac.read_list_ints_minus_one()
                if ll == rr:
                    ac.st(ans)
                    continue
                for y in {ll - 1, ll, rr - 1, rr}:
                    if 0 <= y < y + 1 < n and nums[y] > nums[y + 1]:
                        ans -= nums[y] - nums[y + 1]
                nums[ll], nums[rr] = nums[rr], nums[ll]
                for y in {ll - 1, ll, rr - 1, rr}:
                    if 0 <= y < y + 1 < n and nums[y] > nums[y + 1]:
                        ans += nums[y] - nums[y + 1]
                ac.st(ans)
        return

    @staticmethod
    def cf_1859d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1859/D
        tag: range_ascend|range_max|implemention
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = [ac.read_list_ints() for _ in range(n)]
            ac.read_int()
            queries = ac.read_list_ints()

            nodes = queries[:]
            for ls in nums:
                nodes.extend(ls)
            nodes = sorted(set(nodes))
            ind = {num: i for i, num in enumerate(nodes)}
            m = len(ind)
            tree = RangeAscendRangeMax(m)
            tree.build(list(range(m)))
            index = [bb * n + i for i, (_, _, _, bb) in enumerate(nums)]
            index.sort(reverse=True)
            for num in index:
                i = num % n
                ll, rr, aa, bb = nums[i]
                pre = tree.range_max(ind[aa], ind[bb])
                tree.range_ascend(ind[ll], ind[rr], pre)
            ans = tree.get()
            ans = [nodes[ans[ind[x]]] for x in queries]
            ac.lst(ans)
        return

    @staticmethod
    def lg_p2846(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2846
        tag: range_reverse|range_bit_count
        """
        n, m = ac.read_list_ints()
        tree = RangeRevereRangeBitCount(n)
        for _ in range(m):
            lst = ac.read_list_ints()
            s, e = lst[1:]
            if lst[0] == 0:
                tree.range_reverse(s - 1, e - 1)
            else:
                ac.st(tree.range_bit_count(s - 1, e - 1))
        return

    @staticmethod
    def lg_p3130(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3130
        tag: range_add|range_sum|range_min
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = RangeAddRangeSumMinMax(n)
        tree.build(nums)
        for _ in range(m):
            lst = ac.read_list_strs()
            if lst[0] == "M":
                a, b = [int(w) - 1 for w in lst[1:]]
                ac.st(tree.range_min(a, b))
            elif lst[0] == "P":
                a, b, c = [int(w) - 1 for w in lst[1:]]
                tree.range_add(a, b, c + 1)
            else:
                a, b = [int(w) - 1 for w in lst[1:]]
                ac.st(tree.range_sum(a, b))
        return

    @staticmethod
    def cf_1555e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1555/E
        tag: brain_teaser|build_graph|segment_tree|range_add|range_min|two_pointers
        """
        n, m = ac.read_list_ints()
        tree = RangeAddRangeSumMinMax(m)
        nums = []
        for _ in range(n):
            ll, rr, w = ac.read_list_ints()
            ll -= 1
            rr -= 2
            nums.append(w * m * m + ll * m + rr)
        nums.sort()
        j = 0
        ans = math.inf
        for i in range(n):
            while j < n and tree.range_min(0, m - 2) == 0:
                val = nums[j]
                w = val // m // m
                ll, rr = (val - w * m * m) // m, (val - w * m * m) % m
                tree.range_add(ll, rr, 1)
                j += 1
            if tree.range_min(0, m - 2):
                ans = min(ans, nums[j - 1] // m // m - nums[i] // m // m)
            val = nums[i]
            w = val // m // m
            ll, rr = (val - w * m * m) // m, (val - w * m * m) % m
            tree.range_add(ll, rr, -1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p5057(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5057
        tag: segment_tree|range_reverse|range_sum
        """
        n, m = ac.read_list_ints()
        tree = RangeRevereRangeBitCount(n)
        for _ in range(m):
            lst = ac.read_list_ints_minus_one()
            if lst[0] == 0:
                a, b = lst[1:]
                tree.range_reverse(a, b)
            else:
                x = lst[1]
                ac.st(tree.point_get(x))
        return

    @staticmethod
    def cf_2001d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/2001/problem/D
        tag: segment_tree|point_set|range_max|range_max_bisect_right
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            tree1 = RangeAddRangeSumMinMax(n)
            tree_max = PointSetRangeMax(n)
            tree_max.build(nums)
            tree_min = PointSetRangeMin(n)
            tree_min.build(nums)

            post = defaultdict(list)
            for i in range(n - 1, -1, -1):
                if not post[nums[i]]:
                    tree1.range_add(0, i, 1)
                post[nums[i]].append(i)

            ans = [-1]
            while tree1.ceil[1]:
                j = tree1.range_max_bisect_right(ans[-1] + 1, n - 1, tree1.ceil[1])
                if len(ans) % 2:
                    num = tree_max.range_max(ans[-1] + 1, j)
                else:
                    num = tree_min.range_min(ans[-1] + 1, j)
                for x in post[num][::-1]:
                    if x >= ans[-1] + 1:
                        ans.append(x)
                        break
                tree1.range_add(0, post[num][0], -1)
                for i in post[num]:
                    tree_max.point_set(i, -1)
                    tree_min.point_set(i, math.inf)
            ac.st(len(ans) - 1)
            ac.lst([nums[x] for x in ans[1:]])
        return

    @staticmethod
    def abc_369g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc369/tasks/abc369_g
        tag: dfs_order|range_add|range_max|implemention
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j, ll = ac.read_list_ints_minus_one()
            ll += 1
            dct[i].append(ll * n + j)
            dct[j].append(ll * n + i)

        order = 0
        # index is original node value is dfs order
        start = [-1] * n
        # index is original node value is the maximum subtree dfs order
        end = [-1] * n
        # index is original node and value is its parent
        parent = [-1] * n
        stack = [(0, -1)]
        # depth of every original node
        depth = [0] * n
        # index is dfs order and value is original node
        order_to_node = [-1] * n
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                start[i] = order
                order_to_node[order] = i
                end[i] = order
                order += 1
                stack.append((~i, fa))
                for val in dct[i]:
                    j, w = val % n, val // n
                    # the order of son nodes can be assigned for lexicographical order
                    if j != fa:
                        parent[j] = i
                        depth[j] = depth[i] + w
                        stack.append((j, i))
            else:
                i = ~i
                if parent[i] != -1:
                    end[parent[i]] = end[i]

        tree = RangeAddRangeMaxIndex(n)
        tree.build([depth[x] for x in order_to_node])
        ans = 0
        visit = [0] * n
        for _ in range(n):
            ceil = tree.ceil[1]
            i = order_to_node[tree.index[1]]
            if ceil <= 0:
                ac.st(ans)
                continue
            visit[i] = 1
            path = [i]
            while parent[i] != -1 and not visit[parent[i]]:
                visit[parent[i]] = 1
                i = parent[i]
                path.append(i)
            path.reverse()
            for i in path:
                if parent[i] != -1:
                    pre = depth[i] - depth[parent[i]]
                else:
                    pre = 0
                tree.range_add(start[i], end[i], -pre)
            ans += ceil * 2
            ac.st(ans)
        return

    @staticmethod
    def cf_786b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/786/problem/B
        tag: segment_tree_opt_build_graph|dijkstra|classical
        """

        n, q, s = ac.read_list_ints()
        s -= 1  # TLE
        dct = [[] for _ in range(4 * n)]
        tree = SegmentTreeOptBuildGraphZKW(n)
        for i in range(1, n):
            dct[i].append((i << 1, 0))
            dct[i].append(((i << 1) | 1, 0))
            dct[(i << 1) + 2 * n].append((i + 2 * n, 0))
            dct[((i << 1) | 1) + 2 * n].append((i + 2 * n, 0))
        for i in range(n):
            dct[i + 3 * n].append((i + n, 0))
            dct[i + n].append((i + 3 * n, 0))
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                v, u, w = [x - 1 for x in lst[1:]]
                dct[v + n].append((u + n, w + 1))
            elif lst[0] == 2:
                v, ll, rr, w = [x - 1 for x in lst[1:]]
                lst = tree.range_opt(ll, rr)
                for j in lst:
                    dct[v + 3 * n].append((j, w + 1))
            else:
                v, ll, rr, w = [x - 1 for x in lst[1:]]
                lst = tree.range_opt(ll, rr)
                for j in lst:
                    dct[j + 2 * n].append((v + n, w + 1))
        dis = Dijkstra().get_shortest_path(dct, s + 3 * n)
        for i in range(n, 2 * n):
            if dis[i] == math.inf:
                dis[i] = -1
        ac.lst(dis[n:2 * n])
        return

    @staticmethod
    def abc_194e_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc194/tasks/abc194_e
        tag: point_set|pre_min|post_min|bisect_right
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = PointSetPreMinPostMin(n + 1)
        ans = math.inf
        cnt = [0] * (n + 1)
        for i in range(m):
            cnt[nums[i]] += 1
        tree.build(cnt)
        for i in range(n - m + 1):
            cur = tree.bisect_right_pre_min(1)
            ans = min(ans, cur)
            if i + m < n:
                cnt[nums[i + m]] += 1
                tree.point_set(nums[i + m], cnt[nums[i + m]])
            cnt[nums[i]] -= 1
            tree.point_set(nums[i], cnt[nums[i]])
        ac.st(ans)
        return

    @staticmethod
    def abc_194e_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc194/tasks/abc194_e
        tag: point_set|pre_min|post_min|bisect_right
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        cnt = [0] * (n + 1)
        for i in range(m):
            cnt[nums[i]] += 1
        ans = n
        for i in range(n + 1):
            if not cnt[i]:
                ans = i
                break
        for i in range(n - m + 1):
            cnt[nums[i]] -= 1
            if i + m < n:
                cnt[nums[i + m]] += 1
            if i + m < n and not cnt[nums[i]]:
                ans = min(ans, nums[i])
        ac.st(ans)
        return
"""

Algorithm：sorted_list
Description：range_query|binary_search


====================================LeetCode====================================
295（https://leetcode.cn/problems/find-median-from-data-stream/）sorted_list
2426（https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/）math|sorted_list|binary_search
2179（https://leetcode.cn/problems/count-good-triplets-in-an-array/）sorted_list|binary_search
2141（https://leetcode.cn/problems/maximum-running-time-of-n-computers/）greedy|binary_search|implemention
2102（https://leetcode.cn/problems/sequentially-ordinal-rank-tracker/）sorted_list
2519（https://leetcode.cn/problems/count-the-number-of-k-big-indices/）sorted_list
1912（https://leetcode.cn/problems/design-movie-rental-system/）sorted_list|classical
1825（https://leetcode.cn/problems/finding-mk-average/）sorted_list|deque
2250（https://leetcode.cn/problems/count-number-of-rectangles-containing-each-point/）offline_query|pointer|sort|binary_search
2426（https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/）math|sorted_list|binary_search
2276（https://leetcode.cn/problems/count-integers-in-intervals/）sorted_list|implemention|classical
3013（https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/）sorted_list|top_k_sum
1851（https://leetcode.cn/problems/minimum-interval-to-include-each-query）
100441（https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/）sorted_list|top_k_sum|bit_operation

=====================================LuoGu======================================
P7333（https://www.luogu.com.cn/problem/P7333）sort|sorted_list|circular_array|range_query
P7391（https://www.luogu.com.cn/problem/P7391）sorted_list|greedy|implemention|lazy_heapq
P7910（https://www.luogu.com.cn/problem/P7910）sorted_list
P4375（https://www.luogu.com.cn/problem/P4375）bubble_sort|sorted_list
P1908（https://www.luogu.com.cn/problem/P1908）reverse_order_pair|merge_sort
P1966（https://www.luogu.com.cn/problem/P1966）reverse_order_pair|greedy
P2161（https://www.luogu.com.cn/problem/P2161）range_merge_to_disjoint
P1637（https://www.luogu.com.cn/problem/P1637）sorted_list|prefix_suffix|counter
P2234（https://www.luogu.com.cn/problem/P2234）sorted_list
P2804（https://www.luogu.com.cn/problem/P2804）prefix_sum|sorted_list
P3608（https://www.luogu.com.cn/problem/P3608）sorted_list
P5076（https://www.luogu.com.cn/problem/P5076）sorted_list|implemention
P5149（https://www.luogu.com.cn/problem/P5149）reverse_order_pair|bisect
P5459（https://www.luogu.com.cn/problem/P5459）prefix_sum|sorted_list|binary_search
P6538（https://www.luogu.com.cn/problem/P6538）sorted_list|greedy
P7912（https://www.luogu.com.cn/problem/P7912）sorted_list|implemention
P8667（https://www.luogu.com.cn/problem/P8667）sorted_list
P3369（https://www.luogu.com.cn/problem/P3369）sorted_list
P6136（https://www.luogu.com.cn/problem/P6136）sorted_list
P2161（https://www.luogu.com.cn/problem/P2161）sorted_list|trick
P5677（https://www.luogu.com.cn/problem/P5677）sorted_list|offline_query|range|contribution_method|two_pointers

===================================CodeForces===================================
459D（https://codeforces.com/problemset/problem/459/D）sorted_list|counter
61E（https://codeforces.com/problemset/problem/61/E）sorted_list|prefix_suffix|counter
1354D（https://codeforces.com/problemset/problem/1354/D）sorted_list
1005E2（https://codeforces.com/contest/1005/problem/E2）median|inclusion_exclusion|prefix_sum|sorted_list|binary_search
1619E（https://codeforces.com/contest/1619/problem/E）mex|greedy
1676H2（https://codeforces.com/contest/1676/problem/H2）sorted_list|inversion_pair
1915F（https://codeforces.com/contest/1915/problem/F）sorted_list|sorting
1462F（https://codeforces.com/contest/1462/problem/F）sorted_list|brute_force|prefix_suffix
1690G（https://codeforces.com/contest/1690/problem/G）sorted_list|implemention
1969D（https://codeforces.com/contest/1969/problem/D）sorted_list|top_k_sum|greedy
1974F（https://codeforces.com/contest/1974/problem/F）sorted_list|implemention
1418D（https://codeforces.com/problemset/problem/1418/D）sorted_list|implemention
1342D（https://codeforces.com/problemset/problem/1342/D）sorted_list|greedy|reverse_order

===================================AtCoder===================================
ABC306E（https://atcoder.jp/contests/abc306/tasks/abc306_e）sorted_list|top_k_sum
ABC330E（https://atcoder.jp/contests/abc330/tasks/abc330_e）reverse_thinking|sorted_list|hash
ABC324E（https://atcoder.jp/contests/abc324/tasks/abc324_e）sorted_list|two_pointers
ABC306F（https://atcoder.jp/contests/abc306/tasks/abc306_f）sorted_list|contribution_method
ABC298F（https://atcoder.jp/contests/abc298/tasks/abc298_f）sorted_list|brute_force|greedy
ABC281E（https://atcoder.jp/contests/abc281/tasks/abc281_e）top_k_sum|sorted_list|classical
ABC267E（https://atcoder.jp/contests/abc267/tasks/abc267_e）implemention|greedy|sorted_list|degree|classical
ABC261F（https://atcoder.jp/contests/abc261/tasks/abc261_f）reverse_pair|sorted_list|classical
ABC245E（https://atcoder.jp/contests/abc245/tasks/abc245_e）partial_order|sorted_list|greedy|implemention

===================================CodeForces===================================
129（https://www.acwing.com/problem/content/129/）greedy|classical|sorted_list

"""
import bisect
from bisect import insort_left, bisect_left
from collections import Counter
from typing import List

from src.basis.various_sort.template import VariousSort
from src.data_structure.sorted_list.template import SortedList, TopKSum, TopKSumSpecial
from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO

from tests.codeforces.problem_a import LocalSortedList


class Solution:
    def __int__(self):
        return

    @staticmethod
    def lg_4375(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4375
        tag: bubble_sort|sorted_list|hard
        """
        n = ac.read_int()
        ans = 1
        nums = [ac.read_int() for _ in range(n)]
        tmp = sorted(nums)
        ind = {num: i + 1 for i, num in enumerate(tmp)}
        lst = SortedList()
        for i in range(n):
            lst.add(ind[nums[i]])
            ans = max(ans, i + 1 - lst.bisect_right(i + 1))
        ac.st(ans)
        return

    @staticmethod
    def cf_61e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/61/E
        tag: sorted_list|prefix_suffix|counter
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [0] * (n + 1)
        lst = SortedList()
        for i in range(n):
            pre[i + 1] = i - lst.bisect_right(nums[i])
            lst.add(nums[i])

        post = [0] * (n + 1)
        lst = SortedList()
        for i in range(n - 1, -1, -1):
            post[i] = lst.bisect_left(nums[i])
            lst.add(nums[i])

        ans = 0
        for i in range(1, n - 1):
            ans += pre[i + 1] * post[i]
        ac.st(ans)
        return

    @staticmethod
    def cf_1005e2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1005/problem/E2
        tag: median|inclusion_exclusion|prefix_sum|sorted_list|binary_search|brain_teaser
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        def check(x):
            lst = [1 if num >= x else -1 for num in nums]
            pre = SortedList([0])
            cur = res = 0
            for num in lst:
                cur += num
                res += pre.bisect_left(cur)
                pre.add(cur)
            return res

        ac.st(- check(m + 1) + check(m))
        return

    @staticmethod
    def lc_2426(nums1: List[int], nums2: List[int], diff: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/
        tag: math|sorted_list|binary_search
        """
        n = len(nums1)
        ans = 0
        lst = SortedList([nums1[n - 1] - nums2[n - 1] + diff])
        for i in range(n - 2, -1, -1):
            k = lst.bisect_left(nums1[i] - nums2[i])
            ans += len(lst) - k
            lst.add(nums1[i] - nums2[i] + diff)
        return ans

    @staticmethod
    def lg_1966(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1966
        tag: reverse_order_pair|greedy|classical
        """
        n = ac.read_int()
        ans = 0
        mod = 10 ** 8 - 3
        nums1 = ac.read_list_ints()
        ind1 = list(range(n))
        ind1.sort(key=lambda it: nums1[it])

        nums2 = ac.read_list_ints()
        ind2 = list(range(n))
        ind2.sort(key=lambda it: nums2[it])

        q = [0] * n
        for i in range(n):
            q[ind1[i]] = ind2[i]
        lst = SortedList()
        for num in q:
            ans += len(lst) - lst.bisect_right(num)
            lst.add(num)
        ac.st(ans % mod)
        return

    @staticmethod
    def ac_129(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/129/
        tag: greedy|classical|sorted_list
        """
        n, m = ac.read_list_ints()
        machine = [ac.read_list_ints() for _ in range(n)]
        task = [ac.read_list_ints() for _ in range(m)]
        machine.sort(reverse=True)
        task.sort(reverse=True)
        lst = []
        ans = money = j = 0
        for i in range(m):
            tm, level = task[i]
            while j < n and machine[j][0] >= tm:
                insort_left(lst, machine[j][1])
                j += 1
            ind = bisect_left(lst, level)
            if ind < len(lst):
                lst.pop(ind)
                ans += 1
                money += 500 * tm + 2 * level
        ac.lst([ans, money])
        return

    @staticmethod
    def lg_p1637(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1637
        tag: sorted_list|prefix_suffix|counter
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        pre = [0] * n
        lst = SortedList()
        for i in range(n):
            pre[i] = lst.bisect_left(nums[i])
            lst.add(nums[i])

        lst = SortedList()
        post = [0] * n
        for i in range(n - 1, -1, -1):
            post[i] = n - i - 1 - lst.bisect_right(nums[i])
            lst.add(nums[i])
        ans = sum(pre[i] * post[i] for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def lg_p2234(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2234
        tag: sorted_list
        """
        n = ac.read_int()
        ans = 0
        lst = SortedList()
        for _ in range(n):
            x = ac.read_int()
            if not lst:
                ans += x
            else:
                i = lst.bisect_left(x)
                cur = math.inf
                for j in [i - 1, i]:
                    if 0 <= j < len(lst):
                        cur = min(cur, abs(lst[j] - x))
                ans += cur
            lst.add(x)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2804(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2804
        tag: prefix_sum|sorted_list|classical|brain_teaser
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        mod = 92084931
        pre = 0
        lst = SortedList()
        lst.add(0)
        ans = 0
        for num in nums:
            pre += num - m
            ans += lst.bisect_left(pre)
            lst.add(pre)
        ac.st(ans % mod)
        return

    @staticmethod
    def lg_p5076(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5076
        tag: sorted_list|implemention
        """
        q = ac.read_int()
        dct = set()
        lst = []
        lst_set = []
        for _ in range(q):
            op, x = ac.read_list_ints()
            if op == 1:
                i = bisect.bisect_left(lst, x)
                ac.st(i + 1)
            elif op == 2:
                ac.st(lst_set[x - 1])
            elif op == 3:
                i = bisect.bisect_left(lst, x)
                n = len(lst)
                ans = -2147483647
                if 0 <= i - 1 < n and lst_set[i - 1] < x:
                    ans = lst_set[i - 1]
                ac.st(ans)
            elif op == 4:
                i = bisect.bisect_right(lst, x)
                n = len(lst)
                if 0 <= i < n:
                    ac.st(lst[i])
                else:
                    ac.st(2147483647)
            else:
                bisect.insort_left(lst, x)
                if x not in dct:
                    bisect.insort_left(lst_set, x)
                    dct.add(x)
        return

    @staticmethod
    def lg_p5149(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5149
        tag: reverse_order_pair|bisect
        """
        ac.read_int()
        lst = ac.read_list_strs()
        ind = {st: i for i, st in enumerate(lst)}
        lst = [ind[s] for s in ac.read_list_strs()]
        ans = 0
        pre = []
        for num in lst:
            ans += len(pre) - bisect.bisect_left(pre, num)
            bisect.insort_left(pre, num)
        ac.st(ans)
        return

    @staticmethod
    def lg_p5459(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5459
        tag: prefix_sum|sorted_list|binary_search
        """
        n, low, high = ac.read_list_ints()
        a = ac.read_list_ints()
        ans = 0
        lst = []
        s = sum(a)
        bisect.insort_left(lst, s)
        for i in range(n - 1, -1, -1):
            s -= a[i]
            x = bisect.bisect_left(lst, s + low)
            ans += bisect.bisect_right(lst, s + high) - x
            bisect.insort_left(lst, s)
        ac.st(ans)
        return

    @staticmethod
    def lg_p7912(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7912
        tag: sorted_list|implemention|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        lst = [SortedList([i + 1 for i in range(n) if not nums[i]]),
               SortedList([i + 1 for i in range(n) if nums[i]])]

        while lst[0] and lst[1]:
            ans = []
            if lst[0][0] < lst[1][0]:
                i = 0
            else:
                i = 1
            ans.append(lst[i].pop(0))
            i = 1 - i
            while lst[i] and lst[i][-1] > ans[-1]:
                j = lst[i].bisect_left(ans[-1])
                ans.append(lst[i].pop(j))
                i = 1 - i
            ac.lst(ans)

        for a in lst[0]:
            ac.st(a)
        for a in lst[1]:
            ac.st(a)
        return

    @staticmethod
    def lc_2276():
        """
        url: https://leetcode.cn/problems/count-integers-in-intervals/
        tag: sorted_list|implemention|classical
        """

        class CountIntervals:

            def __init__(self):
                self.lst = SortedList()
                self.sum = 0

            def add(self, left: int, right: int) -> None:
                x = self.lst.bisect_left([left, left])
                while x - 1 >= 0 and self.lst[x - 1][1] >= left:
                    x -= 1

                while 0 <= x < len(self.lst) and not (self.lst[x][0] > right or self.lst[x][1] < left):
                    a, b = self.lst.pop(x)
                    left = left if left < a else a
                    right = right if right > b else b
                    self.sum -= b - a + 1
                self.sum += right - left + 1
                self.lst.add([left, right])

            def count(self) -> int:
                return self.sum

        return CountIntervals

    @staticmethod
    def lc_3013(nums: List[int], k: int, dist: int) -> int:
        """
        url: https://leetcode.com/problems/divide-an-array-into-subarrays-with-minimum-cost-ii/
        tag: sorted_list|top_k_sum
        """
        n = len(nums)
        ans = math.inf
        lst = TopKSum(k - 2)
        j = 2
        for i in range(1, n):
            if i >= 2:
                lst.discard(nums[i])
            if n - i - 1 < k - 2:
                break
            while j <= i + dist and j < n:
                lst.add(nums[j])
                j += 1
            if len(lst.lst) >= k - 2:
                cur = nums[0] + nums[i] + lst.top_k_sum
                if cur < ans:
                    ans = cur
        return ans

    @staticmethod
    def abc_306e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc306/tasks/abc306_e
        tag: sorted_list|top_k_sum
        """
        n, k, q = ac.read_list_ints()
        nums = [0] * n
        lst = TopKSum(k)
        for _ in range(q):
            x, y = ac.read_list_ints()
            x -= 1
            if nums[x]:
                lst.discard(-nums[x])
            nums[x] = y
            if nums[x]:
                lst.add(-nums[x])
            ac.st(-lst.top_k_sum)
        return

    @staticmethod
    def lg_p3369(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3369
        tag: sorted_list
        """
        n = ac.read_int()
        lst = SortedList()
        for _ in range(n):
            op, x = ac.read_list_ints()
            if op == 1:
                lst.add(x)
            elif op == 2:
                lst.discard(x)
            elif op == 3:
                ac.st(lst.bisect_left(x) + 1)
            elif op == 4:
                ac.st(lst[x - 1])
            elif op == 5:
                i = lst.bisect_left(x)
                if i == len(lst) or lst[i] >= x:
                    i -= 1
                ac.st(lst[i])
            else:
                i = lst.bisect_right(x)
                ac.st(lst[i])
        return

    @staticmethod
    def lg_p6136(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6136
        tag: sorted_list
        """
        n, q = ac.read_list_ints()
        lst = SortedList(ac.read_list_ints())
        ans = last = 0
        for _ in range(q):
            op, x = ac.read_list_ints()
            x ^= last
            if op == 1:
                lst.add(x)
            elif op == 2:
                lst.discard(x)
            elif op == 3:
                last = lst.bisect_left(x) + 1
                ans ^= last
            elif op == 4:
                last = lst[x - 1]
                ans ^= last
            elif op == 5:
                i = lst.bisect_left(x)
                if i == len(lst) or lst[i] >= x:
                    i -= 1
                last = lst[i]
                ans ^= last
            else:
                i = lst.bisect_right(x)
                last = lst[i]
                ans ^= last
        ac.st(ans)
        return

    @staticmethod
    def abc_306f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc306/tasks/abc306_f
        tag: sorted_list|contribution_method
        """
        n, m = ac.read_list_ints()
        nums = [sorted(ac.read_list_ints()) for _ in range(n)]
        post = SortedList(nums[-1])
        ans = 0
        for i in range(n - 2, -1, -1):
            for num in nums[i]:
                ans += bisect.bisect_left(post, num) + (n - i - 1)
            ans += (n - 1 - i) * (1 + m - 1) * (m - 1) // 2
            for num in nums[i]:
                post.add(num)
        ac.st(ans)
        return

    @staticmethod
    def abc_281e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc281/tasks/abc281_e
        tag: top_k_sum|sorted_list|classical
        """
        n, m, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = TopKSum(k)
        ans = []
        for i in range(m - 1):
            lst.add(nums[i])
        for i in range(n - m + 1):
            lst.add(nums[i + m - 1])
            ans.append(lst.top_k_sum)
            lst.discard(nums[i])
        ac.lst(ans)
        return

    @staticmethod
    def abc_267e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc267/tasks/abc267_e
        tag: implemention|greedy|sorted_list|degree|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += nums[j]
            degree[j] += nums[i]
        lst = SortedList([(degree[i], i) for i in range(n)])
        ans = 0
        while lst:
            d, i = lst.pop(0)
            ans = max(ans, d)
            degree[i] = 0
            for j in dct[i]:
                if degree[j]:
                    lst.discard((degree[j], j))
                    degree[j] -= nums[i]
                    lst.add((degree[j], j))
        ac.st(ans)
        return

    @staticmethod
    def abc_261f_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc261/tasks/abc261_f
        tag: reverse_pair|inverse_pair|sorted_list|classical
        """
        n = ac.read_int()
        c = ac.read_list_ints()
        x = ac.read_list_ints()
        dct = [SortedList() for _ in range(n + 1)]
        ans = 0
        pre = SortedList()
        for i in range(n):
            cc, xx = c[i], x[i]
            bigger = i - pre.bisect_right(x[i])
            bigger -= len(dct[cc]) - dct[cc].bisect_right(xx)
            ans += bigger
            pre.add(xx)
            dct[cc].add(xx)
        ac.st(ans)
        return

    @staticmethod
    def abc_261f_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc261/tasks/abc261_f
        tag: reverse_pair|inverse_pair|sorted_list|classical
        """
        n = ac.read_int()
        c = ac.read_list_ints_minus_one()
        x = ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        for i in range(n):
            dct[c[i]].append(x[i])
        ans = VariousSort().range_merge_to_disjoint_sort_inverse_pair(x)
        for ls in dct:
            if ls:
                ans -= VariousSort().range_merge_to_disjoint_sort_inverse_pair(ls)
        ac.st(ans)
        return


    @staticmethod
    def cf_1969d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1969/problem/D
        tag: sorted_list|top_k_sum|greedy
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            ind = list(range(n))
            ind.sort(key=lambda it: -b[it])
            lst = TopKSum(k)
            tot = sum(b[i] - a[i] for i in range(n) if b[i] >= a[i])
            if k == 0:
                ans = tot
            else:
                ans = 0
                for i in ind:
                    if b[i] >= a[i]:
                        tot -= b[i] - a[i]
                    lst.add(a[i])
                    if len(lst.lst) >= k > 0:
                        ans = max(ans, tot - lst.top_k_sum)
            ac.st(ans)
        return

    @staticmethod
    def lg_p2161(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2161
        tag: sorted_list|trick
        """
        n = ac.read_int()
        lst = LocalSortedList()
        part = 2 * 10 ** 5 + 10
        for _ in range(n):
            cur = ac.read_list_strs()
            if cur[0] == "B":
                ac.st(len(lst))
            else:
                a, b = cur[1:]
                a = int(a)
                b = int(b)
                ans = 0
                i = lst.bisect_left(a*part+a)
                for x in [i - 1, i, i + 1]:
                    while 0 <= x < len(lst) and not (lst[x]//part > b or lst[x]%part < a):
                        lst.pop(x)
                        ans += 1
                ac.st(ans)
                lst.add(a*part+b)
        return

    @staticmethod
    def lg_p5677(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5677
        tag: sorted_list|offline_query|range|contribution_method|two_pointers
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        if n == 1:
            ac.st(0)
            return
        ind = {num: i for i, num in enumerate(nums)}
        nums.sort()
        pairs = []
        for i in range(n):
            if i == 0:
                x, y = ind[nums[0]], ind[nums[1]]
                pairs.append(y * n + x if x < y else x * n + y)
            elif i == n - 1:
                x, y = ind[nums[n - 1]], ind[nums[n - 2]]
                pairs.append(y * n + x if x < y else x * n + y)
            else:
                if nums[i] - nums[i - 1] <= nums[i + 1] - nums[i]:
                    x, y = ind[nums[i]], ind[nums[i - 1]]
                    pairs.append(y * n + x if x < y else x * n + y)
                if nums[i] - nums[i - 1] >= nums[i + 1] - nums[i]:
                    x, y = ind[nums[i]], ind[nums[i + 1]]
                    pairs.append(y * n + x if x < y else x * n + y)
        pairs.sort()
        length = len(pairs)
        queries = []
        k = 10 ** 6
        for i in range(m):
            ll, rr = ac.read_list_ints_minus_one()
            queries.append(rr * k * k + ll * k + i)
        queries.sort()
        ans = j = 0
        lst = LocalSortedList()
        for val in queries:
            i = val % k
            left, right = (val // k) % k, val // k // k
            while j < length and pairs[j] // n <= right:
                lst.add(pairs[j] % n)
                j += 1
            cur = j - lst.bisect_right(left - 1)
            ans += (i + 1) * cur
        ac.st(ans)
        return

    @staticmethod
    def lc_100442(nums: List[int], k: int, x: int) -> List[int]:
        """
        url: https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/
        tag: top_k_sum|bit_operation
        """
        ans = []
        bit = 32
        lst = TopKSumSpecial(x, bit)
        n = len(nums)
        cnt = Counter()
        for i in range(n):
            num = nums[i]
            c = cnt[num]
            if c:
                lst.discard(-((c << bit) | num))
            cnt[num] += 1
            c = cnt[num]
            if c:
                lst.add(-((c << bit) | num))

            if i >= k - 1:
                ans.append(lst.top_k_sum)
                num = nums[i - k + 1]
                c = cnt[num]
                lst.discard(-((c << bit) | num))
                cnt[num] -= 1
                c = cnt[num]
                if c:
                    lst.add(-((c << bit) | num))

        return ans
"""
Algorithm：sparse_table|multiplication_method|aggregation_property|sub_consequence|log_trick
Description：static_range|range_query|range_max|range_min|range_gcd|range_and|range_or|range_lcm|sparse_table|binary_search

====================================LeetCode====================================
1521（https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/）bit_operation|sub_consequence
2411（https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/）sub_consequence|range_or
2447（https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/）range_gcd|counter|sub_consequence
2470（https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/）range_lcm|counter|sub_consequence
2654（https://leetcode.cn/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/）range_gcd|sub_consequence
2836（https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/description/）multiplication_method|classical
3117（https://leetcode.com/problems/minimum-sum-of-values-by-dividing-array/）range_and|linear_dp|classical
100315（https://leetcode.cn/problems/find-subarray-with-bitwise-and-closest-to-k/）range_and|bit_operation|classical|sparse_table|binary_search|binary_right
2398（https://leetcode.cn/problems/maximum-number-of-robots-within-budget/）sparse_table|binary_search|monotonic_queue

=====================================LuoGu======================================
P3865（https://www.luogu.com.cn/problem/P3865）sparse_table|range_max
P2880（https://www.luogu.com.cn/problem/P2880）sparse_table|range_max|range_min
P3865（https://www.luogu.com.cn/problem/P3865）sparse_table|range_gcd
P1816（https://www.luogu.com.cn/problem/P1816）sparse_table|range_min
P2412（https://www.luogu.com.cn/problem/P2412）lexicographical_order|sparse_table
P5097（https://www.luogu.com.cn/problem/P5097）sparse_table|range_min
P5648（https://www.luogu.com.cn/problem/P5648）sparse_table|range_max_index|monotonic_stack
P2048（https://www.luogu.com.cn/problem/P2048）sparse_table_index|heapq|greedy

===================================CodeForces===================================
1691D（https://codeforces.com/problemset/problem/1691/D）monotonic_stack|brute_force|sparse_table|range_max|range_min
689D（https://codeforces.com/problemset/problem/689/D）binary_search|sparse_table|counter
1359D（https://codeforces.com/problemset/problem/1359/D）monotonic_stack|brute_force|sparse_table|range_max|range_min
1548B（https://codeforces.com/problemset/problem/1548/B）sparse_table|range_gcd|brute_force|binary_search
474F（https://codeforces.com/problemset/problem/474/F）sparse_table|range_min|range_gcd|binary_search|counter
1834E（https://codeforces.com/contest/1834/problem/E）sparse_table|range_lcm
1878E（https://codeforces.com/contest/1878/problem/E）sparse_table|range_and
1547F（https://codeforces.com/contest/1547/problem/F）sparse_table|range_gcd
1579F（https://codeforces.com/contest/1579/problem/F）circular_section|range_and
1709D（https://codeforces.com/contest/1709/problem/D）sparse_table|range_max|implemention
1516D（https://codeforces.com/contest/1516/problem/D）multiplication_method
1977C（https://codeforces.com/contest/1977/problem/C）data_range|subsequence_lcm|brain_teaser|classical
1847F（https://codeforces.com/contest/1847/problem/F）range_or|classical|implemention|sub_consequence
359D（https://codeforces.com/problemset/problem/359/D）range_gcd|classical
475D（https://codeforces.com/problemset/problem/475/D）range_gcd|classical
451D（https://codeforces.com/problemset/problem/451/D）sparse_table|divide_and_conquer
1632D（https://codeforces.com/problemset/problem/1632/D）sparse_table|binary_search

=====================================AcWing=====================================
109（https://www.acwing.com/problem/content/111/）greedy|multiplication_method

=====================================AtCoder=====================================
ABC212F（https://atcoder.jp/contests/abc212/tasks/abc212_f）multiplication_method|build_graph|brain_teaser|classical
ABC367E（https://atcoder.jp/contests/abc367/tasks/abc367_e）multiplication_method|classical

"""

import bisect
import math
from collections import defaultdict, Counter
from functools import lru_cache
from heapq import heappop, heapify, heappush
from itertools import accumulate
from operator import and_
from typing import List

from src.data_structure.sparse_table.template import SparseTable, SparseTableIndex
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p2880(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2880
        tag: sparse_table|range_max|range_min
        """
        n, q = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        st1 = SparseTable(nums, max)
        st2 = SparseTable(nums, min)
        for _ in range(q):
            a, b = ac.read_list_ints_minus_one()
            ac.st(st1.query(a, b) - st2.query(a, b))
        return

    @staticmethod
    def lg_p3865(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3865
        tag: sparse_table|range_gcd
        """
        n, m = ac.read_list_ints()
        st = SparseTable(ac.read_list_ints(), max)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            ac.st(st.query(x, y))
        return

    @staticmethod
    def cf_474f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/474/F
        tag: sparse_table|range_min|range_gcd|binary_search|counter
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dct = defaultdict(list)
        for i, num in enumerate(nums):
            dct[num].append(i)
        st_gcd = SparseTable(nums, math.gcd)
        st_min = SparseTable(nums, min)
        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints_minus_one()
            num1 = st_gcd.query(x, y)
            num2 = st_min.query(x, y)
            if num1 == num2:
                res = bisect.bisect_right(dct[num1], y) - bisect.bisect_left(dct[num1], x)
                ac.st(y - x + 1 - res)
            else:
                ac.st(y - x + 1)
        return

    @staticmethod
    def ac_109(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/111/
        tag: greedy|multiplication_method|two_pointers|merge_sort|hard|classical
        """

        def range_merge_to_disjoint(lst1, lst2):
            a, b = len(lst1), len(lst2)
            x = y = 0
            res = []
            while x < a or y < b:
                if x == a or (y < b and lst2[y] < lst1[x]):
                    res.append(lst2[y])
                    y += 1
                else:
                    res.append(lst1[x])
                    x += 1
            return res

        def check(lst1):
            k = len(lst1)
            x, y = 0, k - 1
            res = cnt = 0
            while x < y and cnt < m:
                res += (lst1[x] - lst1[y]) ** 2
                if res > t:
                    return False
                x += 1
                y -= 1
                cnt += 1
            return True

        for _ in range(ac.read_int()):
            n, m, t = ac.read_list_ints()
            nums = ac.read_list_ints()
            ans = i = 0
            while i < n:
                p = 1
                lst = [nums[i]]
                right = i
                while p and right < n:
                    cur = nums[right + 1:right + p + 1]
                    cur.sort()
                    tmp = range_merge_to_disjoint(lst, cur)
                    if check(tmp):
                        lst = tmp[:]
                        right += p
                        p *= 2
                    else:
                        p //= 2
                ans += 1
                i = right + 1
            ac.st(ans)
        return

    @staticmethod
    def lg_p5648(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5648
        tag: sparse_table|range_max_index|monotonic_stack
        """
        n, t = ac.read_list_ints()
        nums = ac.read_list_ints()
        post = [n] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] < nums[i]:
                post[stack.pop()] = i
            stack.append(i)
        edge = [[] for _ in range(n + 1)]
        for i in range(n):
            edge[post[i]].append(i)
        sub = [0] * (n + 1)
        stack = [n]
        while stack:
            i = stack.pop()
            for j in edge[i]:
                sub[j] = sub[i] + nums[j] * (i - j)
                stack.append(j)
        st = SparseTableIndex(nums, max)
        last_ans = 0
        for _ in range(t):
            u, v = ac.read_list_ints()
            left = 1 + (u ^ last_ans) % n
            q = 1 + (v ^ (last_ans + 1)) % (n - left + 1)
            right = left + q - 1
            ceil_ind = st.query(left - 1, right - 1)
            last_ans = sub[left - 1] - sub[ceil_ind] + nums[ceil_ind] * (right - ceil_ind)
            ac.st(last_ans)
        return

    @staticmethod
    def lc_2447(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/
        tag: range_gcd|counter|sub_consequence
        """
        ans = 0
        pre = dict()
        for num in nums:
            cur = dict()
            for p in pre:
                x = math.gcd(p, num)
                if x % k == 0:
                    cur[x] = cur.get(x, 0) + pre[p]
            if num % k == 0:
                cur[num] = cur.get(num, 0) + 1
            ans += cur.get(k, 0)
            pre = cur
        return ans

    @staticmethod
    def lc_2470(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/
        tag: range_lcm|counter|sub_consequence
        """
        ans = 0
        pre = dict()
        for num in nums:
            cur = dict()
            for p in pre:
                x = math.lcm(p, num)
                if k % x == 0:
                    cur[x] = cur.get(x, 0) + pre[p]
            if k % num == 0:
                cur[num] = cur.get(num, 0) + 1
            ans += cur.get(k, 0)
            pre = cur
        return ans

    @staticmethod
    def lc_2836(nex: List[int], k: int) -> int:
        """
        url:https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/
        tag: multiplication_method|classical|can_not_be_circular_section|can_not_to_be_permutation_circle
        """
        n = len(nex)
        ans = list(range(n))
        pos = list(range(n))
        s = nex[:]
        while k:
            if k & 1:
                ans = [ans[i] + s[pos[i]] for i in range(n)]
                pos = [nex[i] for i in pos]
            k >>= 1
            s = [s[i] + s[nex[i]] for i in range(n)]
            nex = [nex[i] for i in nex]
        return max(ans)

    @staticmethod
    def lc_2411(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/
        tag: sub_consequence|range_or
        """
        n = len(nums)
        ans = [0] * n
        post = dict()
        for i in range(n - 1, -1, -1):
            cur = dict()
            num = nums[i]
            for x in post:
                y = cur.get(x | num, math.inf)
                cur[x | num] = y if y < post[x] else post[x]
            cur[num] = i
            post = cur
            ans[i] = post[max(post)] - i + 1
        return ans

    @staticmethod
    def cf_1516d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1516/problem/D
        tag: multiplication_method|classical|sparse_table
        """
        pf = PrimeFactor(10 ** 5)
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        post = [n] * (n + 1)
        ind = [n] * (10 ** 5)
        for i in range(n - 1, -1, -1):
            right = post[i + 1]
            for p, _ in pf.prime_factor[nums[i]]:
                right = min(ind[p], right)
                ind[p] = i
            post[i] = right

        col = max(2, math.ceil(math.log2(n)))
        dp = [[n] * col for _ in range(n)]
        for i in range(n):
            dp[i][0] = post[i]
        for j in range(1, col):
            for i in range(n):
                father = dp[i][j - 1]
                if father <= n - 1:
                    dp[i][j] = dp[father][j - 1]

        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            ans = 0
            for j in range(col - 1, -1, -1):
                if dp[x][j] <= y:
                    x = dp[x][j]
                    ans += 1 << j
            ac.st(ans + 1)
        return

    @staticmethod
    def cf_1709d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1709/problem/D
        tag: sparse_table|range_max|implemention
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        st = SparseTable(nums, max)
        for _ in range(ac.read_int()):
            x1, y1, x2, y2, k = ac.read_list_ints()
            if x1 % k != x2 % k or y1 % k != y2 % k:
                ac.no()
                continue
            if y1 == y2:
                ac.yes()
                continue
            if y1 > y2:
                y1, y2 = y2, y1
            ceil = st.query(y1 - 1, y2 - 1)
            y = (n - x1) // k
            w = k * y + x1
            if w <= ceil:
                ac.no()
            else:
                ac.yes()
        return

    @staticmethod
    def cf_1878e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1878/problem/E
        tag: sparse_table|range_and
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            q = ac.read_int()
            query = [dict() for _ in range(n)]
            res = []
            for _ in range(q):
                ll, k = ac.read_list_ints()
                ll -= 1
                res.append([ll, k])
                query[ll][k] = -2
            post = dict()
            for i in range(n - 1, -1, -1):
                cur = dict()
                num = nums[i]
                for p in post:
                    x = p & num
                    if x not in cur or post[p] > cur[x]:
                        cur[x] = post[p]
                if num not in cur:
                    cur[num] = i
                lst = sorted(query[i].keys(), reverse=True)
                val = [[num, cur[num]] for num in cur]
                val.sort(reverse=True)
                right = -2
                m = len(val)
                p = 0
                for ke in lst:
                    while p < m and val[p][0] >= ke:
                        _, xx = val[p]
                        if xx > right:
                            right = xx
                        p += 1
                    query[i][ke] = right
                post = cur.copy()
            ac.lst([query[ll][k] + 1 for ll, k in res])
        return

    @staticmethod
    def lc_1521(arr: List[int], target: int) -> int:
        """
        url: https://leetcode.cn/problems/find-a-value-of-a-mysterious-function-closest-to-target/
        tag: bit_operation|sub_consequence
        """
        ans = abs(arr[0] - target)
        pre = {arr[0]}
        for num in arr[1:]:
            pre = {num & p for p in pre}
            pre.add(num)
            for x in pre:
                if abs(x - target) < ans:
                    ans = abs(x - target)
        return ans

    @staticmethod
    def lg_p2048(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2048
        tag: sparse_table_index|heapq|greedy
        """
        n, k, l, r = ac.read_list_ints()
        pre = [0] * (n + 1)
        for i in range(n):
            pre[i + 1] = pre[i] + ac.read_int()
        st_ind = SparseTableIndex(pre, max)
        stack = []
        for i in range(n):
            if i + l - 1 < n:
                j = st_ind.query(i + l, min(i + r, n))
                stack.append((pre[i] - pre[j], i, j, i + l, min(i + r, n)))
            else:
                break

        heapify(stack)
        ans = 0
        for _ in range(k):
            x, i, j, ll, rr = heappop(stack)
            ans -= x
            if ll <= j - 1:
                jj = st_ind.query(ll, j - 1)
                heappush(stack, (pre[i] - pre[jj], i, jj, ll, j - 1))
            if j + 1 <= rr:
                jj = st_ind.query(j + 1, rr)
                heappush(stack, (pre[i] - pre[jj], i, jj, j + 1, rr))
        ac.st(ans)
        return

    @staticmethod
    def cf_1548b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1548/B
        tag: sparse_table|range_gcd|two_pointers|diff_array|brain_teaser|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            diff = [nums[i + 1] - nums[i] for i in range(n - 1)]
            st = SparseTable(diff, math.gcd)
            ans = 1
            j = 0
            for i in range(n - 1):
                if abs(diff[i]) == 1:
                    continue
                while j < i:
                    j += 1
                while j + 1 < n - 1 and st.query(i, j + 1) > 1:
                    j += 1
                if j - i + 2 > ans:
                    ans = j - i + 2
            ac.st(ans)
        return

    @staticmethod
    def cf_689d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1548/B
        tag: sparse_table|range_gcd|two_pointers|diff_array|brain_teaser|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            diff = [nums[i + 1] - nums[i] for i in range(n - 1)]
            st = SparseTable(diff, math.gcd)
            ans = 1
            j = 0
            for i in range(n - 1):
                if abs(diff[i]) == 1:
                    continue
                while j < i:
                    j += 1
                while j + 1 < n - 1 and st.query(i, j + 1) > 1:
                    j += 1
                if j - i + 2 > ans:
                    ans = j - i + 2
            ac.st(ans)
        return

    @staticmethod
    def lc_3117(nums: List[int], and_values: List[int]) -> int:
        """
        url: https://leetcode.com/contest/weekly-contest-393/problems/minimum-sum-of-values-by-dividing-array/
        tag: range_and|linear_dp|classical
        """
        n = len(nums)
        m = len(and_values)

        @lru_cache(None)
        def dfs(i, pre, a):
            if i == n:
                return nums[-1] if pre == and_values[-1] and a == m else math.inf
            if a > m:
                return math.inf
            if pre == -1:
                res = dfs(i + 1, nums[i], a + 1)
                return res
            res = math.inf
            if pre == and_values[a - 1]:
                res = dfs(i + 1, nums[i], a + 1) + nums[i - 1]
            res = min(res, dfs(i + 1, nums[i] & pre, a))
            return res

        ans = dfs(0, -1, 0)
        return ans if ans < math.inf else -1

    @staticmethod
    def abc_212f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc212/tasks/abc212_f
        tag: multiplication_method|build_graph|brain_teaser|classical
        """

        def tuple_to_num(aa, bb, cc):
            return (aa << 34) | (bb << 2) | cc

        mask = (1 << 34) - 1

        def num_to_tp(num):
            return num >> 34, (num & mask) >> 2, num & 1

        n, m, q = ac.read_list_ints()
        pos = [[] for _ in range(n)]
        post = dict()
        for i in range(m):
            a, b, s, t = ac.read_list_ints()
            s = 2 * s + 1
            a -= 1
            b -= 1
            t = 2 * t + 1
            ss = tuple_to_num(a, s, 0)
            if ss not in post:
                post[ss] = dict()
            post[ss][0] = tuple_to_num(b, t, 1)
            pos[a].append((s, 0))
            pos[b].append((t, 1))

        lst = []
        for i in range(n):
            pos[i].sort(key=lambda it: (it[0], -it[1]))
            m = len(pos[i])
            ls = []
            for j in range(m - 1, -1, -1):
                if pos[i][j][1] == 0:
                    ls = pos[i][j][:]
                else:
                    if ls:
                        cur = tuple_to_num(i, pos[i][j][0], pos[i][j][1])
                        if cur not in post:
                            post[cur] = dict()
                        post[cur][0] = tuple_to_num(i, ls[0], ls[1])
            lst.append([ls[0] for ls in pos[i]])

        for x in range(1, 20):
            for s in post:
                if x - 1 in post[s] and post[s][x - 1] in post and x - 1 in post[post[s][x - 1]]:
                    post[s][x] = post[post[s][x - 1]][x - 1]

        for _ in range(q):
            x, y, z = ac.read_list_ints()
            z *= 2
            x *= 2
            y -= 1
            i = bisect.bisect_left(lst[y], x)
            if i == len(lst[y]):
                ac.st(y + 1)
                continue
            state = tuple_to_num(y, pos[y][i][0], pos[y][i][1])
            for x in range(19, -1, -1):
                if state in post and x in post[state] and num_to_tp(post[state][x])[1] <= z:
                    state = post[state][x]
            tmp = num_to_tp(state)
            if tmp[-1] == 0 and z > tmp[1]:
                res = num_to_tp(post[state][0])
                ac.lst([tmp[0] + 1, res[0] + 1])
            else:
                ac.st(tmp[0] + 1)
        return

    @staticmethod
    def cf_1977c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1977/problem/C
        tag: data_range|subsequence_lcm|brain_teaser|classical
        """
        ceil = 10 ** 9 + 1
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            ans = pre = 0
            dct = set(nums)
            cnt = Counter(nums)
            for num in nums:
                pre = math.lcm(pre, num) if pre else num
                if pre > ceil:
                    break
            if pre > ceil or pre not in dct:
                ans = n
                ac.st(ans)
                continue
            pre = defaultdict(int)
            pre[1] = 0
            for num in cnt:
                cur = pre.copy()
                for p in pre:
                    pp = math.lcm(p, num)
                    cur[pp] = max(cur[pp], pre[p] + cnt[num])
                pre = cur
                for k in pre:
                    if k not in dct:
                        ans = max(ans, pre[k])
            ac.st(ans)
        return

    @staticmethod
    def lc_100315(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-subarray-with-bitwise-and-closest-to-k/
        tag: range_and|bit_operation|classical|sparse_table|binary_search|binary_right
        """
        n = len(nums)
        st = SparseTable(nums, and_)
        ans = math.inf
        initial = (1 << 32) - 1
        for i in range(n):
            j, val = st.bisect_right(i, k, initial)
            ans = min(ans, abs(val - k))
            if j + 1 < n:
                ans = min(ans, abs((val & nums[j + 1]) - k))
        return ans

    @staticmethod
    def cf_1847f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1847/problem/F
        tag: range_or|classical|implemention|sub_consequence
        """

        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            nums = ac.read_list_ints()

            def check(length, index):
                if length == 1:
                    return index + 1
                res = n + (length - 2) * (n - 1)
                start = (-length + 2) % n
                if index >= start:
                    res += index - start + 1
                else:
                    res += index + 1 + n - start
                return res

            val = dict()
            pre = dict()
            for i in range(2 * n):
                cur = dict()
                num = nums[i % n]
                for p in pre:
                    cur[p | num] = min(cur.get(p | num, math.inf), pre[p] + 1)
                cur[num] = min(cur.get(num, math.inf), 1)
                pre = cur
                for p in pre:
                    tmp = val.get(p, math.inf)
                    ind = check(pre[p], (i - pre[p] + 1) % n)
                    if ind < tmp:
                        val[p] = ind
            lst = [i << 32 | p for p, i in val.items()]
            lst.sort()
            ind = []
            val = []
            for pi in lst:
                i = pi >> 32
                p = pi ^ (i << 32)
                if val and val[-1] >= p:
                    continue
                val.append(p)
                ind.append(i)
            for _ in range(q):
                v = ac.read_int()
                if v >= val[-1]:
                    ac.st(-1)
                else:
                    i = bisect.bisect_right(val, v)
                    ac.st(ind[i])
        return

    @staticmethod
    def cf_359d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/359/D
        tag: range_gcd|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [0] * n
        dct = defaultdict(int)
        for i, num in enumerate(nums):
            cur = defaultdict(int)
            for p in dct:
                x = math.gcd(p, num)
                cur[x] = max(cur[x], dct[p] + 1)
            cur[num] = max(cur[num], 1)
            pre[i] = cur[num]
            dct = cur

        post = [0] * n
        dct = defaultdict(int)
        for i in range(n - 1, -1, -1):
            num = nums[i]
            cur = defaultdict(int)
            for p in dct:
                x = math.gcd(p, num)
                cur[x] = max(cur[x], dct[p] + 1)
            cur[num] = max(cur[num], 1)
            post[i] = cur[num]
            dct = cur

        ceil = max(pre[i] + post[i] - 1 for i in range(n))
        ans = set()
        for i in range(n):
            if pre[i] + post[i] - 1 == ceil:
                ans.add(i - pre[i] + 2)
        ac.lst([len(ans), ceil - 1])

        ac.lst(sorted(ans))
        return

    @staticmethod
    def abc_367e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc367/tasks/abc367_e
        tag: multiplication_method|classical
        """
        n, k = ac.read_list_ints()
        x = ac.read_list_ints_minus_one()
        a = ac.read_list_ints()
        for xx in range(60):
            if k & (1 << xx):
                a = [a[x[i]] for i in range(n)]
            x = [x[x[i]] for i in range(n)]
        ac.lst(a)
        return

    @staticmethod
    def cf_451d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/451/D
        tag: sparse_table|divide_and_conquer
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            mx = SparseTableIndex(nums, max)
            mn = SparseTableIndex(nums, min)

            dct = dict()
            stack = [n - 1]
            while stack:
                val = stack.pop()
                if val >= 0:

                    ll, rr = val // n, val % n
                    if ll == rr:
                        dct[val] = 0
                        continue
                    stack.append(~val)
                    p1 = mx.query(ll, rr)
                    p2 = mn.query(ll, rr)
                    if p1 > p2:
                        p1, p2 = p2, p1
                    stack.append(ll * n + p1)
                    stack.append(p2 * n + rr)
                else:
                    val = ~val
                    ll, rr = val // n, val % n
                    p1 = mx.query(ll, rr)
                    p2 = mn.query(ll, rr)
                    if p1 > p2:
                        p1, p2 = p2, p1
                    dct[val] = dct[ll * n + p1] + dct[p2 * n + rr] + 1
            ans = dct[n - 1]
            ac.st(ans)
        return

    @staticmethod
    def cf_1632d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1632/D
        tag: sparse_table|binary_search
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        nums.reverse()
        st = SparseTable(nums, math.gcd)
        dp = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            flag, j = st.bisect_right_length(i)
            if flag:
                dp[i] = dp[j + 1] + 1
            else:
                dp[i] = dp[i + 1]
        ac.lst(dp[:-1][::-1])
        return

    @staticmethod
    def lc_2398(charge: List[int], costs: List[int], budget: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-robots-within-budget/
        tag: sparse_table|binary_search|monotonic_queue
        """
        n = len(charge)
        m = n.bit_length()
        st = [[0] * n for _ in range(m + 1)]
        st[0] = charge[:]
        acc = list(accumulate(costs, initial=0))
        for i in range(1, m + 1):
            for j in range(n - (1 << i) + 1):
                st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])
        ans = 0

        for i in range(n):
            pos = i
            pre = 0
            for x in range(m, -1, -1):
                if pos + (1 << x) - 1 < n and max(st[x][pos], pre) + (pos + (1 << x) - i) * (
                        acc[pos + (1 << x)] - acc[i]) <= budget:
                    pre = max(st[x][pos], pre)
                    pos += (1 << x)
            ans = max(ans, pos - i)
        return ans
"""
Algorithm：block_query|offline_query|sort|two_pointers
Description：sort the query interval into blocks and alternate between moving two pointers dynamically maintain query values

====================================LeetCode====================================
1157（https://leetcode.cn/problems/online-majority-element-in-subarray/description/）range_super_mode|CF1514D|random_guess|binary_search|bit_operation|segment_tree
100404（https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/）sqrt_decomposition|inclusion_exclusion|prefix_sum

=====================================LuoGu======================================
P3396（https://www.luogu.com.cn/problem/P3396）sqrt_decomposition
P3765（https://www.luogu.com.cn/problem/P3765）range_super_mode
P3567（https://www.luogu.com.cn/problem/P3567）range_super_mode
P3203（https://www.luogu.com.cn/problem/P3203）sqrt_decomposition|classical

===================================CodeForces===================================
220B（https://codeforces.com/contest/220/problem/B）block_query|counter
86D（https://codeforces.com/contest/86/problem/D）block_query|math
617E（https://codeforces.com/contest/617/problem/E）block_query|xor_pair|counter
1514D（https://codeforces.com/contest/1514/problem/D）range_super_mode|random_guess|binary_search|bit_operation|segment_tree
1468M（https://codeforces.com/problemset/problem/1468/M）sqrt_decomposition
1207F（https://codeforces.com/problemset/problem/1207/F）sqrt_decomposition
797E（https://codeforces.com/problemset/problem/797/E）sqrt_decomposition
677D（https://codeforces.com/contest/677/problem/D）sqrt_decomposition
425D（https://codeforces.com/problemset/problem/425/D）sqrt_decomposition
1921F（https://codeforces.com/contest/1921/problem/F）sqrt_decomposition
103D（https://codeforces.com/contest/103/problem/D）sqrt_decomposition
1806E（https://codeforces.com/problemset/problem/1806/E）sqrt_decomposition
342E（https://codeforces.com/contest/342/problem/E）block_size|sqt_decomposition|tree_lca|classical
375D（https://codeforces.com/contest/375/problem/D）dfs_order|tree_sqrt_decomposition|classical
786C（https://codeforces.com/contest/786/problem/C）sqrt_decomposition|binary_search
13E（https://codeforces.com/contest/13/problem/E）sqrt_decomposition|classical

====================================AtCoder=====================================
ABC132F（https://atcoder.jp/contests/abc132/tasks/abc132_f）block_query|counter|dp|prefix_sum
ABC335F（https://atcoder.jp/contests/abc335/tasks/abc335_f）sqrt_decomposition|linear_dp|refresh_table|fill_table|classical
ABC293G（https://atcoder.jp/contests/abc293/tasks/abc293_g）sqrt_decomposition|brain_teaser|classical
ABC242G（https://atcoder.jp/contests/abc242/tasks/abc242_g）sqrt_decomposition|classical
ABC238G（https://atcoder.jp/contests/abc238/tasks/abc238_g）sqrt_decomposition|offline_query|classical
ABC219G（https://atcoder.jp/contests/abc219/tasks/abc219_g）sqrt_decomposition|classical

"""
import bisect
from collections import defaultdict, Counter
from itertools import accumulate
from operator import xor
from typing import List

from src.data_structure.segment_tree.template import PointSetMergeRangeMode, PointSetBitRangeMode, \
    PointSetRandomRangeMode
from src.data_structure.sorted_list.template import SortedList
from src.data_structure.sqrt_decomposition.template import BlockSize
from src.data_structure.tree_array.template import PointAddRangeSum
from src.graph.tree_lca.template import TreeAncestor
from src.mathmatics.prime_factor.template import PrimeFactor
from src.search.dfs.template import UnWeightedTree
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_132f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc132/tasks/abc132_f
        tag: block_query|counter|dp|prefix_sum
        """
        mod = 10 ** 9 + 7
        n, k = ac.read_list_ints()
        cnt, _ = BlockSize().get_divisor_split(n)
        m = len(cnt)
        dp = cnt[:]
        for _ in range(k - 1):
            pre = list(ac.accumulate(dp)[1:])[::-1]
            dp = [(cnt[i] * pre[i]) % mod for i in range(m)]
        ac.st(sum(dp) % mod)
        return

    @staticmethod
    def cf1514_d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1514/problem/D
        tag: range_super_mode|random_guess|binary_search|bit_operation|segment_tree
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        cnt = [0] * (n + 1)
        freq = [0] * (n + 1)
        size = int(n ** 0.5) + 500

        queries = [[] for _ in range(size)]

        for i in range(m):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append([a, b, i])

        def update(num, p):
            nonlocal cnt, ceil
            if p == 1:
                cnt[num] += 1
                freq[cnt[num] - 1] -= 1
                freq[cnt[num]] += 1
                if cnt[num] > ceil:
                    ceil = cnt[num]
            else:
                cnt[num] += -1
                freq[cnt[num] + 1] -= 1
                freq[cnt[num]] += 1
                if not freq[cnt[num] + 1] and ceil == cnt[num] + 1:
                    ceil = cnt[num]
            return

        ans = [0] * m
        x = y = 0
        cnt[nums[0]] = 1
        freq[1] = 1
        ceil = 1
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                while y > b:
                    update(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    update(nums[y], 1)
                while x > a:
                    x -= 1
                    update(nums[x], 1)
                while x < a:
                    update(nums[x], -1)
                    x += 1
                if ceil * 2 <= b - a + 1:
                    ans[j] = 1
                else:
                    ans[j] = ceil - (b - a + 1 - ceil + 1) + 1
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf1514_d_2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1514/problem/D
        tag: range_super_mode|random_guess|binary_search|bit_operation|segment_tree|random_like
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        ind = [[] for _ in range(1 << 20)]
        cnt = [0] * 20
        pre = [cnt[:]]
        for i, num in enumerate(nums):
            ind[num].append(i)
            for j in range(20):
                if num & (1 << j):
                    cnt[j] += 1
            pre.append(cnt[:])
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            num = 0
            length = y - x + 1
            for j in range(20):
                if pre[y + 1][j] - pre[x][j] >= length / 2:
                    num |= 1 << j

            ceil = bisect.bisect_right(ind[num], y) - bisect.bisect_left(ind[num], x)
            if ceil * 2 <= length:
                ac.st(1)
            else:
                ac.st(ceil - (length - ceil + 1) + 1)
        return

    @staticmethod
    def cf1514_d_3(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1514/problem/D
        tag: range_super_mode|random_guess|binary_search|bit_operation|segment_tree|random_like
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        ds = PointSetBitRangeMode(nums, 20)
        ds = PointSetRandomRangeMode(nums)
        ds = PointSetMergeRangeMode(nums)
        for _ in range(m):
            ll, rr = ac.read_list_ints_minus_one()
            length = rr - ll + 1
            ans = ds.range_mode(ll, rr, (length + 1) // 2)
            if ans == -1:
                ac.st(1)
                continue
            cnt = ds.dct[ans].bisect_right(rr) - ds.dct[ans].bisect_left(ll)
            ac.st(length - ((length - cnt) * 2 + 1) + 1)
        return

    @staticmethod
    def cf_220b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/220/problem/B
        tag: block_query|counter|sqrt_decomposition|offline_query|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        size = int(n ** 0.5) + 1

        queries = [[] for _ in range(size)]
        for i in range(m):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append([a, b, i])

        def update(num, p):
            nonlocal cur, cnt
            if num == cnt[num]:
                cur -= 1
            cnt[num] += p
            if num == cnt[num]:
                cur += 1
            return

        cur = 0
        ans = [0] * m
        x = y = 0
        cnt = defaultdict(int)
        cnt[nums[0]] = 1
        if nums[0] == 1:
            cur += 1
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                while y > b:
                    update(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    update(nums[y], 1)
                while x > a:
                    x -= 1
                    update(nums[x], 1)
                while x < a:
                    update(nums[x], -1)
                    x += 1
                ans[j] = cur
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_86d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/86/problem/D
        tag: sqrt_decomposition|offline_query|math
        """
        n, t = ac.read_list_ints()
        nums = ac.read_list_ints()
        size = int(n ** 0.5) + 1

        queries = [[] for _ in range(t)]
        for i in range(t):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append([a, b, i])

        def update(p, z):
            nonlocal cur
            num = nums[p]
            cur -= cnt[num] * cnt[num] * num
            cnt[num] += z
            cur += cnt[num] * cnt[num] * num
            return

        cnt = [0] * (10 ** 6 + 1)
        x = y = 0
        ans = [0] * t
        cnt = Counter()
        cur = nums[0]
        cnt[nums[0]] = 1
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])

            for a, b, j in queries[i]:
                while y > b:
                    update(y, -1)
                    y -= 1
                while y < b:
                    y += 1
                    update(y, 1)

                while x > a:
                    x -= 1
                    update(x, 1)
                while x < a:
                    update(x, -1)
                    x += 1
                ans[j] = cur
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_617e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/617/problem/E
        tag: sqrt_decomposition|offline_query|xor_pair|counter
        """
        n, m, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre = list(accumulate(nums, xor, initial=0))

        size = int(n ** 0.5) + 1
        queries = [[] for _ in range(size)]
        for i in range(m):
            a, b = ac.read_list_ints()
            queries[b // size].append([a, b, i])

        def update(num, p):
            nonlocal cur
            if p == 1:
                cur += dct[num ^ k]
                dct[num] += 1
            else:
                dct[num] -= 1
                cur -= dct[num ^ k]
            return

        dct = [0] * (2 * 10 ** 6 + 1)
        x = y = 0
        ans = [0] * m
        dct[pre[0]] += 1
        cur = 0
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                a -= 1
                while y > b:
                    update(pre[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    update(pre[y], 1)
                while x > a:
                    x -= 1
                    update(pre[x], 1)
                while x < a:
                    update(pre[x], -1)
                    x += 1
                ans[j] = cur
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_1806e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1806/E
        tag: sqrt_decomposition
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        parent = [-1] + ac.read_list_ints_minus_one()
        fxx = [0] * n
        depth = [0] * n
        cnt = [0] * n
        for i in range(n):
            fxx[i] += nums[i] * nums[i]
            if i:
                fxx[i] += fxx[parent[i]]
                depth[i] = depth[parent[i]] + 1
            cnt[depth[i]] += 1

        size = 100
        dct = dict()
        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            if x > y:
                y, x = x, y
            stack = [(x, y)]
            while x != y and x * n + y not in dct:
                x, y = parent[x], parent[y]
                stack.append((x, y))
            m = len(stack)
            val = dct[x * n + y] if x != y else fxx[x]
            if x != y and cnt[depth[x]] <= size:
                dct[x * n + y] = val
            for i in range(m - 2, -1, -1):
                x, y = stack[i]
                val += nums[x] * nums[y]
                if cnt[depth[x]] <= size:
                    dct[x * n + y] = val
            ac.st(val)
        return

    @staticmethod
    def lg_p3396(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3396
        tag: sqrt_decomposition
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        size = min(n - 1, 10 ** 7 // n)  # 100
        pre = [[]]
        for p in range(1, size + 1):
            lst = [0] * p
            for i in range(n):
                lst[(i + 1) % p] += nums[i]
            pre.append(lst[:])
        for _ in range(q):
            lst = ac.read_list_strs()
            if lst[0] == "A":
                x, y = [int(w) for w in lst[1:]]
                if x <= size:
                    ac.st(pre[x][y])
                else:
                    w = y if y else x
                    ans = 0
                    while w <= n:
                        ans += nums[w - 1]
                        w += x
                    ac.st(ans)
            else:
                x, y = [int(w) for w in lst[1:]]
                num = nums[x - 1]
                nums[x - 1] = y
                for p in range(1, size + 1):
                    pre[p][x % p] -= num
                    pre[p][x % p] += y
        return

    @staticmethod
    def cf_103d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/103/problem/D
        tag: sqrt_decomposition
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        size = min(n, 100)
        q = ac.read_int()
        queries = [ac.read_list_ints() for _ in range(q)]
        ind = [[] for _ in range(size + 1)]
        for i in range(q):
            t, k = queries[i]
            if k <= size:
                ind[k].append(i)
        ans = [-1] * q
        cur = [0] * (n + 1)
        for k in range(1, size + 1):
            if ind[k]:
                cur[0] = 0
                for i in range(n):
                    cur[i + 1] = cur[max(0, i - k + 1)] + nums[i]
                for x in ind[k]:
                    t, k = queries[x]
                    xx = (n - t) // k + 1
                    s = t - 1
                    end = s + (xx - 1) * k
                    ans[x] = cur[end + 1] - cur[max(s - k + 1, 0)]
        for i in range(q):
            t, k = queries[i]
            if k > size:
                t -= 1
                res = 0
                for x in range(t, n, k):
                    res += nums[x]
                ac.st(res)
            else:
                ac.st(ans[i])
        return

    @staticmethod
    def cf_1921(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1921/problem/F
        tag: sqrt_decomposition
        """

        def ind_to_rk(ii, kk):
            return ii // kk + 1

        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            nums = ac.read_list_ints()
            size = min(n, 150)
            queries = [ac.read_list_ints() for _ in range(q)]
            ind = [[] for _ in range(size + 1)]
            for i in range(q):
                s, k, c = queries[i]
                if k <= size:
                    ind[k].append(i)
            ans = [-1] * q
            for k in range(1, size + 1):
                if ind[k]:
                    cur = [0] * (n + 1)
                    pre = [0] * (n + 1)
                    for i in range(n):
                        r = ind_to_rk(i, k)
                        cur[i + 1] = cur[max(i - k + 1, 0)] + nums[i] * r
                        pre[i + 1] = pre[max(i - k + 1, 0)] + nums[i]
                    for x in ind[k]:
                        s, k, c = queries[x]
                        s -= 1
                        e = s + (c - 1) * k
                        length = c * k
                        res = cur[e + 1] - cur[max(e + 1 - length, 0)]
                        res -= (s // k) * (pre[e + 1] - pre[max(e + 1 - length, 0)])
                        ans[x] = res
                    del cur

            for i in range(q):
                s, k, c = queries[i]
                if k > size:
                    s -= 1
                    res = 0
                    for x in range(s, s + k * c - 1, k):
                        res += nums[x] * (((x + 1) - s) // k + 1)
                    ans[i] = res
            ac.lst(ans)
        return

    @staticmethod
    def cf_425d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/425/D
        tag: sqrt_decomposition
        """
        n = ac.read_int()
        dct = dict()
        for _ in range(n):
            a, b = ac.read_list_ints()
            if a not in dct:
                dct[a] = set()
            dct[a].add(b)

        ans = 0
        size = int(n ** 0.5) + 1
        res = []
        for a in sorted(dct):
            if len(dct[a]) <= size:
                lst = sorted(list(dct[a]))
                m = len(lst)
                for i in range(m):
                    x = lst[i]
                    for j in range(i + 1, m):
                        y = lst[j]
                        length = y - x
                        for z in [a - length, a + length]:
                            if z in dct and len(dct[z]) > size:
                                if x in dct[z] and y in dct[z]:
                                    ans += 1
                        z = a + length
                        if z in dct and len(dct[z]) <= size and x in dct[z] and y in dct[z]:
                            ans += 1

            else:
                res.append(a)
        m = len(res)
        for i in range(m):
            x = res[i]
            for j in range(i + 1, m):
                y = res[j]
                length = y - x
                for z in sorted(dct[x]):
                    if z + length in dct[x] and z + length in dct[y] and z in dct[y]:
                        ans += 1
        ac.st(ans)
        return

    @staticmethod
    def cf_677d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/677/problem/D
        tag: sqrt_decomposition
        """
        m, n, p = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        dct = [[] for _ in range(p + 1)]
        for i in range(m):
            for j in range(n):
                dct[grid[i][j]].append(i * n + j)
        pre = defaultdict(lambda: math.inf)
        for x in dct[1]:
            i, j = x // n, x % n
            if i == j == 0:
                pre[x] = 0
            else:
                pre[x] = i + j
        dis = [m * n + 1] * n * m
        for y in range(2, p + 1):
            m1 = len(dct[y - 1])
            m2 = len(dct[y])
            if m1 * m2 < m * n:
                cur = defaultdict(lambda: math.inf)
                for x in pre:
                    i1, j1 = x // n, x % n
                    for yy in dct[y]:
                        i2, j2 = yy // n, yy % n
                        cur[yy] = min(cur[yy], pre[x] + abs(i2 - i1) + abs(j2 - j1))
            else:
                for i in range(m * n):
                    dis[i] = m * n + 1
                nodes = [[] for _ in range(m * n + 1)]
                for x in pre:
                    nodes[pre[x]].append(x)
                    dis[x] = pre[x]

                for d in range(m * n + 1):
                    for x in nodes[d]:
                        i, j = x // n, x % n
                        if dis[x] < d:
                            continue
                        for a, b in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                            if 0 <= a < m and 0 <= b < n and dis[a * n + b] > d + 1:
                                dis[a * n + b] = d + 1
                                nodes[d + 1].append(a * n + b)
                cur = defaultdict(lambda: math.inf)
                for x in dct[y]:
                    cur[x] = dis[x]
            pre = cur
        ac.st(min(pre.values()))
        return

    @staticmethod
    def cf_797e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/797/E
        tag: sqrt_decomposition
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        q = ac.read_int()
        queries = [ac.read_list_ints() for _ in range(q)]
        dct = [[] for _ in range(n + 1)]
        ans = [0] * q
        for i in range(q):
            _, k = queries[i]
            dct[k].append(i)
        size = int(n ** 0.5) + 1
        for k in range(1, n + 1):
            if k <= size:
                dp = [0] * (n + 1)
                for i in range(n - 1, -1, -1):
                    dp[i] = dp[min(n, i + nums[i] + k)] + 1
                for i in dct[k]:
                    ans[i] = dp[queries[i][0] - 1]
            else:
                break
        for i in range(q):
            if ans[i] == 0:
                p, k = queries[i]
                p -= 1
                res = 0
                while p < n:
                    res += 1
                    p += nums[p] + k
                ans[i] = res
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_1207f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1207/F
        tag: sqrt_decomposition
        """
        n = 5 * 10 ** 5
        q = ac.read_int()
        nums = [0] * n
        size = 400
        pre = [0] * (size + 1) * (size + 1)
        for _ in range(q):
            op, x, y = ac.read_list_ints()
            if op == 2:
                if x <= size:
                    ac.st(pre[x * (size + 1) + y])
                else:
                    w = y if y else x
                    ans = 0
                    while w <= n:
                        ans += nums[w - 1]
                        w += x
                    ac.st(ans)
            else:
                nums[x - 1] += y
                for p in range(1, size + 1):
                    pre[p * (size + 1) + x % p] += y
        return

    @staticmethod
    def cf_1468m(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1468/M
        tag: sqrt_decomposition
        """
        for _ in range(ac.read_int()):  # TLE

            def check():
                nums = [ac.read_list_ints() for _ in range(ac.read_int())]
                nodes = []
                for ls in nums:
                    nodes.extend(ls[1:])
                n = sum(ls[0] for ls in nums)
                size = int(n ** 0.5) + 1
                nodes = sorted(set(nodes))
                ind = {num: i for i, num in enumerate(nodes)}
                nums = [[ind[x] for x in ls[1:]] for ls in nums]
                length = len(nums)
                res = []
                dct = dict()
                for i in range(length):
                    if len(nums[i]) > size:
                        res.append(i)
                    lst = sorted(nums[i])
                    m = len(lst)
                    for j in range(m):
                        for k in range(j + 1, m):
                            x, y = lst[j], lst[k]
                            if x * n + y in dct:
                                ac.lst([dct[x * n + y] + 1, i + 1])
                                return
                            dct[x * n + y] = i
                m = len(res)
                for i in range(m):
                    x = res[i]
                    pre = set(nums[x])
                    for j in range(i + 1, m):
                        y = res[j]
                        cnt = 0
                        for num in nums[y]:
                            if num in pre:
                                cnt += 1
                        if cnt >= 2:
                            ac.lst([x + 1, y + 1])
                            return

                ac.st(-1)
                return

            check()

        return

    @staticmethod
    def lc_1157():
        """
        url: https://leetcode.cn/problems/online-majority-element-in-subarray
        tag: range_super_mode|point_set
        """

        class MajorityChecker:

            def __init__(self, arr: List[int]):
                self.ds = PointSetMergeRangeMode(arr)
                self.ds = PointSetBitRangeMode(arr, 20)
                self.ds = PointSetRandomRangeMode(arr)

            def query(self, left: int, right: int, threshold: int) -> int:
                return self.ds.range_mode(left, right, threshold - 1)

        return MajorityChecker

    @staticmethod
    def lg_p3567_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3567
        tag: range_super_mode|sqrt_decomposition
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        size = int(n ** 0.5) + 1
        queries = [[] for _ in range(size)]
        for i in range(m):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append(a * m * n + b * m + i)

        def update(num, p):
            freq[cnt[num]].discard(num)
            cnt[num] += p
            freq[cnt[num]].add(num)
            if p == 1:
                if ceil[0] < cnt[num]:
                    ceil[0] = cnt[num]
            else:
                if ceil[0] == cnt[num] + 1 and not freq[cnt[num] + 1]:
                    ceil[0] -= 1
            return

        cnt = defaultdict(int)
        freq = defaultdict(set)
        freq[0] = set(nums)
        x = y = 0
        ans = [0] * m
        ceil = [0]
        update(nums[0], 1)
        for i in range(size):
            if i % 2:
                queries[i].sort(reverse=True)
            else:
                queries[i].sort()
            for val in queries[i]:
                a, b, j = val // m // n, (val // m) % n, val % m
                while y > b:
                    update(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    update(nums[y], 1)
                while x > a:
                    x -= 1
                    update(nums[x], 1)
                while x < a:
                    update(nums[x], -1)
                    x += 1

                if ceil[0] > (b - a + 1) / 2:
                    ans[j] = next(iter(freq[ceil[0]]))
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p3567_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3567
        tag: range_super_mode
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        ds = PointSetBitRangeMode(nums, 20)
        ds = PointSetRandomRangeMode(nums)
        ds = PointSetMergeRangeMode(nums)
        for _ in range(m):
            ll, rr = ac.read_list_ints_minus_one()
            ans = ds.range_mode(ll, rr)
            ac.st(ans if ans > -1 else 0)
        return

    @staticmethod
    def lg_p3765(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3765
        tag: range_super_mode
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        ds = PointSetBitRangeMode(nums, 20)
        ds = PointSetRandomRangeMode(nums)
        ds = PointSetMergeRangeMode(nums)
        for _ in range(m):
            lst = ac.read_list_ints()
            ll, rr = lst[0] - 1, lst[1] - 1
            winner = ds.range_mode(ll, rr)
            if winner == -1:
                winner = lst[2]
            ac.st(winner)
            for x in lst[4:]:
                ds.point_set(x - 1, winner)
        ac.st(ds.range_mode(0, n - 1))
        return

    @staticmethod
    def abc_335f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc335/tasks/abc335_f
        tag: sqrt_decomposition|linear_dp|refresh_table|fill_table|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        size = int((2 * 10 ** 5) ** 0.5)
        dp = [0] * n
        dp[0] = 1
        mod = 998244353
        pre = [0] * size * (size + 1)
        for i in range(n):
            a = nums[i]
            for x in range(1, size + 1):
                dp[i] += pre[x * size + i % x]
                dp[i] %= mod
            if a > size:
                for j in range(i + a, n, a):
                    dp[j] += dp[i]
                    dp[j] %= mod
            else:
                pre[a * size + i % a] += dp[i]
                pre[a * size + i % a] %= mod
        ac.st(sum(dp) % mod)
        return

    @staticmethod
    def abc_293g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc293/tasks/abc293_g
        tag: sqrt_decomposition|brain_teaser|classical
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()

        m = 2 * 10 ** 5
        cnt = [0] * (m + 1)
        size = int(m ** 0.5) + 1
        queries = [[] for _ in range(size)]
        for i in range(q):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append([a, b, i])

        def compute(xx):
            return xx * (xx - 1) * (xx - 2) // 6

        def add(num, xx):
            if cnt[num] >= 3:
                cur[0] -= compute(cnt[num])
            cnt[num] += xx
            if cnt[num] >= 3:
                cur[0] += compute(cnt[num])
            return

        ans = [0] * q
        x = y = 0
        cnt[nums[0]] = 1
        cur = [0]
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                while y > b:
                    add(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    add(nums[y], 1)
                while x > a:
                    x -= 1
                    add(nums[x], 1)
                while x < a:
                    add(nums[x], -1)
                    x += 1
                ans[j] = cur[0]
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_242g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc242/tasks/abc242_g
        tag: sqrt_decomposition|classical
        """

        n = ac.read_int()
        nums = ac.read_list_ints()
        cnt = [0] * (n + 1)
        q = ac.read_int()

        size = int(n ** 0.5) + 1
        queries = [[] for _ in range(size)]
        for i in range(q):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append((a, b, i))

        def add(num, xx):
            if cnt[num] >= 2:
                cur[0] -= cnt[num] // 2
            cnt[num] += xx
            if cnt[num] >= 2:
                cur[0] += cnt[num] // 2
            return

        ans = [0] * q
        x = y = 0
        cnt[nums[0]] = 1
        cur = [0]
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                while y > b:
                    add(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    add(nums[y], 1)
                while x > a:
                    x -= 1
                    add(nums[x], 1)
                while x < a:
                    add(nums[x], -1)
                    x += 1
                ans[j] = cur[0]
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_238g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc238/tasks/abc238_g
        tag: sqrt_decomposition|offline_query|classical
        """
        pf = PrimeFactor(10 ** 6 + 10)  # TLE
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        m = 2 * 10 ** 5
        size = int(m ** 0.5) + 1
        queries = [[] for _ in range(size)]
        for i in range(q):
            a, b = ac.read_list_ints_minus_one()
            queries[b // size].append((a, b, i))
        cnt = Counter()
        tot = [0, 0, 0]

        def add(num, xx):
            for p, c in pf.prime_factor[num]:
                tot[cnt[p] % 3] -= 1
            for p, c in pf.prime_factor[num]:
                cnt[p] += c * xx
                tot[cnt[p] % 3] += 1
            return

        ans = [0] * q
        x = y = 0
        for pp, cc in pf.prime_factor[nums[0]]:
            cnt[pp] += cc
            tot[cnt[pp] % 3] += 1
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                while y > b:
                    add(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    add(nums[y], 1)
                while x > a:
                    x -= 1
                    add(nums[x], 1)
                while x < a:
                    add(nums[x], -1)
                    x += 1
                ans[j] = "Yes" if tot[1] == tot[2] == 0 else "No"
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_219g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc219/tasks/abc219_g
        tag: sqrt_decomposition|classical
        """
        n, m, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += 1
            degree[j] += 1
        k = int(n ** 0.5) + 1
        heavy = [[x for x in ls if degree[x] >= k] for ls in dct]
        cur_color = list(range(n))
        cur_tm = [-1] * n

        out_color = [0] * n
        out_tm = [-1] * n

        queries = ac.read_list_ints_minus_one()
        for i in range(q):
            x = queries[i]
            c, t = cur_color[x], cur_tm[x]
            for y in heavy[x]:
                if out_tm[y] > t:
                    t = out_tm[y]
                    c = out_color[y]
            cur_color[x] = c
            cur_tm[x] = i
            if degree[x] < k:
                for y in dct[x]:
                    cur_color[y] = c
                    cur_tm[y] = i
            else:
                out_color[x] = c
                out_tm[x] = i
        for x in range(n):
            c, t = cur_color[x], cur_tm[x]
            for y in heavy[x]:
                if out_tm[y] > t:
                    t = out_tm[y]
                    c = out_color[y]
            cur_color[x] = c
        ac.lst([x + 1 for x in cur_color])
        return

    @staticmethod
    def lc_100404(s: str, k: int, lst: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/
        tag: sqrt_decomposition|inclusion_exclusion|prefix_sum
        """
        s = [int(w) for w in s]
        pre = list(accumulate(s, initial=0))
        n = len(s)
        left = [-1] * n
        right = [-1] * n
        j = 0
        for i in range(n):
            while j + 1 < n and pre[i + 1] - pre[j + 1] > k and (i - j) - (pre[i + 1] - pre[j + 1]) > k:
                j += 1
            if pre[i + 1] - pre[j] > k and (i - j + 1) - (pre[i + 1] - pre[j]) > k:
                left[i] = j

        j = n - 1
        for i in range(n - 1, -1, -1):
            while j - 1 >= 0 and pre[j] - pre[i] > k and (j - i) - (pre[j] - pre[i]) > k:
                j -= 1
            if pre[j + 1] - pre[i] > k and (j + 1 - i) - (pre[j + 1] - pre[i]) > k:
                right[i] = j

        size = int(n ** 0.5) + 500

        queries = [[] for _ in range(size)]
        m = len(lst)
        for i in range(m):
            a, b = lst[i]
            queries[b // size].append([a, b, i])

        def check_right(ll, rr):
            if left[rr] >= ll:
                return left[rr] - ll + 1
            return 0

        def check_left(ll, rr):
            if -1 < right[ll] <= rr:
                return rr - right[ll] + 1
            return 0

        ans = [0] * m
        x = y = 0
        cnt = 0
        for i in range(size):
            if i % 2:
                queries[i].sort(key=lambda it: -it[0])
            else:
                queries[i].sort(key=lambda it: it[0])
            for a, b, j in queries[i]:
                while y > b:
                    cnt -= check_right(x, y)
                    y -= 1
                while y < b:
                    y += 1
                    cnt += check_right(x, y)
                while x > a:
                    x -= 1
                    cnt += check_left(x, y)
                while x < a:
                    cnt -= check_left(x, y)
                    x += 1
                ans[j] = (b - a + 1) * (b - a + 1 + 1) // 2 - cnt
        return ans

    @staticmethod
    def cf_342e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/342/problem/E
        tag: block_size|sqt_decomposition|tree_lca|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        tree = TreeAncestor(dct)
        dis = tree.depth[:]
        block_size = 100
        lst = []
        for i in range(m):
            op, x = ac.read_list_ints_minus_one()
            if op == 0:
                lst.append(x)
                if len(lst) >= block_size:
                    for y in lst:
                        dis[y] = 0
                    while lst:
                        nex = []
                        for x in lst:
                            for y in dct[x]:
                                if dis[y] > dis[x] + 1:
                                    dis[y] = dis[x] + 1
                                    nex.append(y)
                        lst = nex
            else:
                ans = dis[x]
                for y in lst:
                    ans = min(ans, tree.get_dist(y, x))
                ac.st(ans)
        return

    @staticmethod
    def cf_375d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/375/problem/D
        tag: dfs_order|tree_sqrt_decomposition|classical
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints_minus_one()
        ceil = 10 ** 5 + 1
        cnt = [0] * ceil
        graph = UnWeightedTree(n)
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j)
        graph.dfs_order()

        size = 200
        block = n // size + 1
        queries = [[] for _ in range(block)]
        right = [-1] * q
        target = [-1] * q
        ans = [-1] * q
        for i in range(q):
            v, k = ac.read_list_ints_minus_one()
            target[i] = k + 1
            right[i] = graph.end[v]
            queries[graph.end[v] // size].append(graph.start[v] * q + i)

        def add(num, xx):
            if cnt[num] > 0:
                tree.point_add(ceil - 1 - cnt[num], -1)
            cnt[num] += xx
            if cnt[num] > 0:
                tree.point_add(ceil - 1 - cnt[num], 1)
            return

        tree = PointAddRangeSum(ceil)
        x = y = 0
        nums = [nums[x] for x in graph.order_to_node]
        cnt[nums[0]] = 1
        tree.point_add(ceil - 2, 1)
        for i in range(block):
            if i % 2:
                queries[i].sort(reverse=True)
            else:
                queries[i].sort()
            for val in queries[i]:
                a, j = val // q, val % q
                b = right[j]
                k = target[j]
                while y > b:
                    add(nums[y], -1)
                    y -= 1
                while y < b:
                    y += 1
                    add(nums[y], 1)
                while x > a:
                    x -= 1
                    add(nums[x], 1)
                while x < a:
                    add(nums[x], -1)
                    x += 1
                ans[j] = tree.range_sum(0, ceil - 1 - k)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_786c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/786/problem/C
        tag: sqrt_decomposition|binary_search
        """

        def check(x):
            tm[0] += 1
            if ans[x - 1]:
                return ans[x - 1]
            res = cnt = 0
            for num in nums:
                if not (cnt < x or visit[num - 1] == tm[0]):
                    res += 1
                    tm[0] += 1
                    visit[num - 1] = tm[0]
                    cnt = 1
                else:
                    if visit[num - 1] != tm[0]:
                        cnt += 1
                        visit[num - 1] = tm[0]
            return res + 1

        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = [0] * n  # TLE
        tm = [0] # trick
        visit = [0] * n
        l = min(2 * round(n ** 0.5), n - 1)
        for i in range(l):
            ans[i] = check(i + 1)
        stack = [l * n + n - 1]
        while stack:
            val = stack.pop()
            i, j = val // n, val % n
            if i > j:
                continue
            if not ans[i]:
                ans[i] = check(i + 1)
            if not ans[j]:
                ans[j] = check(j + 1)
            if ans[i] == ans[j]:
                for k in range(i + 1, j):
                    ans[k] = ans[i]
                continue
            else:
                mid = i + (j - i) // 2
                stack.append(i * n + mid)
                stack.append((mid + 1) * n + j)
        ac.lst(ans)
        return

    @staticmethod
    def cf_13e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/13/problem/E
        tag: sqrt_decomposition|classical
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        size = int(n ** 0.5) + 1
        post = [0] * n
        cost = [0] * n
        for j in range(0, n, size):
            right = min(j + size, n) - 1
            for i in range(right, j - 1, -1):
                if i + nums[i] > right:
                    cost[i] = 1
                    post[i] = i + nums[i]
                else:
                    cost[i] = 1 + cost[i + nums[i]]
                    post[i] = post[i + nums[i]]

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 0:
                j, b = lst[1] - 1, lst[2]
                nums[j] = b
                right = min(n - 1, j + (size - 1 - (j % size)))
                left = (j // size) * size
                for i in range(j, left - 1, -1):
                    if i + nums[i] > right:
                        cost[i] = 1
                        post[i] = i + nums[i]
                    else:
                        cost[i] = 1 + cost[i + nums[i]]
                        post[i] = post[i + nums[i]]
            else:
                j = lst[1] - 1
                ans = 0
                while post[j] < n:
                    ans += cost[j]
                    j = post[j]
                ans += cost[j]
                while j + nums[j] < n:
                    j += nums[j]
                ac.lst([j + 1, ans])
        return

    @staticmethod
    def lg_p3203(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3203
        tag: sqrt_decomposition|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        size = int(n ** 0.5) + 1
        post = [0] * n
        cost = [0] * n
        for j in range(0, n, size):
            right = min(j + size, n) - 1
            for i in range(right, j - 1, -1):
                if i + nums[i] > right:
                    cost[i] = 1
                    post[i] = i + nums[i]
                else:
                    cost[i] = 1 + cost[i + nums[i]]
                    post[i] = post[i + nums[i]]
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 2:
                j, b = lst[1], lst[2]
                nums[j] = b
                right = min(n - 1, j + (size - 1 - (j % size)))
                left = (j // size) * size
                for i in range(j, left - 1, -1):
                    if i + nums[i] > right:
                        cost[i] = 1
                        post[i] = i + nums[i]
                    else:
                        cost[i] = 1 + cost[i + nums[i]]
                        post[i] = post[i + nums[i]]
            else:
                j = lst[1]
                ans = 0
                while j < n:
                    ans += cost[j]
                    j = post[j]
                ac.st(ans)
        return
"""
Algorithm：tree_array|tree_matrix
Description：range_add|range_sum

====================================LeetCode====================================
307（https://leetcode.cn/problems/range-sum-query-mutable）PointChangeRangeSum
1409（https://leetcode.cn/problems/queries-on-a-permutation-with-key/）tree_array|implemention
1626（https://leetcode.cn/problems/best-team-with-no-conflicts/）tree_array|prefix_maximum|dp
2617（https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/）tree_array|prefix_minimum
308（https://leetcode.cn/problems/range-sum-query-2d-mutable/）tree_matrix|RangeAddRangeSum
2659（https://leetcode.cn/problems/make-array-empty/submissions/）implemention|tree_array|sortedList|greedy
1505（https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/）tree_array|implemention|counter|sorted_list
2193（https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/description/）tree_array|greedy|implemention|P5041
2407（https://leetcode.cn/problems/longest-increasing-subsequence-ii/description/）tree_array|liner_dp
2926（https://leetcode.cn/problems/maximum-balanced-subsequence-sum/）discretization|tree_array|liner_dp
2736（https://leetcode.cn/problems/maximum-sum-queries/）PointAddPreMax
2916（https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/）range_add|range_sum|contribution_method|linear_dp
100317（https://leetcode.cn/problems/peaks-in-array/）tree_array|implemention

=====================================LuoGu======================================
P2068（https://www.luogu.com.cn/problem/P2068）PointAddRangeSum
P2345（https://www.luogu.com.cn/problem/P2345）tree_array|counter|range_sum
P2357（https://www.luogu.com.cn/problem/P2357）tree_array|range_sum
P2781（https://www.luogu.com.cn/problem/P2781）tree_array|range_sum
P5200（https://www.luogu.com.cn/problem/P5200）tree_array|greedy|implemention
P3374（https://www.luogu.com.cn/problem/P3374）tree_array|RangeAddRangeSum
P3368（https://www.luogu.com.cn/problem/P3368）tree_array|RangeAddRangeSum
P5094（https://www.luogu.com.cn/problem/P5094）tree_array|RangeAddRangeSum
P1816（https://www.luogu.com.cn/problem/P1816）tree_array|range_min
P1725（https://www.luogu.com.cn/problem/P1725）reverse_order|liner_dp|PointAscendRangeMax
P3586（https://www.luogu.com.cn/problem/P3586）offline_query|discretization|tree_array|PointAddPreSum
P1198（https://www.luogu.com.cn/problem/P1198）tree_array|range_max
P4868（https://www.luogu.com.cn/problem/P4868）math|tree_array|prefix_sum_of_prefix_sum
P5463（https://www.luogu.com.cn/problem/P5463）tree_array|counter|brute_force|contribution_method
P6225（https://www.luogu.com.cn/problem/P6225）tree_array|prefix_xor
P1972（https://www.luogu.com.cn/problem/P1972）tree_array|offline_query|range_unique|PointChangeRangeSum
P5041（https://www.luogu.com.cn/problem/P5041）tree_array|implemention|classical

====================================AtCoder=====================================
ABC103D（https://atcoder.jp/contests/abc103/tasks/abc103_d）greedy|tree_array
ABC127F（https://atcoder.jp/contests/abc127/tasks/abc127_f）discretization|tree_array|counter
ABC287G（https://atcoder.jp/contests/abc287/tasks/abc287_g）segment_tree|range_sum|dynamic|offline|tree_array|bisect_right
ABC306F（https://atcoder.jp/contests/abc306/tasks/abc306_f）tree_array|contribution_method|classical
ABC286F（https://atcoder.jp/contests/abc283/tasks/abc283_f）point_descend|pre_min|tree_array|classical
ABC276F（https://atcoder.jp/contests/abc276/tasks/abc276_f）expectation|comb|tree_array|contribution_method|classical
ABC256F（https://atcoder.jp/contests/abc256/tasks/abc256_f）tree_array|cumulative_cumulative_cumulative_sum|math|classical
ABC250E（https://atcoder.jp/contests/abc250/tasks/abc250_e）tree_array|point_ascend|pre_max|implemention|set|classical
ABC231F（https://atcoder.jp/contests/abc231/tasks/abc231_f）discretize|tree_array|inclusion_exclusion|two_pointers
ABC351F（https://atcoder.jp/contests/abc351/tasks/abc351_f）tree_array|discretize|classical
ABC221E（https://atcoder.jp/contests/abc221/tasks/abc221_e）tree_array|contribution_method
ABC353G（https://atcoder.jp/contests/abc353/tasks/abc353_g）point_ascend|range_max|pre_max|classical
ABC356F（https://atcoder.jp/contests/abc356/tasks/abc356_f）tree_array|binary_search|bisect_right|classical
ABC368G（https://atcoder.jp/contests/abc368/tasks/abc368_g）point_add|range_sum|observation|data_range
ABC369F（https://atcoder.jp/contests/abc369/tasks/abc369_f）tree_array|point_ascend|pre_max_index|construction|specific_plan

===================================CodeForces===================================
1791F（https://codeforces.com/problemset/problem/1791/F）tree_array|data_range|union_find_right|limited_operation
1676H2（https://codeforces.com/contest/1676/problem/H2）tree_array|pre_sum
987C（https://codeforces.com/problemset/problem/987/C）brute_force|tree_array|prefix_suffix|pre_min
1311F（https://codeforces.com/contest/1311/problem/F）discretization|tree_array|counter
1860C（https://codeforces.com/contest/1860/problem/C）PointDescendRangeMin
1550C（https://codeforces.com/contest/1550/problem/C）PointAscendPreMax
1679C（https://codeforces.com/contest/1679/problem/C）PointAddRangeSum
1722E（https://codeforces.com/problemset/problem/1722/E）data_range|matrix_prefix_sum|classical|can_be_discretization_hard_version|tree_array_2d
1430E（https://codeforces.com/problemset/problem/1430/E）tree_array|classical|implemention|point_add|range_sum|pre_sum
1788E（https://codeforces.com/problemset/problem/1788/E）linear_dp|tree_array|point_ascend|pre_max
677D（https://codeforces.com/problemset/problem/677/D）layered_bfs|tree_array|two_pointers|partial_order|implemention|classical
1667B（https://codeforces.com/problemset/problem/1667/B）tree_array|classical|prefix_sum
597C（https://codeforces.com/problemset/problem/597/C）point_add|range_sum|bag_dp|classical

=====================================LibraryChecker=====================================
1（https://judge.yosupo.jp/problem/vertex_add_subtree_sum）tree_array|dfs_order
135. tree_matrix|3（https://loj.ac/p/135）range_change|range_sum
134. tree_matrix|2（https://loj.ac/p/134）range_change|range_sum
4（https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/A）tree_array|point_set|range_sum|inversion

"""
from collections import defaultdict, deque
from typing import List

from src.data_structure.segment_tree.template import RangeAscendRangeMax
from src.data_structure.sorted_list.template import SortedList
from src.data_structure.tree_array.template import PointAddRangeSum, PointDescendPreMin, RangeAddRangeSum, \
    PointAscendPreMax, PointAscendRangeMax, PointAddRangeSum2D, RangeAddRangeSum2D, PointXorRangeXor, \
    PointDescendRangeMin, PointChangeRangeSum, PointDescendPostMin, PointAscendPreMaxIndex
from src.mathmatics.comb_perm.template import Combinatorics
from src.search.dfs.template import DfsEulerOrder
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1626(scores: List[int], ages: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/best-team-with-no-conflicts/
        tag: tree_array|prefix_maximum|dp
        """
        n = max(ages)
        tree_array = PointAscendPreMax(n)
        for score, age in sorted(zip(scores, ages)):
            cur = tree_array.pre_max(age) + score
            tree_array.point_ascend(age, cur)
        return tree_array.pre_max(n)

    @staticmethod
    def lc_2193_1(s: str) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/description/
        tag: tree_array|greedy|implemention|P5041
        """
        n = len(s)
        lst = list(s)
        ans = 0
        dct = defaultdict(deque)
        for i in range(n):
            dct[lst[i]].append(i)
        tree = PointAddRangeSum(n)
        i, j = 0, n - 1
        while i < j:
            if lst[i] == "":
                i += 1
                continue
            if lst[j] == "":
                j -= 1
                continue
            if lst[i] == lst[j]:
                dct[lst[i]].popleft()
                dct[lst[j]].pop()
                i += 1
                j -= 1
                continue

            if len(dct[lst[j]]) >= 2:
                left = dct[lst[j]][0]
                ans += left - i - tree.range_sum(i + 1, left + 1)
                x = dct[lst[j]].popleft()
                dct[lst[j]].pop()
                lst[x] = ""
                tree.point_add(x + 1, 1)
                j -= 1
            else:
                right = dct[lst[i]][-1]
                ans += j - right - tree.range_sum(right + 1, j + 1)
                x = dct[lst[i]].pop()
                dct[lst[i]].popleft()
                tree.point_add(x + 1, 1)
                lst[x] = ""
                i += 1
        return ans

    @staticmethod
    def lc_2193_2(s: str) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-moves-to-make-palindrome/description/
        tag: tree_array|greedy|implemention|P5041
        """
        n = len(s)
        ans = 0
        for _ in range(n // 2):
            j = s.rindex(s[0])
            if j == 0:
                i = s.index(s[-1])
                ans += i
                s = s[:i] + s[i + 1:-1]
            else:
                ans += len(s) - 1 - j
                s = s[1:j] + s[j + 1:]

        return ans

    @staticmethod
    def lc_2407(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/longest-increasing-subsequence-ii/description/
        tag: tree_array|liner_dp
        """
        n = max(nums)
        ans = 0
        tree = PointAscendRangeMax(n)
        tree.ceil = [0] * (n + 1)
        tree.floor = [0] * (n + 1)
        for num in nums:
            low = num - k
            high = num - 1
            if low < 1:
                low = 1
            if low <= high:
                cur = tree.range_max(low, high)
                cur += 1
            else:
                cur = 1
            if cur > ans:
                ans = cur
            tree.point_ascend(num, cur)
        return ans

    @staticmethod
    def lc_2659(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/make-array-empty/submissions/
        tag: implemention|tree_array|sortedList|greedy
        """
        n = len(nums)
        ans = 0
        pre = 1
        dct = {num: i + 1 for i, num in enumerate(nums)}
        tree = PointAddRangeSum(n)
        for num in sorted(nums):
            i = dct[num]
            if pre <= i:
                ans += i - pre + 1 - tree.range_sum(pre, i)
            else:
                ans += n - pre + 1 - tree.range_sum(pre, n) + i - 1 + 1 - tree.range_sum(1, i)
            tree.point_add(i, 1)
            pre = i
        return ans

    @staticmethod
    def lc_2736(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-sum-queries/
        tag: PointAddPreMax
        """
        nodes = set(nums1 + nums2)
        for x, y in queries:
            nodes.add(x)
            nodes.add(y)
        nodes = sorted(nodes)
        dct = {num: i for i, num in enumerate(nodes)}
        k = len(nodes)
        n = len(nums1)
        m = len(queries)
        ans = [-1] * m
        ind = list(range(m))
        ind.sort(key=lambda it: queries[it][0], reverse=True)
        index = list(range(n))
        index.sort(key=lambda it: nums1[it], reverse=True)
        i = 0
        tree = PointAscendPreMax(k, -1)
        for j in ind:
            x, y = queries[j]
            while i < n and nums1[index[i]] >= x:
                value = nums1[index[i]] + nums2[index[i]]
                tree.point_ascend(k - dct[nums2[index[i]]], value)
                i += 1
            ans[j] = tree.pre_max(k - dct[y])
        return ans

    @staticmethod
    def lc_2617(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/
        tag: tree_array|prefix_minimum
        """
        n, m = len(grid), len(grid[0])
        dp = [[math.inf] * m for _ in range(n)]
        r, c = [PointDescendPreMin(m) for _ in range(n)], [PointDescendPreMin(n) for _ in range(m)]
        dp[n - 1][m - 1] = 1
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                if grid[i][j] > 0:
                    dp[i][j] = min(r[i].pre_min(min(j + grid[i][j] + 1, m)),
                                   c[j].pre_min(min(i + grid[i][j] + 1, n))) + 1
                if dp[i][j] <= n * m:
                    r[i].point_descend(j + 1, dp[i][j])
                    c[j].point_descend(i + 1, dp[i][j])
        return -1 if dp[0][0] > n * m else dp[0][0]

    @staticmethod
    def lc_2926_1(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-balanced-subsequence-sum/
        tag: discretization|tree_array|liner_dp
        """
        n = len(nums)
        tmp = [nums[i] - i for i in range(n)]
        ind = sorted(list(set(tmp)))
        dct = {x: i for i, x in enumerate(ind)}
        tree = PointAscendRangeMax(n, -math.inf)
        for j in range(n):
            num = nums[j]
            i = dct[num - j]
            pre = tree.range_max(1, i + 1) if i + 1 >= 1 else 0
            pre = 0 if pre < 0 else pre
            tree.point_ascend(i + 1, pre + num)
        return tree.range_max(1, n)

    @staticmethod
    def lc_2926_2(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-balanced-subsequence-sum/
        tag: discretization|tree_array|liner_dp
        """
        n = len(nums)
        tmp = [nums[i] - i for i in range(n)]
        ind = sorted(list(set(tmp)))
        dct = {x: i for i, x in enumerate(ind)}
        tree = PointAscendPreMax(n)
        for j in range(n):
            num = nums[j]
            i = dct[num - j]
            pre = tree.pre_max(i + 1)
            pre = 0 if pre < 0 else pre
            tree.point_ascend(i + 1, pre + num)
        return tree.pre_max(n)

    @staticmethod
    def lc_2926_3(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-balanced-subsequence-sum/
        tag: discretization|tree_array|liner_dp
        """
        n = len(nums)
        tmp = [nums[i] - i for i in range(n)]
        ind = sorted(list(set(tmp)))
        dct = {x: i for i, x in enumerate(ind)}
        tree = RangeAscendRangeMax(n)
        for j in range(n):
            num = nums[j]
            i = dct[num - j]
            pre = tree.range_max(0, i)
            pre = 0 if pre < 0 else pre
            tree.range_ascend(i, i, pre + num)
        ans = tree.range_max(0, n - 1)
        return ans

    @staticmethod
    def library_checker_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/vertex_add_subtree_sum
        tag: tree_array|dfs_order|classical|hard
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        p = ac.read_list_ints()
        for i in range(n - 1):
            dct[p[i]].append(i + 1)
        dfs_euler = DfsEulerOrder(dct)
        tree = PointAddRangeSum(n)
        tree.build([nums[i] for i in dfs_euler.order_to_node])
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0]:
                u = lst[1]
                x, y = dfs_euler.start[u], dfs_euler.end[u]
                ac.st(tree.range_sum(x + 1, y + 1))
            else:
                u, x = lst[1:]
                ind = dfs_euler.start[u]
                tree.point_add(ind + 1, x)
        return

    @staticmethod
    def lg_p5094(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5094
        tag: tree_array|RangeAddRangeSum
        """
        n = ac.read_int()
        m = 5 * 10 ** 4
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda y: y[0])
        tree_sum = PointAddRangeSum(m)
        tree_cnt = PointAddRangeSum(m)
        total_cnt = 0
        total_sum = 0
        ans = 0
        for v, x in nums:
            pre_sum = tree_sum.range_sum(1, x)
            pre_cnt = tree_cnt.range_sum(1, x)
            ans += v * (pre_cnt * x - pre_sum) + v * (total_sum - pre_sum - (total_cnt - pre_cnt) * x)
            tree_sum.point_add(x, x)
            tree_cnt.point_add(x, 1)
            total_cnt += 1
            total_sum += x
        ac.st(ans)
        return

    @staticmethod
    def lg_xxxx(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/xxxx
        tag:
        """
        n, q = ac.read_list_ints()
        tree = PointAscendRangeMax(n)
        tree2 = PointDescendRangeMin(n)
        for i in range(n):
            tree.a[i + 1] = ac.read_int()
            tree.point_ascend(i + 1, tree.a[i + 1])
            tree2.a[i + 1] = ac.read_int()
            tree2.point_descend(i + 1, tree.a[i + 1])
        for _ in range(q):
            a, b = ac.read_list_ints()
            ac.st(tree.range_max(a, b) - tree2.range_min(a, b))
        return

    @staticmethod
    def cf_1311f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1311/problem/F
        tag: discretization|tree_array|counter
        """
        n = ac.read_int()
        ind = list(range(n))
        x = ac.read_list_ints()
        ind.sort(key=lambda it: x[it])
        v = ac.read_list_ints()
        dct = {w: i for i, w in enumerate(sorted(set(v)))}
        m = len(dct)
        tree_cnt = PointAddRangeSum(m)
        tree_tot = PointAddRangeSum(m)
        ans = 0
        for i in ind:
            cur_v = v[i]
            tree_cnt.point_add(dct[cur_v] + 1, 1)
            tree_tot.point_add(dct[cur_v] + 1, x[i])
            pre_cnt = tree_cnt.range_sum(1, dct[cur_v] + 1)
            pre_tot = tree_tot.range_sum(1, dct[cur_v] + 1)
            ans += pre_cnt * x[i] - pre_tot
        ac.st(ans)
        return

    @staticmethod
    def cf_1676h2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1676/problem/H2
        tag: tree_array|pre_sum
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            a = ac.read_list_ints()
            ceil = max(a)
            ans = 0
            tree = PointAddRangeSum(ceil)
            x = 0
            for num in a:
                ans += x - tree.range_sum(1, num - 1)
                tree.point_add(num, 1)
                x += 1
            ac.st(ans)
        return

    @staticmethod
    def lg_p1972(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1972
        tag: tree_array|offline_query|range_unique|PointChangeRangeSum
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        m = ac.read_int()
        queries = [ac.read_list_ints_minus_one() + [i] for i in range(m)]
        ans = [0] * m
        tree = PointAddRangeSum(n)
        queries.sort(key=lambda it: it[1])
        pre = [-1] * (max(nums) + 1)
        i = 0
        for ll, rr, ii in queries:
            while i <= rr:
                d = nums[i]
                if pre[d] != -1:
                    tree.point_add(pre[d] + 1, -1)
                pre[d] = i
                tree.point_add(i + 1, 1)
                i += 1

            ans[ii] = tree.range_sum(ll + 1, rr + 1)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p2068(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2068
        tag: PointAddRangeSum
        """
        n = ac.read_int()
        w = ac.read_int()
        tree = RangeAddRangeSum(n)
        for _ in range(w):
            lst = ac.read_list_strs()
            a, b = int(lst[1]), int(lst[2])
            if lst[0] == "x":
                tree.range_add(a, a, b)
            else:
                ac.st(tree.range_sum(a, b))
        return

    @staticmethod
    def lg_p1816(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1816
        tag: tree_array|range_min
        """
        m, n = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree = PointDescendRangeMin(m)
        for i in range(m):
            tree.point_descend(i + 1, nums[i])
        ans = []
        for _ in range(n):
            x, y = ac.read_list_ints()
            ans.append(tree.range_min(x, y))
        ac.lst(ans)
        return

    @staticmethod
    def lg_p3374(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3374
        tag: tree_array|RangeAddRangeSum
        """
        n, m = ac.read_list_ints()
        tree = PointAddRangeSum(n)
        tree.build(ac.read_list_ints())
        for _ in range(m):
            op, x, y = ac.read_list_ints()
            if op == 1:
                tree.point_add(x, y)
            else:
                ac.st(tree.range_sum(x, y))
        return

    @staticmethod
    def lg_p3368(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3368
        tag: tree_array|RangeAddRangeSum
        """
        n, m = ac.read_list_ints()
        tree = RangeAddRangeSum(n)
        tree.build(ac.read_list_ints())
        for _ in range(m):
            lst = ac.read_list_ints()
            if len(lst) == 2:
                ac.st(tree.range_sum(lst[1], lst[1]))
            else:
                x, y, k = lst[1:]
                tree.range_add(x, y, k)
        return

    @staticmethod
    def main(ac=FastIO()):
        n, m = ac.read_list_ints()
        tree = RangeAddRangeSum2D(n, m)
        while True:
            lst = ac.read_list_ints()
            if not lst:
                break
            if lst[0] == 1:
                a, b, c, d, x = lst[1:]
                tree.range_add(a, b, c, d, x)
            else:
                a, b, c, d = lst[1:]
                ac.st(tree.range_query(a, b, c, d))
        return

    @staticmethod
    def lg_p1725(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1725
        tag: reverse_order|liner_dp|PointAscendRangeMax
        """
        n, a, b = ac.read_list_ints()
        n += 1
        nums = ac.read_list_ints()
        tree = PointAscendRangeMax(n + 1)
        tree.point_ascend(n + 1, 0)
        post = 0
        for i in range(n - 1, -1, -1):
            x, y = i + a + 1, i + b + 1
            x = n + 1 if x > n + 1 else x
            y = n + 1 if y > n + 1 else y
            post = tree.range_max(x, y)
            tree.point_ascend(i + 1, post + nums[i])
        ac.st(post + nums[0])
        return

    @staticmethod
    def lg_p3586(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3586
        tag: offline_query|discretization|tree_array|PointAddPreSum
        """
        n, m = ac.read_list_ints()
        value = {0}
        lst = []
        for _ in range(m):
            cur = ac.read_list_strs()
            if cur[0] == "U":
                k, a = [int(w) for w in cur[1:]]
                value.add(a)
                lst.append([1, k, a])
            else:
                c, s = [int(w) for w in cur[1:]]
                value.add(s)
                lst.append([2, c, s])
        value = sorted(list(value))
        ind = {num: i for i, num in enumerate(value)}
        length = len(ind)

        tree_cnt = PointAddRangeSum(length)
        tree_sum = PointAddRangeSum(length)
        nums = [0] * n
        total_s = 0
        total_c = 0

        for op, a, b in lst:
            if op == 1:
                if nums[a - 1]:
                    tree_cnt.point_add(ind[nums[a - 1]], -1)
                    tree_sum.point_add(ind[nums[a - 1]], -nums[a - 1])
                    total_s -= nums[a - 1]
                    total_c -= 1
                nums[a - 1] = b
                if nums[a - 1]:
                    tree_cnt.point_add(ind[nums[a - 1]], 1)
                    tree_sum.point_add(ind[nums[a - 1]], nums[a - 1])
                    total_s += nums[a - 1]
                    total_c += 1
            else:
                c, s = a, b
                less_than_s = tree_cnt.range_sum(0, ind[s])
                less_than_s_sum = tree_sum.range_sum(0, ind[s])
                if (total_c - less_than_s) * s + less_than_s_sum >= c * s:
                    ac.st("TAK")
                else:
                    ac.st("NIE")
        return

    @staticmethod
    def lg_p1198(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1198
        tag: tree_array|range_max
        """
        m, d = ac.read_list_ints()
        t = 0
        tree = PointAscendRangeMax(m + 1)
        i = 1
        for _ in range(m):
            op, x = ac.read_list_strs()
            if op == "A":
                x = (int(x) + t) % d
                tree.point_ascend(i, x)
                i += 1
            else:
                x = int(x)
                t = tree.range_max(i - x, i - 1)
                ac.st(t)
        return

    @staticmethod
    def lg_p4868(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4868
        tag: math|tree_array|prefix_sum_of_prefix_sum
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree1 = PointAddRangeSum(n)
        tree1.build(nums)
        tree2 = PointAddRangeSum(n)
        tree2.build([nums[i] * (i + 1) for i in range(n)])
        for _ in range(m):
            lst = ac.read_list_strs()
            if lst[0] == "Modify":
                i, x = [int(w) for w in lst[1:]]
                y = nums[i - 1]
                nums[i - 1] = x
                tree1.point_add(i, x - y)
                tree2.point_add(i, i * (x - y))
            else:
                i = int(lst[1])
                ac.st((i + 1) * tree1.range_sum(1, i) - tree2.range_sum(1, i))
        return

    @staticmethod
    def lg_p5463(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5463
        tag: tree_array|counter|brute_force|contribution_method
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        lst = sorted(list(set(nums)))
        ind = {num: i + 1 for i, num in enumerate(lst)}
        m = len(ind)
        tree = PointAddRangeSum(m)
        ans = 0
        for i in range(n - 1, -1, -1):
            left = i + 1
            right = tree.range_sum(1, ind[nums[i]] - 1)
            ans += left * right
            tree.point_add(ind[nums[i]], n - i)
        ac.st(ans)
        return

    @staticmethod
    def lg_p6225(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6225
        tag: tree_array|prefix_xor
        """
        n, q = ac.read_list_ints()  # TLE
        nums = ac.read_list_ints()

        tree_odd = PointXorRangeXor(n)
        tree_even = PointXorRangeXor(n)
        for i in range(n):
            if i % 2:
                tree_odd.point_xor(i, nums[i])
            else:
                tree_even.point_xor(i, nums[i])

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                i, x = lst[1:]
                i -= 1
                if i % 2:
                    tree_odd.point_xor(i, nums[i] ^ x)
                else:
                    tree_even.point_xor(i, nums[i] ^ x)
                nums[i] = x
            else:
                left, right = lst[1:]
                left -= 1
                right -= 1
                if (right - left + 1) % 2 == 0:
                    ac.st(0)
                else:
                    if left % 2:
                        ac.st(tree_odd.range_xor(left, right))
                    else:
                        ac.st(tree_even.range_xor(left, right))
        return

    @staticmethod
    def abc_127f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc127/tasks/abc127_f
        tag: discretization|tree_array|counter
        """
        queries = [ac.read_list_ints() for _ in range(ac.read_int())]
        nodes = set()
        for lst in queries:
            if len(lst) > 1:
                a, _ = lst[1:]
                nodes.add(a)
        nodes = sorted(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        n = len(ind)
        ans = 0
        tree_sum = PointAddRangeSum(n)
        tree_cnt = PointAddRangeSum(n)
        pre = SortedList()
        for lst in queries:
            if lst[0] == 1:
                a, b = lst[1:]
                ans += b
                tree_sum.point_add(ind[a] + 1, a)
                tree_cnt.point_add(ind[a] + 1, 1)
                pre.add(a)
            else:
                m = len(pre)
                if m % 2 == 0:
                    i = m // 2 - 1
                else:
                    i = m // 2
                val = pre[i]
                i = ind[val]
                left = val * tree_cnt.range_sum(1, i + 1) - tree_sum.range_sum(1, i + 1)
                if i + 2 <= n:
                    right = -val * tree_cnt.range_sum(i + 2, n) + tree_sum.range_sum(i + 2, n)
                else:
                    right = 0
                ac.lst([val, left + right + ans])
        return

    @staticmethod
    def cf_987c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/987/C
        tag: brute_force|tree_array|prefix_suffix|pre_min
        """
        n = ac.read_int()
        s = ac.read_list_ints()
        c = ac.read_list_ints()

        nodes = sorted(list(set(s)) + [0, 10 ** 9 + 1])
        dct = {num: i + 1 for i, num in enumerate(nodes)}
        m = len(nodes)

        pre = [math.inf] * n
        tree = PointDescendPreMin(m)
        for i in range(n):
            pre[i] = tree.pre_min(dct[s[i]] - 1)
            tree.point_descend(dct[s[i]], c[i])

        post = [math.inf] * n
        tree = PointDescendPreMin(m)
        for i in range(n - 1, -1, -1):
            post[i] = tree.pre_min(m - dct[s[i]])
            tree.point_descend(m - dct[s[i]] + 1, c[i])

        ans = math.inf
        if n >= 3:
            ans = min(pre[i] + post[i] + c[i] for i in range(1, n - 1))
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def cf_1679c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1679/problem/C
        tag: PointAddRangeSum
        """
        n, q = ac.read_list_ints()
        row = [0] * n
        col = [0] * n
        row_tree = PointAddRangeSum(n)
        col_tree = PointAddRangeSum(n)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y = [w - 1 for w in lst[1:]]
                row[x] += 1
                col[y] += 1
                if row[x] == 1:
                    row_tree.point_add(x + 1, 1)
                if col[y] == 1:
                    col_tree.point_add(y + 1, 1)
            elif lst[0] == 2:
                x, y = [w - 1 for w in lst[1:]]
                row[x] -= 1
                col[y] -= 1
                if row[x] == 0:
                    row_tree.point_add(x + 1, -1)
                if col[y] == 0:
                    col_tree.point_add(y + 1, -1)
            else:
                x1, y1, x2, y2 = [w - 1 for w in lst[1:]]
                if (row_tree.range_sum(x1 + 1, x2 + 1) == x2 - x1 + 1
                        or col_tree.range_sum(y1 + 1, y2 + 1) == y2 - y1 + 1):
                    ac.yes()
                    continue
                ac.no()
        return

    @staticmethod
    def cf_1860c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1860/problem/C
        tag: PointDescendRangeMin
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints_minus_one()
            tree = PointDescendRangeMin(n, 2)

            for i in range(n):
                x = nums[i]
                if x == 0:
                    cur = 1
                else:
                    low = tree.range_min(1, x)
                    if low == 0:
                        cur = 1
                    elif low == 1:
                        cur = 0
                    else:
                        cur = 1
                tree.point_descend(x + 1, cur)
            ans = [tree.range_min(x, x) for x in range(1, n + 1)]
            ac.st(n - sum(ans))
        return

    @staticmethod
    def lc_1505_1(num: str, k: int) -> str:
        """
        url: https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/
        tag: tree_array|implemention|counter|sorted_list
        """
        n = len(num)
        dct = defaultdict(deque)
        for i, d in enumerate(num):
            dct[d].append(i)
        tree = PointAddRangeSum(n)
        ans = ""
        for i in range(n):
            cur = i
            for d in range(10):
                if dct[str(d)]:
                    i = dct[str(d)][0]
                    ind = i + tree.range_sum(i + 1, n)
                    if ind - cur <= k:
                        ans += str(d)
                        k -= ind - cur
                        tree.point_add(i + 1, 1)
                        dct[str(d)].popleft()
                        break
        return ans

    @staticmethod
    def lc_1505_2(num: str, k: int) -> str:
        """
        url: https://leetcode.cn/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/
        tag: tree_array|implemention|counter|sorted_list
        """
        ind = [deque() for _ in range(10)]
        n = len(num)
        for i in range(n):
            ind[int(num[i])].append(i)

        move = SortedList()
        ans = ""
        for i in range(n):
            for x in range(10):
                if ind[x]:
                    j = ind[x][0]
                    dis = len(move) - move.bisect_right(j)
                    if dis + j - i <= k:
                        move.add(ind[x].popleft())
                        ans += str(x)
                        k -= dis + j - i
                        break
        return ans

    @staticmethod
    def lc_307():
        """
        url: https://leetcode.com/problems/range-sum-query-mutable
        tag: PointChangeRangeSum
        """

        class NumArray:

            def __init__(self, nums: List[int]):
                n = len(nums)
                self.tree = PointChangeRangeSum(n)
                self.tree.build(nums)

            def update(self, index: int, val: int) -> None:
                self.tree.point_change(index + 1, val)

            def sum_range(self, left: int, right: int) -> int:
                return self.tree.range_sum(left + 1, right + 1)

        return NumArray

    @staticmethod
    def lc_308():
        """
        url: https://leetcode.com/problems/range-sum-query-2d-mutable/
        tag: tree_matrix|RangeAddRangeSum
        """

        class NumMatrix:
            def __init__(self, matrix: List[List[int]]):
                m, n = len(matrix), len(matrix[0])
                self.matrix = matrix
                self.tree = PointAddRangeSum2D(m, n)
                for i in range(m):
                    for j in range(n):
                        self.tree.point_add(i + 1, j + 1, matrix[i][j])

            def update(self, row: int, col: int, val: int) -> None:
                self.tree.point_add(row + 1, col + 1, val - self.matrix[row][col])
                self.matrix[row][col] = val

            def sum_region(self, row1: int, col1: int, row2: int, col2: int) -> int:
                return self.tree.range_sum(row1 + 1, col1 + 1, row2 + 1, col2 + 1)

        return NumMatrix

    @staticmethod
    def library_check_4(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/4/3/practice/contest/274545/problem/A
        tag: segment_tree|point_set|range_sum|inversion
        """
        n = ac.read_int()
        tree = PointAddRangeSum(n, 0)
        nums = ac.read_list_ints()
        ans = [0] * n
        for j in range(n):
            i = n + 1 - nums[j]
            ans[j] = tree.range_sum(1, i)
            tree.point_add(i, 1)
        ac.lst(ans)
        return

    @staticmethod
    def abc_287g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc287/tasks/abc287_g
        tag: segment_tree|range_sum|dynamic|offline|tree_array|bisect_right
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        q = ac.read_int()
        queries = [ac.read_list_ints() for _ in range(q)]
        nodes = set()
        for a, _ in nums:
            nodes.add(a)
        for lst in queries:
            if lst[0] == 1:
                nodes.add(lst[2])
        nodes = sorted(nodes)
        ind = {num: i + 1 for i, num in enumerate(nodes)}
        n = len(nodes)
        tree1 = PointAddRangeSum(n)
        tree2 = PointAddRangeSum(n)
        tot1 = tot2 = 0
        for a, b in nums:
            tree1.point_add(ind[a], b)
            tree2.point_add(ind[a], a * b)
            tot1 += b
            tot2 += a * b

        for lst in queries:
            if lst[0] < 3:
                x, y = lst[1:]
                x -= 1
                a, b = nums[x]
                tree1.point_add(ind[a], -b)
                tree2.point_add(ind[a], -a * b)
                tot1 -= b
                tot2 -= a * b
                if lst[0] == 1:
                    nums[x][0] = y
                else:
                    nums[x][1] = y
                a, b = nums[x]
                tree1.point_add(ind[a], b)
                tree2.point_add(ind[a], a * b)
                tot1 += b
                tot2 += a * b
            else:
                x = lst[1]
                if tot1 < x:
                    ac.st(-1)
                    continue
                i = tree1.bisect_right(tot1 - x)
                ans = tree2.range_sum(1, i) if i else 0
                rest = tot1 - x - tree1.range_sum(1, i) if i else tot1 - x
                ans += rest * nodes[i]
                ac.st(tot2 - ans)
        return

    @staticmethod
    def lc_2916(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii/
        tag: range_add|range_sum|contribution_method|linear_dp

        """
        n = len(nums)
        mod = 10 ** 9 + 7
        ans = dp = 0
        dct = dict()
        tree = RangeAddRangeSum(n)
        for i in range(n):
            num = nums[i]
            if num not in dct:
                dp += 2 * tree.range_sum(1, i + 1) + i + 1
                tree.range_add(1, i + 1, 1)

            else:
                j = dct[num]
                dp += 2 * tree.range_sum(j + 2, i + 1) + i - j
                tree.range_add(j + 2, i + 1, 1)
            ans += dp
            dct[num] = i
            ans %= mod
            dp %= mod
        return ans

    @staticmethod
    def cf_1722e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1722/E
        tag: data_range|matrix_prefix_sum|classical|can_be_discretization_hard_version|tree_array_2d
        """

        for _ in range(ac.read_int()):
            k, q = ac.read_list_ints()
            rec = [ac.read_list_ints() for _ in range(k)]
            qur = [ac.read_list_ints() for _ in range(q)]
            n = max([y for _, y in rec] + [ls[3] for ls in qur])
            m = max([y for y, _ in rec] + [ls[2] for ls in qur])
            tree_2d = PointAddRangeSum2D(m, n)
            for x, y in rec:
                tree_2d.point_add(x, y, x * y)

            for hs, ws, hb, wb in qur:
                ans = tree_2d.range_sum(hs + 1, ws + 1, hb - 1, wb - 1)
                ac.st(ans)
        return

    @staticmethod
    def abc_306f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc306/tasks/abc306_f
        tag: tree_array|contribution_method|classical
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        nodes = []
        for num in nums:
            nodes.extend(num)
        nodes.sort()
        ind = {num: i + 1 for i, num in enumerate(nodes)}

        nums = [[ind[x] for x in ls] for ls in nums]
        k = len(ind)
        tree = PointAddRangeSum(k)
        for x in nums[-1]:
            tree.point_add(x, 1)
        ans = 0
        for i in range(n - 2, -1, -1):
            for num in nums[i]:
                if num > 1:
                    ans += tree.range_sum(1, num - 1) + (n - i - 1)
                else:
                    ans += (n - i - 1)
            ans += (n - 1 - i) * (1 + m - 1) * (m - 1) // 2
            for x in nums[i]:
                tree.point_add(x, 1)
        ac.st(ans)
        return

    @staticmethod
    def abc_283f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc283/tasks/abc283_f
        tag: manhattan_distance|point_descend|pre_min|tree_array|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        ans = [math.inf] * n
        tree1 = PointDescendPreMin(n)
        tree2 = PointDescendPreMin(n)
        for i in range(n):
            if nums[i] > 1:
                pre = tree1.pre_min(nums[i] - 1)
                ans[i] = min(ans[i], nums[i] + i + pre)
            if nums[i] < n:
                pre = tree2.pre_min(n - nums[i])
                ans[i] = min(ans[i], -nums[i] + i + pre)

            tree1.point_descend(nums[i], -nums[i] - i)
            tree2.point_descend(n + 1 - nums[i], nums[i] - i)

        tree1 = PointDescendPreMin(n)
        tree2 = PointDescendPreMin(n)
        for i in range(n - 1, -1, -1):
            if nums[i] > 1:
                pre = tree1.pre_min(nums[i] - 1)
                ans[i] = min(ans[i], nums[i] - i + pre)
            if nums[i] < n:
                pre = tree2.pre_min(n - nums[i])
                ans[i] = min(ans[i], -nums[i] - i + pre)

            tree1.point_descend(nums[i], -nums[i] + i)
            tree2.point_descend(n + 1 - nums[i], nums[i] + i)
        ac.lst(ans)
        return

    @staticmethod
    def abc_276f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc276/tasks/abc276_f
        tag: expectation|comb|tree_array|contribution_method|classical
        """
        mod = 998244353
        ac.read_int()
        nums = ac.read_list_ints()
        tot = 0
        m = 2 * 10 ** 5
        tree_cnt = PointAddRangeSum(m)
        tree_sum = PointAddRangeSum(m)
        cb = Combinatorics(m, mod)
        for i, num in enumerate(nums):
            cnt = cb.inv[i + 1]
            smaller = tree_cnt.range_sum(1, num - 1) if num else 0
            tot += num + smaller * 2 * num + 2 * tree_sum.range_sum(1, m + 1 - num)
            tot %= mod
            tree_sum.point_add(m + 1 - num, num)
            tree_cnt.point_add(num, 1)
            ac.st(tot * cnt * cnt % mod)
        return

    @staticmethod
    def abc_256f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc256/tasks/abc256_f
        tag: tree_array|cumulative_cumulative_cumulative_sum|math|classical
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        tree1 = PointAddRangeSum(n)
        tree1.build([nums[i - 1] * i * i for i in range(1, n + 1)])
        tree2 = PointAddRangeSum(n)
        tree2.build([nums[i - 1] * i for i in range(1, n + 1)])
        tree3 = PointAddRangeSum(n)
        tree3.build(nums)
        mod = 998244353
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, v = lst[1:]
                p = v * x * x - nums[x - 1] * x * x
                tree1.point_add(x, p)
                p = v * x - nums[x - 1] * x
                tree2.point_add(x, p)
                p = v - nums[x - 1]
                tree3.point_add(x, p)
                nums[x - 1] = v
            else:
                x = lst[1]
                ans = (tree1.range_sum(1, x) - (2 * x + 3) * tree2.range_sum(1, x) + (x + 1) * (
                        x + 2) * tree3.range_sum(1, x)) // 2
                ans %= mod
                ac.st(ans)
        return

    @staticmethod
    def abc_250e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc250/tasks/abc250_e
        tag: tree_array|point_ascend|pre_max|implemention|set|classical
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        ind = dict()
        for i in range(n - 1, -1, -1):
            ind[a[i]] = i
        b = ac.read_list_ints()
        pre_a = [0] * n
        tmp = set()
        for i in range(n):
            tmp.add(a[i])
            pre_a[i] = len(tmp)

        pre_b = [0] * n
        tmp = set()
        for i in range(n):
            tmp.add(b[i])
            pre_b[i] = len(tmp)

        tree = PointAscendPreMax(n)
        for i in range(n):
            tree.point_ascend(i + 1, ind.get(b[i], math.inf) + 1)
        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints()
            if pre_a[x - 1] == pre_b[y - 1] and tree.pre_max(y) <= x:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def abc_231f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc231/tasks/abc231_f
        tag: discretize|tree_array|inclusion_exclusion|two_pointers
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        tot = sorted(set(a + b))
        ind = {num: i for i, num in enumerate(tot)}
        a = [ind[x] for x in a]
        b = [ind[x] for x in b]
        m = len(tot)
        tree = PointAddRangeSum(m)
        ind = list(range(n))
        ind.sort(key=lambda it: a[it])
        ans = tot = 0
        k = -1
        for i in ind:
            while k + 1 < n and a[ind[k + 1]] <= a[i]:
                tree.point_add(b[ind[k + 1]] + 1, 1)
                tot += 1
                k += 1
            tree.point_add(b[i] + 1, -1)
            tot -= 1
            aa, bb = a[i], b[i]
            if bb == 0:
                ans += tot
            else:
                ans += tot - tree.range_sum(1, bb)
            tree.point_add(b[i] + 1, 1)
            tot += 1
        ans += n
        ac.st(ans)
        return

    @staticmethod
    def abc_351f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc351/tasks/abc351_f
        tag: tree_array|discretize|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ind = {num: i + 1 for i, num in enumerate(sorted(set(nums)))}

        m = len(ind)
        tree_sum = PointAddRangeSum(m)
        tree_cnt = PointAddRangeSum(m)
        ans = 0
        for num in nums:
            tree_cnt.point_add(ind[num], 1)
            tree_sum.point_add(ind[num], num)
            ans += tree_cnt.range_sum(1, ind[num]) * num - tree_sum.range_sum(1, ind[num])
        ac.st(ans)
        return

    @staticmethod
    def abc_221e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc221/tasks/abc221_e
        tag: tree_array|contribution_method
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = 998244353
        pp = [1] * (n + 1)
        for i in range(1, n + 1):
            pp[i] = (pp[i - 1] * 2) % mod
        rev = [1] * (n + 1)
        x = pow(2, -1, mod)
        for i in range(1, n + 1):
            rev[i] = (rev[i - 1] * x) % mod
        ind = {num: i + 1 for i, num in enumerate(sorted(set(nums)))}
        m = len(ind)
        tree = PointAddRangeSum(m)
        ans = 0
        for i in range(n):
            j = ind[nums[i]]
            if i:
                ans += tree.range_sum(1, j) * pp[i - 1] % mod
                ans %= mod
            tree.point_add(j, rev[i])
        ac.st(ans)
        return

    @staticmethod
    def abc_353g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc353/tasks/abc353_g
        tag: point_ascend|range_max|pre_max|classical
        """
        n, c = ac.read_list_ints()
        tree_ceil = PointAscendPreMax(n, -math.inf)
        tree_ceil.point_ascend(1, c)
        ceil = [-math.inf] * (n + 1)
        ceil[1] = c

        tree_floor = PointAscendPreMax(n, -math.inf)
        tree_floor.point_ascend(n, -c)

        ans = 0
        for _ in range(ac.read_int()):
            t, p = ac.read_list_ints()
            cur = ceil[t] - c * t + p
            if t > 1:
                cur = max(cur, tree_ceil.pre_max(t - 1) - c * t + p)
            if t + 1 < n:
                cur = max(cur, tree_floor.pre_max(n - t) + c * t + p)
            ans = max(ans, cur)
            ceil[t] = max(ceil[t], cur + c * t)
            tree_ceil.point_ascend(t, cur + c * t)
            tree_floor.point_ascend(n + 1 - t, cur - c * t)
        ac.st(ans)
        return

    @staticmethod
    def abc_356f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc356/tasks/abc356_f
        tag: tree_array|binary_search|bisect_right|classical
        """
        q, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(q)]
        nodes = sorted(set([x for _, x in nums] + [-1, 10 ** 18 + 1]))
        ind = {num: i for i, num in enumerate(nodes)}
        n = len(ind)
        tree_cnt = PointAddRangeSum(n)
        tree_root = PointAddRangeSum(n)  # index is point and value is root or not
        cur = set()
        root = set()
        part = 0
        for op, x in nums:
            i = ind[x]
            if op == 1:
                if x in cur:
                    tree_cnt.point_add(i + 1, -1)
                    cur.remove(x)
                    loc = tree_cnt.range_sum(1, i + 1)
                    left = -math.inf
                    right = math.inf
                    if loc:
                        left = nodes[tree_cnt.bisect_right(loc - 1)]
                    if loc < len(cur):
                        right = nodes[tree_cnt.bisect_right(loc)]
                    if x - left <= k < right - left:
                        tree_root.point_add(ind[left] + 1, 1)
                        root.add(ind[left] + 1)
                    if right - x > k:
                        tree_root.point_add(i + 1, -1)
                        root.remove(i + 1)
                else:
                    cur.add(x)
                    tree_cnt.point_add(i + 1, 1)
                    loc = tree_cnt.range_sum(1, i + 1)
                    left = -math.inf
                    right = math.inf
                    if loc > 1:
                        left = nodes[tree_cnt.bisect_right(loc - 2)]
                    if loc < len(cur):
                        right = nodes[tree_cnt.bisect_right(loc)]
                    if x - left <= k < right - left:
                        tree_root.point_add(ind[left] + 1, -1)
                        root.remove(ind[left] + 1)
                    if right - x > k:
                        tree_root.point_add(i + 1, 1)
                        root.add(i + 1)
                        part += 1
            else:
                loc = tree_root.range_sum(1, i + 1)
                label = 1 if i + 1 in root else 0
                if not label:
                    if loc:
                        left = tree_root.bisect_right(loc - 1) + 1
                    else:
                        left = 0
                    right = tree_root.bisect_right(loc)
                else:
                    if loc >= 2:
                        left = tree_root.bisect_right(loc - 2) + 1
                    else:
                        left = 0
                    right = i
                ans = tree_cnt.range_sum(left + 1, right + 1)
                ac.st(ans)
        return

    @staticmethod
    def lc_100317(nums: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/peaks-in-array/
        tag: tree_array|implemention
        """
        n = len(nums)
        tree = PointAddRangeSum(n)
        for i in range(1, n - 1):
            if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]:
                tree.point_add(i, 1)

        res = []
        for op, a, b in queries:
            if op == 1:
                res.append(tree.range_sum(a + 1, b - 1) if a + 1 <= b - 1 else 0)
            else:
                for aa in [a - 1, a, a + 1]:
                    if 0 <= aa <= aa + 1 < n and nums[aa] > nums[aa - 1] and nums[aa] > nums[aa + 1]:
                        tree.point_add(aa, -1)
                nums[a] = b
                for aa in [a - 1, a, a + 1]:
                    if 0 <= aa < aa + 1 < n and nums[aa] > nums[aa - 1] and nums[aa] > nums[aa + 1]:
                        tree.point_add(aa, 1)
        return res

    @staticmethod
    def cf_1430e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1430/E
        tag: tree_array|classical|implemention|point_add|range_sum|pre_sum
        """
        n = ac.read_int()
        s = ac.read_str()
        dct = defaultdict(list)
        for i in range(n - 1, -1, -1):
            dct[s[i]].append(i)
        tree = PointAddRangeSum(n)
        tree.build([1] * n)
        ans = 0
        for i in range(n - 1, -1, -1):
            x = dct[s[i]].pop()
            ans += tree.range_sum(0, x) - 1
            tree.point_add(x, -1)
        ac.st(ans)
        return

    @staticmethod
    def cf_1788e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1788/E
        tag: linear_dp|tree_array|point_ascend|pre_max
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = ac.accumulate(nums)
        nodes = sorted(set(pre))
        ind = {num: i + 1 for i, num in enumerate(nodes)}
        m = len(ind)
        tree = PointAscendPreMax(m)
        pre_max = [0] * (n + 1)
        tree.point_ascend(ind[0], 0)
        for i in range(n):
            cur = tree.pre_max(ind[pre[i + 1]]) + i + 1
            pre_max[i + 1] = max(pre_max[i], cur)
            tree.point_ascend(ind[pre[i + 1]], pre_max[i + 1] - i - 1)
        ans = pre_max[-1]
        ac.st(ans)
        return

    @staticmethod
    def cf_677d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/677/D
        tag: layered_bfs|tree_array|two_pointers|partial_order|implemention|classical
        """
        m, n, p = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        dct = [[] for _ in range(p + 1)]
        for i in range(m):
            for j in range(n):
                dct[grid[i][j]].append(i * n + j)
        dct[1].sort()
        dis = [math.inf] * m * n
        for x in dct[1]:
            i, j = x // n, x % n
            dis[i * n + j] = i + j
        tree_pre = PointDescendPreMin(n)
        tree_post = PointDescendPostMin(n)
        for x in range(2, p + 1):
            dct[x].sort()
            k1 = len(dct[x - 1])
            k2 = len(dct[x])
            if k1 * k2 <= 100:
                for x1 in dct[x - 1]:
                    i1, j1 = x1 // n, x1 % n
                    for x2 in dct[x]:
                        i2, j2 = x2 // n, x2 % n
                        dis[x2] = min(dis[x2], dis[x1] + abs(i2 - i1) + abs(j2 - j1))
            else:
                ind = 0
                tree_pre.initialize()
                tree_post.initialize()
                for x2 in dct[x]:
                    i2, j2 = x2 // n, x2 % n
                    while ind < k1 and dct[x - 1][ind] // n <= i2:
                        x1 = dct[x - 1][ind]
                        i1, j1 = x1 // n, x1 % n
                        tree_pre.point_descend(j1, -i1 - j1 + dis[x1])
                        tree_post.point_descend(j1, j1 - i1 + dis[x1])
                        ind += 1
                    cur = min(i2 + j2 + tree_pre.pre_min(j2), i2 - j2 + tree_post.post_min(j2))
                    dis[x2] = cur

                ind = k1 - 1
                tree_pre.initialize()
                tree_post.initialize()
                for x2 in dct[x][::-1]:
                    i2, j2 = x2 // n, x2 % n
                    while ind >= 0 and dct[x - 1][ind] // n >= i2:
                        x1 = dct[x - 1][ind]
                        i1, j1 = x1 // n, x1 % n
                        tree_pre.point_descend(j1, i1 - j1 + dis[x1])
                        tree_post.point_descend(j1, j1 + i1 + dis[x1])
                        ind -= 1
                    cur = min(j2 - i2 + tree_pre.pre_min(j2), - i2 - j2 + tree_post.post_min(j2))
                    dis[x2] = min(dis[x2], cur)
        ans = min(dis[x] for x in dct[p])
        ac.st(ans)
        return

    @staticmethod
    def lg_p5041(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5041
        tag: tree_array|implemention|classical
        """
        s = ac.read_str()
        n = len(s)
        lst = list(s)
        ans = 0
        dct = defaultdict(deque)
        for i in range(n):
            dct[lst[i]].append(i)
        tree = PointAddRangeSum(n)
        i, j = 0, n - 1
        while i < j:
            if lst[i] == "":
                i += 1
                continue
            if lst[j] == "":
                j -= 1
                continue
            if lst[i] == lst[j]:
                dct[lst[i]].popleft()
                dct[lst[j]].pop()
                i += 1
                j -= 1
                continue

            if len(dct[lst[j]]) >= 2:
                left = dct[lst[j]][0]
                ans += left - i - tree.range_sum(i, left)
                x = dct[lst[j]].popleft()
                dct[lst[j]].pop()
                lst[x] = ""
                tree.point_add(x, 1)
                j -= 1
            else:
                right = dct[lst[i]][-1]
                ans += j - right - tree.range_sum(right, j)
                x = dct[lst[i]].pop()
                dct[lst[i]].popleft()
                tree.point_add(x, 1)
                lst[x] = ""
                i += 1
        ac.st(ans)
        return

    @staticmethod
    def abc_368g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc368/tasks/abc368_g
        tag: point_add|range_sum|observation|data_range
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        tree = PointAddRangeSum(n)
        tree.build(a)
        lst = SortedList([i for i in range(n) if b[i] > 1] + [n])

        for _ in range(ac.read_int()):
            op, i, x = ac.read_list_ints()
            if op == 1:
                tree.point_add(i - 1, x - a[i - 1])
                a[i - 1] = x
            elif op == 2:
                if b[i - 1] != 1:
                    lst.discard(i - 1)
                b[i - 1] = x
                if b[i - 1] != 1:
                    lst.add(i - 1)
            else:
                v = 0
                i -= 1
                x -= 1
                j = lst.bisect_left(i)
                while i <= x:
                    while lst[j] < i:
                        j += 1
                    if lst[j] == i:
                        v = max(v + a[lst[j]], v * b[lst[j]])
                        i += 1
                    elif lst[j] <= x:
                        v += tree.range_sum(i, lst[j] - 1)
                        v = max(v + a[lst[j]], v * b[lst[j]])
                        i = lst[j] + 1
                    else:
                        v += tree.range_sum(i, x)
                        i = x + 1
                ac.st(v)
        return

    @staticmethod
    def abc_369f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc369/tasks/abc369_f
        tag: tree_array|point_ascend|pre_max_index|construction|specific_plan
        """
        m, n, k = ac.read_list_ints()
        nums = [ac.read_list_ints_minus_one() for _ in range(k)]

        tree = PointAscendPreMaxIndex(2 * 10 ** 5, 0)
        ind = list(range(k))
        ind.sort(key=lambda it: nums[it])
        dct = dict()
        for i in ind:
            x, y = nums[i]
            pre, ind = tree.pre_max(y)
            dct[i] = ind
            tree.point_ascend(y, pre + 1, i)

        ans1, ans2 = tree.pre_max(2 * 10 ** 5 - 1)
        path = [ans2]
        while path[-1] != -1:
            path.append(dct[path[-1]])
        path.pop()
        path.reverse()
        path = [(0, 0)] + [nums[x] for x in path] + [(m - 1, n - 1)]
        lst = []
        for i in range(1, len(path)):
            a, b = path[i - 1]
            c, d = path[i]
            lst.append("R" * (d - b))
            lst.append("D" * (c - a))
        ac.st(ans1)
        ac.st("".join(lst))
        return

    @staticmethod
    def cf_1667b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1667/B
        tag: tree_array|classical|prefix_sum
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            pre = ac.accumulate(nums)
            ind = {num: i for i, num in enumerate(sorted(set(pre)))}
            m = len(ind)
            tree_ceil = PointAscendPreMax(m)
            tree_floor = PointAscendPreMax(m)
            ans = 0
            tree_ceil.point_ascend(ind[0], 0)
            tree_floor.point_ascend(m - ind[0] - 1, 0)
            ac.get_random_seed()
            dct = dict()
            dct[0 ^ ac.random_seed] = 0
            for i in range(n):
                ans = dct.get(pre[i + 1] ^ ac.random_seed, -math.inf)
                # < pre[i+1]
                cur = tree_ceil.pre_max(ind[pre[i + 1]] - 1) if ind[pre[i + 1]] >= 1 else -math.inf
                ans = max(ans, cur + i + 1)
                # > pre[i+1]
                cur = tree_floor.pre_max(m - 1 - ind[pre[i + 1]] - 1) if m - 1 - ind[pre[i + 1]] >= 1 else -math.inf
                ans = max(ans, cur - i - 1)
                # update
                tree_floor.point_ascend(m - 1 - ind[pre[i + 1]], ans + (i + 1))
                tree_ceil.point_ascend(ind[pre[i + 1]], ans - (i + 1))
                dct[pre[i + 1] ^ ac.random_seed] = max(ans, dct.get(pre[i + 1] ^ ac.random_seed, -math.inf))
            ac.st(ans)
        return

    @staticmethod
    def cf_597c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/597/C
        tag: point_add|range_sum|bag_dp|classical
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_int() - 1 for _ in range(n)]
        ans = [1] * n
        for _ in range(k):
            tree = PointAddRangeSum(n)
            for x in nums:
                res = tree.range_sum(0, x - 1) if x > 0 else 0
                tree.point_add(x, ans[x])
                ans[x] = res
        ac.st(sum(ans))
        return
"""
Algorithm：trie_like|binary_trie
Description：string|bit_operation

====================================LeetCode====================================
421（https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/）binary_trie
638（https://leetcode.cn/problems/shopping-offers/）trie_like|memory_search
2416（https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/）prefix|counter
1803（https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/）binary_trie|classical
677（https://leetcode.cn/problems/map-sum-pairs/）prefix|counter
2479（https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/）binary_trie|maximum_xor
1717（https://leetcode.cn/problems/multi-search-lcci/）automaton|counter|trie_like|reverse_thinking
1707（https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/）sort|offline_query|binary_trie
1938（https://leetcode.cn/problems/maximum-genetic-difference-query/）dfs|back_trace|binary_trie|maximum_xor
1032（https://leetcode.cn/problems/stream-of-characters/description/）trie_like|classical|reverse_order
1554（https://leetcode.cn/problems/strings-differ-by-one-character/）string_hash|trie
2935（https://leetcode.cn/problems/maximum-strong-pair-xor-ii/description/）binary_trie|hash|bit_operation
3093（https://leetcode.cn/problems/longest-common-suffix-queries）trie|classical

=====================================LuoGu======================================
P8306（https://www.luogu.com.cn/problem/P8306）trie_like
P4551（https://www.luogu.com.cn/problem/P4551）xor
P3864（https://www.luogu.com.cn/problem/P3864）hash|brute_force|trie_like
P5755（https://www.luogu.com.cn/problem/P5755）trie_like|counter
P1481（https://www.luogu.com.cn/problem/P1481）trie_like
P5283（https://www.luogu.com.cn/problem/P5283）trie_like|kth_xor|heapq|greedy
P2922（https://www.luogu.com.cn/problem/P2922）trie_like|prefix|counter
P1738（https://www.luogu.com.cn/problem/P1738）trie_like|counter
P8420（https://www.luogu.com.cn/problem/P8420）trie_like|greedy
P4735（https://www.luogu.com.cn/problem/P4735）

===================================CodeForces===================================
1792D（https://codeforces.com/problemset/problem/1792/D）trie_like|counter
706D（https://codeforces.com/problemset/problem/706/D）binary_trie|maximum_xor
241B（https://codeforces.com/contest/241/problem/B）binary_trie|kth_xor|heapq|greedy
665E（https://codeforces.com/contest/665/problem/E）counter|xor_pair
282E（https://codeforces.com/contest/282/problem/E）binary_trie|maximum_xor
1902E（https://codeforces.com/contest/1902/problem/E）trie_like|prefix_count
665E（https://codeforces.com/contest/665/problem/E）binary_trie|get_cnt_smaller_xor
817E（https://codeforces.com/contest/817/problem/E）binary_trie|get_cnt_smaller_xor
1777F（https://codeforces.com/problemset/problem/1777/F）
1446C（https://codeforces.com/contest/1446/problem/C）
923C（https://codeforces.com/problemset/problem/923/C）binary_trie|greedy
1055F（https://codeforces.com/problemset/problem/1055/F）binary_trie|get_cnt_smaller_xor
1720D2（https://codeforces.com/contest/1720/problem/D2）
1849F（https://codeforces.com/problemset/problem/1849/F）
888G（https://codeforces.com/problemset/problem/888/G）
1980G（https://codeforces.com/contest/1980/problem/G）binary_trie|bfs|implemention|maximum_xor|classical

===================================AtCoder===================================
ABC287E（https://atcoder.jp/contests/abc287/tasks/abc287_e）trie|prefix_suffix|classical

=====================================AcWing=====================================
144（https://www.acwing.com/problem/content/144/）trie_like|prefix_count
145（https://www.acwing.com/problem/content/145/）maximum_xor|classical
146（https://www.acwing.com/problem/content/description/146/）binary_trie|maximum_xor
163（https://www.acwing.com/problem/content/163/）trie_like
258（https://www.acwing.com/problem/content/258/）

=====================================LibraryChecker=====================================
1（https://judge.yosupo.jp/problem/set_xor_min）template|minimum_xor|classical|update|query

"""
import heapq
from collections import Counter, defaultdict
from functools import reduce
from operator import or_
from typing import List

from src.data_structure.trie_like.template import BinaryTrieXor, StringTriePrefix, StringTrieSearch, \
    BinaryTrieXorLimited
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_1717(big: str, smalls: List[str]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/multi-search-lcci/
        tag: automaton|counter|trie_like|reverse_thinking
        """
        n = len(smalls)
        sts = StringTrieSearch(sum(len(x) for x in smalls) + 1, n)
        for i, word in enumerate(smalls):
            if word:
                sts.add([ord(w) - ord("a") for w in word], i + 1)

        ans = [[] for _ in range(n)]
        for i in range(len(big)):
            for j in sts.search([ord(w) - ord("a") for w in big[i:]]):
                ans[j - 1].append(i)
        return ans

    @staticmethod
    def lc_677():
        """
        url: https://leetcode.cn/problems/map-sum-pairs/
        tag: prefix|counter
        """

        class MapSum:

            def __init__(self):
                self.trie = StringTriePrefix(50 * 50, 5 * 10 ** 4)
                self.dct = defaultdict(int)

            def insert(self, key: str, val: int) -> None:
                self.trie.add([ord(w) - ord("a") for w in key], val - self.dct[key])
                self.dct[key] = val
                return

            def sum(self, prefix: str) -> int:
                return self.trie.count_end([ord(w) - ord("a") for w in prefix])

        return MapSum()

    @staticmethod
    def lc_1803_1(nums: List[int], low: int, high: int) -> int:
        """
        url: https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/
        tag: binary_trie|classical|inclusion_exclusion
        """
        n = len(nums)
        trie = BinaryTrieXor(max(high, max(nums)), n)
        ans = 0
        for num in nums:
            ans += trie.get_cnt_smaller_xor(num, high)
            ans -= trie.get_cnt_smaller_xor(num, low - 1)
            trie.add(num)
        return ans

    @staticmethod
    def lc_1803_2(nums: List[int], low: int, high: int) -> int:
        """
        url: https://leetcode.cn/problems/count-pairs-with-xor-in-a-range/
        tag: binary_trie|classical|hard
        """
        ans, cnt = 0, Counter(nums)
        high += 1
        while high:
            nxt = Counter()
            for x, c in cnt.items():
                if high & 1:
                    ans += c * cnt[x ^ (high ^ 1)]
                if low & 1:
                    ans -= c * cnt[x ^ (low ^ 1)]
                nxt[x >> 1] += c
            cnt = nxt
            low >>= 1
            high >>= 1
        return ans // 2

    @staticmethod
    def cf_706d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/706/D
        tag: binary_trie|maximum_xor
        """
        q = ac.read_int()
        trie = BinaryTrieXor(10 ** 9, q)
        trie.add(0)
        for _ in range(q):
            op, x = ac.read_list_strs()
            if op == "+":
                trie.add(int(x))
            elif op == "-":
                trie.remove(int(x))
            else:
                ac.st(trie.get_maximum_xor(int(x)))
        return

    @staticmethod
    def cf_1902e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1902/problem/E
        tag: trie_like|prefix_count
        """
        n = ac.read_int()
        words = [ac.read_str() for _ in range(n)]
        trie = StringTriePrefix(sum(len(x) for x in words), n)
        ans = 0
        for i in range(2):
            pre = 0
            for j, word in enumerate(words):
                ans -= trie.count([ord(w) - ord("a") for w in word[::-1]]) * 2
                ans += j * len(word) + pre
                pre += len(word)
                trie.add([ord(w) - ord("a") for w in word])
            if i == 0:
                words.reverse()
                trie.initial()

        for word in words:
            n = len(word)
            i = n - 1
            j = 0
            while i >= 0:
                if word[i] == word[j]:
                    i -= 1
                    j += 1
                else:
                    break
            ans += 2 * (i + 1)
        ac.st(ans)
        return

    @staticmethod
    def lc_2479(n: int, edges: List[List[int]], values: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-xor-of-two-non-overlapping-subtrees/
        tag: binary_trie|maximum_xor|classical|dfs_order|implemention
        """
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)
        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                for j in dct[i]:
                    if j != fa:
                        values[i] += values[j]
        trie = BinaryTrieXor(values[0], n)
        ans = 0
        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                ans = max(ans, trie.get_maximum_xor(values[i]))
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                trie.add(values[i])
        return ans

    @staticmethod
    def lc_2416(words: List[str]) -> List[int]:
        """
        url: https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/
        tag: prefix|counter
        """
        trie = StringTriePrefix(sum(len(x) for x in words), len(words))
        for word in words:
            trie.add([ord(w) - ord("a") for w in word])
        return [trie.count([ord(w) - ord("a") for w in word]) for word in words]

    @staticmethod
    def lg_p1481(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1481
        tag: trie_like
        """
        n = ac.read_int()
        words = [ac.read_str() for _ in range(n)]
        trie = StringTrieSearch(sum(len(x) for x in words), n)
        ans = 0
        for i in range(n):
            ans = max(ans, trie.add_cnt([ord(w) - ord("a") for w in words[i]], i + 1))
        ac.st(ans)
        return

    @staticmethod
    def lg_p4551_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4551
        tag: get_maximum_xor|binary_trie|hash|implemention
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v, w = ac.read_list_ints_minus_one()
            dct[u].append((v, w + 1))
        trie = BinaryTrieXor((1 << 31) - 1, n)
        ans = 0
        stack = [(0, 0)]
        while stack:
            i, v = stack.pop()
            ans = max(ans, trie.get_maximum_xor(v))
            trie.add(v)
            for j, w in dct[i]:
                stack.append((j, w ^ v))
        ac.st(ans)
        return

    @staticmethod
    def lg_p4551_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4551
        tag: get_maximum_xor|binary_trie|hash|implemention
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v, w = ac.read_list_ints_minus_one()
            dct[u].append((v, w + 1))

        xor = [0] * n
        stack = [(0, 0)]
        while stack:
            i, v = stack.pop()
            xor[i] = v
            for j, w in dct[i]:
                stack.append((j, w ^ v))
        ans = 0
        for i in range(30, -1, -1):
            pre = set()
            cur = (ans >> i) | 1
            for num in xor:
                if cur ^ (num >> i) in pre:
                    ans |= (1 << i)
                    break
                pre.add(num >> i)
        ac.st(ans)
        return

    @staticmethod
    def lg_p5283(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5283
        tag: trie_like|kth_xor|heapq|greedy
        """
        mod = 10 ** 9 + 7  # TLE
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        trie = BinaryTrieXor(max(nums), n)
        for i, num in enumerate(nums):
            trie.add(num)
        stack = [(-trie.get_kth_maximum_xor(nums[i], 1), i, 1) for i in range(n)]
        heapq.heapify(stack)
        ans = 0
        for _ in range(2 * k):
            num, i, c = heapq.heappop(stack)
            ans -= num
            if c + 1 <= n:
                heapq.heappush(stack, (-trie.get_kth_maximum_xor(nums[i], c + 1), i, c + 1))
        ac.st((ans // 2) % mod)
        return

    @staticmethod
    def cf_241b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/241/problem/B
        tag: binary_trie|kth_xor|heapq|greedy
        """
        mod = 10 ** 9 + 7  # TLE
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        trie = BinaryTrieXor(max(nums), n)
        for i, num in enumerate(nums):
            trie.add(num)
        stack = [(-trie.get_kth_maximum_xor(nums[i], 1), i, 1) for i in range(n)]
        heapq.heapify(stack)
        ans = 0
        for _ in range(2 * k):
            num, i, c = heapq.heappop(stack)
            ans -= num
            if c + 1 <= n:
                heapq.heappush(stack, (-trie.get_kth_maximum_xor(nums[i], c + 1), i, c + 1))
        ac.st((ans // 2) % mod)
        return

    @staticmethod
    def ac_145_1(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/145/
        tag: maximum_xor|classical
        """
        n = ac.read_int()
        ans = 0
        trie = BinaryTrieXor((1 << 31) - 1, n)
        for num in ac.read_list_ints():
            ans = max(ans, trie.get_maximum_xor(num))
            trie.add(num)
        ac.st(ans)
        return

    @staticmethod
    def ac_145_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/145/
        tag: maximum_xor|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ans = 0
        for i in range(30, -1, -1):
            pre = set()
            cur = (ans >> i) | 1
            for num in nums:
                if cur ^ (num >> i) in pre:
                    ans |= (1 << i)
                    break
                pre.add(num >> i)
        ac.st(ans)
        return

    @staticmethod
    def ac_146_1(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/146/
        tag: binary_trie|maximum_xor|hash
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v, w = ac.read_list_ints()
            dct[u].append((v, w))
            dct[v].append((u, w))
        trie = BinaryTrieXor((1 << 31) - 1, n)
        ans = 0
        stack = [(0, -1, 0)]
        while stack:
            i, fa, v = stack.pop()
            ans = max(ans, trie.get_maximum_xor(v))
            trie.add(v)
            for j, w in dct[i]:
                if j != fa:
                    stack.append((j, i, w ^ v))
        ac.st(ans)
        return

    @staticmethod
    def ac_146_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/146/
        tag: binary_trie|maximum_xor|hash
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v, w = ac.read_list_ints()
            dct[u].append((v, w))
            dct[v].append((u, w))

        xor = [0] * n
        stack = [(0, -1, 0)]
        while stack:
            i, fa, v = stack.pop()
            xor[i] = v
            for j, w in dct[i]:
                if j != fa:
                    stack.append((j, i, w ^ v))

        ans = 0
        for i in range(30, -1, -1):
            pre = set()
            cur = (ans >> i) | 1
            for num in xor:
                if cur ^ (num >> i) in pre:
                    ans |= (1 << i)
                    break
                pre.add(num >> i)
        ac.st(ans)
        return

    @staticmethod
    def ac_144(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/144/
        tag: trie_like|prefix_count
        """
        n, m = ac.read_list_ints()
        trie = StringTriePrefix(10 ** 6, n)
        for i in range(n):
            trie.add_end([ord(w) - ord("a") for w in ac.read_str()], 1)
        for _ in range(m):
            ac.st(trie.count_pre_end([ord(w) - ord("a") for w in ac.read_str()]))
        return

    @staticmethod
    def ac_163(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/163/
        tag: trie_like
        """

        class StringTriePrefixSP:
            def __init__(self, most_word, word_cnt, string_state=26):  # prefix count
                assert most_word >= 1
                assert word_cnt >= 1
                self.string_state = string_state
                self.cnt_bit = word_cnt.bit_length()
                self.node_cnt = most_word * self.string_state
                self.son_and_cnt = [0] * (self.node_cnt + 1)
                self.end = [0] * (self.node_cnt + 1)
                self.ind = 0
                self.mask = (1 << self.cnt_bit) - 1

            def add_query(self, word):
                cur = 0
                res = True
                for w in word:
                    bit = ord(w) - ord("a")
                    if not self.son_and_cnt[bit + cur * self.string_state] >> self.cnt_bit:
                        self.ind += 1
                        self.son_and_cnt[bit + cur * self.string_state] |= self.ind << self.cnt_bit
                    cur = self.son_and_cnt[bit + cur * self.string_state] >> self.cnt_bit
                    if self.end[cur]:
                        res = False
                    self.son_and_cnt[cur] += 1
                if self.son_and_cnt[cur] & self.mask > 1:
                    res = False
                self.end[cur] = 1
                return res

        for _ in range(ac.read_int()):
            n = ac.read_int()
            trie = StringTriePrefixSP(10 ** 5, n)
            ans = "YES"
            for _ in range(n):
                s = ac.read_str()
                if ans == "YES":
                    if not trie.add_query(s):
                        ans = "NO"
            ac.st(ans)
        return

    @staticmethod
    def lg_p2922(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2922
        tag: trie_like|prefix|counter|classical|hard|inclusion_exclusion
        """

        class StringTriePrefixSP:
            def __init__(self, most_word, word_cnt, string_state=2):  # prefix count
                assert most_word >= 1
                assert word_cnt >= 1
                self.string_state = string_state
                self.cnt_bit = word_cnt.bit_length()
                self.node_cnt = most_word * self.string_state
                self.son_and_cnt = [0] * (self.node_cnt + 1)
                self.end = [0] * (self.node_cnt + 1)
                self.ind = 0
                self.mask = (1 << self.cnt_bit) - 1

            def add(self, word):
                cur = 0
                for w in word:
                    bit = int(w)
                    if not self.son_and_cnt[bit + cur * self.string_state] >> self.cnt_bit:
                        self.ind += 1
                        self.son_and_cnt[bit + cur * self.string_state] |= self.ind << self.cnt_bit
                    cur = self.son_and_cnt[bit + cur * self.string_state] >> self.cnt_bit
                    self.son_and_cnt[cur] += 1
                self.end[cur] += 1
                return

            def count_prefix(self, word):
                cur = res = 0
                for w in word:
                    bit = int(w)
                    if not self.son_and_cnt[bit + cur * self.string_state] >> self.cnt_bit:
                        return res
                    cur = self.son_and_cnt[bit + cur * self.string_state] >> self.cnt_bit
                    res += self.end[cur]
                res += (self.son_and_cnt[cur] & self.mask) - self.end[cur]
                return res

        m, n = ac.read_list_ints()
        trie = StringTriePrefixSP(5 * 10 ** 5, m)
        for _ in range(m):
            b = ac.read_list_strs()
            trie.add("".join(b[1:]))

        for _ in range(n):
            b = ac.read_list_strs()
            ac.st(trie.count_prefix("".join(b[1:])))
        return

    @staticmethod
    def lg_p1738(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1738
        tag: trie_like|counter
        """
        n = ac.read_int()
        dct = dict()
        ans = 0
        for _ in range(n):
            s = ac.read_str().split("/")[1:]
            cur = dct
            for w in s:
                if w not in cur:
                    ans += 1
                    cur[w] = dict()
                cur = cur[w]
            ac.st(ans)
        return

    @staticmethod
    def lg_p8420(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8420
        tag: trie_like|greedy
        """
        n, m, length = ac.read_list_ints()
        cnt = [0] * length
        for _ in range(n):
            s = ac.read_str()
            for i in range(length):
                cnt[i] += 1 if s[i] == "1" else 0

        cost = [0] * (length + 1)
        for i in range(length - 1, -1, -1):
            cost[i] = cost[i + 1] + min(n - cnt[i], cnt[i])

        trie = StringTrieSearch(m * length, m, 2)
        for i in range(m):
            word = ac.read_str()
            trie.add_bin([ord(w) - ord("a") for w in word], i + 1)

        ans = math.inf
        stack = [(0, 0, 0)]
        while stack:
            x, cur, p = stack.pop()
            if x == length:
                continue

            one = trie.son_and_ind[1 + cur * trie.string_state] >> trie.cnt_bit
            if one:
                stack.append((x + 1, one, p + n - cnt[x]))
            else:
                ans = min(ans, p + n - cnt[x] + cost[x + 1])

            zero = trie.son_and_ind[cur * trie.string_state] >> trie.cnt_bit
            if zero:
                stack.append((x + 1, zero, p + cnt[x]))
            else:
                ans = min(ans, p + cnt[x] + cost[x + 1])
        ac.st(ans)
        return

    @staticmethod
    def lc_1707_1(nums: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/
        tag: sort|offline_query|binary_trie
        """
        n = len(nums)
        nums.sort()

        m = len(queries)
        for i in range(m):
            queries[i].append(i)
        queries.sort(key=lambda it: it[1])

        trie = BinaryTrieXor(10 ** 9, n)
        ans = [-1] * m
        j = 0
        for x, m, i in queries:
            while j < n and nums[j] <= m:
                trie.add(nums[j])
                j += 1
            if trie.son_and_cnt[0] & trie.mask:
                ans[i] = trie.get_maximum_xor(x)
            else:
                ans[i] = -1
        return ans

    @staticmethod
    def lc_1707_2(nums: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-xor-with-an-element-from-array/
        tag: sort|offline_query|binary_trie
        """
        n = len(nums)
        trie = BinaryTrieXorLimited(10 ** 9, n)
        for num in nums:
            trie.add(num)
        ans = [trie.get_maximum_xor_limited(x, m) for x, m in queries]
        return ans

    @staticmethod
    def cf_665e_1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/665/problem/E
        tag: binary_trie|get_cnt_smaller_xor
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre = 0
        trie = BinaryTrieXor(reduce(or_, nums), n + 1)
        trie.add(0)
        ans = n * (n + 1) // 2
        for num in nums:
            pre ^= num
            ans -= trie.get_cnt_smaller_xor(pre, k - 1)
            trie.add(pre)
        ac.st(ans)
        return

    @staticmethod
    def cf_665e_2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/665/problem/E
        tag: counter|xor_pair
        """
        n, k = ac.read_list_ints()  # TLE
        nums = ac.read_list_ints()
        for i in range(1, n):
            nums[i] ^= nums[i - 1]
        cnt = {0: 1}
        for num in nums:
            cnt[num] = cnt.get(num, 0) + 1
        ans = 0
        del nums
        high = 1 << 30
        low = k
        while high:
            nxt = dict()
            for x in cnt:
                c = cnt[x]
                if high & 1:
                    ans += c * cnt.get(x ^ (high ^ 1), 0)
                if low & 1:
                    ans -= c * cnt.get(x ^ (low ^ 1), 0)
                nxt[x >> 1] = nxt.get(x >> 1, 0) + c
            cnt = nxt
            low >>= 1
            high >>= 1
        ac.st(ans // 2)
        return

    @staticmethod
    def lib_check_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/set_xor_min
        tag: template|minimum_xor|classical|update|query
        """
        q = ac.read_int()
        trie = BinaryTrieXor((1 << 30) - 1, q)
        dct = set()
        for _ in range(q):
            op, x = ac.read_list_ints()
            if op == 0:
                if x not in dct:
                    dct.add(x)
                    trie.add(x)
            elif op == 1:
                if x in dct:
                    dct.discard(x)
                    trie.remove(x)
            else:
                ac.st(trie.get_minimum_xor(x))
        return

    @staticmethod
    def lc_421_1(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/
        tag: binary_trie|hash
        """
        trie = BinaryTrieXor(max(nums) + 1, len(nums))
        ans = 0
        for num in nums:
            cur = trie.get_maximum_xor(num)
            ans = ans if ans > cur else cur
            trie.add(num)
        return ans

    @staticmethod
    def lc_421_2(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/
        tag: binary_trie|hash
        """
        m = max(nums).bit_length() - 1  # faster!
        ans = 0
        for i in range(m, -1, -1):
            cur = (ans >> i) | 1
            pre = set()
            for num in nums:
                if cur ^ (num >> i) in pre:
                    ans |= 1 << i
                    break
                pre.add(num >> i)
        return ans

    @staticmethod
    def cf_282e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/282/problem/E
        tag: binary_trie|maximum_xor
        """

        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = pre = 0
        trie = BinaryTrieXor(10 ** 12, n + 1)
        trie.add(0)
        for i in range(n):
            pre ^= nums[i]
            trie.add(pre)
            ans = max(ans, pre)

        pre = 0
        for i in range(n - 1, -1, -1):
            pre ^= nums[i]
            ans = max(ans, trie.get_maximum_xor(pre))
        ac.st(ans)
        return

    @staticmethod
    def lc_1938(parents: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-genetic-difference-query/
        tag: dfs|back_trace|binary_trie|maximum_xor
        """
        n = len(parents)
        root = -1
        dct = [[] for _ in range(n)]
        for i in range(n):
            if parents[i] == -1:
                root = i
            else:
                dct[parents[i]].append(i)
        ceil = n
        query = [dict() for _ in range(n)]
        for node, val in queries:
            query[node][val] = 0
            ceil = max(ceil, val)
        trie = BinaryTrieXor(ceil, n)
        stack = [root]
        while stack:
            i = stack.pop()
            if i >= 0:
                trie.add(i)
                stack.append(~i)
                for w in query[i]:
                    query[i][w] = trie.get_maximum_xor(w)
                for j in dct[i]:
                    stack.append(j)
            else:
                trie.remove(~i)
        ans = [query[node][val] for node, val in queries]
        return ans

    @staticmethod
    def lc_1554(words: List[str]) -> bool:
        """
        url: https://leetcode.cn/problems/strings-differ-by-one-character/
        tag: string_hash|trie
        """
        n, m = len(words), len(words[0])
        trie = StringTrieSearch(m * n, n, 26)
        for i, word in enumerate(words):
            lst = [ord(w) - ord("a") for w in word]
            if trie.search_for_one_difference(lst):
                return True
            trie.add_int(lst, i + 1)
        return False

    @staticmethod
    def lc_2935_1(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-strong-pair-xor-ii/description/
        tag: binary_trie|hash|bit_operation
        """
        ceil = max(nums)
        n = len(nums)
        nums.sort()
        trie = BinaryTrieXor(ceil, n)
        ans = j = 0
        for i in range(n):
            while j < n and nums[j] - nums[i] <= nums[i]:
                cur = trie.get_maximum_xor(nums[j])
                trie.add(nums[j], 1)
                if cur > ans:
                    ans = cur
                j += 1
            trie.remove(nums[i], 1)
        return ans

    @staticmethod
    def lc_2935_2(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-strong-pair-xor-ii/description/
        tag: binary_trie|hash|bit_operation
        """
        nums.sort()
        ceil = len(bin(max(nums))) - 1
        ans = mask = 0
        for i in range(ceil, -1, -1):
            new_ans = ans | (1 << i)
            pre = dict()
            mask |= (1 << i)
            for num in nums:
                cur = num & mask
                if cur ^ new_ans in pre and pre[cur ^ new_ans] * 2 >= num:
                    ans = new_ans
                    break
                pre[cur] = num
        return ans

    @staticmethod
    def cf_923c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/923/C
        tag: binary_trie|greedy
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        trie = BinaryTrieXor(1 << 30, n)
        for num in b:
            trie.add(num, 1)
        ans = []
        for num in a:
            ans.append(trie.get_minimum_xor(num))
            trie.remove(num ^ ans[-1])
        ac.lst(ans)
        return

    @staticmethod
    def cf_817e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/817/problem/E
        tag: binary_trie|get_cnt_smaller_xor
        """
        q = ac.read_int()
        binary_trie = BinaryTrieXor(10 ** 8, q)
        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                binary_trie.add(lst[1])
            elif lst[0] == 2:
                binary_trie.remove(lst[1])
            else:
                ac.st(binary_trie.get_cnt_smaller_xor(lst[1], lst[2] - 1))
        return

    @staticmethod
    def abc_287e_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc287/tasks/abc287_e
        tag: trie|prefix_suffix|classical
        """
        n = ac.read_int()
        words = [ac.read_str() for _ in range(n)]

        def check():
            ans = []
            dct = dict()
            for word in words:
                cur = dct
                tot = 0
                for w in word:
                    if w in cur:
                        cur = cur[w]
                        tot += 1
                    else:
                        break
                ans.append(tot)

                cur = dct
                for w in word:
                    if w not in cur:
                        cur[w] = dict()
                    cur = cur[w]
            return ans

        ans1 = check()
        words.reverse()
        ans2 = check()
        for i in range(n):
            ac.st(max(ans1[i], ans2[n - 1 - i]))
        return

    @staticmethod
    def abc_287e_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc287/tasks/abc287_e
        tag: trie|prefix_suffix|classical
        """
        n = ac.read_int()
        words = [[ord(w) - ord("a") for w in ac.read_str()] for _ in range(n)]
        m = sum(len(w) for w in words)

        def check():
            ans = []
            trie = StringTrieSearch(m, 1, 26)
            for word in words:
                ans.append(trie.search_length(word))
                trie.add(word, 1)
            return ans

        ans1 = check()
        words.reverse()
        ans2 = check()
        for i in range(n):
            ac.st(max(ans1[i], ans2[n - 1 - i]))
        return

    @staticmethod
    def lc_3093_1(words_container: List[str], words_query: List[str]) -> List[int]:
        """
        url: https://leetcode.cn/problems/longest-common-suffix-queries
        tag: trie|classical
        """

        dct = dict()
        n = len(words_container)
        ind = list(range(n))
        ind.sort(key=lambda it: (len(words_container[it]), it))
        for i in ind:
            word = words_container[i]
            cur = dct
            for w in word[::-1]:
                if w not in cur:
                    cur[w] = dict()
                cur = cur[w]
                if "ind" not in cur:
                    cur["ind"] = i

        ans = []
        for word in words_query:
            st = word[::-1]
            cur = dct
            x = ind[0]
            for w in st:
                if w in cur:
                    cur = cur[w]
                    x = cur["ind"]
                else:
                    break
            ans.append(x)
        return ans

    @staticmethod
    def lc_3093_2(words_container: List[str], words_query: List[str]) -> List[int]:
        """
        url: https://leetcode.cn/problems/longest-common-suffix-queries
        tag: trie|classical
        """

        words_container = [[ord(w) - ord("a") for w in word] for word in words_container]
        words_query = [[ord(w) - ord("a") for w in word] for word in words_query]

        n = len(words_container)
        ind = list(range(n))
        ind.sort(key=lambda it: (len(words_container[it]), it))

        trie = StringTrieSearch(sum(len(s) for s in words_container), n, 26)
        for i in ind:
            word = words_container[i]
            trie.add_ind(word[::-1], i + 1)

        ans = []
        for word in words_query:
            x = trie.search_ind(word[::-1])
            x = x - 1 if x else ind[0]
            ans.append(x)
        return ans

    @staticmethod
    def cf_1980g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1980/problem/G
        tag: binary_trie|bfs|implemention|maximum_xor|classical
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                u, v, w = ac.read_list_ints()
                dct[u - 1].append((v - 1, w))
                dct[v - 1].append((u - 1, w))

            dis = [-1] * n
            path = [0] * n
            stack = [0]
            dis[0] = 0
            while stack:
                nex = []
                for x in stack:
                    for y, w in dct[x]:
                        if dis[y] == -1:
                            dis[y] = dis[x] + 1
                            nex.append(y)
                            path[y] = path[x] ^ w
                stack = nex[:]
            odd_trie = BinaryTrieXor((1 << 32) - 1, n + 1)
            even_trie = BinaryTrieXor((1 << 32) - 1, n + 1)
            tot = 0
            for i in range(n):
                if dis[i] % 2:
                    odd_trie.add(path[i], 1)
                else:
                    even_trie.add(path[i], 1)
            res = []
            for _ in range(m):
                lst = ac.read_list_strs()
                if lst[0] == "^":
                    tot ^= int(lst[1])
                else:
                    v, x = int(lst[1]) - 1, int(lst[2])
                    cur = path[v] ^ x
                    if dis[v] % 2:
                        cur ^= tot
                    ans = -math.inf
                    if dis[v] % 2:
                        odd_trie.remove(path[v], 1)
                    ans = max(ans, odd_trie.get_maximum_xor(cur ^ tot))
                    if dis[v] % 2:
                        odd_trie.add(path[v], 1)
                    if dis[v] % 2 == 0:
                        even_trie.remove(path[v], 1)
                    ans = max(ans, even_trie.get_maximum_xor(cur))
                    if dis[v] % 2 == 0:
                        even_trie.add(path[v], 1)
                    res.append(ans)
            ac.lst(res)
        return

    @staticmethod
    def cf_1055f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1055/F
        tag: binary_trie|get_cnt_smaller_xor|binary_search|tree_xor
        """
        n, k = ac.read_list_ints()  # MLE
        dis = [0] * n
        dct = [[] for _ in range(n)]
        for i in range(n - 1):
            p, w = ac.read_list_ints()
            dct[p - 1].append((i + 1, w))
        stack = [0]
        while stack:
            x = stack.pop()
            for y, w in dct[x]:
                dis[y] = dis[x] ^ w
                stack.append(y)

        trie = BinaryTrieXor(max(dis) + 1, n)
        for num in dis:
            trie.add(num, 1)
        ans = (1 << 62) - 1
        for i in range(61, -1, -1):
            cnt = sum(trie.get_cnt_smaller_xor(x, ans ^ (1 << i)) for x in dis)
            if cnt >= k:
                ans ^= 1 << i
        ac.st(ans)
        return"""
Algorithm：segment_tree|bisect_left
Description：range_sum|range_min|range_add|range_change|range_max|dynamic_segment_tree|defaulteddict

====================================LeetCode====================================

=====================================LuoGu======================================

===================================CodeForces===================================
1093G（https://codeforces.com/contest/1093/problem/G）manhattan_distance|point_set|range_max_min_gap|classical

====================================AtCoder=====================================

=====================================AcWing=====================================

=====================================LibraryChecker=====================================


"""
from src.data_structure.segment_tree.template import PointSetRangeMaxMinGap
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def cf_1093g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1093/problem/G
        tag: point_set|range_max_min_gap|classical
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        pre = [[1]]
        for _ in range(k - 1):
            cur = []
            for p in pre:
                cur.append(p + [1])
                cur.append(p + [-1])
            pre = cur[:]
        m = len(pre)
        assert m == 1 << (k - 1)
        tree = [PointSetRangeMaxMinGap(n) for _ in range(m)]
        for i in range(m):
            ls = pre[i]
            val = [sum(ls[j] * num[j] for j in range(k)) for num in nums]
            tree[i].build(val)
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                i = lst[1] - 1
                nums[i] = lst[2:]
                for x in range(m):
                    val = sum(pre[x][j] * nums[i][j] for j in range(k))
                    tree[x].point_set(i, val)
            else:
                ans = -math.inf
                ll, rr = [w - 1 for w in lst[1:]]
                for i in range(m):
                    cur = tree[i].range_max_min_gap(ll, rr)
                    ans = ans if ans > cur else cur
                ac.st(ans)
        return
"""
Algorithm：bag_dp|group_bag_dp|linear_bag_dp|matrix_bag_dp|limited_bag_dp|fill_table(from past)|refresh_table(update future)|lazy_bag_like|inclusion_exclusion
Description：bag_dp|bin_split|finite|math.infinite|tree_bag_dp

====================================LeetCode====================================
140（https://leetcode.cn/problems/word-break-ii/）bag_dp|specific_plan
956（https://leetcode.cn/problems/tallest-billboard/description/）meet_in_middle|bag_dp
2218（https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/）group_bag_dp
2585（https://leetcode.cn/problems/number-of-ways-to-earn-points/）bag_dp
2189（https://leetcode.cn/problems/number-of-ways-to-build-house-of-cards/）bag_dp
254（https://leetcode.cn/problems/factor-combinations/）bag_dp|mul
377（https://leetcode.cn/problems/factor-combinations/）math.infinite|no_order|bag_dp
1449（https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/）bag_dp
1049（https://leetcode.cn/problems/last-stone-weight-ii/）bag_dp
2742（https://leetcode.cn/problems/painting-the-walls/description/）bag_dp
2518（https://leetcode.cn/problems/number-of-great-partitions/）bag_dp|counter
1155（https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/）group_bag_dp|fill_table|refresh_table
2902（https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/）monotonic_queue|mod|group_bag_dp|prefix_sum|inclusion_exclusion|lazy_bag_like
3287（https://leetcode.cn/problems/find-the-maximum-sequence-value-of-array）bag_dp|brute_force|bit_operation

=====================================LuoGu======================================
P1048（https://www.luogu.com.cn/problem/P1048）bag_dp|finite
P1049（https://www.luogu.com.cn/problem/P1049）bag_dp
P1776（https://www.luogu.com.cn/problem/P1776）matrix_bag_dp|bin_split|monotonic_queue
P1509（https://www.luogu.com.cn/problem/P1509）matrix_bag_dp
P1799（https://www.luogu.com.cn/problem/P1799）matrix_bag_dp
P1566（https://www.luogu.com.cn/problem/P1566）counter|limited|bag_dp
P1794（https://www.luogu.com.cn/problem/P1794）matrix_bag_dp
P1806（https://www.luogu.com.cn/problem/P1806）bag_dp|counter
P1853（https://www.luogu.com.cn/problem/P1853）bag_dp|math.infinite
P1874（https://www.luogu.com.cn/problem/P1874）brute_force|bag_dp
P1977（https://www.luogu.com.cn/problem/P1977）group_bag_dp|finite
P1586（https://www.luogu.com.cn/problem/P1586）group_bag_dp|math.infinite
P1566（https://www.luogu.com.cn/problem/P1566）bag_dp|counter
P1509（https://www.luogu.com.cn/problem/P1509）matrix_bag_dp
P1504（https://www.luogu.com.cn/problem/P1504）bag_dp|finite
P2066（https://www.luogu.com.cn/problem/P2066）group_bag_dp|finite
P2340（https://www.luogu.com.cn/problem/P2340）bag_dp
P2370（https://www.luogu.com.cn/problem/P2370）mst|sort|greedy|bag_dp
P2386（https://www.luogu.com.cn/problem/P2386）bag_dp|counter
P2623（https://www.luogu.com.cn/problem/P2623）bag_dp|finite|bin_split|math.infinite
P1474（https://www.luogu.com.cn/problem/P1474）bag_dp|math.infinite|counter
P1466（https://www.luogu.com.cn/problem/P1466）bag_dp|finite|和counter
P1455（https://www.luogu.com.cn/problem/P1455）union_find|bag_dp|finite|
P1230（https://www.luogu.com.cn/problem/P1230）sort|bag_dp|finite|
P1077（https://www.luogu.com.cn/problem/P1077）bag_dp|finite|counter
P2725（https://www.luogu.com.cn/problem/P2725）bag_dp|math.infinite|counter
P2918（https://www.luogu.com.cn/problem/P2918）bag_dp|math.infinite|
P3027（https://www.luogu.com.cn/problem/P3027）bag_dp|math.infinite
P3030（https://www.luogu.com.cn/problem/P3030）brute_force|group_bag_dp|finite|bag_dp
P3040（https://www.luogu.com.cn/problem/P3040）matrix_bag_dp
P4817（https://www.luogu.com.cn/problem/P4817）bag_dp|finite
P5087（https://www.luogu.com.cn/problem/P5087）matrix_bag_dp
P6205（https://www.luogu.com.cn/problem/P6205）bag_dp|math.infinite
P6389（https://www.luogu.com.cn/problem/P6389）bag_dp|finite
P6567（https://www.luogu.com.cn/problem/P6567）finite|bag_dp|bin_split|classical
P6771（https://www.luogu.com.cn/problem/P6771）sort|bag_dp|finite|bin_split
P2842（https://www.luogu.com.cn/problem/P2842）bag_dp|math.infinite
P2840（https://www.luogu.com.cn/problem/P2840）bag_dp|math.infinite
P2834（https://www.luogu.com.cn/problem/P2834）bag_dp|math.infinite
P1064（https://www.luogu.com.cn/problem/P1064）bag_dp|finite|brute_force|classification_discussion|group_bag_dp
P1156（https://www.luogu.com.cn/problem/P1156）bag_dp|finite
P1273（https://www.luogu.com.cn/problem/P1273）tree|graph|group_bag_dp
P1284（https://www.luogu.com.cn/problem/P1284）brute_force|triangle|math|bag_dp
P1441（https://www.luogu.com.cn/problem/P1441）brute_force|bag_dp
P1537（https://www.luogu.com.cn/problem/P1537）bin_split|bag_dp
P1541（https://www.luogu.com.cn/problem/P1541）brute_force|matrix_dp|fill_table
P1759（https://www.luogu.com.cn/problem/P1759）matrix_bag_dp|lexicographical_order|specific_plan
P1833（https://www.luogu.com.cn/problem/P1833）math.infinite|bag_dp|monotonic_queue|matrix_bag_dp
P2014（https://www.luogu.com.cn/problem/P2014）dag|tree_bag_dp
P2079（https://www.luogu.com.cn/problem/P2079）rolling_hash|bag_dp
P2170（https://www.luogu.com.cn/problem/P2170）union_find|bag_dp|finite|bin_split
P2214（https://www.luogu.com.cn/problem/P2214）bag_dp|greedy
P2306（https://www.luogu.com.cn/problem/P2306）data_range|counter|finite|bin_split
P2320（https://www.luogu.com.cn/problem/P2320）bin_split|greedy|reverse_thinking
P2737（https://www.luogu.com.cn/problem/P2737）math.infinite|bag_dp
P2760（https://www.luogu.com.cn/problem/P2760）monotonic_queue|matrix_bag_dp
P2854（https://www.luogu.com.cn/problem/P2854）bag_dp|group_bag_dp|finite
P2938（https://www.luogu.com.cn/problem/P2938）math.infinite|group_bag_dp
P2979（https://www.luogu.com.cn/problem/P2979）bag_dp|group_bag_dp|finite
P3010（https://www.luogu.com.cn/problem/P3010）bag_dp|heapq
P3423（https://www.luogu.com.cn/problem/P3423）bin_split|matrix_bag_dp|specific_plan|monotonic_queue
P3983（https://www.luogu.com.cn/problem/P3983）math.infinite|bag_dp
P5322（https://www.luogu.com.cn/problem/P5322）matrix_dp|group_bag_dp|classical
P5365（https://www.luogu.com.cn/problem/P5365）bag_dp|math.infinite|brute_force|counter
P5662（https://www.luogu.com.cn/problem/P5662）math.infinite|bag_dp|greedy
P1417（https://www.luogu.com.cn/problem/P1417）greedy|sort|bag_dp
P1489（https://www.luogu.com.cn/problem/P1489）bag_dp|brute_force
P1651（https://www.luogu.com.cn/problem/P1651）linear_dp|brain_teaser|classical
P1687（https://www.luogu.com.cn/problem/P1687）bag_dp
P3861（https://www.luogu.com.cn/problem/P3861）bag_dp|math|num_factor|matrix_dp|classical

===================================CodeForces===================================
577B（https://codeforces.com/problemset/problem/577/B）mod|counter|bin_split|bag_dp
543A（https://codeforces.com/problemset/problem/543/A）matrix_bag_dp
148E（https://codeforces.com/problemset/problem/148/E）bag_dp|finite|brute_force
1433F（https://codeforces.com/problemset/problem/1433/F）bag_dp|finite|brute_force
1657D（https://codeforces.com/contest/1657/problem/D）math.infinite|bag_dp|mul|euler_series|O(nlogn)||binary_search|greedy
1650F（https://codeforces.com/contest/1650/problem/F）bag_dp|reverse_thinking|greedy|specific_plan|classical
1862F（https://codeforces.com/contest/1862/problem/F）bag_dp|brute_force
1974E（https://codeforces.com/contest/1974/problem/E）bag_dp|greedy|data_range|classical
837D（https://codeforces.com/problemset/problem/837/D）matrix_dp|observation|classical|brain_teaser|bag_dp
478D（https://codeforces.com/problemset/problem/478/D）matrix_dp|data_range|implemention|bag_dp
163A（https://codeforces.com/problemset/problem/163/A）bag_dp|matrix_dp|classical
1340B（https://codeforces.com/problemset/problem/1340/B）bag_dp|reverse_order|specific_plan
2000E（https://codeforces.com/problemset/problem/2000/F）brute_force|greedy|bag_dp
366C（https://codeforces.com/problemset/problem/366/C）bag_dp|data_range
864E（https://codeforces.com/problemset/problem/864/E）bag_dp|specific_plan|greedy|observation|classical

====================================AtCoder=====================================
ABC054D（https://atcoder.jp/contests/abc054/tasks/abc054_d）matrix_bag_dp|finite
ABC118D（https://atcoder.jp/contests/abc118/tasks/abc118_d）greedy|bag_dp|specific_plan
ABC145E（https://atcoder.jp/contests/abc145/tasks/abc145_e）brain_teaser|bag_dp|finite|sort|refresh_table
ABC341F（https://atcoder.jp/contests/abc341/tasks/abc341_f）bag_dp|tree_dp|greedy|classical
ABC327E（https://atcoder.jp/contests/abc327/tasks/abc327_e）bag_dp|brute_force
ABC321f（https://atcoder.jp/contests/abc321/tasks/abc321_f）bag_dp|classical
ABC317D（https://atcoder.jp/contests/abc317/tasks/abc317_d）bag_dp|brute_force|classical
ABC257E（https://atcoder.jp/contests/abc257/tasks/abc257_e）bag_dp|greedy
ABC222E（https://atcoder.jp/contests/abc222/tasks/abc222_e）bfs|bag_dp
ABC219D（https://atcoder.jp/contests/abc219/tasks/abc219_d）bag_dp|classical
ABC216F（https://atcoder.jp/contests/abc216/tasks/abc216_f）matrix_dp|bag_dp
ABC204D（https://atcoder.jp/contests/abc204/tasks/abc204_d）bag_dp
ABC200E（https://atcoder.jp/contests/abc200/tasks/abc200_e）bag_dp|counter|prefix_sum
ABC200D（https://atcoder.jp/contests/abc200/tasks/abc200_d）bag_dp|specific_plan
ABC373F（https://atcoder.jp/contests/abc373/tasks/abc373_f）bag_dp|heapq|greedy|brain_teaser

=====================================AcWing=====================================
4（https://www.acwing.com/problem/content/4/）bin_split|matrix_bag_dp
6（https://www.acwing.com/problem/content/description/6/）monotonic_queue|matrix_bag_dp
7（https://www.acwing.com/problem/content/7/）bag_dp|finite|math.infinite|matrix_bag_dp
8（https://www.acwing.com/problem/content/8/）matrix_bag_dp|finite
9（https://www.acwing.com/problem/content/9/）bag_dp|group_bag_dp|finite
10（https://www.acwing.com/problem/content/10/）tree_bag_dp
11（https://www.acwing.com/problem/content/description/11/）bag_dp|counter|specific_plan
12（https://www.acwing.com/problem/content/12/）bag_dp|specific_plan
4081（https://www.acwing.com/problem/content/4084/）matrix_bag_dp

"""
import bisect
from collections import defaultdict, deque, Counter
from functools import lru_cache
from heapq import heapify, heappop, heappush
from itertools import combinations
from typing import List

from src.dp.bag_dp.template import BagDP
from src.graph.union_find.template import UnionFind
from src.mathmatics.number_theory.template import NumFactor
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1433f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1433/F
        tag: bag_dp|finite|brute_force
        """
        m, n, k = ac.read_list_ints()
        pre = [-math.inf] * k
        pre[0] = 0
        x = n // 2
        for _ in range(m):
            nums = ac.read_list_ints()
            dp = [[-math.inf] * k for _ in range(x + 1)]
            dp[0][0] = 0
            for num in nums:
                nex = [ls[:] for ls in dp]
                for i in range(x):
                    for j in range(k):
                        d = (j + num) % k
                        nex[i + 1][d] = max(dp[i][j] + num, nex[i + 1][d])
                dp = [ls[:] for ls in nex]
            tmp = [max(dp[i][j] for i in range(x + 1)) for j in range(k)]

            cur = pre[:]
            for i in range(k):
                for j in range(k):
                    cur[(i + j) % k] = max(cur[(i + j) % k], pre[i] + tmp[j])
            pre = cur[:]

        ac.st(pre[0])
        return

    @staticmethod
    def cf_543a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/543/A
        tag: matrix_bag_dp
        """
        n, m, b, mod = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre = [[0] * (b + 1) for _ in range(m + 1)]
        pre[0][0] = 1
        for num in nums:
            for i in range(1, m + 1):
                for j in range(num, b + 1):
                    pre[i][j] = (pre[i][j] + pre[i - 1][j - num]) % mod
        ac.st(sum(pre[m]) % mod)
        return

    @staticmethod
    def cf_577b(m, nums):
        """
        url: https://codeforces.com/problemset/problem/577/B
        tag: mod|counter|bin_split|bag_dp
        """
        cnt = [0] * m
        for num in nums:
            cnt[num % m] += 1
        if cnt[0] or max(cnt) >= m:
            return "YES"
        pre = [0] * m
        for i in range(1, m):
            if cnt[i]:
                for x in BagDP().bin_split_1(cnt[i]):
                    cur = pre[:]
                    y = (x * i) % m
                    cur[y] = 1
                    for j in range(m):
                        if pre[j]:
                            cur[(j + y) % m] = 1
                    pre = cur[:]
                if pre[0]:
                    return "YES"
        return "NO"

    @staticmethod
    def lc_2218(piles: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/
        tag: group_bag_dp
        """
        cur = [0] * (k + 1)
        for lst in piles:
            n = len(lst)
            pre = [0] * (n + 1)
            for i in range(n):
                pre[i + 1] = pre[i] + lst[i]

            nex = cur[:]
            for j in range(1, k + 1):
                for x in range(min(n + 1, j + 1)):
                    nex[j] = max(nex[j], cur[j - x] + pre[x])
            cur = nex[:]
        return cur[-1]

    @staticmethod
    def lg_p6567(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6567
        tag: finite|bag_dp|bin_split|classical
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        target = ac.read_list_ints()
        ceil = max(target)
        dp = [0] * (ceil + 1)
        dp[0] = 1
        for k, a in nums:
            for b in BagDP().bin_split_1(a):
                x = b * k
                for i in range(ceil, x - 1, -1):
                    if dp[i - x]:
                        dp[i] = 1
        for t in target:
            if dp[t]:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def lc_2742_1(cost: List[int], time: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/painting-the-walls/description/
        tag: bag_dp
        """

        @lru_cache(None)
        def dfs(i, pre):
            if pre >= n - i:
                return 0
            if i == n:
                return math.inf
            res = dfs(i + 1, pre - 1)
            cur = dfs(i + 1, pre + time[i]) + cost[i]
            if cur < res:
                res = cur
            return res

        n = len(cost)
        return dfs(0, 0)

    @staticmethod
    def lc_2742_2(cost: List[int], time: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/painting-the-walls/description/
        tag: bag_dp
        """
        n = len(cost)
        dp = [sum(time)] * (n + 1)
        dp[0] = 0
        for i in range(n):
            c, t = cost[i], time[i]
            for j in range(n, -1, -1):
                s = j - t - 1 if j - t - 1 >= 0 else 0
                if dp[s] + c < dp[j]:
                    dp[j] = dp[s] + c
        return dp[-1]

    @staticmethod
    def lc_2518(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-great-partitions/
        tag: bag_dp|counter
        """
        mod = 10 ** 9 + 7
        dp = [0] * k
        s = sum(nums)
        if s < 2 * k:
            return 0
        dp[0] = 1
        n = len(nums)
        for num in nums:
            for i in range(k - 1, num - 1, -1):
                dp[i] += dp[i - num]
        ans = pow(2, n, mod)
        ans -= 2 * sum(dp)
        return ans % mod

    @staticmethod
    def lc_2585(target: int, types: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-earn-points/
        tag: bag_dp
        """
        mod = 10 ** 9 + 7
        n = len(types)
        pre = [0] * (target + 1)
        pre[0] = 1
        for i in range(n):
            c, m = types[i]
            cur = pre[:]
            for x in range(1, c + 1):
                for j in range(target - x * m + 1):
                    if x * m + j <= target:
                        cur[x * m + j] += pre[j]
            pre = [num % mod for num in cur]
        return pre[-1]

    @staticmethod
    def cf_1657d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1657/problem/D
        tag: math.infinite|bag_dp|mul|euler_series|O(nlogn)||binary_search|greedy
        """
        n, c = ac.read_list_ints()
        dp = [0] * (c + 1)
        for _ in range(n):
            cc, dd, hh = ac.read_list_ints()
            dp[cc] = max(dp[cc], dd * hh)

        for i in range(1, c + 1):
            dp[i] = max(dp[i], dp[i - 1])
            x = dp[i]
            for y in range(i * 2, c + 1, i):
                dp[y] = max(dp[y], x * (y // i))

        ans = []
        for _ in range(ac.read_int()):
            h, d = ac.read_list_ints()
            if h * d >= dp[c]:
                ans.append(-1)
            else:
                ans.append(bisect.bisect_right(dp, h * d))
        ac.lst(ans)
        return

    @staticmethod
    def lc_254(n: int) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/factor-combinations/
        tag: bag_dp|mul
        """
        lst = NumFactor().get_all_factor(n)
        m = len(lst)
        dp = defaultdict(list)
        dp[1] = [[]]
        for i in range(1, m - 1):
            for j in range(i, m):
                if lst[j] % lst[i] == 0:
                    x = lst[j] // lst[i]
                    for p in dp[x]:
                        dp[lst[j]].append(p + [lst[i]])
        return [ls for ls in dp[n] if ls]

    @staticmethod
    def abc_118d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc118/tasks/abc118_d
        tag: greedy|bag_dp|specific_plan
        """
        score = [2, 5, 5, 4, 5, 6, 3, 7, 6]
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums.sort(reverse=True)
        dp = [-math.inf] * (n + 1)
        dp[0] = 0
        for num in nums:
            val = score[num - 1]
            for i in range(val, n + 1):
                if dp[i - val] + 1 > dp[i]:
                    dp[i] = dp[i - val] + 1
        ans = []
        i = n
        while i:
            for num in nums:
                val = score[num - 1]
                if i >= val and dp[i] == dp[i - val] + 1:
                    ans.append(num)
                    i -= val
                    break
        ans.sort(reverse=True)
        ac.st("".join(str(x) for x in ans))
        return

    @staticmethod
    def abc_145e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc145/tasks/abc145_e
        tag: brain_teaser|bag_dp|finite|sort|refresh_table
        """
        n, t = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort()
        dp = [0] * (t + 3010)
        for x, y in nums:
            for i in range(t - 1, -1, -1):
                if dp[i] + y > dp[i + x]:
                    dp[i + x] = dp[i] + y
        ac.st(max(dp))
        return

    @staticmethod
    def ac_6(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/6/
        tag: monotonic_queue|matrix_bag_dp|classical|classical
        """
        n, m = ac.read_list_ints()
        dp = [0] * (m + 1)
        for _ in range(n):
            # value weight number
            v, w, s = ac.read_list_ints()
            for r in range(v):
                stack = deque()
                for i in range(r, m + 1, v):
                    while stack and stack[0][0] < i - s * v:
                        stack.popleft()
                    while stack and stack[-1][1] + (i - stack[-1][0]) // v * w <= dp[i]:
                        stack.pop()
                    stack.append([i, dp[i]])
                    dp[i] = stack[0][1] + (i - stack[0][0]) // v * w
        ac.st(dp[-1])
        return

    @staticmethod
    def ac_10(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/10/
        tag: tree_bag_dp|classical
        """
        n, m = ac.read_list_ints()
        vol = []
        weight = []
        parent = [-1] * n
        dct = [[] for _ in range(n)]
        root = 0
        for i in range(n):
            v, w, p = ac.read_list_ints()
            p -= 1
            parent[i] = p
            if p != -2:
                dct[p].append(i)
            else:
                root = i
            vol.append(v)
            weight.append(w)

        stack = [root]
        sub = [[0] * (m + 1) for _ in range(n)]
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                for j in dct[i]:
                    stack.append(j)
            else:
                i = ~i
                sub[i][vol[i]] = weight[i]
                for j in dct[i]:
                    cur = sub[i][:]
                    for x in range(vol[i], m + 1):
                        for y in range(m + 1 - x):
                            cur[x + y] = max(cur[x + y], sub[i][x] + sub[j][y])
                    sub[i] = cur[:]
        ac.st(max(sub[root]))
        return

    @staticmethod
    def ac_11(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/11/
        tag: bag_dp|counter|specific_plan
        """
        n, m = ac.read_list_ints()
        dp = [0] * (m + 1)
        cnt = [1] * (m + 1)
        mod = 10 ** 9 + 7
        for _ in range(n):
            v, w = ac.read_list_ints()
            for i in range(m, v - 1, -1):
                if dp[i - v] + w > dp[i]:
                    dp[i] = dp[i - v] + w
                    cnt[i] = cnt[i - v]
                elif dp[i - v] + w == dp[i]:
                    cnt[i] += cnt[i - v]
                    cnt[i] %= mod
        ac.st(cnt[-1])
        return

    @staticmethod
    def ac_12_1(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/12/
        tag: bag_dp|specific_plan|finite|lexicographical_order
        """
        n, m = ac.read_list_ints()
        dp = [[0] * (m + 1) for _ in range(n + 1)]
        nums = [ac.read_list_ints() for _ in range(n)]

        for i in range(n - 1, -1, -1):
            v, w = nums[i]
            for j in range(m, -1, -1):
                dp[i][j] = dp[i + 1][j]
                if j >= v and dp[i + 1][j - v] + w > dp[i][j]:
                    dp[i][j] = dp[i + 1][j - v] + w

        j = m
        path = []
        for i in range(n):
            v, w = nums[i]
            if j >= v and dp[i][j] == dp[i + 1][j - v] + w:
                j -= v
                path.append(i + 1)
        ac.lst(path)
        return

    @staticmethod
    def ac_12_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/12/
        tag: bag_dp|specific_plan|finite
        """
        n, m = ac.read_list_ints()
        dp = [[0, [-1]] for _ in range(m + 1)]
        for ind in range(n):
            v, w = ac.read_list_ints()
            for i in range(m, v - 1, -1):
                if dp[i - v][0] + w > dp[i][0] or (
                        dp[i - v][0] + w == dp[i][0] and dp[i - v][1] + [ind + 1] < dp[i][1]):
                    dp[i] = [dp[i - v][0] + w, dp[i - v][1] + [ind + 1]]
        ac.lst(dp[-1][1][1:])
        return

    @staticmethod
    def lg_p1064(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1064
        tag: bag_dp|finite|brute_force|classification_discussion|group_bag_dp
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(m)]
        sub = [[] for _ in range(m)]
        for i in range(m):
            v, p, q = ac.read_list_ints()
            if q == 0:
                dct[i].append([v, p])
            else:
                sub[q - 1].append([v, p])
        dp = [[0] * (n + 1) for _ in range(2)]
        pre = 0
        for i in range(m):
            if dct[i]:
                cur = 1 - pre
                dp[cur] = dp[pre][:]
                x = len(sub[i])
                for j in range(1 << x):
                    lst = dct[i] + [sub[i][k] for k in range(x) if j & (1 << k)]
                    gain = sum(v * p for v, p in lst)
                    cost = sum(v for v, _ in lst)
                    for xx in range(n, cost - 1, -1):
                        dp[cur][xx] = max(
                            dp[cur][xx], dp[pre][xx - cost] + gain)
                pre = cur
        ac.st(dp[pre][-1])
        return

    @staticmethod
    def lg_p1156(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1156
        tag: bag_dp|finite
        """
        n, m = ac.read_list_ints()

        dct = [ac.read_list_ints() for _ in range(m)]
        dct.sort(key=lambda it: it[0])

        dp = [-math.inf] * (n + 1)  # dp[height]=life
        dp[0] = 10
        for t, f, h in dct:
            if dp[0] < t:
                ac.st(dp[0])
                return
            for i in range(n, -1, -1):
                if dp[i] >= t:
                    if i + h >= n:
                        ac.st(t)
                        return
                    if i + h <= n:
                        dp[i + h] = max(dp[i + h], dp[i])
                    dp[i] += f
        ac.st(dp[0])
        return

    @staticmethod
    def lg_p1273(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1273
        tag: tree|graph|group_bag_dp
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for j in range(n - m):
            lst = ac.read_list_ints()
            for i in range(1, len(lst), 2):
                dct[j].append([lst[i] - 1, lst[i + 1]])
        nums = [0] * (n - m) + ac.read_list_ints()
        sub = [[] for _ in range(n)]
        stack = [0]
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                for j, _ in dct[i]:
                    stack.append(j)
            else:
                i = ~i
                sub[i].append(0)
                if i >= n - m:
                    sub[i].append(nums[i])
                    continue

                for j, cost in dct[i]:
                    cur = sub[i][:]
                    for k1 in range(m + 1):
                        if k1 >= len(sub[i]):
                            break
                        for k2 in range(m - k1 + 1):
                            if k2 >= len(sub[j]):
                                break
                            if len(cur) < k1 + k2 + 1:
                                cur.extend([-math.inf] * (k1 + k2 + 1 - len(cur)))
                            cur[k1 + k2] = max(cur[k1 + k2], sub[j][k2] + sub[i][k1] - cost)
                    sub[j] = []
                    sub[i] = cur[:]
        for x in range(m, -1, -1):
            if x < len(sub[0]) and sub[0][x] >= 0:
                ac.st(x)
                return
        ac.st(0)
        return

    @staticmethod
    def lg_p1284(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1284
        tag: brute_force|triangle|math|bag_dp|classical|hard
        """
        n = ac.read_int()

        def check():
            ss = (a + b + c) / 2
            return (ss * (ss - a) * (ss - b) * (ss - c)) ** 0.5

        def idx(i1, j1):
            return i1 * (s // 2 + 1) + j1

        nums = []
        while len(nums) < n:
            nums.extend(ac.read_list_ints())

        s = sum(nums)
        dp = [0] * (s // 2 + 1) * (s // 2 + 1)
        dp[0] = 1
        for num in nums:
            for i in range(s // 2, -1, -1):
                for j in range(s // 2, -1, -1):
                    if j >= num and dp[idx(i, j - num)]:
                        dp[idx(i, j)] = 1
                    if i >= num and dp[idx(i - num, j)]:
                        dp[idx(i, j)] = 1
        ans = -1
        for a in range(s // 2 + 1):
            for b in range(s // 2 + 1):
                if dp[idx(a, b)]:
                    c = s - a - b
                    if b + c > a > 0 and a + c > b > 0 and a + b > c > 0:
                        cur = check()
                        ans = max(ans, cur)
        if ans == -1:
            ac.st(ans)
        else:
            ac.st(int(ans * 100))
        return

    @staticmethod
    def lg_p1441(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1441
        tag: brute_force|bag_dp
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        ans = 0
        s = sum(a)
        for item in combinations(a, n - m):
            dp = [0] * (s + 1)
            dp[0] = 1
            for num in item:
                for i in range(s, num - 1, -1):
                    if dp[i - num]:
                        dp[i] = 1
            cur = sum(dp) - 1
            ans = max(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1537(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1537
        tag: bin_split|bag_dp
        """
        case = 0
        while True:
            lst = ac.read_list_ints()
            if sum(lst) == 0:
                break

            case += 1
            ac.st(f"Collection #{case}:")
            s = sum(lst[i] * (i + 1) for i in range(6))
            if s % 2:
                ac.st("Can't be divided.")
                ac.st("")
                continue

            m = s // 2
            dp = [0] * (m + 1)
            dp[0] = 1
            for x in range(6):
                w, s = x + 1, lst[x]
                if s:
                    for num in BagDP().bin_split_1(s):
                        for i in range(m, w * num - 1, -1):
                            if dp[i - num * w]:
                                dp[i] = 1
            if dp[-1]:
                ac.st("Can be divided.")
            else:
                ac.st("Can't be divided.")
            ac.st("")
        return

    @staticmethod
    def lg_p1541(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1541
        tag: brute_force|matrix_dp|fill_table
        """

        def idx(i1, i2, i3, i4):
            return i1 * (b + 1) * (c + 1) * (d + 1) + i2 * (c + 1) * (d + 1) + i3 * (d + 1) + i4

        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        cnt = Counter(ac.read_list_ints())
        a, b, c, d = cnt[1], cnt[2], cnt[3], cnt[4]
        dp = [0] * (a + 1) * (b + 1) * (c + 1) * (d + 1)
        dp[0] = nums[0]
        ans = 0
        for i in range(a + 1):
            for j in range(b + 1):
                for k in range(c + 1):
                    for p in range(d + 1):
                        if i + 2 * j + 3 * k + 4 * p <= n - 1:
                            pre = 0
                            if i:
                                pre = max(pre, dp[idx(i - 1, j, k, p)])
                            if j:
                                pre = max(pre, dp[idx(i, j - 1, k, p)])
                            if k:
                                pre = max(pre, dp[idx(i, j, k - 1, p)])
                            if p:
                                pre = max(pre, dp[idx(i, j, k, p - 1)])
                            dp[idx(i, j, k, p)] = max(dp[idx(i, j, k, p)],
                                                         pre + nums[i + 2 * j + 3 * k + 4 * p])
                        if i + 2 * j + 3 * k + 4 * p == n - 1:
                            ans = max(ans, dp[idx(i, j, k, p)])
        ac.st(ans)
        return

    @staticmethod
    def lg_p1759(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1759
        tag: matrix_bag_dp|lexicographical_order|specific_plan
        """
        m, v, n = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        dp = [[[0, []] for _ in range(v + 1)] for _ in range(m + 1)]
        for i in range(n):
            a, b, c = nums[i]
            for j in range(m, a - 1, -1):
                for k in range(v, b - 1, -1):
                    t, p = dp[j - a][k - b]
                    if dp[j][k][0] < t + c or (dp[j][k][0] == t + c and p + [i + 1] < dp[j][k][1]):
                        dp[j][k] = [t + c, p + [i + 1]]
        ans1, ans2 = dp[m][v]
        ac.st(ans1)
        ac.lst(ans2)
        return

    @staticmethod
    def lg_p1776(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1776
        tag: matrix_bag_dp|bin_split|monotonic_queue|classical
        """
        n, m = ac.read_list_ints()
        dp = [0] * (m + 1)
        for _ in range(n):
            a, b, c = ac.read_list_ints()
            v, w, s = b, a, c
            for r in range(v):
                stack = deque()
                for i in range(r, m + 1, v):
                    while stack and stack[0][0] < i - s * v:
                        stack.popleft()
                    while stack and stack[-1][1] + (i - stack[-1][0]) // v * w <= dp[i]:
                        stack.pop()
                    stack.append([i, dp[i]])
                    dp[i] = stack[0][1] + (i - stack[0][0]) // v * w
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p1799(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1799
        tag: matrix_bag_dp
        """
        n = ac.read_int()
        if not n:
            ac.st(0)
            return
        nums = ac.read_list_ints()
        dp = [[-math.inf] * (n + 1) for _ in range(n)]
        dp[0][0] = 0
        dp[0][1] = 1 if nums[0] == 1 else 0
        for i in range(1, n):
            dp[i][0] = 0
            for j in range(1, i + 2):
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + int(nums[i] == j))
        ac.st(max(dp[n - 1]))
        return

    @staticmethod
    def lg_p1833(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1833
        tag: math.infinite|bag_dp|monotonic_queue|matrix_bag_dp|classical
        """

        def check(st):
            hh, mm = st.split(":")
            return int(hh) * 60 + int(mm)

        s, e, n = ac.read_list_strs()
        t = check(e) - check(s)
        dp = [0] * (t + 1)
        for _ in range(int(n)):
            tt, cc, p = ac.read_list_ints()
            if not p:
                for i in range(tt, t + 1):
                    dp[i] = max(dp[i], dp[i - tt] + cc)
            else:
                v, w, s = tt, cc, p
                for r in range(v):
                    stack = deque()
                    for i in range(r, t + 1, v):
                        while stack and stack[0][0] < i - s * v:
                            stack.popleft()
                        while stack and stack[-1][1] + (i - stack[-1][0]) // v * w <= dp[i]:
                            stack.pop()
                        stack.append([i, dp[i]])
                        dp[i] = stack[0][1] + (i - stack[0][0]) // v * w
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p2014(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2014
        tag: dag|tree_bag_dp
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        nums = [0]
        for i in range(n):
            k, s = ac.read_list_ints()
            nums.append(s)
            dct[k].append(i + 1)
        dp = [[0] * (m + 2) for _ in range(n + 1)]
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                dp[i][1] = nums[i]
                for j in dct[i]:
                    if j != fa:
                        cur = dp[i][:]
                        for x in range(m + 2):
                            for y in range(m + 2 - x):
                                cur[x + y] = max(cur[x + y], dp[i][x] + dp[j][y])
                        dp[i] = cur[:]
        ac.st(dp[0][m + 1])
        return

    @staticmethod
    def lg_p2079(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2079
        tag: rolling_hash|bag_dp|classical
        """
        n, v = ac.read_list_ints()
        dp = [defaultdict(lambda: defaultdict(lambda: -math.inf)), defaultdict(lambda: defaultdict(lambda: -math.inf))]
        pre = 0
        dp[pre][0][0] = 0
        for i in range(n):
            c, x, y = ac.read_list_ints()
            cur = 1 - pre
            for c1 in dp[pre]:
                for x1 in dp[pre][c1]:
                    if c1 + c <= v:
                        dp[cur][c1 + c][x1 + x] = max(dp[cur][c1 + c][x1 + x], dp[pre][c1][x1] + y)
                    dp[cur][c1][x1] = max(dp[cur][c1][x1], dp[pre][c1][x1])
            pre = cur
        ans = -math.inf
        for c1 in dp[pre]:
            for x1 in dp[pre][c1]:
                if x1 >= 0:
                    ans = max(ans, dp[pre][c1][x1])
        ac.st(ans)
        return

    @staticmethod
    def lg_p2170(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2170
        tag: union_find|bag_dp|finite|bin_split
        """
        n, m, k = ac.read_list_ints()
        uf = UnionFind(n)
        for _ in range(k):
            i, j = ac.read_list_ints_minus_one()
            uf.union(i, j)
        dct = defaultdict(int)
        for i in range(n):
            dct[uf.find(i)] += 1
        lst = list(dct.values())
        del uf

        target = min(2 * m, n)
        dp = [0] * (target + 1)
        dp[0] = 1
        cnt = Counter(lst)
        for num in cnt:
            for x in BagDP().bin_split_1(cnt[num]):
                for i in range(target, x * num - 1, -1):
                    if dp[i - x * num]:
                        dp[i] = 1
        ans = 0
        for i in range(1, target + 1):
            if dp[i] and abs(i - m) < abs(ans - m):
                ans = i
        ac.st(ans)
        return

    @staticmethod
    def lg_p2214(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2214
        tag: bag_dp|greedy
        """
        n, b = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(b)]
        voice = [ac.read_int() for _ in range(n)]

        for i in range(n - 1, 0, -1):
            if voice[i - 1] > 0:
                voice[i] -= voice[i - 1] - 1
        ceil = max(voice)
        if any(v < 0 for v in voice):
            ac.st(-1)
            return

        dp = [math.inf] * (ceil + 1)
        dp[0] = 0
        for num in nums:
            for i in range(num, ceil + 1):
                dp[i] = min(dp[i - num] + 1, dp[i])
        ans = sum(dp[x] for x in voice)
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p2306(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2306
        tag: data_range|counter|finite|bin_split
        """
        n, m, k = ac.read_list_ints()
        cnt = defaultdict(lambda: defaultdict(int))
        for _ in range(n):
            a, b = ac.read_list_ints()
            cnt[a][b] += 1
        dp = [0] * (m + 1)
        for a in cnt:
            for b in cnt[a]:
                for x in BagDP().bin_split_1(cnt[a][b]):
                    for i in range(m, x * a - 1, -1):
                        dp[i] = max(dp[i], dp[i - x * a] + x * b)
        ans = max(dp)
        if ans >= k:
            ac.yes()
        else:
            ac.no()
        ac.st(ans)
        return

    @staticmethod
    def lg_p2320(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2320
        tag: bin_split|greedy|reverse_thinking
        """
        m = ac.read_int()
        ans = []
        while m:
            ans.append((m + 1) // 2)
            m //= 2
        ac.st(len(ans))
        ac.st(*ans[::-1])
        return

    @staticmethod
    def lg_p2737(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2737
        tag: math.infinite|bag_dp
        """
        n = ac.read_int()
        ceil = 256 ** 2 + 1
        nums = [ac.read_int() for _ in range(n)]
        dp = [0] * (ceil + 1)
        dp[0] = 1
        for i in range(1, ceil + 1):
            for num in nums:
                if i >= num and dp[i - num]:
                    dp[i] = 1
        ans = 0
        for i in range(1, ceil + 1):
            if not dp[i]:
                ans = i
        ac.st(ans if ans < ceil else 0)
        return

    @staticmethod
    def lg_p2760(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2760
        tag: monotonic_queue|matrix_bag_dp|classical
        """
        m, n, p, t = ac.read_list_ints()
        rest = min(p, t - 1)
        dp = [0] * (rest + 1)
        grid = [ac.read_list_ints() for _ in range(m)]
        mat = [ac.read_list_ints() for _ in range(m)]
        for a in range(m):
            for b in range(n):
                if grid[a][b]:
                    v, w, s = (a + 1 + b + 1) * 2, grid[a][b], mat[a][b]
                    for r in range(v):
                        stack = deque()
                        for i in range(r, rest + 1, v):
                            while stack and stack[0][0] < i - s * v:
                                stack.popleft()
                            while stack and stack[-1][1] + (i - stack[-1][0]) // v * w <= dp[i]:
                                stack.pop()
                            stack.append([i, dp[i]])
                            dp[i] = stack[0][1] + (i - stack[0][0]) // v * w
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p2854(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2854
        tag: bag_dp|group_bag_dp|finite
        """
        length, n, b = ac.read_list_ints()
        dp = [[-math.inf] * (b + 1) for _ in range(length + 1)]
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort()
        for x, w, f, c in nums:
            if x == 0:
                if c <= b:
                    dp[x + w][c] = max(dp[x + w][c], f)
            else:
                for i in range(b + 1):
                    if i + c <= b and x + w <= length:
                        dp[x + w][i + c] = max(dp[x + w][i + c], dp[x][i] + f)
        ans = max(dp[length])
        ac.st(ans if ans > -math.inf else -1)
        return

    @staticmethod
    def lg_p2938(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2938
        tag: math.infinite|group_bag_dp
        """
        s, d, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(s)]
        for i in range(1, d):
            dp = [0] * (m + 1)
            for j in range(s):
                a, b = nums[j][i - 1], nums[j][i]
                if b > a:
                    for p in range(a, m + 1):
                        dp[p] = max(dp[p], dp[p - a] + b)
            m = max(m - i + dp[i] for i in range(m + 1))
        ac.st(m)
        return

    @staticmethod
    def lg_p2979(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2979
        tag: bag_dp|group_bag_dp|finite
        """
        n, t, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        m = 5 * t // 4 + 1

        dp1 = [0] * (m + 1)
        for v, h in nums:
            for i in range(h, m + 1):
                if dp1[i - h] + v > dp1[i]:
                    dp1[i] = dp1[i - h] + v
        ans = dp1[t]
        for v, h in nums:
            if h >= k:
                for i in range(t, h - 1, -1):
                    ans = max(ans, dp1[(i - h) * 5 // 4] + v)
        ac.st(ans)
        return

    @staticmethod
    def lg_p3010(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3010
        tag: bag_dp|heapq|specific_plan
        """
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        s = sum(nums)
        mod = 10 ** 6

        t = s // 2
        dp = [0] * (t + 1)
        dp[0] = 1
        cnt = [0] * (t + 1)
        cnt[0] = 1
        for num in nums:
            for i in range(t, num - 1, -1):
                if dp[i - num]:
                    dp[i] = 1
                    cnt[i] += cnt[i - num]
                    cnt[i] %= mod

        for i in range(t, -1, -1):
            if dp[i]:
                ac.st(s - 2 * i)
                ac.st(cnt[i])
                break
        return

    @staticmethod
    def lg_p3423_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3423
        tag: bin_split|matrix_bag_dp|specific_plan
        """
        n = ac.read_int()  # MLE
        b = ac.read_list_ints()
        c = ac.read_list_ints()
        k = ac.read_int()
        dp = [math.inf] * (k + 1)
        dp[0] = 0
        state = [[] for _ in range(k + 1)]
        for j in range(n):
            bb, cc = b[j], c[j]
            for x in BagDP().bin_split_1(cc):
                for i in range(k, x * bb - 1, -1):
                    if dp[i - x * bb] + x < dp[i]:
                        dp[i] = dp[i - x * bb] + x
                        state[i] = state[i - x * bb][:] + [[bb, x]]
        cnt = defaultdict(int)
        for bb, xx in state[k]:
            cnt[bb] += xx
        ac.st(dp[k])
        ac.lst([cnt[bb] for bb in b])
        return

    @staticmethod
    def lg_p3423_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3423
        tag: bin_split|matrix_bag_dp|specific_plan|monotonic_queue
        """
        n = ac.read_int()

        vv = ac.read_list_ints()
        ss = ac.read_list_ints()
        m = ac.read_int()
        dp = [math.inf] * (m + 1)
        dp[0] = 0
        pre = [[0] * (m + 1) for _ in range(n)]
        for j in range(n):
            v, w, s = vv[j], 1, ss[j]
            for r in range(v):
                stack = deque()
                for i in range(r, m + 1, v):
                    while stack and stack[0][0] < i - s * v:
                        stack.popleft()
                    while stack and stack[-1][1] + (i - stack[-1][0]) // v * w >= dp[i]:
                        stack.pop()
                    stack.append([i, dp[i]])
                    dp[i] = stack[0][1] + (i - stack[0][0]) // v * w
                    pre[j][i] = (i - stack[0][0]) // v
        ac.st(dp[-1])
        cnt = [0] * n
        res = m
        for j in range(n - 1, -1, -1):
            x = pre[j][res]
            cnt[j] += x
            res -= x * vv[j]
        ac.lst(cnt)
        return

    @staticmethod
    def lg_p3983(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3983
        tag: math.infinite|bag_dp
        """
        n = ac.read_int()
        m = 10
        a = [0] + ac.read_list_ints()
        for i in range(1, m + 1):
            for j in range(i + 1):
                a[i] = max(a[i], a[j] + a[i - j])

        cost = [0] + [1, 3, 5, 7, 9, 10, 11, 14, 15, 17]
        dp = [0] * (n + 1)
        for i in range(1, m + 1):
            for j in range(i, n + 1):
                dp[j] = max(dp[j], dp[j - i] + a[i] - cost[i])
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p5322(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5322
        tag: matrix_dp|group_bag_dp|classical
        """
        s, n, m = ac.read_list_ints()  # TLE
        grid = [ac.read_list_ints() for _ in range(s)]
        dp = [0] * (m + 1)
        for i in range(n):
            lst = [grid[x][i] for x in range(s)]
            lst.sort()
            for j in range(m, -1, -1):
                for ind, w in enumerate(lst):
                    if j <= w * 2:
                        break
                    dp[j] = max(dp[j], dp[j - 2 * w - 1] + (ind + 1) * (i + 1))
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p5365(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5365
        tag: bag_dp|math.infinite|brute_force|counter
        """
        n, m = ac.read_list_ints()
        kk = ac.read_list_ints()
        cc = ac.read_list_ints()
        s = sum(kk[i] * cc[i] for i in range(n))
        dp = [0] * (s + 1)
        dp[0] = 1
        for i in range(n):
            k, c = kk[i], cc[i]
            for x in range(s, -1, -1):
                for p in range(1, k + 1):
                    if x < p * c:
                        break
                    dp[x] = max(dp[x], dp[x - p * c] * p)
        for i in range(s + 1):
            if dp[i] >= m:
                ac.st(i)
                break
        return

    @staticmethod
    def lg_p5662(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5662
        tag: math.infinite|bag_dp|greedy
        """
        t, n, m = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(t)]
        for i in range(1, t):
            dp = [0] * (m + 1)
            for j in range(n):
                b, a = grid[i][j], grid[i - 1][j]
                if b > a:
                    for x in range(a, m + 1):
                        dp[x] = max(dp[x], dp[x - a] + b)
            m = max(m - i + dp[i] for i in range(m + 1))
        ac.st(m)
        return

    @staticmethod
    def lg_p1417(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1417
        tag: greedy|sort|bag_dp
        """
        t, n = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        c = ac.read_list_ints()
        dp = [0] * (t + 1)
        ind = list(range(n))
        ind.sort(key=lambda it: -b[it] / c[it])
        for i in ind:
            aa, bb, cc = a[i], b[i], c[i]
            for j in range(t, cc - 1, -1):
                dp[j] = max(dp[j], dp[j - cc] + aa - j * bb)
        ac.st(max(dp))
        return

    @staticmethod
    def ac_4081(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4084/
        tag: matrix_bag_dp
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()

        def check2(xx):
            res = 0
            while xx % 2 == 0:
                res += 1
                xx //= 2
            return res

        def check5(xx):
            res = 0
            while xx % 5 == 0:
                res += 1
                xx //= 5
            return res

        cnt2 = [check2(num) for num in nums]
        cnt5 = [check5(num) for num in nums]

        s5 = sum(cnt5)
        dp = [[-math.inf] * (s5 + 1) for _ in range(k + 1)]
        dp[0][0] = 0
        for i in range(n):
            a2 = cnt2[i]
            a5 = cnt5[i]
            for j in range(k, 0, -1):
                for p in range(s5, a5 - 1, -1):
                    x, y = dp[j][p], dp[j - 1][p - a5] + a2
                    if y > x:
                        dp[j][p] = y
        ans = 0
        for a5 in range(s5 + 1):
            cur = min(dp[k][a5], a5)
            if cur > ans:
                ans = cur
        ac.st(ans)
        return

    @staticmethod
    def lc_2902(nums: List[int], ll: int, r: int) -> int:
        """
        url: https://leetcode.cn/problems/count-of-sub-multisets-with-bounded-sum/
        tag: monotonic_queue|mod|group_bag_dp|prefix_sum|inclusion_exclusion|lazy_bag_like
        """
        cnt = Counter(nums)
        mod = 10 ** 9 + 7
        dp = [0] * (r + 1)
        dp[0] = 1
        for num in cnt:
            if num:
                c = cnt[num]
                for i in range(num):
                    pre = [0]
                    x = 0
                    for j in range(i, r + 1, num):
                        val = pre[-1] + dp[j]
                        dp[j] += pre[x]
                        if x - c >= 0:
                            dp[j] -= pre[x - c]
                        dp[j] %= mod
                        pre.append(val % mod)
                        x += 1
        return sum(dp[ll:]) * (cnt[0] + 1) % mod

    @staticmethod
    def lc_1049(stones: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/last-stone-weight-ii/
        tag: bag_dp
        """
        s = sum(stones)
        dp = [0] * (s // 2 + 1)
        dp[0] = 1
        for num in stones:
            for i in range(s // 2, num - 1, -1):
                if dp[i - num]:
                    dp[i] = 1
        return min(abs(s - 2 * i) for i in range(s // 2 + 1) if dp[i])

    @staticmethod
    def abc_257e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc257/tasks/abc257_e
        tag: bag_dp|greedy
        """
        n = ac.read_int()
        c = ac.read_list_ints()
        dp = [[0] * 10 for _ in range(n + 1)]
        s = [0] * (n + 1)

        def check(x1, x2, lst1, lst2):
            if x1 > x2:
                return True
            if x1 < x2:
                return False
            for jj in range(9, 0, -1):
                if lst1[jj] > lst2[jj]:
                    return True
                if lst1[jj] < lst2[jj]:
                    return False
            return False

        for i in range(1, n + 1):
            for j in range(9, 0, -1):
                if i >= c[j - 1]:
                    pre = dp[i - c[j - 1]][:]
                    pre[j] += 1
                    if check(s[i - c[j - 1]] + 1, s[i], pre, dp[i][:]):
                        dp[i] = pre[:]
                        s[i] = s[i - c[j - 1]] + 1
        ans = []
        for i in range(9, 0, -1):
            ans.append(str(i) * dp[n][i])
        ac.st("".join(ans))
        return

    @staticmethod
    def lc_377(nums: List[int], target: int) -> int:
        """
        url: https://leetcode.cn/problems/factor-combinations/
        tag: math.infinite|no_order|bag_dp
        """
        dp = [0] * (target + 1)
        dp[0] = 1
        nums.sort()
        for i in range(1, target + 1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i - num]
                else:
                    break
        return dp[-1]

    @staticmethod
    def abc_222e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc222/tasks/abc222_e
        tag: bfs|bag_dp
        """
        n, m, k = ac.read_list_ints()
        a = ac.read_list_ints_minus_one()
        dct = [dict() for _ in range(n)]
        for x in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i][j] = x
            dct[j][i] = x
        cnt = [0] * (n - 1)
        for i in range(m - 1):
            s, t = a[i], a[i + 1]
            if s == t:
                continue
            parent = [-1] * n
            stack = [s]
            while stack and parent[t] == -1:
                nex = []
                for y in stack:
                    for xx in dct[y]:
                        if parent[xx] == -1 and xx != s:
                            parent[xx] = y
                            nex.append(xx)
                stack = nex[:]
            node = t
            while node != s:
                cnt[dct[node][parent[node]]] += 1
                node = parent[node]
        mod = 998244353
        tot = sum(cnt)
        if (tot + k) % 2 or (tot + k) // 2 < 0:
            ac.st(0)
            return
        r = (tot + k) // 2
        dp = [0] * (r + 1)
        dp[0] = 1
        ans = 1
        for i in range(n - 1):
            if cnt[i] == 0:
                ans *= 2
                ans %= mod
                continue
            c = cnt[i]
            for x in range(r, c - 1, -1):
                dp[x] = (dp[x] + dp[x - c]) % mod
        ans *= dp[r]
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_219d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc219/tasks/abc219_d
        tag: bag_dp|classical
        """
        n = ac.read_int()
        x, y = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]

        dp = [[math.inf] * (300 + 1) for _ in range(301)]
        dp[0][0] = 0
        for a, b in nums:
            for xx in range(300, a - 1, -1):
                for yy in range(300, b - 1, -1):
                    dp[xx][yy] = min(dp[xx][yy], dp[xx - a][yy - b] + 1)
            for xx in range(300, -1, -1):
                for yy in range(300, -1, -1):
                    if xx + 1 < 301:
                        dp[xx][yy] = min(dp[xx][yy], dp[xx + 1][yy])
                    if yy + 1 < 301:
                        dp[xx][yy] = min(dp[xx][yy], dp[xx][yy + 1])
        ans = dp[x][y]
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_216f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc216/tasks/abc216_f
        tag: matrix_dp|bag_dp
        """
        mod = 998244353
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        ind = list(range(n))
        ind.sort(key=lambda it: a[it])
        ceil = 5000
        dp = [0] * (ceil + 1)
        ans = 0
        dp[0] = 1
        for i in ind:
            num = b[i]
            for j in range(ceil, -1, -1):
                if j <= a[i]:
                    ans += dp[j - num] if j >= num else 0
                    ans %= mod
                dp[j] += dp[j - num] if j >= num else 0
                dp[j] %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1964e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1974/problem/E
        tag: bag_dp|greedy|data_range|classical
        """
        for _ in range(ac.read_int()):
            m, x = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(m)]
            tot = sum(h for _, h in nums)
            dp = [-math.inf] * (tot + 1)
            dp[0] = 0
            for i in range(m):
                c, h = nums[i]
                if i:
                    for j in range(tot + 1):
                        dp[j] += x
                for j in range(tot, h - 1, -1):
                    if dp[j - h] >= c:
                        dp[j] = max(dp[j], dp[j - h] - c)
            for ans in range(tot, -1, -1):
                if dp[ans] >= 0:
                    ac.st(ans)
                    break
        return

    @staticmethod
    def cf_837d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/837/D
        tag: matrix_dp|observation|classical|brain_teaser|bag_dp
        """
        tot5 = 0
        num = 1
        while num <= 10 ** 18:
            num *= 5
            tot5 += 1
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        tot5 *= n
        dp = [-math.inf] * tot5 * (k + 1)
        dp[0] = 0
        pre5 = 0
        for i, num in enumerate(nums):
            f2 = 0
            while num % 2 == 0:
                f2 += 1
                num //= 2
            f5 = 0
            while num % 5 == 0:
                f5 += 1
                num //= 5
            pre5 += f5
            for x in range(k, 0, -1):
                for y in range(min(tot5 - 1, pre5), f5 - 1, -1):
                    dp[x * tot5 + y] = max(dp[x * tot5 + y], dp[(x - 1) * tot5 + y - f5] + f2)
        ans = 0
        for y in range(tot5):
            ans = max(ans, min(y, dp[k * tot5 + y]))
        ac.st(ans)
        return

    @staticmethod
    def cf_478d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/478/D
        tag: matrix_dp|data_range|implemention|bag_dp
        """
        mod = 10 ** 9 + 7
        r, g = ac.read_list_ints()
        h = 1
        while (h + 1) * (h + 2) // 2 <= r + g:
            h += 1
        dp = [0] * (r + 1)

        dp[0] = 1
        tot = 0
        for i in range(1, h + 1):
            for j in range(min(r, tot + i), i - 1, -1):
                dp[j] = (dp[j] + dp[j - i]) % mod
            tot += i
        res = 0
        low = max(h * (h + 1) // 2 - g, 0)
        for i in range(low, r + 1):
            res += dp[i]
            res %= mod
        ac.st(res)
        return

    @staticmethod
    def cf_163a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/163/A
        tag: bag_dp|matrix_dp|classical
        """
        s = ac.read_str()
        t = ac.read_str()
        n = len(s)
        m = len(t)

        mod = 10 ** 9 + 7
        dp = [0] * (n + 1)
        for j in range(m):
            for i in range(n - 1, -1, -1):
                if s[i] == t[j]:
                    dp[i + 1] += dp[i] + 1
                    dp[i + 1] %= mod
        ans = sum(dp)
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p1651(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1651
        tag: linear_dp|brain_teaser|classical
        """
        ac.read_int()  # MLE
        nums = ac.read_list_ints()
        s = sum(nums)
        dp = [-10 ** 9] * (s // 2 + 1)
        dp[0] = 0
        for num in nums:
            ndp = dp[:]
            for x in range(s // 2 + 1):
                if x + num <= s // 2:
                    ndp[x + num] = max(ndp[x + num], dp[x])
                if num <= x:
                    ndp[x - num] = max(ndp[x - num], dp[x] + num)
                elif num - x <= s // 2:
                    ndp[num - x] = max(ndp[num - x], dp[x] + x)
            dp = ndp[:]
        ac.st(dp[0] if dp[0] > 0 else -1)
        return

    @staticmethod
    def lc_956(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/tallest-billboard/
        tag: meet_in_middle|bag_dp
        """
        s = sum(nums)
        dp = [-10 ** 9] * (s // 2 + 1)
        dp[0] = 0
        for num in nums:
            ndp = dp[:]
            for x in range(s // 2 + 1):
                if x + num <= s // 2:
                    ndp[x + num] = max(ndp[x + num], dp[x])
                if num <= x:
                    ndp[x - num] = max(ndp[x - num], dp[x] + num)
                elif num - x <= s // 2:
                    ndp[num - x] = max(ndp[num - x], dp[x] + x)
            dp = ndp[:]
        return dp[0]

    @staticmethod
    def lg_p1687(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1687
        tag: bag_dp
        """
        n, k = ac.read_list_ints()  # TLE
        nums = ac.read_list_ints()
        nums = [x for x in nums if x <= 119]
        dp = [[math.inf] * 120 for _ in range(k + 1)]
        dp[0][0] = 1
        n = len(nums)
        for i in range(n):
            num = nums[i]
            for j in range(min(i, k - 1), -1, -1):
                for x in range(120):
                    if num + x < 120:
                        dp[j + 1][num + x] = min(dp[j + 1][num + x], dp[j][x])
                    else:
                        dp[j + 1][num] = min(dp[j + 1][num], dp[j][x] + 1)
        ans = min(dp[k][i] for i in range(120))
        if ans < math.inf:
            ac.st(ans)
        else:
            ac.st("You can't do it.")
        return

    @staticmethod
    def lg_p3861(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3861
        tag: bag_dp|math|num_factor|matrix_dp|classical
        """
        mod = 998244353
        for _ in range(ac.read_int()):
            n = ac.read_int()
            factor = [x for x in NumFactor().get_all_factor(n)]
            ind = {num: i for i, num in enumerate(factor)}
            k = len(factor)
            dp = [0] * k
            dp[0] = 1
            for i in range(1, k):
                f = factor[i]
                for j in range(k - 1, i - 1, -1):
                    num = factor[j]
                    if num % f == 0:
                        dp[ind[num]] += dp[ind[num // f]]
                        dp[ind[num]] %= mod
            ans = dp[-1] - 1
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def abc_200e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc200/tasks/abc200_e
        tag: bag_dp|counter|prefix_sum
        """
        n, k = ac.read_list_ints()
        dp = [0] * (3 * n + 1)
        dp[0] = 0
        for i in range(1, n + 1):
            dp[i] = 1

        ndp = [0] * (3 * n + 1)
        pre = [0] * (3 * n + 1)
        for i in range(3 * n):
            pre[i + 1] = pre[i] + dp[i]
        for x in range(3 * n + 1):
            ndp[x] = pre[x] - pre[max(0, x - n)]
        dp = ndp[:]
        dp2 = ndp[:]

        ndp = [0] * (3 * n + 1)
        pre = [0] * (3 * n + 1)
        for i in range(3 * n):
            pre[i + 1] = pre[i] + dp[i]
        for x in range(3 * n + 1):
            ndp[x] = pre[x] - pre[max(0, x - n)]
        dp = ndp[:]

        for x in range(3 * n + 1):
            if k > dp[x]:
                k -= dp[x]
            else:
                ans = []
                for y in range(1, n + 1):
                    if k > dp2[x - y]:
                        k -= dp2[x - y]
                    else:
                        ans.append(y)
                        for z in range(1, n + 1):
                            if x - y - z > n:
                                continue
                            if k > 1:
                                k -= 1
                            else:
                                ans.append(z)
                                ans.append(x - y - z)
                                ac.lst(ans)
                                return
        return

    @staticmethod
    def cf_1340b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1340/B
        tag: bag_dp|reverse_order|specific_plan
        """
        n, k = ac.read_list_ints()
        st = ["1110111", "0010010", "1011101", "1011011", "0111010", "1101011", "1101111", "1010010", "1111111",
              "1111011"]
        mask = [int("0b" + x, 2) for x in st]
        nums = [int("0b" + ac.read_str(), 2) for _ in range(n)]
        dp = [[-1] * (k + 1) for _ in range(n + 1)]
        dp[n][0] = 0
        for i in range(n - 1, -1, -1):
            change = [(j, (nums[i] ^ mask[j]).bit_count()) for j in range(10) if nums[i] & mask[j] == nums[i]]
            for x in range(k + 1):
                if dp[i + 1][x] != -1:
                    for a, b in change:
                        if x + b <= k:
                            dp[i][x + b] = max(dp[i][x + b], a)
        if dp[0][k] == -1:
            ac.st(-1)
        else:
            ans = [dp[0][k]]
            x = k - (nums[0] ^ mask[ans[-1]]).bit_count()
            for i in range(1, n):
                ans.append(dp[i][x])
                x -= (nums[i] ^ mask[ans[-1]]).bit_count()
            ac.st("".join(str(x) for x in ans))
        return

    @staticmethod
    def abc_373f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc373/tasks/abc373_f
        tag: bag_dp|heapq|greedy|brain_teaser
        """
        n, w = ac.read_list_ints()
        nums = [[] for _ in range(w + 1)]
        for _ in range(n):
            ww, vv = ac.read_list_ints()
            nums[ww].append(vv)
        dp = [0] * (w + 1)
        dp[0] = 0
        for ww in range(w + 1):
            if nums[ww]:
                stack = [-(v - 1) for v in nums[ww]]
                heapify(stack)
                cur = [0]
                for i in range(1, w // ww + 1):
                    v = -heappop(stack)
                    cur.append(cur[-1] + v)
                    heappush(stack, -(v - 2))

                for j in range(w, -1, -1):
                    for i in range(1, j // ww + 1):
                        dp[j] = max(dp[j], dp[j - i * ww] + cur[i])
        ac.st(max(dp))
        return

    @staticmethod
    def cf_2000e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/2000/F
        tag: brute_force|greedy|bag_dp
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(n)]
            if sum(sum(ls) for ls in nums) < k:
                ac.st(-1)
                continue
            dp = [math.inf] * (k + 1)
            dp[0] = 0
            for a, b in nums:
                lst = []
                while a and b:
                    if a > b:
                        a, b = b, a
                    lst.append(a)
                    b -= 1
                lst.extend([0] * a)
                lst.extend([0] * b)
                lst = ac.accumulate(lst)[1:]
                for j in range(k, -1, -1):
                    for i in range(j - 1, -1, -1):
                        if j - i > len(lst):
                            break
                        dp[j] = min(dp[j], dp[i] + lst[j - i - 1])
            ac.st(dp[k])
        return

    @staticmethod
    def cf_366c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/366/C
        tag: bag_dp|data_range
        """
        n, k = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        low = (1 - 100 * k) * 100
        high = (100 - k) * 100
        dp = [-1] * (high - low + 1)
        dp[0] = 0
        for i in range(n):
            c = a[i] - k * b[i]
            if c >= 0:
                for x in range(high, low - 1, -1):
                    if dp[x - c] > -1 and low <= (x - c) <= high:
                        dp[x] = max(dp[x], dp[x - c] + a[i])
            else:
                for x in range(low, high + 1):
                    if dp[x - c] > -1 and low <= (x - c) <= high:
                        dp[x] = max(dp[x], dp[x - c] + a[i])
        ans = dp[0]
        ac.st(ans if ans > 0 else -1)
        return

    @staticmethod
    def cf_864e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/864/E
        tag: bag_dp|specific_plan|greedy|observation|classical
        """
        n = ac.read_int()
        t = []
        d = []
        p = []
        for i in range(n):
            tt, dd, pp = ac.read_list_ints()
            t.append(tt)
            d.append(dd * n + i)
            p.append(pp)
        d.sort()
        dp = [0] * 2001
        plan = [[] for _ in range(2001)]
        for val in d:
            dd, i = val // n, val % n
            tt, pp = t[i], p[i]
            for x in range(dd - 1, tt - 1, -1):
                if dp[x - tt] + pp > dp[x]:
                    dp[x] = dp[x - tt] + pp
                    plan[x] = plan[x - tt] + [i + 1]
        ceil = max(dp)
        i = dp.index(ceil)
        ac.st(ceil)
        ans = plan[i]
        ac.st(len(ans))
        ac.lst(ans)
        return
"""
Algorithm：circular_array|liner_dp|interval_dp|brute_force|circle_to_linear
Description：operations on circular_array, always copy the array to double or use index to implement liner_dp


====================================LeetCode====================================
213（https://leetcode.cn/problems/house-robber-ii/）circular_array|linear_dp|classical
918（https://leetcode.cn/problems/maximum-sum-circular-subarray/）circular_array|brute_force|sub_array
1388（https://leetcode.cn/problems/pizza-with-3n-slices/）brute_force|circular_array|linear_dp
1888（https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/）circular_dp|brute_force
2560（https://leetcode.cn/problems/house-robber-iv/）binary_search|circular_array|linear_dp|classical

=====================================LuoGu======================================
P1880（https://www.luogu.com.cn/problem/P1880）brute_force|circular_array|linear_dp
P1121（https://www.luogu.com.cn/problem/P1121）circular_array|brute_force|sub_array
P1043（https://www.luogu.com.cn/problem/P1043）brute_force|circular_array|linear_dp
P1133（https://www.luogu.com.cn/problem/P1133）brute_force|circular_array|linear_dp

=====================================AtCoder======================================
ABC251E（https://atcoder.jp/contests/abc251/tasks/abc251_e）circular_array|linear_dp|classical


"""
from collections import defaultdict

from typing import List

from src.basis.binary_search.template import BinarySearch
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_251e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc251/tasks/abc251_e
        tag: circular_array|linear_dp|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [math.inf] * n
        dp[0] = nums[-1]
        dp[1] = dp[0] + nums[0]
        for i in range(2, n):
            dp[i] = min(dp[i - 1], dp[i - 2]) + nums[i - 1]
        ans1 = min(dp[n - 2], dp[n - 3] + nums[n - 2])

        dp = [math.inf] * n
        dp[0] = nums[0]
        dp[1] = nums[0]
        for i in range(2, n):
            dp[i] = min(dp[i - 1], dp[i - 2]) + nums[i - 1]
        ans2 = min(dp[n - 1], dp[n - 2] + nums[n - 1])

        ans = min(ans1, ans2)
        ac.st(ans)
        return

    @staticmethod
    def lc_213(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/house-robber-ii
        tag: circular_array|linear_dp|classical
        """

        def check(lst):
            n = len(lst)
            dp = [0] * (n + 1)
            for i in range(n):
                dp[i + 1] = dp[i] if dp[i] > lst[i] else lst[i]
                if i and dp[i - 1] + lst[i] > dp[i + 1]:
                    dp[i + 1] = dp[i - 1] + lst[i]
            return dp[-1]

        if len(nums) == 1:
            return nums[0]
        return max(check(nums[1:]), check(nums[:-1]))

    @staticmethod
    def lc_1388(slices: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/pizza-with-3n-slices/
        tag: brute_force|circular_array|linear_dp
        """

        def check(lst):
            n = len(lst)
            m = n // 3 + 1
            dp = [[0] * (m + 1) for _ in range(n + 1)]
            for i in range(n):
                for j in range(1, m + 1):
                    dp[i + 1][j] = max(dp[i][j], dp[i - 1][j - 1] + lst[i] if i else lst[i])
            return dp[-1][-1]

        ans = max(check(slices[1:]), check(slices[:-1]))

        return ans

    @staticmethod
    def lg_p1880(ac=FastIO()):

        """
        url: https://www.luogu.com.cn/problem/P1880
        tag: brute_force|circular_array|linear_dp
        """

        def check(fun):
            dp = [[0] * n for _ in range(n)]
            for i in range(n - 1, -1, -1):
                dp[i][i] = 0
                if i + 1 < n:
                    dp[i][i + 1] = nums[i] + nums[i + 1]
                for j in range(i + 2, n):
                    dp[i][j] = 0 if fun == max else math.inf
                    for k in range(i, j):
                        cur = dp[i][k] + dp[k + 1][j] + pre[j + 1] - pre[i]
                        dp[i][j] = fun(dp[i][j], cur)
            return fun([dp[i][i + n // 2 - 1] for i in range(n // 2)])

        n = ac.read_int() * 2
        nums = ac.read_list_ints()
        nums.extend(nums)
        pre = [0] * (n + 1)
        for x in range(n):
            pre[x + 1] = pre[x] + nums[x]
        ac.st(check(min))
        ac.st(check(max))
        return

    @staticmethod
    def lg_p1121(ac=FastIO()):

        """
        url: https://www.luogu.com.cn/problem/P1121
        tag: circular_array|brute_force|sub_array
        """

        n = ac.read_int()
        nums = ac.read_list_ints()
        s = sum(nums)

        pre = [-math.inf] * (n + 1)
        x = 0
        for i in range(n):
            x = x if x > 0 else 0
            x += nums[i]
            pre[i + 1] = max(pre[i], x)

        post = [-math.inf] * (n + 1)
        x = 0
        for i in range(n - 1, -1, -1):
            x = x if x > 0 else 0
            x += nums[i]
            post[i] = max(post[i + 1], x)
        ans = max(pre[i] + post[i + 1] for i in range(1, n))
        cnt = sum(num >= 0 for num in nums)
        if cnt <= 1:
            ac.st(ans)
            return

        pre = [0] * (n + 1)
        x = 0
        for i in range(n):
            x = x if x < 0 else 0
            x += nums[i]
            pre[i + 1] = min(pre[i], x)

        post = [0] * (n + 1)
        x = 0
        for i in range(n - 1, -1, -1):
            x = x if x < 0 else 0
            x += nums[i]
            post[i] = min(post[i + 1], x)

        ans = max(ans, s - min(pre[i] + post[i + 1] for i in range(1, n)))
        ac.st(ans)
        return

    @staticmethod
    def lc_918(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-sum-circular-subarray/
        tag: circular_array|brute_force|sub_array
        """

        ans = -math.inf
        pre = 0
        for num in nums:
            pre = pre if pre > 0 else 0
            pre += num
            if pre > ans:
                ans = pre

        low = math.inf
        pre = 0
        for num in nums:
            pre = pre if pre < 0 else 0
            pre += num
            if pre < low:
                low = pre

        if all(num < 0 for num in nums):
            return ans
        low = sum(nums) - low
        if low > ans:
            ans = low
        return ans

    @staticmethod
    def lc_2560(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/house-robber-iv/
        tag: binary_search|circular_array|linear_dp|classical
        """
        n = len(nums)

        def check(x):
            dp = [0] * (n + 1)
            for i in range(n):
                dp[i + 1] = dp[i]
                if nums[i] <= x and dp[i - 1] + 1 > dp[i + 1]:
                    dp[i + 1] = dp[i - 1] + 1
            return dp[-1] >= k

        return BinarySearch().find_int_left(min(nums), max(nums), check)

    @staticmethod
    def lg_p1043(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1043
        tag: brute_force|circular_array|linear_dp
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        floor = math.inf
        ceil = -math.inf
        for _ in range(n):
            nums.append(nums.pop(0))
            pre = [0] * (n + 1)
            for i in range(n):
                pre[i + 1] = pre[i] + nums[i]
            dp = [[[math.inf, -math.inf] for _ in range(m + 1)] for _ in range(n + 1)]
            dp[0][0] = [1, 1]
            for i in range(n):
                for k in range(i + 1):
                    for j in range(1, m + 1):
                        cur = (pre[i + 1] - pre[k]) % 10
                        if dp[k][j - 1][0] != math.inf:
                            dp[i + 1][j][0] = min(dp[i + 1][j][0], dp[k][j - 1][0] * cur)
                            dp[i + 1][j][1] = max(dp[i + 1][j][1], dp[k][j - 1][0] * cur)
                        if dp[k][j - 1][1] != -math.inf:
                            dp[i + 1][j][0] = min(dp[i + 1][j][0], dp[k][j - 1][1] * cur)
                            dp[i + 1][j][1] = max(dp[i + 1][j][1], dp[k][j - 1][1] * cur)
            floor = min(floor, dp[-1][-1][0])
            ceil = max(ceil, dp[-1][-1][1])
        ac.st(floor)
        ac.st(ceil)
        return

    @staticmethod
    def lg_p1133(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1133
        tag: brute_force|circular_array|linear_dp
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = 0
        state = []
        for a in range(3):
            for b in range(3):
                if a != b:
                    state.append([a, b])
        nex = defaultdict(list)
        for a, b in state:
            for c in range(3):
                if b < a and b < c:
                    nex[(a, b)].append(c)
                if b > a and b > c:
                    nex[(a, b)].append(c)

        for a, b in state:
            pre = dict()
            pre[(a, b)] = nums[-1][a] + nums[0][b]
            for i in range(1, n - 1):
                cur = dict()
                for x1, x2 in pre:
                    for y in nex[(x1, x2)]:
                        cur[(x2, y)] = max(cur.get((x2, y), 0), pre[(x1, x2)] + nums[i][y])
                pre = cur.copy()
            for x1, x2 in pre:
                if (a < x2 and a < b) or (a > x2 and a > b):
                    ans = max(ans, pre[(x1, x2)])
        ac.st(ans)
        return
"""
Algorithm：digital_dp
Description：lexicographical_order|counter|high_to_low|low_to_high


====================================LeetCode====================================
233（https://leetcode.cn/problems/number-of-digit-one/）counter|digital_dp
357（https://leetcode.cn/problems/count-numbers-with-unique-digits/）comb|digital_dp
600（https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/）counter|digital_dp
902（https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/）counter|digital_dp
1012（https://leetcode.cn/problems/numbers-with-repeated-digits/）inclusion_exclusion|counter|digital_dp
1067（https://leetcode.cn/problems/digit-count-in-range/）counter|digital_dp|inclusion_exclusion
1397（https://leetcode.cn/problems/find-all-good-strings/）digital_dp|implemention|kmp
2376（https://leetcode.cn/problems/count-special-integers/）counter|digital_dp
2719（https://leetcode.cn/problems/count-of-integers/）digital_dp|inclusion_exclusion
2801（https://leetcode.cn/problems/count-stepping-numbers-in-range/）digital_dp|inclusion_exclusion
2827（https://leetcode.cn/problems/number-of-beautiful-integers-in-the-range/）digital_dp|inclusion_exclusion
17（https://leetcode.cn/problems/number-of-2s-in-range-lcci/）counter|digital_dp
100160（https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/）bit_operation|binary_search|bit_operation|binary_search|digital_dp
104301C（https://codeforces.com/gym/104301/problem/C）digital_dp

====================================AtCoder=====================================
ABC121D（https://atcoder.jp/contests/abc121/tasks/abc121_d）xor_property|digital_dp
ABC208E（https://atcoder.jp/contests/abc208/tasks/abc208_e）brain_teaser|digital_dp
ABC336E（https://atcoder.jp/contests/abc336/tasks/abc336_e）brute_force|digital_dp
ABC317F（https://atcoder.jp/contests/abc317/tasks/abc317_f）2-base|digital_dp|classical
ABC295F（https://atcoder.jp/contests/abc295/tasks/abc295_f）digital_dp|kmp_automaton|classical
ABC235F（https://atcoder.jp/contests/abc235/tasks/abc235_f）digital_dp|classical

===================================CodeForces===================================
628D（https://codeforces.com/problemset/problem/628/D）digital_dp
55D（https://codeforces.com/contest/55/problem/D）digital_dp|memorized|classical

=====================================LuoGu======================================
P1590（https://www.luogu.com.cn/problem/P1590）counter|digital_dp
P1239（https://www.luogu.com.cn/problem/P1239）counter|digital_dp
P3908（https://www.luogu.com.cn/problem/P3908）xor_property|digital_dp|counter|odd_even
P1836（https://www.luogu.com.cn/problem/P1836）digital_dp

======================================Other======================================
（https://www.lanqiao.cn/problems/5891/learning/?contest_id=145）inclusion_exclusion|digital_dp

"""
from functools import lru_cache

from src.dp.digital_dp.template import DigitalDP
from src.strings.kmp.template import KMP
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_121d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc121/tasks/abc121_d
        tag: xor_property|digital_dp
        """

        #  n^(n+1) == 1 (n%2==0)
        def count(num):
            @lru_cache(None)
            def dfs(i, cnt, is_limit, is_num):
                if i == n:
                    if is_num:
                        return cnt
                    return 0
                res = 0
                if not is_num:
                    res += dfs(i + 1, 0, False, False)

                floor = 0 if is_num else 1
                ceil = int(s[i]) if is_limit else 9
                for x in range(floor, ceil + 1):
                    res += dfs(i + 1, cnt + int(i == d and x == 1),
                               is_limit and ceil == x, True)
                return res

            if num <= 0:
                return 0
            s = bin(num)[2:]
            n = len(s)
            ans = 0
            for d in range(n):
                c = dfs(0, 0, True, False)
                dfs.cache_clear()
                if c % 2:
                    ans += 1 << (n - d - 1)
            return ans

        a, b = ac.read_list_ints()
        ac.st(count(b) ^ count(a - 1))
        return

    @staticmethod
    def abc_208e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc208/tasks/abc208_e
        tag: brain_teaser|digital_dp
        """

        @lru_cache(None)
        def dfs(i, is_limit, is_num, pre):
            if i == m:
                return int(is_num) and pre <= k
            res = 0
            if not is_num:
                res += dfs(i + 1, False, False, 0)
            low = 0 if is_num else 1
            high = int(st[i]) if is_limit else 9
            for x in range(low, high + 1):
                y = pre * x if is_num else x
                if y > k:
                    y = k + 1
                res += dfs(i + 1, is_limit and high == x, True, y)
            return res

        n, k = ac.read_list_ints()
        st = str(n)
        m = len(st)
        ans = dfs(0, True, False, 0)
        ac.st(ans)
        return

    @staticmethod
    def lc_233(n: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-digit-one/
        tag: counter|digital_dp
        """
        return DigitalDP().count_digit_dp(n, 1)

    @staticmethod
    def lc_2719_1(num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        """
        url: https://leetcode.cn/problems/count-of-integers/
        tag: digital_dp|inclusion_exclusion
        """

        def check(n):
            # calculate the number of occurrences of positive integer binary bit 1 from 1 to n

            @lru_cache(None)
            def dfs(i, is_limit, is_num, cnt):
                if i == m:
                    return 1 if (min_sum <= cnt <= max_sum and is_num) else 0
                if cnt + 9 * (m - i) < min_sum:
                    return 0
                if cnt > max_sum:
                    return 0
                res = 0
                if not is_num:
                    res += dfs(i + 1, False, False, 0)
                low = 0 if is_num else 1
                high = int(st[i]) if is_limit else 9
                for x in range(low, high + 1):
                    if cnt + x <= max_sum:
                        res += dfs(i + 1, is_limit and high == x, True, cnt + x)
                return res % mod

            st = str(n)
            m = len(st)
            ans = dfs(0, True, False, 0)
            dfs.cache_clear()
            return ans

        mod = 10 ** 9 + 7
        return (check(int(num2)) - check(int(num1) - 1)) % mod

    @staticmethod
    def lc_2719_2(num1: str, num2: str, min_sum: int, max_sum: int) -> int:
        """
        url: https://leetcode.cn/problems/count-of-integers/
        tag: digital_dp|inclusion_exclusion
        """
        mod = 10 ** 9 + 7

        def dfs(i, down, up, pre, is_num):
            if i < 0:
                return 1 if is_num and min_sum <= pre <= max_sum else 0
            if not down and not up and dp[i][pre][is_num] > -1:
                return dp[i][pre][is_num]

            res = 0
            if pre + 9 * (i + 1) >= min_sum:
                floor = int(low[i]) if down else (0 if is_num else 1)
                ceil = int(high[i]) if up else 9
                for x in range(floor, ceil + 1):
                    if pre + x <= max_sum:
                        res += dfs(i - 1, down and x == floor, up and x == ceil, pre + x, 1 if x > 0 or is_num else -1)
                        res %= mod
                    else:
                        break

            if not down and not up:
                dp[i][pre][is_num] = res
            return res

        high = num2[::-1]
        low = num1[::-1]
        low += (len(high) - len(low)) * "0"
        dp = [[[-1] * 2 for _ in range(max_sum + 1)] for _ in range(len(high))]
        ans = dfs(len(high) - 1, True, True, 0, 0)
        return ans

    @staticmethod
    def lc_2801_1(low: str, high: str) -> int:
        """
        url: https://leetcode.cn/problems/count-stepping-numbers-in-range/
        tag: digital_dp|inclusion_exclusion
        """

        def check(num):
            @lru_cache(None)
            def dfs(i, is_limit, is_num, pre):
                if i == n:
                    return is_num
                res = 0
                if not is_num:
                    res += dfs(i + 1, False, 0, -1)

                floor = 0 if is_num else 1
                ceil = int(s[i]) if is_limit else 9
                for x in range(floor, ceil + 1):
                    if pre == -1 or abs(x - pre) == 1:
                        res += dfs(i + 1, is_limit and ceil == x, 1, x)
                return res

            s = str(num)
            n = len(s)
            return dfs(0, True, 0, -1)

        mod = 10 ** 9 + 7
        return (check(int(high)) - check(int(low) - 1)) % mod

    @staticmethod
    def lc_2801_2(low: str, high: str) -> int:
        """
        url: https://leetcode.cn/problems/count-stepping-numbers-in-range/
        tag: digital_dp|inclusion_exclusion
        """
        dp = [[[-1] * 2 for _ in range(11)] for _ in range(101)]
        mod = 10 ** 9 + 7

        def dfs(i, down, up, pre, is_num):
            if i < 0:
                return is_num
            if not down and not up and dp[i][pre][is_num] > -1:
                return dp[i][pre][is_num]
            res = 0

            floor = int(low[i]) if down else (0 if is_num else 1)
            ceil = int(high[i]) if up else 9
            if is_num:
                for x in [pre - 1, pre + 1]:
                    if floor <= x <= ceil:
                        res += dfs(i - 1, down and x == floor, up and x == ceil, x, is_num)
                        res %= mod
            else:
                for x in range(floor, ceil + 1):
                    res += dfs(i - 1, down and x == floor, up and x == ceil, x, int(x > 0))
                    res %= mod
            if not down and not up:
                dp[i][pre][is_num] = res
            return res

        high = high[::-1]
        low = low[::-1]
        low += (len(high) - len(low)) * "0"
        ans = dfs(len(high) - 1, True, True, -1, 0)
        return ans

    @staticmethod
    def lc_2827_1(low: int, high: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-beautiful-integers-in-the-range/
        tag: digital_dp|inclusion_exclusion
        """

        def check(num):
            @lru_cache(None)
            def dfs(i, is_limit, is_num, odd, rest):
                if i == n:
                    return 1 if is_num and not odd and not rest else 0
                res = 0
                if not is_num:
                    res += dfs(i + 1, False, 0, 0, 0)

                floor = 0 if is_num else 1
                ceil = int(s[i]) if is_limit else 9
                for x in range(floor, ceil + 1):
                    res += dfs(i + 1, is_limit and ceil == x, 1, odd + 1 if x % 2 == 0 else odd - 1,
                               (rest * 10 + x) % k)
                return res

            s = str(num)
            n = len(s)
            return dfs(0, True, 0, 0, 0)

        return check(high) - check(low - 1)

    @staticmethod
    def lc_2827_2(low: int, high: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-beautiful-integers-in-the-range/
        tag: digital_dp|inclusion_exclusion
        """
        dp = [[[[[-1] * 2 for _ in range(21)] for _ in range(21)] for _ in range(25)] for _ in range(11)]

        def dfs(i, down, up, odd, rest, is_num):
            if i < 0:
                return 1 if is_num and not odd and not rest else 0

            if not down and not up and dp[i][odd][k][rest][is_num] > -1:
                return dp[i][odd][k][rest][is_num]

            res = 0
            floor = int(low[i]) if down else (0 if is_num else 1)
            ceil = int(high[i]) if up else 9
            for x in range(floor, ceil + 1):
                cur_is_num = 1 if x > 0 or is_num else 0
                res += dfs(i - 1, down and x == floor, up and x == ceil,
                           0 if not cur_is_num else odd + 1 if x % 2 == 0 else odd - 1,
                           (rest * 10 + x) % k, cur_is_num)

            if not down and not up:
                dp[i][odd][k][rest][is_num] = res
            return res

        high = str(high)[::-1]
        low = str(low)[::-1]
        low += (len(high) - len(low)) * "0"
        ans = dfs(len(high) - 1, True, True, 0, 0, 0)
        return ans

    @staticmethod
    def lg_p1836(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1836
        tag: digital_dp
        """
        n = ac.read_int()
        ac.st(DigitalDP().count_digit_sum(n))
        return

    @staticmethod
    def lc_1067(d: int, low: int, high: int) -> int:
        """
        url: https://leetcode.cn/problems/digit-count-in-range/
        tag: counter|digital_dp|inclusion_exclusion
        """
        dd = DigitalDP()
        return dd.count_digit_dp(high, d) - dd.count_digit_dp(low - 1, d)

    @staticmethod
    def abc_336e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc336/tasks/abc336_e
        tag: brute_force|digital_dp
        """
        num = ac.read_int()
        num += 1
        lst = [int(x) for x in str(num)]
        n = len(lst)
        ans = 0
        for digit_sum in range(1, 9 * n + 1):
            pre = [0] * digit_sum * (digit_sum + 1)
            x = x_mod = 0
            for k in range(n):
                cur = [0] * digit_sum * (digit_sum + 1)
                for i in range(min(digit_sum + 1, (k + 1) * 9 + 1)):
                    for j in range(digit_sum):
                        if not pre[i * digit_sum + j]:
                            continue
                        for d in range(10):
                            if i + d > digit_sum:
                                break
                            cur[(i + d) * digit_sum + (j * 10 + d) % digit_sum] += pre[i * digit_sum + j]
                for i in range(lst[k]):
                    if x + i <= digit_sum:
                        cur[(x + i) * digit_sum + (x_mod * 10 + i) % digit_sum] += 1
                x += lst[k]
                x_mod = (x_mod * 10 + lst[k]) % digit_sum
                pre = cur
            ans += pre[digit_sum * digit_sum + 0]
        ac.st(ans)
        return

    @staticmethod
    def abc_317f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc317/tasks/abc317_f
        tag: 2-base|digital_dp|classical
        """

        n, a, b, c = ac.read_list_ints()
        lst = [int(w) for w in bin(n)[2:]]
        m = len(lst)

        mod = 998244353
        tmp = [(0, 1, 1), (1, 0, 1), (0, 0, 0), (1, 1, 0)]

        @lru_cache(None)
        def dfs(i, x, y, z, is_x, is_y, is_z, num_x, num_y, num_z):
            if i == m:
                return x == y == z == 0 and num_x == num_y == num_z == 1
            res = 0
            for xx, yy, zz in tmp:
                if (not is_x or xx <= lst[i]) and (not is_y or yy <= lst[i]) and (not is_z or zz <= lst[i]):
                    nex_x = (x * 2 + xx) % a
                    nex_y = (y * 2 + yy) % b
                    nex_z = (z * 2 + zz) % c
                    nex_is_x = int(is_x and xx == lst[i])
                    nex_is_y = int(is_y and yy == lst[i])
                    nex_is_z = int(is_z and zz == lst[i])
                    res += dfs(i + 1, nex_x, nex_y, nex_z, nex_is_x, nex_is_y, nex_is_z, num_x | xx, num_y | yy,
                               num_z | zz)
            return res % mod

        ans = dfs(0, 0, 0, 0, 1, 1, 1, 0, 0, 0)
        ac.st(ans)
        return

    @staticmethod
    def abc_295f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc295/tasks/abc295_f
        tag: digital_dp|kmp_automaton|classical
        """

        def check(num):

            @lru_cache(None)
            def dfs(i, is_limit, is_num, cnt, pre):
                if i == m:

                    if is_num:
                        return cnt
                    return 0
                res = 0
                if not is_num:
                    res += dfs(i + 1, False, False, 0, 0)
                low = 0 if is_num else 1
                high = int(st[i]) if is_limit else 9
                for x in range(low, high + 1):
                    nex_length = nex[pre * 10 + x]
                    nex_cnt = cnt + 1 if nex_length == n else cnt
                    res += dfs(i + 1, is_limit and high == x, True, nex_cnt, nex_length)
                return res

            st = str(num)
            m = len(st)
            ans = dfs(0, True, False, 0, 0)
            dfs.cache_clear()
            return ans

        for _ in range(ac.read_int()):
            s, ll, rr = ac.read_list_strs()
            lst = [int(w) for w in s]
            n = len(s)
            nex = KMP().kmp_automaton(lst, 10)
            cur = check(int(rr)) - check(int(ll) - 1)
            ac.st(cur)
        return

    @staticmethod
    def abc_235f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc235/tasks/abc235_f
        tag: digital_dp|classical
        """

        mod = 998244353  # TLE
        s = ac.read_str()
        ac.read_int()
        c = ac.read_list_ints()
        target = sum(1 << x for x in c)
        k = len(s)

        weight = [[0] * 10 for _ in range(k + 1)]
        for x in range(10):
            weight[1][x] = x % mod
        for ii in range(2, k + 1):
            for x in range(10):
                weight[ii][x] = (weight[ii - 1][x] * 10) % mod

        @lru_cache(None)
        def dfs(i, state, is_limit, is_num):
            if i == k:
                return (1, 0) if state & target == target else (0, -1)
            res = -1
            tot = -1
            if not is_num:
                cc, ss = dfs(i + 1, 0, False, False)
                if ss > -1:
                    if res == -1:
                        res = ss
                        tot = cc
                    else:
                        res += ss
                        tot += cc

            floor = 0 if is_num else 1
            ceil = int(s[i]) if is_limit else 9
            for x in range(floor, ceil + 1):
                cc, ss = dfs(i + 1, state | (1 << x), is_limit and ceil == x, True)
                if ss > -1:
                    if res == -1:
                        res = ss + weight[k - i][x] * cc
                        tot = cc
                    else:
                        res += ss + weight[k - i][x] * cc
                        tot += cc
            return (tot % mod, res % mod) if res > -1 else (0, -1)

        ans = dfs(0, 0, 1, 0)[1]
        ac.st(ans if ans > -1 else 0)
        return

    @staticmethod
    def cf_628d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/628/D
        tag: digital_dp
        """
        m, d = ac.read_list_ints()  # TLE
        a = [int(w) for w in ac.read_str()]
        b = ac.read_str()
        k = len(a)
        for i in range(k - 1, -1, -1):
            if a[i]:
                a[i] -= 1
                for j in range(i + 1, k):
                    a[j] = 9
                break
        if len(a) >= 2 and a[0] == 0:
            a.pop(0)
        a = "".join(str(x) for x in a)
        mod = 10 ** 9 + 7

        def count(s):
            n = len(s)
            dp = [0] * m * (1 << 3)
            ndp = [0] * m * (1 << 3)
            for p in range(n, -1, -1):
                for rest in range(m):
                    for state in range(1 << 3):
                        is_limit = (state >> 2) & 1
                        is_num = (state >> 1) & 1
                        odd = state & 1
                        if p == n:
                            ndp[state * m + rest] = int(rest == 0 and is_num)
                            continue
                        else:
                            res = 0
                            if not is_num:
                                res += dp[0]

                            floor = 0 if is_num else 1
                            ceil = int(s[p]) if is_limit else 9
                            if odd == 1:
                                if floor <= d <= ceil:
                                    res += dp[
                                        ((int(is_limit and ceil == d) << 2) | 2 | (odd ^ 1)) * m + (rest * 10 + d) % m]
                                ndp[state * m + rest] = res % mod
                                continue
                            for x in range(floor, ceil + 1):
                                if odd == 0 and x == d:
                                    continue
                                res += dp[
                                    ((int(is_limit and ceil == x) << 2) | 2 | (odd ^ 1)) * m + (rest * 10 + x) % m]
                            ndp[state * m + rest] = res % mod
                for rest in range(m):
                    for state in range(1 << 3):
                        dp[state * m + rest] = ndp[state * m + rest]
            return dp[4 * m]

        final = count(b) - count(a)
        ac.st(final % mod)
        return
"""
Algorithm：game_dp|wining_state|lose
Description：brute_force|interval_dp|implemention|greedy

====================================LeetCode====================================
375（https://leetcode.cn/problems/guess-number-higher-or-lower-ii/）interval_dp|classical|game_dp
1140（https://leetcode.cn/problems/stone-game-ii/）prefix_sum|linear_dp

=====================================LuoGu======================================
P1290（https://www.luogu.com.cn/problem/P1290）classical|game_dp
P5635（https://www.luogu.com.cn/problem/P5635）game_dp|implemention
P3150（https://www.luogu.com.cn/problem/P3150）game_dp|implemention|odd_even
P4702（https://www.luogu.com.cn/problem/P4702）game_dp|implemention|odd_even
P1247（https://www.luogu.com.cn/problem/P1247）nim|game_dp|xor
P1512（https://www.luogu.com.cn/problem/P1512）game_dp|date
P2092（https://www.luogu.com.cn/problem/P2092）prime|game_dp
P2953（https://www.luogu.com.cn/problem/P2953）game_dp|winning_state|liner_dp

=====================================AcWing=====================================
4005（https://www.acwing.com/problem/content/description/4008/）classical|game_dp|brain_teaser|classification_discussion


=====================================CodeForces=====================================
493D（https://codeforces.com/problemset/problem/493/D）implemention|odd_even|game_dp
1728D（https://codeforces.com/contest/1728/problem/D）gap_dp|interval_dp
455B（https://codeforces.com/problemset/problem/455/B）gap_dp|dag_dp|odd_even|classical|win_state|lose_state
1383B（https://codeforces.com/problemset/problem/1383/B）game_dp|odd_even|win_state|lose_state|draw_state

=====================================AtCoder=====================================
ABC349E（https://atcoder.jp/contests/abc349/tasks/abc349_e）game_dp|implemention|classical
ABC231E（https://atcoder.jp/contests/abc231/tasks/abc231_e）implemention|greedy|dfs|linear_dp
ABC368F（https://atcoder.jp/contests/abc368/tasks/abc368_f）nim|game_dp|xor
ABC201D（https://atcoder.jp/contests/abc201/tasks/abc201_d）game_dp|classical

"""
from functools import lru_cache
from functools import reduce

from operator import xor

from src.dp.game_dp.template import DateTime
from src.mathmatics.number_theory.template import NumFactor
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1290(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1290
        tag: classical|game_dp
        """
        n = ac.read_int()
        for _ in range(n):
            x, y = ac.read_list_ints()

            @lru_cache(None)
            def dfs(a, b):
                if a < b:
                    a, b = b, a
                if a % b == 0:
                    return True
                if a // b >= 2:
                    return True
                for i in range(1, a // b + 1):
                    if not dfs(a - i * b, b):
                        return True
                return False

            ans = dfs(x, y)
            if ans:
                ac.st("Stan wins")
            else:
                ac.st("Ollie wins")
        return

    @staticmethod
    def lg_1247(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1247
        tag: nim|game_dp|xor
        """
        k = ac.read_int()
        nums = ac.read_list_ints()
        x = reduce(xor, nums)
        if x == 0:
            ac.st("lose")
        else:
            for i in range(k):
                if nums[i] ^ x < nums[i]:
                    res = [nums[i] - (nums[i] ^ x), i + 1]
                    ac.lst(res)
                    nums[i] = x ^ nums[i]
                    ac.lst(nums)
                    return
        return

    @staticmethod
    def lg_p1512(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1512
        tag: game_dp|date
        """
        dt = DateTime()
        stack = [[1900, 1, 1]]
        yy, mm, dd = stack[0]
        dates = []
        while [yy, mm, dd] < [2006, 11, 4]:
            if dd + 1 <= dt.year_month_day_cnt(yy, mm):
                cur = [yy, mm, dd + 1]
            elif mm + 1 <= 12:
                cur = [yy, mm + 1, 1]
            else:
                cur = [yy + 1, 1, 1]
            yy, mm, dd = cur
            dates.append(cur)
        dct = set(tuple(dt) for dt in dates)

        dp = dict()
        dp[(2006, 11, 4)] = False
        for yy, mm, dd in dates[:-1][::-1]:
            dp[(yy, mm, dd)] = False

            cur = [yy, mm + 1, dd] if mm + 1 <= 12 else [yy + 1, 1, dd]
            if (cur[0], cur[1], cur[2]) in dct and not dp[(cur[0], cur[1], cur[2])]:
                dp[(yy, mm, dd)] = True

            if dd + 1 <= dt.year_month_day_cnt(yy, mm):
                cur = [yy, mm, dd + 1]
            elif mm + 1 <= 12:
                cur = [yy, mm + 1, 1]
            else:
                cur = [yy + 1, 1, 1]
            if (cur[0], cur[1], cur[2]) in dct and not dp[(cur[0], cur[1], cur[2])]:
                dp[(yy, mm, dd)] = True

        for _ in range(ac.read_int()):
            x, y, z = ac.read_list_ints()
            ac.st("YES" if dp.get((x, y, z), True) else "NO")

        return

    @staticmethod
    def lg_p2092(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2092
        tag: prime|game_dp
        """
        n = ac.read_int()
        lst = NumFactor().get_prime_factor(n)
        nums = []
        for p, c in lst:
            nums.extend([p] * c)
        if not nums or len(nums) == 1:
            ac.st(1)
            ac.st(0)
            return
        if len(nums) == 2:
            ac.st(2)
            return
        ac.st(1)
        ac.st(nums[0] * nums[1])
        return

    @staticmethod
    def lg_p2953(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2953
        tag: game_dp|winning_state|liner_dp
        """
        n = 1000000
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            lst = [w for w in str(i) if w != "0"]
            lst.sort()
            for w in [lst[0], lst[-1]]:
                if not dp[i - int(w)]:
                    dp[i] = 1
                    break
        for _ in range(ac.read_int()):
            if dp[ac.read_int()]:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def abc_349e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc349/tasks/abc349_e
        tag: game_dp|implemention|classical
        """
        lst = []
        for _ in range(3):
            lst.extend(ac.read_list_ints())
        ind = list()
        ind.append([[i, i] for i in range(3)])
        ind.append([[i, 2 - i] for i in range(3)])
        ind.extend([[i, j] for j in range(3)] for i in range(3))
        ind.extend([[i, j] for i in range(3)] for j in range(3))

        @lru_cache(None)
        def dfs(tup):
            cur = sum(-math.inf < x < math.inf for x in tup)
            if cur == 0:
                return 0
            res = -math.inf
            flag = -math.inf if cur % 2 else math.inf
            for i in range(3):
                for j in range(3):
                    if -math.inf < tup[i * 3 + j] < math.inf:
                        nex = list(tup)
                        nex[i * 3 + j] = flag
                        if any(all(nex[a * 3 + b] == flag for a, b in ls) for ls in ind):
                            return math.inf
                        res = max(res, tup[i * 3 + j] - dfs(tuple(nex)))
            return res

        ans = dfs(tuple(lst))
        ac.st("Takahashi" if ans > 0 else "Aoki")
        return

    @staticmethod
    def abc_231e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc231/tasks/abc231_e
        tag: implemention|greedy|dfs|linear_dp
        """
        n, x = ac.read_list_ints()
        nums = ac.read_list_ints()

        @lru_cache(None)
        def dfs(num):
            if num == 0:
                return 0
            res = math.inf
            for i in range(n - 1, -1, -1):
                if num >= nums[i]:
                    cur = num // nums[i] + dfs(num % nums[i])
                    res = min(res, cur)
            for i in range(n):
                if nums[i] - num < num < nums[i]:
                    cur = 1 + dfs(nums[i] - num)
                    res = min(res, cur)
                    break
            return res

        ans = dfs(x)
        ac.st(ans)
        return

    @staticmethod
    def cf_1728d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1728/problem/D
        tag: gap_dp|interval_dp
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            dp = [[0] * n for _ in range(n)]

            def comb(x, y):
                if x > y:
                    return 0
                elif x < y:
                    return 2
                return 1

            for i in range(n - 1, -1, -1):
                for j in range(i + 1, n, 2):
                    if i == j - 1:
                        # 2-win 1-draw 0-lose
                        dp[i][j] = 2 if s[i] != s[j] else 1
                        continue

                    # s[i]
                    f1 = comb(s[i], s[i + 1]) if dp[i + 2][j] == 1 else dp[i + 2][j]
                    f2 = comb(s[i], s[j]) if dp[i + 1][j - 1] == 1 else dp[i + 1][j - 1]
                    # s[j]
                    f3 = comb(s[j], s[j - 1]) if dp[i][j - 2] == 1 else dp[i][j - 2]
                    f4 = comb(s[j], s[i]) if dp[i + 1][j - 1] == 1 else dp[i + 1][j - 1]
                    dp[i][j] = max(min(f1, f2), min(f3, f4))
            ans = dp[0][n - 1]
            ac.st("Alice" if ans == 2 else "Draw")
        return

    @staticmethod
    def abc_368f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc368/tasks/abc368_f
        tag: nim|game_dp|xor
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ceil = 10 ** 5
        dp = [1] * (ceil + 1)
        dp[0] = dp[1] = 0
        for num in range(2, ceil + 1):
            for x in range(num * 2, ceil + 1, num):
                dp[x] = max(dp[x], dp[num] + 1)
        ans = reduce(xor, [dp[x] for x in nums])
        ac.st("Bruno" if not ans else "Anna")
        return

    @staticmethod
    def cf_1383b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1383/B
        tag: game_dp|odd_even|win_state|lose_state|draw_state
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            s = reduce(xor, nums)
            if s == 0:
                ac.st("DRAW")
                continue
            for i in range(31, -1, -1):
                if (s >> i) & 1:
                    one = sum((num >> i) & 1 for num in nums)
                    if one % 4 == 3 and (n - one) % 2 == 0:
                        ac.st("LOSE")
                    else:
                        ac.st("WIN")
                    break
        return
"""
Algorithm：interval_dp
Description：prefix_sum|interval_dp|preprocess_dp|memory_search

====================================LeetCode====================================
375（https://leetcode.cn/problems/guess-number-higher-or-lower-ii/）interval_dp
1039（https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/）circular_array|interval_dp
2472（https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/）palindrome_substring|linear_dp|manacher
2430（https://leetcode.cn/problems/maximum-deletions-on-a-string/）lcp|liner_dp
1547（https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/）interval_dp|implemention
1278（https://leetcode.cn/problems/palindrome-partitioning-iii/）preprocess_dp|interval_dp
1690（https://leetcode.cn/problems/stone-game-vii/description/）interval_dp
1312（https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/）interval_dp|longest_palindrome_subsequence
3040（https://leetcode.com/contest/biweekly-contest-124/problems/maximum-number-of-operations-with-the-same-score-ii/）interval_dp|brute_force
3277（https://leetcode.cn/problems/maximum-xor-score-subarray-queries/）interval_dp|brain_teaser|divide_and_conquer|reverse_thinking

=====================================LuoGu======================================
P1521（https://www.luogu.com.cn/problem/P1521）merge_sort|multiplication_method|tree_array
P1775（https://www.luogu.com.cn/problem/P1775）classical|interval_dp|prefix_sum
P2426（https://www.luogu.com.cn/problem/P2426）classical|interval_dp
P2690（https://www.luogu.com.cn/problem/P2690）interval_dp|implemention|memory_search
P1435（https://www.luogu.com.cn/problem/P1435）classical|interval_dp|longest_non_sub_consequence_palindrome
P1388（https://www.luogu.com.cn/problem/P1388）back_trace|brute_force|interval_dp
P1103（https://www.luogu.com.cn/problem/P1103）matrix_dp
P2858（https://www.luogu.com.cn/problem/P2858）classical|interval_dp
P1880（https://www.luogu.com.cn/problem/P1880）circular|interval_dp
P3205（https://www.luogu.com.cn/problem/P3205）interval_dp|rolling_update
P1040（https://www.luogu.com.cn/problem/P1040）interval_dp|specific_plan
P1430（https://www.luogu.com.cn/problem/P1430）interval_dp|prefix_sum
P2308（https://www.luogu.com.cn/problem/P2308）interval_dp|recursion
P2734（https://www.luogu.com.cn/problem/P2734）prefix_sum|interval_dp
P3004（https://www.luogu.com.cn/problem/P3004）interval_dp
P3205（https://www.luogu.com.cn/problem/P3205）interval_dp|rolling_update
P4170（https://www.luogu.com.cn/problem/P4170）interval_dp|math
P1063（https://www.luogu.com.cn/problem/P1063）interval_dp|classical|circular_array

===================================CodeForces===================================
1509C（https://codeforces.com/problemset/problem/1509/C）interval_dp
607B（https://codeforces.com/problemset/problem/607/B）interval_dp
1771D（https://codeforces.com/problemset/problem/1771/D）interval_dp|tree_dp|lps|classical|longest_palindrome_subsequence
1025D（https://codeforces.com/problemset/problem/1025/D）interval_dp|brain_teaser
983B（https://codeforces.com/problemset/problem/983/B）interval_dp|matrix_dp|preprocess|classical

===================================AtCoder===================================
ABC217F（https://atcoder.jp/contests/abc217/tasks/abc217_f）interval_dp|implemention|comb_dp|counter

=====================================AcWing=====================================
3996（https://www.acwing.com/problem/content/3999/）interval_dp|longest_palindrome_subsequence

"""
import math
from collections import defaultdict
from functools import lru_cache
from itertools import accumulate
from typing import List

from src.mathmatics.comb_perm.template import Combinatorics
from src.utils.fast_io import FastIO


MOD = 10 ** 9 + 7


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_607b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/607/B
        tag: interval_dp
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        dp = [[math.inf] * n for _ in range(n + 1)]
        for i in range(n):
            for j in range(i):
                dp[i][j] = 0
        dp[n] = [0] * n

        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            if i + 1 < n:
                dp[i][i + 1] = 2 if nums[i] != nums[i + 1] else 1
            for j in range(i + 2, n):

                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1
                if nums[i] == nums[i + 1]:
                    dp[i][j] = min(dp[i][j], 1 + dp[i + 2][j])

                for k in range(i + 2, j + 1):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])
                    if nums[k] == nums[i]:
                        dp[i][j] = min(dp[i][j], dp[i + 1][k - 1] + dp[k + 1][j])

        ac.st(dp[0][n - 1])
        return

    @staticmethod
    def cf_1509c(n, nums):
        """
        url: https://codeforces.com/problemset/problem/1509/C
        tag: interval_dp
        """
        dp = [[math.inf] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 0
            for j in range(i + 1, n):
                dp[i][j] = nums[j] - nums[i] + min(dp[i + 1][j], dp[i][j - 1])
        return dp[0][n - 1]

    @staticmethod
    def lc_1312(s: str) -> int:
        """
        url: https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/
        tag: interval_dp|longest_palindrome_subsequence
        """
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            if i + 1 < n:
                dp[i][i + 1] = 2 if s[i] == s[i + 1] else 1
            for j in range(i + 2, n):
                a, b = dp[i + 1][j], dp[i][j - 1]
                a = a if a > b else b
                b = dp[i + 1][j - 1] + 2 * int(s[i] == s[j])

                dp[i][j] = a if a > b else b
        return n - dp[0][n - 1]

    @staticmethod
    def lc_1547(n: int, cuts: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/
        tag: interval_dp|implemention
        """
        cuts.sort()
        cuts.insert(0, 0)
        cuts.append(n)
        m = len(cuts)
        dp = [[0] * (m + 1) for _ in range(m + 1)]
        for i in range(m - 1, -1, -1):
            for j in range(i + 2, m):
                dp[i][j] = cuts[j] - cuts[i] + min(dp[i][k] + dp[k][j] for k in range(i + 1, j))
        return dp[0][m - 1]

    @staticmethod
    def lc_1690(stones: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/stone-game-vii/description/
        tag: interval_dp
        """
        n = len(stones)
        pre = list(accumulate(stones, initial=0))

        @lru_cache(None)
        def dfs(i, j):
            if i == j:
                return 0
            return max(-dfs(i + 1, j) + pre[j + 1] - pre[i + 1], -dfs(i, j - 1) + pre[j] - pre[i])

        ans = dfs(0, n - 1)
        dfs.cache_clear()
        return ans

    @staticmethod
    def lc_2472(s: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/
        tag: palindrome_substring|linear_dp|manacher
        """
        n = len(s)
        res = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            res[i][i] = 1
            if i + 1 < n:
                res[i][i + 1] = 1 if s[i] == s[i + 1] else 0
            for j in range(i + 2, n):
                if s[i] == s[j] and res[i + 1][j - 1]:
                    res[i][j] = 1

        dp = [0] * (n + 1)
        for i in range(n):
            dp[i + 1] = dp[i]
            for j in range(0, i - k + 2):
                if i - j + 1 >= k and res[j][i]:
                    dp[i + 1] = max(dp[i + 1], dp[j] + 1)
        return dp[-1]

    @staticmethod
    def lg_p3205(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3205
        tag: interval_dp|rolling_update
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = 19650827
        dp = [[[0, 0] for _ in range(n)] for _ in range(2)]
        pre = 0
        for i in range(n - 1, -1, -1):
            cur = 1 - pre
            dp[cur][i][0] = 1
            for j in range(i + 1, n):
                x = 0

                if nums[j - 1] < nums[j]:
                    x += dp[cur][j - 1][1]
                if nums[i] < nums[j]:
                    x += dp[cur][j - 1][0]
                dp[cur][j][1] = x % mod
                x = 0

                if nums[i + 1] > nums[i]:
                    x += dp[pre][j][0]
                if nums[j] > nums[i]:
                    x += dp[pre][j][1]
                dp[cur][j][0] = x % mod
            pre = cur
        ac.st(sum(dp[pre][n - 1]) % mod)
        return

    @staticmethod
    def lg_p1040(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1040
        tag: interval_dp|specific_plan
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = nums[i]
            if i + 1 < n:
                dp[i][i + 1] = nums[i] + nums[i + 1]
            for j in range(i + 2, n):
                dp[i][j] = max(dp[i][k - 1] * dp[k + 1][j] + dp[k][k] for k in range(i + 1, j))

        ans = []
        stack = [[0, n - 1]]
        while stack:
            i, j = stack.pop()
            if i == j:
                ans.append(i + 1)
                continue
            if i == j - 1:
                ans.append(i + 1)
                ans.append(j + 1)
                continue
            for k in range(i + 1, j):
                if dp[i][j] == dp[i][k - 1] * dp[k + 1][j] + dp[k][k]:
                    ans.append(k + 1)
                    stack.append([k + 1, j])
                    stack.append([i, k - 1])
                    break
        ac.st(dp[0][n - 1])
        ac.lst(ans)
        return

    @staticmethod
    def lg_p1430(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1430
        tag: interval_dp|prefix_sum
        """
        for _ in range(ac.read_int()):
            nums = ac.read_list_ints()
            n = nums.pop(0)
            pre = [0] * (n + 1)
            for i in range(n):
                pre[i + 1] = pre[i] + nums[i]

            dp = [0] * n
            post = [0] * n
            for i in range(n - 1, -1, -1):
                dp[i] = nums[i]
                post[i] = min(nums[i], post[i])
                floor = min(0, nums[i])
                for j in range(i + 1, n):
                    s = pre[j + 1] - pre[i]
                    dp[j] = s
                    dp[j] = max(dp[j], s - post[j])
                    dp[j] = max(dp[j], s - floor)
                    floor = min(floor, dp[j])
                    post[j] = min(post[j], dp[j])
            ac.st(dp[n - 1])
        return

    @staticmethod
    def lg_p2308(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2308
        tag: interval_dp|recursion
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = ac.accumulate(nums)
        dp = [[math.inf] * n for _ in range(n)]
        mid = [[-1] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 0
            for j in range(i + 1, n):
                ind = i
                for k in range(i, j):
                    cur = dp[i][k] + dp[k + 1][j] + pre[j + 1] - pre[i]
                    if cur < dp[i][j]:
                        dp[i][j] = cur
                        ind = k
                mid[i][j] = ind

        ans = []
        nums = [str(x) for x in nums]
        stack = [[0, n - 1]]
        while stack:
            i, j = stack.pop()
            if i >= 0:
                stack.append([~i, j])
                if i >= j - 1:
                    continue
                k = mid[i][j]
                stack.append([k + 1, j])
                stack.append([i, k])
            else:
                i = ~i
                if i < j:
                    nums[i] = "(" + nums[i]
                    nums[j] = nums[j] + ")"
                    ans.append(pre[j + 1] - pre[i])
        ac.st("+".join(nums))
        ac.st(sum(ans))
        ac.lst(ans)
        return

    @staticmethod
    def lg_p2734(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2734
        tag: prefix_sum|interval_dp
        """
        n = ac.read_int()
        nums = []
        while len(nums) < n:
            nums.extend(ac.read_list_ints())
        pre = ac.accumulate(nums)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = nums[i]
            for j in range(i + 1, n):
                dp[i][j] = max(nums[i] + pre[j + 1] - pre[i + 1] - dp[i + 1][j],
                                  nums[j] + pre[j] - pre[i] - dp[i][j - 1])
        a = dp[0][n - 1]
        ac.lst([a, pre[-1] - a])
        return

    @staticmethod
    def lg_p3004(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3004
        tag: interval_dp
        """
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        dp = [[0] * n for _ in range(2)]
        pre = ac.accumulate(nums)
        x = 0
        for i in range(n - 1, -1, -1):
            y = 1 - x
            dp[y][i] = nums[i]
            for j in range(i + 1, n):
                dp[y][j] = max(pre[j + 1] - pre[i + 1] - dp[x][j] + nums[i],
                                  pre[j] - pre[i] - dp[y][j - 1] + nums[j])
            x = y
        ac.st(dp[x][n - 1])
        return

    @staticmethod
    def lg_p4170(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4170
        tag: interval_dp|math
        """
        s = ac.read_str()
        n = len(s)
        dp = [[math.inf] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1])
                else:
                    for k in range(i, j):
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])
        ac.st(dp[0][n - 1])
        return

    @staticmethod
    def ac_3996(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3999/
        tag: interval_dp|longest_palindrome_subsequence
        """
        ac.read_int()
        nums = ac.read_list_ints()
        pre = []
        for num in nums:
            if pre and pre[-1] == num:
                continue
            pre.append(num)
        nums = pre[:]
        n = len(nums)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if nums[i] == nums[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 1
                else:
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1
        ac.st(dp[0][n - 1])
        return

    @staticmethod
    def lc_1278(s: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/palindrome-partitioning-iii/
        tag: preprocess_dp|interval_dp
        """
        n = len(s)

        cost = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            if i + 1 < n:
                j = i + 1
                cost[i][j] = 1 if s[i] != s[j] else 0
            for j in range(i + 2, n):
                cost[i][j] = cost[i + 1][j - 1] + int(s[i] != s[j])

        dp = [[n] * k for _ in range(n + 1)]
        for i in range(n):
            dp[i + 1][0] = cost[0][i]
            for j in range(1, k):
                dp[i + 1][j] = min(dp[x][j - 1] + cost[x][i] for x in range(i + 1))
        return dp[n][k - 1]

    @staticmethod
    def abc_217f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc217/tasks/abc217_f
        tag: interval_dp|implemention|comb_dp|counter
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(2 * n)]
        edges = [set() for _ in range(2 * n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            if i > j:
                i, j = j, i
            if (j - i + 1) % 2 == 0:
                dct[i].append(j)
                edges[i].add(j)
        for i in range(2 * n):
            dct[i].sort()

        mod = 998244353
        cb = Combinatorics(n * 4, mod)

        @lru_cache(None)
        def dfs(x, y):
            if x == y - 1:
                return 1 if y in dct[x] else 0
            res = 0
            for z in dct[x]:
                if z > y:
                    break
                left = dfs(x + 1, z - 1) if x + 1 < z - 1 else 1
                right = dfs(z + 1, y) if z + 1 < y else 1
                cur = left * right
                if not cur:
                    continue
                lst = [1]
                if x + 1 < z - 1:
                    lst.append((z - 1 - x - 1 + 1) // 2)
                else:
                    lst.append(0)
                if z + 1 < y:
                    lst.append((y - z - 1 + 1) // 2)
                else:
                    lst.append(0)
                s = sum(lst)
                cur *= cb.comb(s, lst[1] + 1)
                res += cur
                res %= mod
            return res

        ans = dfs(0, 2 * n - 1)
        ac.st(ans)
        return

    @staticmethod
    def cf_1114d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1114/D
        tag: interval_dp|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        pre = []
        for num in nums:
            if pre and pre[-1] == num:
                continue
            pre.append(num)
        n = len(pre)
        dp = [0] * n
        for i in range(n - 2, -1, -1):
            ndp = [0] * n
            for j in range(i + 1, n):
                if pre[i] == pre[j]:
                    ndp[j] = dp[j - 1] + 1
                else:
                    ndp[j] = min(ndp[j - 1] + 1, dp[j] + 1)
            dp = ndp[:]
        ac.st(dp[n - 1])
        return

    @staticmethod
    def cf_1771d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1771/D
        tag: interval_dp|tree_dp|lps|classical|longest_palindrome_subsequence
        """
        def f(ii, jj):
            return ii * n + jj

        for _ in range(ac.read_int()):
            n = ac.read_int()
            dct = defaultdict(list)
            dp = [0] * n * n
            for i in range(n):
                dp[f(i, i)] = 1
            s = ac.read_str()
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)
                dp[f(i, j)] = dp[f(j, i)] = 2 if s[i] == s[j] else 1

            parent = [-1] * n * n
            edges = defaultdict(list)
            for i in range(n):
                stack = [(i, -1, 0)]
                dis = [0] * n
                while stack:
                    x, fa, d = stack.pop()
                    dis[x] = d
                    for y in dct[x]:
                        if y != fa:
                            parent[f(i, y)] = x
                            stack.append((y, x, d + 1))
                for j in range(i + 1, n):
                    edges[dis[j]].append([i, j])

            for d in range(2, n + 1):
                for i, j in edges[d]:
                    y = parent[f(i, j)]
                    x = parent[f(j, i)]
                    cur = max(dp[f(i, y)], dp[f(j, x)])
                    if s[i] == s[j]:
                        cur = max(dp[f(x, y)] + 2, cur)
                    dp[f(i, j)] = dp[f(j, i)] = cur
            ac.st(max(dp))
        return

    @staticmethod
    def lg_p1063(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1063
        tag: interval_dp|classical|circular_array
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [[0] * 2 * n for _ in range(2 * n)]
        nums += nums
        for i in range(2 * n - 2, -1, -1):
            for j in range(i + 1, 2 * n):
                cur = 0
                for k in range(i, j):
                    cur = max(cur, dp[i][k] + dp[k + 1][j] + nums[i] * nums[k + 1] * nums[(j + 1) % (2 * n)])
                dp[i][j] = cur
        ans = max(dp[i][i + n - 1] for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def lc_3277(nums: List[int], queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-xor-score-subarray-queries/
        tag: interval_dp|brain_teaser|divide_and_conquer|reverse_thinking
        """
        n = len(nums)
        dp = [[0] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = nums[i]
        for ll in range(1, n):
            for i in range(n - ll):
                j = i + ll
                dp[i][j] = dp[i][j - 1] ^ dp[i + 1][j]
        for ll in range(1, n):
            for i in range(n - ll):
                j = i + ll
                dp[i][j] = max(dp[i][j], max(dp[i][j - 1], dp[i + 1][j]))

        return [dp[ll][rr] for ll, rr in queries]

    @staticmethod
    def cf_1025d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1025/D
        tag: interval_dp|brain_teaser
        """
        n = ac.read_int()  # TLE
        nums = ac.read_list_ints()

        f = [[0] * n for _ in range(n)]
        for i in range(n):
            for j in range(i + 1, n):
                if math.gcd(nums[i], nums[j]) != 1:
                    f[i][j] = f[j][i] = 1

        dp = [[[0] * 3 for _ in range(n)] for _ in range(n)]

        for length in range(1, n + 1):
            for i in range(n):
                j = i + length - 1
                if j == n:
                    break
                for ind in range(3):
                    if ind == 0:
                        x = i - 1
                    elif ind == 1:
                        x = j + 1
                    else:
                        x = 0
                    if not 0 <= x < n:
                        continue
                    if ind == 2 and not (i == 0 and j == n - 1):
                        continue
                    if i == j:
                        dp[i][j][ind] = ind == 2 or f[i][x]
                        continue
                    for k in range(i, j + 1):
                        if ind == 2 or f[k][x]:
                            left = 1 if i > k - 1 or dp[i][k - 1][1] else 0
                            right = 1 if k + 1 > j or dp[k + 1][j][0] else 0
                            if left and right:
                                dp[i][j][ind] = 1
                                break
        if dp[0][n - 1][2]:
            ac.yes()
        else:
            ac.no()
        return

    @staticmethod
    def cf_983b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/983/B
        tag: interval_dp|matrix_dp|preprocess|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [1] * n * n
        for i in range(n - 1, -1, -1):
            dp[i * n + i] = nums[i]
            for j in range(i + 1, n):
                dp[i * n + j] = dp[i * n + j - 1] ^ dp[(i + 1) * n + j]
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                dp[i * n + j] = max(dp[i * n + j], max(dp[i * n + j - 1], dp[(i + 1) * n + j]))
        for _ in range(ac.read_int()):
            ll, rr = ac.read_list_ints_minus_one()
            ac.st(dp[ll * n + rr])
        return
"""
Algorithm：liner_dp
Description：prefix_suffix|maximum_sub_consequence_sum

====================================LeetCode====================================
940（https://leetcode.cn/problems/distinct-subsequences-ii/）liner_dp|classical|different_subsequence
87（https://leetcode.cn/problems/scramble-string/）liner_dp|memory_search
2361（https://leetcode.cn/problems/minimum-costs-using-the-train-line/）linear_dp
2318（https://leetcode.cn/problems/number-of-distinct-roll-sequences/）linear_dp|brute_force|counter
2263（https://leetcode.cn/problems/make-array-non-decreasing-or-non-increasing/）linear_dp
2209（https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/）linear_dp|prefix_sum
2188（https://leetcode.cn/problems/minimum-time-to-finish-the-race/）preprocess|linear_dp
2167（https://leetcode.cn/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/）prefix_suffix|linear_dp|preprocess|brute_force
2431（https://leetcode.cn/problems/maximize-total-tastiness-of-purchased-fruits/）liner_dp|implemention
2603（https://leetcode.cn/problems/collect-coins-in-a-tree/）liner_dp
2547（https://leetcode.cn/problems/minimum-cost-to-split-an-array/）liner_dp|counter
2638（https://leetcode.cn/problems/count-the-number-of-k-free-subsets/）liner_dp|counter
2597（https://leetcode.cn/problems/the-number-of-beautiful-subsets/）liner_dp|hash
2713（https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/）data_range|liner_dp
1526（https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/）linear_dp|greedy
1553（https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/）brain_teaser|greedy|memory_search|liner_dp
1872（https://leetcode.cn/problems/stone-game-viii/）prefix_sum|reverse_order|linear_dp
1770（https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/）liner_dp
823（https://leetcode.cn/problems/binary-trees-with-factors/description/）liner_dp|counter
2746（https://leetcode.cn/problems/decremental-string-concatenation/）hash|liner_dp|implemention
1911（https://leetcode.cn/problems/maximum-alternating-subsequence-sum/）liner_dp
2321（https://leetcode.cn/problems/maximum-score-of-spliced-array/description/）liner_dp|maximum_sub_consequence_sum
2320（https://leetcode.cn/problems/count-number-of-ways-to-place-houses/）liner_dp
1824（https://leetcode.cn/problems/minimum-sideway-jumps/description/）liner_dp|rolling_update
978（https://leetcode.cn/problems/longest-turbulent-subarray/description/）liner_dp|rolling_update
1027（https://leetcode.cn/problems/longest-arithmetic-subsequence/）liner_dp
1987（https://leetcode.cn/problems/number-of-unique-good-subsequences/description/）counter|linear_dp
2355（https://leetcode.cn/problems/maximum-number-of-books-you-can-take/）monotonic_stack|liner_do
2866（https://leetcode.cn/problems/beautiful-towers-ii/）monotonic_stack|liner_dp|prefix_suffix
2327（https://leetcode.cn/problems/number-of-people-aware-of-a-secret/description/）prefix_sum|diff_array|liner_dp
2572（https://leetcode.cn/problems/count-the-number-of-square-free-subsets/description/）liner_dp|counter
2289（https://leetcode.cn/problems/steps-to-make-array-non-decreasing/）liner_dp|counter|monotonic_stack|linked_list|
3041（https://leetcode.com/contest/biweekly-contest-124/problems/maximize-consecutive-elements-in-an-array-after-modification/）linear_dp

=====================================LuoGu======================================
P1970（https://www.luogu.com.cn/problem/P1970）greedy|liner_dp
P1564（https://www.luogu.com.cn/problem/P1564）liner_dp
P1481（https://www.luogu.com.cn/problem/P1481）liner_dp
P2029（https://www.luogu.com.cn/problem/P2029）liner_dp
P2031（https://www.luogu.com.cn/problem/P2031）liner_dp
P2062（https://www.luogu.com.cn/problem/P2062）liner_dp|prefix_max
P2072（https://www.luogu.com.cn/problem/P2072）liner_dp
P2096（https://www.luogu.com.cn/problem/P2096）liner_dp
P5761（https://www.luogu.com.cn/problem/P5761）liner_dp
P2285（https://www.luogu.com.cn/problem/P2285）liner_dp|prefix_max
P2642（https://www.luogu.com.cn/problem/P2642）brute_force|liner_dp
P1470（https://www.luogu.com.cn/problem/P1470）liner_dp
P1096（https://www.luogu.com.cn/problem/P1096）liner_dp
P2896（https://www.luogu.com.cn/problem/P2896）prefix_suffix|linear_dp
P2904（https://www.luogu.com.cn/problem/P2904）prefix_sum|preprocess|liner_dp
P3062（https://www.luogu.com.cn/problem/P3062）liner_dp|brute_force
P3842（https://www.luogu.com.cn/problem/P3842）liner_dp|implemention
P3903（https://www.luogu.com.cn/problem/P3903）liner_dp|brute_force
P5414（https://www.luogu.com.cn/problem/P5414）greedy|liner_dp
P6191（https://www.luogu.com.cn/problem/P6191）liner_dp|brute_force|counter
P6208（https://www.luogu.com.cn/problem/P6208）liner_dp|implemention
P7404（https://www.luogu.com.cn/problem/P7404）linear_dp|brute_force
P7541（https://www.luogu.com.cn/problem/P7541）liner_dp|memory_search|digital_dp
P7767（https://www.luogu.com.cn/problem/P7767）liner_dp
P2246（https://www.luogu.com.cn/problem/P2246）string|counter|liner_dp
P4933（https://www.luogu.com.cn/problem/P4933）liner_dp|counter
P1874（https://www.luogu.com.cn/problem/P1874）liner_dp
P2513（https://www.luogu.com.cn/problem/P2513）prefix_sum|linear_dp
P1280（https://www.luogu.com.cn/problem/P1280）reverse_order|linear_dp
P1282（https://www.luogu.com.cn/problem/P1282）classical|liner_dp|hash
P1356（https://www.luogu.com.cn/problem/P1356）classical|mod|linear_dp
P1385（https://www.luogu.com.cn/problem/P1385）liner_dp|prefix_sum|brain_teaser|lexicographical_order
P1809（https://www.luogu.com.cn/problem/P1809）brain_teaser|liner_dp|greedy
P1868（https://www.luogu.com.cn/problem/P1868）liner_dp|binary_search
P1978（https://www.luogu.com.cn/problem/P1978）liner_dp|mul|inclusion_exclusion
P2432（https://www.luogu.com.cn/problem/P2432）liner_dp|pointer
P2439（https://www.luogu.com.cn/problem/P2439）liner_dp|binary_search
P2476（https://www.luogu.com.cn/problem/P2476）counter|linear_dp|memory_search
P2849（https://www.luogu.com.cn/problem/P2849）matrix_dp
P3448（https://www.luogu.com.cn/problem/P3448）liner_dp|counter|matrix_dp
P3558（https://www.luogu.com.cn/problem/P3558）linear_dp|implemention
B3734（https://www.luogu.com.cn/problem/B3734）linear_dp
P3901（https://www.luogu.com.cn/problem/P3901）pointer|linear_dp|pointer
P4401（https://www.luogu.com.cn/problem/P4401）linear_dp
P4933（https://www.luogu.com.cn/problem/P4933）linear_dp|counter
P5095（https://www.luogu.com.cn/problem/P5095）classical|linear_dp
P5810（https://www.luogu.com.cn/problem/P5810）linear_dp
P6040（https://www.luogu.com.cn/problem/P6040）monotonic_queue|linear_dp
P6120（https://www.luogu.com.cn/problem/P6120）linear_dp|implemention
P6146（https://www.luogu.com.cn/problem/P6146）linear_dp|brute_force|counter
P7994（https://www.luogu.com.cn/problem/P7994）linear_dp
P8656（https://www.luogu.com.cn/problem/P8656）linear_dp
P8725（https://www.luogu.com.cn/problem/P8725）classical|matrix_dp|pointer
P8784（https://www.luogu.com.cn/problem/P8784）linear_dp|fast_power
P8786（https://www.luogu.com.cn/problem/P8786）linear_dp|memory_search|implemention
P8816（https://www.luogu.com.cn/problem/P8816）classical|matrix_dp|implemention
P2359（https://www.luogu.com.cn/problem/P2359）linear_dp
P1514（https://www.luogu.com.cn/problem/P1514）bfs|linear_dp|observation

===================================CodeForces===================================
75D（https://codeforces.com/problemset/problem/75/D）compress_array|linear_dp
1084C（https://codeforces.com/problemset/problem/1084/C）liner_dp|prefix_sum
166E（https://codeforces.com/problemset/problem/166/E）liner_dp|counter
1221D（https://codeforces.com/problemset/problem/1221/D）liner_dp|implemention
1437C（https://codeforces.com/problemset/problem/1437/C）liner_dp
1525D（https://codeforces.com/problemset/problem/1525/D）liner_dp
1286A（https://codeforces.com/problemset/problem/1286/A）liner_dp
1221D（https://codeforces.com/problemset/problem/1221/D）liner_dp
731E（https://codeforces.com/contest/731/problem/E）prefix_sum|reverse_order|liner_dp
1913D（https://codeforces.com/contest/1913/problem/D）monotonic_stack|linear_dp|prefix_sum
1703G（https://codeforces.com/contest/1703/problem/G）greedy|linear_dp|data_range|limit_operation
1829H（https://codeforces.com/contest/1829/problem/H）counter|linear_dp|classical|bit_operation|data_range
977F（https://codeforces.com/contest/977/problem/F）linear_dp|specific_plan
988F（https://codeforces.com/contest/988/problem/F）linear_dp|brute_force|classical|greedy
988D（https://codeforces.com/contest/988/problem/D）linear_dp|brute_force
999F（https://codeforces.com/contest/999/problem/F）linear_dp|brute_force
1066F（https://codeforces.com/contest/1066/problem/F）linear_dp|brute_force|greedy|sorting
1066D（https://codeforces.com/contest/1066/problem/D）linear_dp|two_pointers
1108D（https://codeforces.com/contest/1108/problem/D）linear_dp|specific_plan
1154F（https://codeforces.com/contest/1154/problem/F）linear_dp|reverse_thinking|brute_force|greedy|implemention|data_range
1176F（https://codeforces.com/contest/1176/problem/F）linear_dp|greedy|implemention
1249E（https://codeforces.com/contest/1249/problem/E）linear_dp|classical|greedy
1256E（https://codeforces.com/contest/1256/problem/E）linear_dp|greedy|brain_teaser
1353E（https://codeforces.com/contest/1353/problem/E）linear_dp|greedy|brute_force
1472F（https://codeforces.com/contest/1472/problem/F）linear_dp|classical
1624E（https://codeforces.com/contest/1624/problem/E）linear_dp|brute_force
1969C（https://codeforces.com/contest/1969/problem/C）linear_dp|data_range|implemention
264C（https://codeforces.com/contest/264/problem/C）linear_dp|classical|maximum_second
1894C2（https://codeforces.com/contest/1984/problem/C2）linear_dp|implemention|greedy
1984F（https://codeforces.com/contest/1984/problem/F）brute_force|brain_teaser|linear_dp
1312E（https://codeforces.com/contest/1312/problem/E）linear_dp|implemention|greedy
1982C（https://codeforces.com/contest/1982/problem/C）linear_dp|two_pointers
1989D（https://codeforces.com/contest/1989/problem/D）greedy|linear_dp|implemention
1155D（https://codeforces.com/problemset/problem/1155/D）linear_dp|classical|max_con_sub_sum
319C（https://codeforces.com/problemset/problem/319/C）slope_dp|linear_dp|monotonic_queue
1427C（https://codeforces.com/problemset/problem/1427/C）linear_dp|data_range|observation
1992D（https://codeforces.com/contest/1992/problem/D）linear_dp|implemention
463D（https://codeforces.com/problemset/problem/463/D）observation|linear_dp|classical|lcs|dag_dp|topological_sort
1716D（https://codeforces.com/problemset/problem/1716/D）linear_dp|observation|prefix_sum
225C（https://codeforces.com/problemset/problem/225/C）linear_dp|corner_case
710E（https://codeforces.com/problemset/problem/710/E）observation|linear_dp|fill_table
1391D（https://codeforces.com/contest/1391/problem/D）observation|linear_dp|state_dp
372C（https://codeforces.com/problemset/problem/372/C）monotonic_queue|classical
1528B（https://codeforces.com/problemset/problem/1528/B）linear_dp|euler_series
985E（https://codeforces.com/problemset/problem/985/E）linear_dp
1197D（https://codeforces.com/problemset/problem/1197/D）linear_dp|brain_teaser|prefix_sum
372F（https://atcoder.jp/contests/abc372/tasks/abc372_f）linear_dp|implemention|deque|array_implemention
1082E（https://codeforces.com/problemset/problem/1082/E）linear_dp|prefix_sum|brain_teaser|observation
1994C（https://codeforces.com/problemset/problem/1994/C）linear_dp|two_pointers

====================================AtCoder=====================================
ABC129E（https://atcoder.jp/contests/abc129/tasks/abc129_e）brain_teaser|digital_dp
ABC322E（https://atcoder.jp/contests/abc322/tasks/abc322_e）linear_dp
ABC318E（https://atcoder.jp/contests/abc318/tasks/abc318_e）linear_dp
ABC315F（https://atcoder.jp/contests/abc315/tasks/abc315_f）linear_dp|brute_force
ABC345E（https://atcoder.jp/contests/abc345/tasks/abc345_e）linear_dp
ABC291F（https://atcoder.jp/contests/abc291/tasks/abc291_f）linear_dp|prefix_suffix
ABC285E（https://atcoder.jp/contests/abc285/tasks/abc285_e）linear_dp|brain_teaser|circular_array|classical
ABC283E（https://atcoder.jp/contests/abc283/tasks/abc283_e）linear_dp
ABC275F（https://atcoder.jp/contests/abc275/tasks/abc275_f）matrix_dp|linear_dp|classical
ABC271D（https://atcoder.jp/contests/abc271/tasks/abc271_d）linear_dp|specific_plan
ABC270D（https://atcoder.jp/contests/abc270/tasks/abc270_d）linear_dp
ABC266D（https://atcoder.jp/contests/abc266/tasks/abc266_d）linear_dp|implemention
ABC267D（https://atcoder.jp/contests/abc267/tasks/abc267_d）linear_dp
ABC248F（https://atcoder.jp/contests/abc248/tasks/abc248_f）connected_graph|linear_dp|classical
ABC244E（https://atcoder.jp/contests/abc244/tasks/abc244_e）implemention|linear_dp
ABC243G（https://atcoder.jp/contests/abc243/tasks/abc243_g）prefix_sum|preprocess|linear_dp|brain_teaser|high_precision|sqrt_sqrt_n|math
ABC350E（https://atcoder.jp/contests/abc350/tasks/abc350_e）linear_dp|implemention|prob_dp|expectation_dp|classical
ABC234G（https://atcoder.jp/contests/abc234/tasks/abc234_g）monotonic_stack|linear_dp|prefix_sum|contribution_method|classical
ABC234F（https://atcoder.jp/contests/abc234/tasks/abc234_f）brute_force|linear_dp|comb|math
ABC224E（https://atcoder.jp/contests/abc224/tasks/abc224_e）reverse_thinking|linear_dp|classical
ABC224E（https://atcoder.jp/contests/abc224/tasks/abc224_f）linear_dp|contribution_method|math
ABC222D（https://atcoder.jp/contests/abc222/tasks/abc222_d）prefix|linear_dp
ABC214F（https://atcoder.jp/contests/abc214/tasks/abc214_f）prefix|linear_dp
ABC359D（https://atcoder.jp/contests/abc359/tasks/abc359_d）linear_dp
ABC366F（https://atcoder.jp/contests/abc366/tasks/abc366_f）linear_dp|greedy|custom_sort|classical

=====================================AcWing=====================================
96（https://www.acwing.com/problem/content/98/）liner_dp|classical|hanoi_tower
4414（https://www.acwing.com/problem/content/description/4417/）liner_dp


=====================================LibraryChecker=====================================
1（https://www.51nod.com/Challenge/Problem.html#problemId=1202）liner_dp|classical|different_subsequence


"""
import bisect
from collections import defaultdict, Counter, deque
from functools import lru_cache, cmp_to_key
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.mathmatics.comb_perm.template import Combinatorics
from src.mathmatics.number_theory.template import PrimeSieve
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1770(nums: List[int], multipliers: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/
        tag: liner_dp
        """

        @lru_cache(None)
        def dfs(i, j):
            ind = i + (n - 1 - j)
            if ind == m:
                return 0
            a, b = dfs(i + 1, j) + nums[i] * multipliers[ind], dfs(i, j - 1) + nums[j] * multipliers[ind]
            return a if a > b else b

        n = len(nums)
        m = len(multipliers)
        return dfs(0, n - 1)

    @staticmethod
    def lc_823(arr: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/binary-trees-with-factors/description/
        tag: liner_dp|counter
        """
        mod = 10 ** 9 + 7
        n = len(arr)
        arr.sort()
        dct = {num: i for i, num in enumerate(arr)}

        dp = [0] * n
        dp[0] = 1
        for i in range(1, n):
            dp[i] = 1
            x = arr[i]
            for j in range(i):
                y = arr[j]
                if y * y > x:
                    break
                if x % y == 0 and x // y in dct:
                    if y == x // y:
                        dp[i] += dp[j] * dp[j]
                    else:
                        dp[i] += dp[j] * dp[dct[x // y]] * 2
                    dp[i] %= mod
        return sum(dp) % mod

    @staticmethod
    def lc_2289(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/steps-to-make-array-non-decreasing/
        tag: liner_dp|counter|monotonic_stack|linked_list
        """
        n = len(nums)
        stack = []
        for i in range(n - 1, -1, -1):
            cnt = 0
            while stack and stack[-1][0] < nums[i]:
                _, x = stack.pop()
                cnt = cnt + 1 if cnt + 1 > x else x
            stack.append([nums[i], cnt])
        return max(ls[1] for ls in stack)

    @staticmethod
    def lc_2361(regular: List[int], express: List[int], express_cost: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/minimum-costs-using-the-train-line/
        tag: linear_dp
        """
        n = len(regular)
        cost = [[0, 0] for _ in range(n + 1)]
        cost[0][1] = express_cost
        for i in range(1, n + 1):
            cost[i][0] = min(cost[i - 1][0] + regular[i - 1],
                             cost[i - 1][1] + express[i - 1])
            cost[i][1] = min(cost[i][0] + express_cost,
                             cost[i - 1][1] + express[i - 1])
        return [min(c) for c in cost[1:]]

    @staticmethod
    def cf_1913d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1913/problem/D
        tag: monotonic_stack|linear_dp|prefix_sum
        """
        mod = 998244353

        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            pre = [0] * (n + 1)
            dp = [0] * n
            stack = []
            ans = 0
            for i in range(n):
                while stack and nums[stack[-1]] > nums[i]:
                    ans -= dp[stack.pop()]
                j = -1 if not stack else stack[-1]
                dp[i] = (ans + pre[i] - pre[j + 1] + int(len(stack) == 0)) % mod
                ans += dp[i]
                ans %= mod
                stack.append(i)
                pre[i + 1] = (pre[i] + dp[i]) % mod
            ac.st(ans)
        return

    @staticmethod
    def cf_1286a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1286/A
        tag: liner_dp
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ex = set(nums)
        cnt = Counter([i % 2 for i in range(1, n + 1) if i not in ex])

        @ac.bootstrap
        def dfs(i, single, double, pre):
            if (i, single, double, pre) in dct:
                yield
            if i == n:
                dct[(i, single, double, pre)] = 0
                yield
            res = math.inf
            if nums[i] != 0:
                v = nums[i] % 2
                yield dfs(i + 1, single, double, v)
                cur = dct[(i + 1, single, double, v)]
                if pre != -1 and pre != v:
                    cur += 1
                res = min(res, cur)
            else:
                if single:
                    yield dfs(i + 1, single - 1, double, 1)
                    cur = dct[(i + 1, single - 1, double, 1)]
                    if pre != -1 and pre != 1:
                        cur += 1
                    res = min(res, cur)
                if double:
                    yield dfs(i + 1, single, double - 1, 0)
                    cur = dct[(i + 1, single, double - 1, 0)]
                    if pre != -1 and pre != 0:
                        cur += 1
                    res = min(res, cur)
            dct[(i, single, double, pre)] = res
            yield

        dct = dict()
        dfs(0, cnt[1], cnt[0], -1)
        ac.st(dct[(0, cnt[1], cnt[0], -1)])
        return

    @staticmethod
    def lc_2638(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/count-the-number-of-k-free-subsets/
        tag: liner_dp|counter
        """
        n = len(nums)
        dp = [1] * (n + 1)
        dp[1] = 2
        for i in range(2, 51):
            dp[i] = dp[i - 1] + dp[i - 2]
        dct = set(nums)
        ans = 1
        for num in nums:
            if num - k not in dct:
                cnt = 0
                while num in dct:
                    cnt += 1
                    num += k
                ans *= dp[cnt]
        return ans

    @staticmethod
    def lc_2597(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/the-number-of-beautiful-subsets/
        tag: liner_dp|hash
        """
        power = [1 << i for i in range(21)]

        def check(tmp):
            m = len(tmp)
            dp = [1] * (m + 1)
            dp[1] = power[tmp[0]] - 1 + dp[0]
            for i in range(1, m):
                dp[i + 1] = dp[i - 1] * (power[tmp[i]] - 1) + dp[i]
            return dp[-1]

        cnt = Counter(nums)
        ans = 1
        for num in cnt:
            if num - k not in cnt:
                lst = []
                while num in cnt:
                    lst.append(cnt[num])
                    num += k
                ans *= check(lst)
        return ans - 1

    @staticmethod
    def cf_1525d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1525/D
        tag: liner_dp
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        busy = [i for i in range(n) if nums[i]]
        free = [i for i in range(n) if not nums[i]]
        if not busy:
            ac.st(0)
            return
        a, b = len(busy), len(free)
        dp = [[math.inf] * (b + 1) for _ in range(a + 1)]
        dp[0] = [0] * (b + 1)
        for i in range(a):
            for j in range(b):
                dp[i + 1][j + 1] = min(dp[i + 1][j], dp[i][j] + abs(busy[i] - free[j]))
        ac.st(dp[-1][-1])
        return

    @staticmethod
    def cf_1437c(n, nums):
        """
        url: https://codeforces.com/problemset/problem/1437/C
        tag: liner_dp
        """
        nums.sort()
        m = 2 * n
        dp = [[math.inf] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 0
        for i in range(m):
            dp[i + 1][0] = 0
            for j in range(n):
                dp[i + 1][j + 1] = min(dp[i][j + 1], dp[i][j] + abs(nums[j] - i - 1))
        return dp[m][n]

    @staticmethod
    def lg_p4933(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4933
        tag: linear_dp|counter
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = 998244353
        ans = n
        dp = [defaultdict(int) for _ in range(n)]
        for i in range(n):
            for j in range(i):
                dp[i][nums[i] - nums[j]] += dp[j][nums[i] - nums[j]] + 1
                dp[i][nums[i] - nums[j]] %= mod
            for j in dp[i]:
                ans += dp[i][j]
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def ac_96(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/98/
        tag: liner_dp|classical|hanoi_tower
        """
        n = 12
        dp3 = [math.inf] * (n + 1)
        dp3[0] = 0
        dp3[1] = 1
        for i in range(2, n + 1):
            dp3[i] = 2 * dp3[i - 1] + 1

        dp4 = [math.inf] * (n + 1)
        dp4[0] = 0
        dp4[1] = 1
        for i in range(2, n + 1):
            dp4[i] = min(2 * dp4[j] + dp3[i - j] for j in range(1, i))

        for x in range(1, n + 1):
            ac.st(dp4[x])
        return

    @staticmethod
    def lg_p1280(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1280
        tag: reverse_order|linear_dp
        """
        n, k = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        for _ in range(k):
            p, t = ac.read_list_ints()
            dct[p].append(p + t)
        dp = [0] * (n + 2)
        for i in range(n, 0, -1):
            if not dct[i]:
                dp[i] = dp[i + 1] + 1
            else:
                for end in dct[i]:
                    dp[i] = max(dp[i], dp[end])
        ac.st(dp[1])
        return

    @staticmethod
    def lg_p1282(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1282
        tag: classical|liner_dp|hash
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        pre = defaultdict(lambda: math.inf)
        pre[0] = 0
        for i in range(n):
            a, b = nums[i]
            cur = defaultdict(lambda: math.inf)
            for p in pre:
                cur[p + a - b] = min(cur[p + a - b], pre[p])
                cur[p + b - a] = min(cur[p + b - a], pre[p] + 1)
            pre = cur.copy()
        x = min(abs(v) for v in pre.keys())
        ans = math.inf
        for v in pre:
            if abs(v) == x:
                ans = min(ans, pre[v])
        ac.st(ans)
        return

    @staticmethod
    def lg_p1356(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1356
        tag: classical|mod|linear_dp
        """
        m = ac.read_int()
        for _ in range(m):
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()
            pre = [0] * k
            pre[nums[0] % k] = 1
            for num in nums[1:]:
                cur = [0] * k
                for a in [num, -num]:
                    for i in range(k):
                        if pre[i]:
                            cur[(i + a) % k] = 1
                pre = cur[:]
            ac.st("Divisible" if pre[0] else "Not divisible")
        return

    @staticmethod
    def lg_p1385(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1385
        tag: liner_dp|prefix_sum|brain_teaser|lexicographical_order
        """
        mod = 10 ** 9 + 7
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            t = sum(ord(w) - ord("a") + 1 for w in s)
            pre = [0] * (t + 1)
            pre[0] = 1

            for _ in range(n):
                cur = [0] * (t + 1)
                x = 0
                for i in range(t + 1):
                    cur[i] = x
                    x += pre[i]
                    x %= mod
                    if i >= 26:
                        x -= pre[i - 26]
                        x %= mod
                pre = cur[:]
            ac.st((pre[-1] - 1) % mod)
        return

    @staticmethod
    def lg_p1809(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1809
        tag: brain_teaser|liner_dp|greedy|specific_plan
        """
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        if n == 1:
            ac.st(nums[0])
            return
        nums.sort()
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        dp[1] = nums[0]
        dp[2] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i + 1] = min(dp[i] + nums[0] + nums[i],
                               dp[i - 1] + nums[0] + 2 * nums[1] + nums[i])
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p1868(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1868
        tag: liner_dp|binary_search
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        dp = [0] * (n + 1)
        nums.sort(key=lambda it: it[1])
        pre = []
        for i in range(n):
            x, y = nums[i]
            dp[i + 1] = dp[i]
            j = bisect.bisect_right(pre, x - 1) - 1
            dp[i + 1] = max(dp[i + 1], dp[j + 1] + y - x + 1)
            pre.append(y)
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p1978(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1978
        tag: liner_dp|mul|inclusion_exclusion
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = set(nums)
        ans = 0
        for num in nums:
            if num % k == 0 and num // k in dct:
                continue
            x = 0
            while num in dct:
                x += 1
                num *= k
            ans += (x + 1) // 2
        ac.st(ans)
        return

    @staticmethod
    def lg_p2246(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2246
        tag: string|counter|liner_dp
        """
        s = ""
        while True:
            cur = ac.read_str()
            if not cur or cur == "eof":
                break
            s += cur.lower()
        t = list("HelloWorld".lower())
        dct = set(t)
        ind = defaultdict(list)
        for i, w in enumerate(t):
            ind[w].append(i)
        m = len(t)
        pre = [0] * m
        mod = 10 ** 9 + 7
        for w in s:
            if w not in dct:
                continue
            cur = pre[:]
            for i in ind[w]:
                if i:
                    cur[i] += pre[i - 1]
                else:
                    cur[i] += 1
            pre = [num % mod for num in cur]
        ac.st(pre[-1])
        return

    @staticmethod
    def lg_p2359(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2359
        tag: linear_dp
        """
        primes = PrimeSieve().eratosthenes_sieve(10000)
        primes = [str(num) for num in primes if 1000 >
                  num >= 100 and "0" not in str(num)]
        cnt = defaultdict(list)
        for num in primes:
            cnt[num[:-1]].append(num)
        pre = defaultdict(int)
        for num in primes:
            pre[num[1:]] += 1

        mod = 10 ** 9 + 9
        n = ac.read_int()
        for _ in range(n - 3):
            cur = defaultdict(int)
            for num in pre:
                for nex in cnt[num]:
                    cur[nex[1:]] += pre[num]
            pre = defaultdict(int)
            for num in cur:
                pre[num] = cur[num] % mod
        ans = sum(pre.values()) % mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p2432(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2432
        tag: liner_dp|pointer
        """
        w, n = ac.read_list_ints()
        sentence = ac.read_str()
        words = [ac.read_str()[::-1] for _ in range(w)]

        dp = [math.inf] * (n + 1)
        dp[0] = 0
        for x in range(n):
            ind = [0] * w
            for j in range(x, -1, -1):
                cur = x - j + 1
                for i in range(w):
                    m = len(words[i])
                    if ind[i] < m and sentence[j] == words[i][ind[i]]:
                        ind[i] += 1
                    if ind[i] == m:
                        cur = min(cur, x - j + 1 - m)
                dp[x + 1] = min(dp[x + 1], dp[j] + cur)
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p2439(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2439
        tag: liner_dp|binary_search
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[1])
        dp = [0] * (n + 1)
        pre = []
        for i in range(n):
            a, b = nums[i]
            j = bisect.bisect_right(pre, a)
            dp[i + 1] = max(dp[i], dp[j] + b - a)
            pre.append(b)
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p2476(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2476
        tag: counter|linear_dp|memory_search
        """

        @lru_cache(None)
        def dfs(a, b, c, d, e, pre):
            if a + b + c + d + e == 0:
                return 1
            res = 0
            if a:
                res += (a - int(pre == 2)) * dfs(a - 1, b, c, d, e, 1)
            if b:
                res += (b - int(pre == 3)) * dfs(a + 1, b - 1, c, d, e, 2)
            if c:
                res += (c - int(pre == 4)) * dfs(a, b + 1, c - 1, d, e, 3)
            if d:
                res += (d - int(pre == 5)) * dfs(a, b, c + 1, d - 1, e, 4)
            if e:
                res += e * dfs(a, b, c, d + 1, e - 1, 5)
            res %= mod
            return res

        ac.read_int()
        color = ac.read_list_ints()
        mod = 10 ** 9 + 7
        cnt = Counter(color)
        ac.st(dfs(cnt[1], cnt[2], cnt[3], cnt[4], cnt[5], -1))
        return

    @staticmethod
    def lg_p2849(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2849
        tag: matrix_dp
        """
        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        dis = [[0] * n for _ in range(n)]
        for i in range(n):
            x1, y1 = nums[i]
            for j in range(i + 1, n):
                x2, y2 = nums[j]
                dis[i][j] = abs(x1 - x2) + abs(y1 - y2)

        dp = [[math.inf] * (k + 1) for _ in range(n)]
        dp[0][0] = 0
        for i in range(1, n):
            dp[i][0] = dp[i - 1][0] + dis[i - 1][i]
            for j in range(1, k + 1):
                for x in range(i - 1, -1, -1):
                    skip = i - x - 1
                    if j - skip < 0:
                        break
                    dp[i][j] = min(dp[i][j], dp[x][j - skip] + dis[x][i])
        ac.st(dp[-1][-1])
        return

    @staticmethod
    def lg_p3558(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3558
        tag: linear_dp|implemention
        """
        ac.read_int()
        nums = ac.read_list_ints()
        pre = [math.inf, math.inf, math.inf]
        pre[nums[0]] = 0
        for num in nums[1:]:
            cur = [math.inf, math.inf, math.inf]
            for x in [-1, 0, 1]:
                for k in range(3):
                    y = num + k * x
                    if x <= y and -1 <= y <= 1:
                        cur[y] = min(cur[y], pre[x] + k)
            pre = cur[:]
        ans = min(pre)
        ac.st(ans if ans < math.inf else "BRAK")
        return

    @staticmethod
    def lc_2746(words: List[str]) -> int:
        """
        url: https://leetcode.cn/problems/decremental-string-concatenation/
        tag: hash|liner_dp|implemention
        """
        pre = defaultdict(int)
        pre[words[0][0] + words[0][-1]] = len(words[0])

        for a in words[1:]:
            cur = defaultdict(lambda: math.inf)
            for b in pre:

                if a[-1] == b[0]:
                    x = len(a) - 1 + pre[b]
                else:
                    x = len(a) + pre[b]
                cur[a[0] + b[-1]] = min(cur[a[0] + b[-1]], x)

                if b[-1] == a[0]:
                    x = len(a) - 1 + pre[b]
                else:
                    x = len(a) + pre[b]
                cur[b[0] + a[-1]] = min(cur[b[0] + a[-1]], x)
            pre = cur

        return min(pre.values())

    @staticmethod
    def lg_b3734(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/B3734
        tag: linear_dp
        """
        n, r1 = ac.read_list_ints()
        nums = [r1]
        while len(nums) < n:
            nums.append((nums[-1] * 6807 + 2831) % 201701)
        nums = [num % 100 for num in nums]

        dp = [[math.inf] * 100 for _ in range(2)]
        pre = 0
        for x in range(100):
            y = abs(x - nums[0])
            dp[pre][x] = min(y * y, (100 - y) * (100 - y))
        for i in range(1, n):
            cur = 1 - pre
            for j in range(100):
                y = abs(j - nums[i])
                res = math.inf
                a = min(y * y, (100 - y) * (100 - y))
                for k in range(j):
                    res = min(res, a + dp[pre][k])
                dp[cur][j] = res
            pre = cur
        ac.st(min(dp[pre]))
        return

    @staticmethod
    def lg_p3901(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3901
        tag: pointer|linear_dp|pointer
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        ind = dict()
        for i in range(n):
            x = nums[i]
            if x in ind:
                nums[i] = ind[x]
            else:
                nums[i] = -1
            ind[x] = i
            if i:
                nums[i] = max(nums[i], nums[i - 1])
        for _ in range(q):
            left, right = ac.read_list_ints_minus_one()
            ac.st("Yes" if nums[right] < left else "No")
        return

    @staticmethod
    def lg_p4401(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4401
        tag: linear_dp
        """
        ac.read_int()
        s = ac.read_str()
        pre = defaultdict(int)
        pre[("", "")] = 0
        for w in s:
            cur = defaultdict(int)
            for p1, p2 in pre:
                st = p1 + w
                cur[(st[-2:], p2)] = max(cur[(st[-2:], p2)], pre[(p1, p2)] + len(set(st)))

                st = p2 + w
                cur[(p1, st[-2:])] = max(cur[(p1, st[-2:])], pre[(p1, p2)] + len(set(st)))
            pre = cur
        ac.st(max(pre.values()))
        return

    @staticmethod
    def lg_p5095(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5095
        tag: classical|linear_dp
        """
        n, length = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        for i in range(n):
            w = h = 0
            for j in range(i, -1, -1):
                w += nums[j][1]
                h = max(h, nums[j][0])
                if w > length:
                    break
                if dp[j] + h < dp[i + 1]:
                    dp[i + 1] = dp[j] + h
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p5810(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5810
        tag: linear_dp
        """
        n = ac.read_int()
        dp = [0]
        while dp[-1] < n:
            m = len(dp)
            cur = dp[-1] + 1
            x = 1
            while x * 2 + 5 <= m:
                cur = max(dp[-x * 2 - 5] * (x + 1), cur)
                x += 1
            dp.append(cur)
        ac.st(len(dp) - 1)
        return

    @staticmethod
    def lg_p6040(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6040
        tag: monotonic_queue|linear_dp
        """
        n, k, d, x, tp = ac.read_list_ints()
        mod = 10 ** 9
        nums = []
        seed = 0
        xx = int("0x66CCFF", 16)
        if tp == 0:
            nums = ac.read_list_ints()
        else:
            seed = ac.read_int()
            seed = (seed * xx % mod + 20120712) % mod

        pre = nums[0] if not tp else seed
        stack = deque([[0, pre - d]])
        for i in range(1, n):
            seed = nums[i] if not tp else (seed * xx % mod + 20120712) % mod

            while stack and stack[0][0] < i - x:
                stack.popleft()
            cur = pre + seed + k
            if stack:
                cur = min(cur, stack[0][1] + i * d + seed + k)

            while stack and stack[-1][1] >= cur - i * d - d:
                stack.pop()
            stack.append([i, cur - i * d - d])
            pre = cur
        ac.st(pre)
        return

    @staticmethod
    def lg_p6120(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6120
        tag: linear_dp|implemention
        """
        n = ac.read_int()
        ind = {w: i for i, w in enumerate("HSP")}
        dp = [[[0, -math.inf], [0, -math.inf], [0, -math.inf]] for _ in range(2)]
        pre = 0
        for _ in range(n):
            cur = 1 - pre
            i = ind[ac.read_str()]
            w = (i - 1) % 3
            for j in range(3):
                dp[cur][j][0] = dp[pre][j][0]
                dp[cur][j][1] = max(dp[pre][j][1], max(dp[pre][k][0] for k in range(3) if k != j))
                if j == w:
                    dp[cur][j][0] += 1
                    dp[cur][j][1] += 1
            pre = cur
        ac.st(max(max(d) for d in dp[pre]))
        return

    @staticmethod
    def lg_p6146(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6146
        tag: linear_dp|brute_force|counter
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[0])
        mod = 10 ** 9 + 7
        pp = [1] * (n + 1)
        for i in range(1, n + 1):
            pp[i] = (pp[i - 1] * 2) % mod

        dp = [0] * n
        dp[0] = 1
        lst = [nums[0][1]]
        for i in range(1, n):
            a, b = nums[i]
            j = bisect.bisect_left(lst, a)
            dp[i] = 2 * dp[i - 1] + pp[j]
            dp[i] %= mod
            bisect.insort_left(lst, b)
        ac.st(dp[-1])
        return

    @staticmethod
    def lc_2713(mat: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/
        tag: data_range|liner_dp
        """
        m, n = len(mat), len(mat[0])
        dct = defaultdict(list)
        for i in range(m):
            for j in range(n):
                dct[mat[i][j]].append([i, j])
        row = [0] * m
        col = [0] * n
        for val in sorted(dct):
            lst = []
            for i, j in dct[val]:
                x = row[i] if row[i] > col[j] else col[j]
                lst.append([i, j, x + 1])
            for i, j, w in lst:
                if col[j] < w:
                    col[j] = w
                if row[i] < w:
                    row[i] = w
        return max(max(row), max(col))

    @staticmethod
    def lg_p7994(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7994
        tag: linear_dp
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()

        nums = [a[i] - b[i] for i in range(n)]
        ans = abs(nums[0])
        for i in range(1, n):
            x, y = nums[i - 1], nums[i]
            if x == 0:
                ans += abs(y)
            elif y == 0:
                continue
            else:
                if x * y < 0:
                    ans += abs(y)
                else:
                    if x > 0:
                        ans += max(0, y - x)
                    else:
                        ans += max(0, x - y)
        ac.st(ans)
        return

    @staticmethod
    def lg_p8816(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8816
        tag: classical|matrix_dp|implemention
        """
        n, k = ac.read_list_ints()
        nums = sorted([ac.read_list_ints() for _ in range(n)])
        dp = [list(range(1, k + 2)) for _ in range(n)]
        for i in range(n - 1, -1, -1):
            x, y = nums[i]
            for j in range(i + 1, n):
                a, b = nums[j]
                if a >= x and b >= y:
                    dis = a - x + b - y - 1
                    for r in range(k + 1):
                        if r + dis <= k:
                            dp[i][r + dis] = max(dp[i][r + dis], dp[j][r] + dis + 1)
                        else:
                            break
        ac.st(max(max(d) for d in dp))
        return

    @staticmethod
    def ac_4414(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4417/
        tag: liner_dp
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ans = -math.inf
        pre = [-math.inf, -math.inf]
        for num in nums:
            cur = pre[:]
            for i in range(2):
                j = (i + num) % 2
                cur[j] = max(cur[j], pre[i] + num)
                j = num % 2
                cur[j] = max(cur[j], num)
            pre = cur[:]
            ans = max(ans, pre[1])
        ac.st(ans)
        return

    @staticmethod
    def lc_1824(obstacles: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-sideway-jumps/description/
        tag: liner_dp|rolling_update
        """
        n = len(obstacles)
        dp = [1, 0, 1]
        for i in range(n):
            x = obstacles[i]
            if x:
                dp[x - 1] = math.inf
            low = min(dp)
            for j in range(3):
                if j != x - 1:
                    dp[j] = dp[j] if dp[j] < low + 1 else low + 1
        return min(dp)

    @staticmethod
    def lc_978(arr: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/longest-turbulent-subarray/description/
        tag: liner_dp|rolling_update
        """
        n = len(arr)
        ans = dp0 = dp1 = 1
        for i in range(1, n):
            if arr[i] > arr[i - 1]:
                dp1 = dp0 + 1
                dp0 = 1
            elif arr[i] < arr[i - 1]:
                dp0 = dp1 + 1
                dp1 = 1
            else:
                dp0 = dp1 = 1
            ans = ans if ans > dp0 else dp0
            ans = ans if ans > dp1 else dp1
        return ans

    @staticmethod
    def lc_1027(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/longest-arithmetic-subsequence/
        tag: liner_dp
        """
        seen = set()
        count = dict()
        for num in nums:
            for pre in seen:
                d = num - pre
                count[(num, d)] = count.get((pre, d), 1) + 1
            seen.add(num)
        return max(count.values())

    @staticmethod
    def lc_1553(n: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/
        tag: brain_teaser|greedy|memory_search|liner_dp
        """

        @lru_cache(None)
        def dfs(num):
            if num <= 1:
                return num
            a = num % 2 + 1 + dfs(num // 2)
            b = num % 3 + 1 + dfs(num // 3)
            return a if a < b else b

        return dfs(n)

    @staticmethod
    def cf_1829h(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1829/problem/H
        tag: counter|linear_dp|classical|bit_operation|data_range
        """
        mod = 10 ** 9 + 7
        ceil = 2 * 10 ** 5
        power = [1] * (ceil + 1)
        for i in range(1, ceil + 1):
            power[i] = (power[i - 1] * 2) % mod

        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            cnt = [0] * 64
            for num in ac.read_list_ints():
                cnt[num] += 1

            pre = [0] * 64
            for num in range(64):
                if cnt[num]:
                    cur = pre[:]
                    for p in range(64):
                        cur[p & num] += pre[p] * (power[cnt[num]] - 1) % mod
                    cur[num] += (power[cnt[num]] - 1) % mod
                    pre = [x % mod for x in cur]
            ans = 0
            for p in range(64):
                if bin(p).count("1") == k:
                    ans += pre[p]
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def cf_1154f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1154/problem/F
        tag: linear_dp|reverse_thinking|brute_force|greedy|implemention|data_range
        """
        n, m, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums.sort()
        nums = nums[:k]
        pre = ac.accumulate(nums)
        cost = [0] * (k + 1)
        for _ in range(m):
            x, y = ac.read_list_ints()
            if x <= k and cost[x] < y:
                cost[x] = y
        dp = [math.inf] * (k + 1)
        dp[k] = 0
        for i in range(k - 1, -1, -1):
            dp[i] = dp[i + 1] + nums[i]
            for j in range(i, k):
                x = j - i + 1
                y = cost[x]
                cur = dp[j + 1] + pre[j + 1] - pre[i] - (pre[i + y] - pre[i])
                if cur < dp[i]:
                    dp[i] = cur
        ac.st(dp[0])
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://www.51nod.com/Challenge/Problem.html#problemId=1202
        tag: liner_dp|classical|different_subsequence
        """
        mod = 10 ** 9 + 7
        n = ac.read_int()
        dp = [0] * (n + 1)
        pre = dict()
        for i in range(n):
            num = ac.read_int()
            if num not in pre:
                dp[i + 1] = (2 * dp[i] + 1) % mod
            else:
                dp[i + 1] = (2 * dp[i] - dp[pre[num]]) % mod
            pre[num] = i
        ac.st(dp[-1])
        return

    @staticmethod
    def abc_285e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc285/tasks/abc285_e
        tag: linear_dp|brain_teaser|circular_array|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = ac.accumulate(nums)

        def cost(k):
            return pre[k // 2] + pre[(k + 1) // 2]

        dp = [-math.inf] * (n + 1)
        dp[0] = 0
        for i in range(1, n + 1):
            for j in range(i):
                dp[i] = max(dp[i], dp[j] + cost(i - j - 1))
        ac.st(dp[-1])
        return

    @staticmethod
    def abc_275f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc275/tasks/abc275_f
        tag: matrix_dp|linear_dp|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        dp = [[math.inf] * (m + 1) for _ in range(2)]
        dp[0][0] = 0
        for num in nums:
            ndp = [[math.inf] * (m + 1) for _ in range(2)]
            for pre in range(2):
                for s in range(m + 1):
                    if pre:
                        ndp[pre][s] = min(ndp[pre][s], dp[pre][s])
                        if num + s <= m:
                            ndp[0][num + s] = min(ndp[0][num + s], dp[pre][s])
                    else:
                        if num + s <= m:
                            ndp[pre][num + s] = min(ndp[pre][num + s], dp[pre][s])

                        ndp[1][s] = min(ndp[1][s], dp[pre][s] + 1)
            dp = ndp
        for x in range(1, m + 1):
            ans = min(dp[0][x], dp[1][x])
            ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_248f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc248/tasks/abc248_f
        tag: connected_graph|linear_dp|classical
        """
        n, mod = ac.read_list_ints()

        dp = [[0] * n for _ in range(2)]
        dp[1][0] = 1
        for _ in range(n - 1):
            for rem in range(n - 1, -1, -1):
                for state in range(2):
                    res = 0
                    if not state:
                        if rem > 0:
                            res += dp[state][rem - 1]
                        res += dp[1][rem]
                    else:
                        res += dp[0][rem - 2] * 2
                        res += dp[1][rem - 1] * 3
                        res += dp[1][rem]
                    dp[state][rem] = res % mod
        ans = [(dp[0][x - 1] + dp[1][x]) % mod for x in range(1, n)]
        ac.lst(ans)
        return

    @staticmethod
    def abc_244e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc244/tasks/abc244_e
        tag: implemention|linear_dp
        """
        mod = 998244353
        n, m, k, s, t, x = ac.read_list_ints()
        s -= 1
        t -= 1
        x -= 1
        dp = [[0] * n, [0] * n]
        dp[0][s] = 1
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        for _ in range(k):
            ndp = [[0] * n, [0] * n]
            for i, j in edges:
                for a, b in [(i, j), (j, i)]:
                    for w in range(2):
                        if b == x:
                            ndp[1 - w][b] += dp[w][a]
                        else:
                            ndp[w][b] += dp[w][a]
            dp = [[x % mod for x in ls] for ls in ndp]
        ans = dp[0][t]
        ac.st(ans)
        return

    @staticmethod
    def abc_243g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc243/tasks/abc243_g
        tag: prefix_sum|preprocess|linear_dp|brain_teaser|high_precision|sqrt_sqrt_n|math
        """

        def sqrt(m):

            def check(s):
                return s * s <= m

            return BinarySearch().find_int_right(1, m, check)

        def sqrt_sqrt(m):

            def check(s):
                return s * s * s * s <= m

            return BinarySearch().find_int_right(1, m, check)

        x = 9 * 10 ** 18
        n = sqrt_sqrt(x) + 10
        dp = [0] * (n + 1)
        dp[1] = 1
        pre = ac.accumulate(dp)
        for i in range(2, n + 1):
            dp[i] = pre[sqrt(i) + 1] - pre[1]
            pre[i + 1] = pre[i] + dp[i]
        for _ in range(ac.read_int()):
            x = ac.read_int()
            sx = sqrt(x)
            fx = sqrt_sqrt(x)
            ans = sum(dp[i] * (sx - i * i + 1) for i in range(1, fx + 1))
            ac.st(ans)
        return

    @staticmethod
    def abc_350e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc350/tasks/abc350_e
        tag: linear_dp|implemention|prob_dp|expectation_dp|classical
        """

        n, a, x, y = ac.read_list_ints()

        @lru_cache(None)
        def dfs(num):
            if num == 0:
                return 0
            res = dfs(num // a) + x
            res = min(res, (sum(dfs(num // aa) for aa in range(2, 7)) + 6 * y) / 5)
            return res

        ac.st(dfs(n))
        return

    @staticmethod
    def abc_234g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc234/tasks/abc234_g
        tag: monotonic_stack|linear_dp|prefix_sum|contribution_method|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [0] * (n + 1)
        mx = [0] * (n + 1)
        mi = [0] * (n + 1)
        mod = 998244353
        dp[0] = 1
        mx_stack = []
        mi_stack = []
        for i in range(1, n + 1):
            while mx_stack and nums[mx_stack[-1] - 1] <= nums[i - 1]:
                mx_stack.pop()
            while mi_stack and nums[mi_stack[-1] - 1] >= nums[i - 1]:
                mi_stack.pop()

            if not mx_stack:
                mx[i] = dp[i - 1] * nums[i - 1] % mod
            else:
                x = mx_stack[-1]
                mx[i] = mx[x] + (dp[i - 1] - dp[x - 1]) * nums[i - 1]
                mx[i] %= mod

            if not mi_stack:
                mi[i] = dp[i - 1] * nums[i - 1] % mod
            else:
                x = mi_stack[-1]
                mi[i] = mi[x] + (dp[i - 1] - dp[x - 1]) * nums[i - 1]
                mi[i] %= mod

            dp[i] = (dp[i - 1] + mx[i] - mi[i]) % mod
            mx_stack.append(i)
            mi_stack.append(i)

        ac.st((dp[n] - dp[n - 1]) % mod)
        return

    @staticmethod
    def abc_234f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc234/tasks/abc234_f
        tag: brute_force|linear_dp|comb|math
        """
        mod = 998244353
        s = ac.read_str()
        cnt = Counter(s)
        n = len(s)
        cb = Combinatorics(n + 10, mod)
        dp = [0] * (n + 1)
        dp[0] = 1
        for w in cnt:
            ndp = dp[:]
            for x in range(n + 1):
                for y in range(1, cnt[w] + 1):
                    if x + y > n:
                        break
                    ndp[x + y] += dp[x] * cb.comb(x + y, y)
            dp = [x % mod for x in ndp]
        ac.st(sum(dp[1:]) % mod)
        return

    @staticmethod
    def cf_1969c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1969/problem/C
        tag: linear_dp|data_range|implemention
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()

            dp = deque([[math.inf] * (k + 1) for _ in range(20)])
            dp[-1][0] = 0
            for i in range(n):
                cur = [math.inf] * (k + 1)
                cnt = 0
                val = math.inf
                for x in range(k + 1):
                    cur[x] = dp[-1][x] + nums[i]
                for j in range(i, max(-1, i - 11), -1):
                    if nums[j] < val:
                        val = nums[j]
                        cnt = 1
                    elif nums[j] == val:
                        cnt += 1
                    tot = i - j + 1
                    for x in range(k + 1):
                        y = x + (tot - cnt)
                        if y > k:
                            break
                        cur[y] = min(cur[y], dp[-(i - j + 1)][x] + val * tot)
                dp.append(cur[:])
                dp.popleft()
            ac.st(min(dp[-1]))
        return

    @staticmethod
    def abc_224f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc224/tasks/abc224_f
        tag: linear_dp|contribution_method|math
        """
        mod = 998244353
        s = ac.read_str()
        n = len(s)
        dp = [0] * (n + 1)
        cnt = [0] * (n + 1)
        cnt[n] = 1
        cnt[n - 1] = 1
        post_sum = post = 0
        tot = 10
        for i in range(n - 1, -1, -1):
            cnt[i] = 2 * cnt[i + 1] if i < n - 1 else 1
            cnt[i] %= mod
            if i == n - 1:
                tot = 0
            else:
                tot = (tot + cnt[i + 2]) * 10 % mod
            post = post + int(s[i]) * tot + int(s[i]) * cnt[i + 1]
            post %= mod
            dp[i] = (post_sum + post) % mod
            post_sum = (post_sum + dp[i]) % mod
        ac.st(dp[0] % mod)
        return

    @staticmethod
    def cf_264c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/264/problem/C
        tag: linear_dp|classical|maximum_second
        """
        n, q = ac.read_list_ints()
        v = ac.read_list_ints()
        c = ac.read_list_ints_minus_one()
        for _ in range(q):
            a, b = ac.read_list_ints()
            dp = [-math.inf] * n
            c1, ceil1 = 0, -math.inf
            c2, ceil2 = 0, -math.inf
            ans = 0
            for i, x in enumerate(c):
                cur = dp[x]
                if a * v[i] > 0:
                    cur += a * v[i]
                if c1 != x:
                    if ceil1 + b * v[i] > cur:
                        cur = ceil1 + b * v[i]
                else:
                    if ceil2 + b * v[i] > cur:
                        cur = ceil2 + b * v[i]
                if b * v[i] > cur:
                    cur = b * v[i]
                if c1 == x:
                    if ceil1 < cur:
                        ceil1 = cur
                elif c2 == x:
                    if ceil2 < cur:
                        ceil2 = cur
                else:
                    if cur >= ceil1:
                        c2, ceil2 = c1, ceil1
                        c1, ceil1 = x, cur
                    elif cur > ceil2:
                        c2, ceil2 = x, cur
                dp[x] = cur
                if cur > ans:
                    ans = cur
            ac.st(ans)
        return

    @staticmethod
    def cf_1984c2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1984/problem/C2
        tag: linear_dp|implemention|greedy
        """

        mod = 998244353
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            pre = defaultdict(int)
            pre[0] = 1
            for num in nums:
                cur = defaultdict(int)
                for p in pre:
                    cur[p + num] += pre[p]
                    cur[abs(p + num)] += pre[p]
                floor = min(cur)
                ceil = max(cur)
                pre = defaultdict(int)
                pre[floor] = cur[floor] % mod
                pre[ceil] = cur[ceil] % mod
            ac.st(pre[max(pre)])
        return

    @staticmethod
    def cf_1984f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1984/problem/F
        tag: brute_force|brain_teaser|linear_dp
        """
        mod = 998244353
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            s = "P" + ac.read_str() + "S"
            nums = [0] + ac.read_list_ints() + [0]
            ans = 0
            n += 2
            pre = set()
            for i in range(n - 1):
                cur = nums[i] + nums[i + 1]
                if cur in pre:
                    continue
                pre.add(cur)
                dp = [0, 0]  # PS
                dp[0] = 1
                for j in range(1, n):
                    flag = [0, 0]
                    ndp = [0, 0]
                    if s[j] == "P":
                        flag[0] = 1
                    elif s[j] == "S":
                        flag[1] = 1
                    else:
                        flag[0] = flag[1] = 1
                    if abs(nums[j] - nums[j - 1]) <= m:
                        for k in range(2):
                            if flag[k]:
                                ndp[k] += dp[k]
                    if dp[0] and flag[1] and cur == nums[j - 1] + nums[j]:
                        ndp[1] += dp[0]
                    if dp[1] and flag[0]:
                        xx = nums[j] + nums[j - 1] - cur
                        large = max(abs(xx // 2), abs(xx - xx // 2))
                        if large <= m:
                            ndp[0] += dp[1]
                    dp = [x % mod for x in ndp]
                ans += dp[1]
                ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def cf_1989d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1989/problem/D
        tag: greedy|linear_dp|implemention
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        c = ac.read_list_ints()
        ceil = 10 ** 6
        gain = [math.inf] * (ceil + 1)
        ans = 0
        for i in range(n):
            gain[a[i]] = min(gain[a[i]], a[i] - b[i])

        for i in range(1, ceil + 1):
            gain[i] = min(gain[i], gain[i - 1])

        dp = [0] * (ceil + 1)
        for i in range(1, ceil + 1):
            if i >= gain[i]:
                dp[i] = 2 + dp[i - gain[i]]

        for rest in c:
            if rest > ceil:
                k = (rest - ceil) // gain[ceil] + ((rest - ceil) % gain[ceil] > 0)
                ans += k * 2
                rest -= gain[ceil] * k
            ans += dp[rest]
        ac.st(ans)
        return

    @staticmethod
    def cf_1155d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1155/D
        tag: linear_dp|classical|max_con_sub_sum
        """
        n, x = ac.read_list_ints()
        nums = ac.read_list_ints()
        dp = [0, -math.inf, -math.inf]
        ans = 0
        for num in nums:
            ndp = [0, 0, 0]
            ndp[0] = max(dp[0] + num, num, 0)
            ndp[1] = max(dp[1], dp[0]) + x * num
            ndp[2] = max(dp[1], dp[2]) + num
            dp = ndp[:]
            ans = max(ans, max(dp))
        ac.st(ans)
        return

    @staticmethod
    def cf_319c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/319/C
        tag: slope_dp|linear_dp|monotonic_queue
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()

        def slope(x, y):
            return (dp[y] - dp[x]) / (b[y] - b[x])

        dp = [0] * n
        stack = deque([0])
        for i in range(1, n):
            while len(stack) >= 2 and slope(stack[0], stack[1]) >= -a[i]:
                stack.popleft()
            dp[i] = dp[stack[0]] + a[i] * b[stack[0]]
            while len(stack) >= 2 and slope(stack[-2], i) >= slope(stack[-2], stack[-1]):
                stack.pop()
            stack.append(i)
        ac.st(dp[n - 1])
        return

    @staticmethod
    def cf_1427c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1427/C
        tag: linear_dp|data_range|observation
        """
        r, n = ac.read_list_ints()  # TLE
        nums = [ac.read_list_ints() for _ in range(n)]
        dp = [-math.inf] * (n + 1)
        pre = [0] * (n + 1)
        dp[0] = 0
        for i in range(n):
            t, x, y = nums[i]
            cur = -math.inf
            if x + y - 2 <= t:
                cur = 1
            for j in range(i - 1, max(i - 2 * r, 0) - 1, -1):
                if nums[i][0] - nums[j][0] >= 2 * r:
                    cur = max(cur, pre[j + 1] + 1)
                    break
                if abs(x - nums[j][1]) + abs(y - nums[j][2]) <= nums[i][0] - nums[j][0]:
                    cur = max(dp[j + 1] + 1, cur)
            dp[i + 1] = cur
            pre[i + 1] = max(dp[i + 1], pre[i])
        ac.st(pre[-1])
        return

    @staticmethod
    def cf_463d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/463/D
        tag: observation|linear_dp|classical|lcs|dag_dp|topological_sort
        """
        n, k = ac.read_list_ints()

        pos = [[] for _ in range(n)]
        nums = []
        for _ in range(k):
            nums = ac.read_list_ints_minus_one()
            for i in range(n):
                pos[nums[i]].append(i)

        dp = [1] * n
        for i in range(n):
            x = nums[i]
            for j in range(i):
                y = nums[j]
                if all(pos[y][p] < pos[x][p] for p in range(k)) and dp[j] + 1 > dp[i]:
                    dp[i] = dp[j] + 1
        ac.st(max(dp))
        return

    @staticmethod
    def lg_p1514(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1514
        tag: bfs|linear_dp|observation
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        cover = [0] * n
        for j in range(n):
            stack = [(0, j)]
            visit = [[0] * n for _ in range(m)]
            visit[0][j] = 1
            while stack:
                x, y = stack.pop()
                for a, b in ac.dire4:
                    if 0 <= x + a < m and 0 <= y + b < n and not visit[x + a][y + b] and grid[x + a][y + b] < grid[x][
                        y]:
                        stack.append((x + a, y + b))
                        visit[x + a][y + b] = 1
            cur = []
            for i in range(n):
                if visit[m - 1][i]:
                    cur.append(i)

            for x in cur:
                cover[x] = 1

            if cur and cur[-1] - cur[0] + 1 != len(cur):
                continue
            if cur and dp[cur[0]] < math.inf:
                a, b = cur[0], cur[-1]
                pre = dp[a]
                for i in range(a, b + 1):
                    dp[i + 1] = min(dp[i + 1], pre + 1)

        if dp[-1] < math.inf:
            ac.st(1)
            ac.st(dp[-1])
        else:
            ac.st(0)
            ac.st(n - sum(cover))
        return

    @staticmethod
    def cf_1716d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1716/D
        tag: linear_dp|observation|prefix_sum
        """
        n, k = ac.read_list_ints()
        mod = 998244353
        dp = [0] * (n + 1)
        dp[0] = 1
        pre = [0] * (n + 2)
        res = dp[:]
        s = 0
        for x in range(k, n + 1):
            s += x
            if s > n:
                break
            for i in range(n + 1):
                pre[i + 1] = pre[i - x + 1] + dp[i] if i - x + 1 >= 0 else dp[i]
                dp[i] = 0
                pre[i + 1] %= mod
                if i >= x:
                    dp[i] = pre[i - x + 1]
                res[i] += dp[i]
                res[i] %= mod
        ac.lst(res[1:])
        return

    @staticmethod
    def abc_366f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc366/tasks/abc366_f
        tag: linear_dp|greedy|custom_sort|classical
        """
        n, k = ac.read_list_ints()
        dp = [-math.inf] * (k + 1)
        dp[0] = 1
        nums = [ac.read_list_ints() for _ in range(n)]

        def compare_(x, y):
            if x[0] * y[1] + x[1] < y[0] * x[1] + y[1]:
                return -1
            return 1

        nums.sort(key=cmp_to_key(compare_))

        for a, b in nums:
            for i in range(k, 0, -1):
                dp[i] = max(dp[i], a * dp[i - 1] + b)
        ac.st(dp[-1])
        return

    @staticmethod
    def cf_1197d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1197/D
        tag: linear_dp|brain_teaser|prefix_sum
        """
        n, m, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        dp = [-math.inf] * m
        ans = 0
        for i in range(n):
            for j in range(m):
                dp[j] += nums[i]
            dp[i % m] = max(dp[i % m], nums[i]) - k
            for j in range(m):
                ans = max(ans, dp[j])
        ac.st(ans)
        return

    @staticmethod
    def abc_372f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc372/tasks/abc372_f
        tag: linear_dp|implemention|deque|array_implemention
        """
        n, m, k = ac.read_list_ints()
        mod = 998244353
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        dp = [0] * (n + k)
        dp[k] = 1

        for i in range(k, 0, -1):
            post = [(y, dp[i + x]) for x, y in edges]
            for y, num in post:
                dp[i + y - 1] += num
                dp[i + y - 1] %= mod
            dp[i - 1] += dp[i + n - 1]
            dp[i - 1] %= mod
            dp[i + n - 1] = 0
        ac.st(sum(dp) % mod)
        return

    @staticmethod
    def cf_1082e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1082/E
        tag: linear_dp|prefix_sum|brain_teaser|observation
        """
        n, c = ac.read_list_ints()
        nums = ac.read_list_ints()
        k = nums.count(c)
        ans = k
        ceil = 5 * 10 ** 5
        cnt = [0] * (ceil + 1)
        dp = [0] * (ceil + 1)
        kk = 0
        for num in nums:
            k -= num == c
            cnt[num] += 1
            dp[num] = max(dp[num], kk - cnt[num] + 1)
            ans = max(ans, dp[num] + k + cnt[num])
            kk += num == c
        ac.st(ans)
        return
"""
Algorithm：matrix_dp|memory_search|lcs|md_matrix_dp
Description：matrix_prefix_sum|sub_matrix_sum|maximum_square|edit_distance|lcs|palindrome_substring

====================================LeetCode====================================
174（https://leetcode.cn/problems/dungeon-game/）matrix_dp|reverse_thinking
2478（https://leetcode.cn/problems/number-of-beautiful-partitions/）matrix_dp
2463（https://leetcode.cn/problems/minimum-total-distance-traveled/）matrix_dp
2435（https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/）matrix_dp|mod
2088（https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/）matrix_dp
221（https://leetcode.cn/problems/maximal-square/）maximum_square|classical
72（https://leetcode.cn/problems/edit-distance/）matrix_dp
329（https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/）matrix_dp
1478（https://leetcode.cn/problems/allocate-mailboxes/）matrix_dp|median_greedy|interval_dp|greedy
2573（https://leetcode.cn/problems/find-the-string-with-lcp/）greedy|construction|lcp
2328（https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/）matrix_dp|counter
2312（https://leetcode.cn/problems/selling-pieces-of-wood/）memory_search|specific_plan
2267（https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/）memory_search
1092（https://leetcode.cn/problems/shortest-common-supersequence/）construction|lcs|construction|specific_plan
1143（https://leetcode.cn/problems/longest-common-subsequence/）lis|lcs
1035（https://leetcode.cn/problems/uncrossed-lines/）lis|lcs
2617（https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/）reverse_order|matrix_dp|tree_array|prefix_min
1092（https://leetcode.cn/problems/shortest-common-supersequence/）lis|lcs|specific_plan
1692（https://leetcode.cn/problems/count-ways-to-distribute-candies/）matrix_dp|specific_plan|counter
1771（https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/）longest_palindrome_subsequence|matrix_dp
1883（https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/）matrix_dp|high_precision|bag_dp
1977（https://leetcode.cn/problems/number-of-ways-to-separate-numbers/）matrix_dp|lcp|prefix_sum
2430（https://leetcode.cn/problems/maximum-deletions-on-a-string/）lcp|matrix_dp
1216（https://leetcode.cn/problems/valid-palindrome-iii/）matrix_dp|longest_palindrome_subsequence
2060（https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/description/）matrix_dp|brute_force|memory_search
2556（https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/description/）matrix_dp|brain_teaser
920（https://leetcode.cn/problems/number-of-music-playlists/）matrix_dp
1594（https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/）matrix_dp|maximum_mul|minimum_mul
1639（https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/）prefix_sum|matrix_dp
956（https://leetcode.cn/problems/tallest-billboard/description/）matrix_dp
1301（https://leetcode.cn/contest/biweekly-contest-16/problems/number-of-paths-with-max-score/）matrix_dp|specific_plan|counter
1937（https://leetcode.cn/problems/maximum-number-of-points-with-cost/）prefix_sum|matrix_dp
1751（https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/）matrix_dp|binary_search
1959（https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/description/）matrix_dp|prefix_sum
1458（https://leetcode.cn/problems/max-dot-product-of-two-subsequences/description/）matrix_dp
1745（https://leetcode.cn/problems/palindrome-partitioning-iv/description/）matrix_dp|palindrome_substring|manacher|brute_force
2809（https://leetcode.cn/problems/minimum-time-to-make-array-sum-at-most-x/）matrix_dp|greedy|implemention
100327（https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/）matrix_dp|bag_dp|brain_teaser
100358（https://leetcode.cn/problems/find-the-maximum-length-of-valid-subsequence-ii/）matrix_dp|implemention
3098（https://leetcode.cn/problems/find-the-sum-of-subsequence-powers）matrix_dp
3316（https://leetcode.com/problems/find-maximum-removals-from-source-string）matrix_dp

=====================================LuoGu======================================
P2701（https://www.luogu.com.cn/problem/P2701）maximum_square|matrix_dp|brute_force|classical|O(n^3)|hollow
P2049（https://www.luogu.com.cn/problem/P2049）matrix_dp|counter|mod
P2138（https://www.luogu.com.cn/problem/P2138）matrix_dp|lcs
P1681（https://www.luogu.com.cn/problem/P1681）maximum_square|matrix_dp
P2268（https://www.luogu.com.cn/problem/P2268）matrix_dp|edit_distance
P2301（https://www.luogu.com.cn/problem/P2301）matrix_dp
P2364（https://www.luogu.com.cn/problem/P2364）lcs|specific_plan|matrix_dp
P2543（https://www.luogu.com.cn/problem/P2543）matrix_dp|lcs
list?user=739032&status=12&page=2（https://www.luogu.com.cn/record/list?user=739032&status=12&page=2）matrix_dp|prefix_sum
P1434（https://www.luogu.com.cn/problem/P1434）matrix_dp|lis
P1140（https://www.luogu.com.cn/problem/P1140）matrix_dp
P1057（https://www.luogu.com.cn/problem/P1057）matrix_dp
P8825（https://www.luogu.com.cn/problem/P8825）mod|matrix_dp|rolling_update
P2758（https://www.luogu.com.cn/problem/P2758）matrix_dp|edit_distance
P2803（https://www.luogu.com.cn/problem/P2803）matrix_dp|median_greedy|interval_dp
P2946（https://www.luogu.com.cn/problem/P2946）matrix_dp
P2427（https://www.luogu.com.cn/problem/P2427）matrix_dp|square
P7074（https://www.luogu.com.cn/problem/P7074）matrix_dp
P7160（https://www.luogu.com.cn/problem/P7160）matrix_dp|brute_force|counter
P7266（https://www.luogu.com.cn/problem/P7266）matrix_dp
P3399（https://www.luogu.com.cn/problem/P3399）matrix_dp
P2516（https://www.luogu.com.cn/problem/P2516）lcs|matrix_dp
P1544（https://www.luogu.com.cn/problem/P1544）matrix_dp
P1004（https://www.luogu.com.cn/problem/P1004）matrix_dp
P1006（https://www.luogu.com.cn/problem/P1006）matrix_dp
P1107（https://www.luogu.com.cn/problem/P1107）matrix_dp|prefix_max
P1279（https://www.luogu.com.cn/problem/P1279）edit_distance
P1353（https://www.luogu.com.cn/problem/P1353）matrix_dp
P1410（https://www.luogu.com.cn/problem/P1410）matrix_dp
P1799（https://www.luogu.com.cn/problem/P1799）matrix_dp
P1854（https://www.luogu.com.cn/problem/P1854）prefix_max|matrix_dp|specific_plan
P2140（https://www.luogu.com.cn/problem/P2140）matrix_dp
P2217（https://www.luogu.com.cn/problem/P2217）matrix_dp
P1436（https://www.luogu.com.cn/problem/P1436）md_matrix_dp
P5752（https://www.luogu.com.cn/problem/P5752）md_matrix_dp
P2380（https://www.luogu.com.cn/problem/P2380）md_matrix_dp
P2401（https://www.luogu.com.cn/problem/P2401）md_matrix_dp
P2528（https://www.luogu.com.cn/problem/P2528）reverse_order_pair|matrix_dp|implemention|construction
P2733（https://www.luogu.com.cn/problem/P2733）diff_array|matrix_dp|counter|maximum_square
P2736（https://www.luogu.com.cn/problem/P2736）matrix_dp
P2769（https://www.luogu.com.cn/problem/P2769）matrix_dp
P3012（https://www.luogu.com.cn/problem/P3012）matrix_dp
P3860（https://www.luogu.com.cn/problem/P3860）matrix_dp|specific_plan
P4958（https://www.luogu.com.cn/problem/P4958）linear_dp|prefix_sum
P5144（https://www.luogu.com.cn/problem/P5144）linear_dp|prefix_xor
P5858（https://www.luogu.com.cn/problem/P5858）matrix_dp|monotonic_queue
P5879（https://www.luogu.com.cn/problem/P5879）matrix_dp|prefix_sum
P6119（https://www.luogu.com.cn/problem/P6119）matrix_dp|lcs
P6323（https://www.luogu.com.cn/problem/P6323）reverse_order_pair|prefix_sum
P6394（https://www.luogu.com.cn/problem/P6394）matrix_dp|prefix_sum
P6433（https://www.luogu.com.cn/problem/P6433）greedy|classification_discussion|matrix_dp
P6451（https://www.luogu.com.cn/problem/P6451）md_matrix_dp|brute_force|4-tree
P6509（https://www.luogu.com.cn/problem/P6509）classical|matrix_dp|specific_plan
P6870（https://www.luogu.com.cn/problem/P6870）matrix_dp|comb|counter
P7995（https://www.luogu.com.cn/problem/P7995）matrix_dp
P8325（https://www.luogu.com.cn/problem/P8325）brute_force|matrix_dp|maximum_square
P8614（https://www.luogu.com.cn/problem/P8614）matrix_dp|mod
P8638（https://www.luogu.com.cn/problem/P8638）matrix_dp|longest_palindrome_sequence
P8786（https://www.luogu.com.cn/problem/P8786）classical|md_matrix_dp|implemention|memory_search
P1128（https://www.luogu.com.cn/problem/P1128）brain_teaser|data_range|brute_force|matrix_dp|high_precision|specific_plan
P1373（https://www.luogu.com.cn/problem/P1373）matrix_dp
P2028（https://www.luogu.com.cn/problem/P2028）bag_dp|math|comb|matrix_dp|second_stirling_num
P2132（https://www.luogu.com.cn/problem/P2132）matrix_dp|classical
P4771（https://www.luogu.com.cn/problem/P4771）matrix_dp|classical
P5888（https://www.luogu.com.cn/problem/P5888）observation|matrix_dp|inclusion_exclusion|implemention
P7074（https://www.luogu.com.cn/problem/P7074）matrix_dp|brain_teaser
P7248（https://www.luogu.com.cn/problem/P7248）matrix_dp|classical|regular_bracket

===================================CodeForces===================================
1446B（https://codeforces.com/problemset/problem/1446/B）lcs|matrix_dp
429B（https://codeforces.com/problemset/problem/429/B）matrix_dp
1398D（https://codeforces.com/problemset/problem/1398/D）md_matrix_dp|maximum_mul|maximum_sum
2B（https://codeforces.com/problemset/problem/2/B）matrix_dp
1381B（https://codeforces.com/problemset/problem/1381/B）matrix_dp|monotonic_stack
1393D（https://codeforces.com/problemset/problem/1393/D）matrix_dp
1731D（https://codeforces.com/contest/1731/problem/D）binary_search|maximum_square
1003F（https://codeforces.com/contest/1003/problem/F）con_lcp|matrix_dp|lcp
835D（https://codeforces.com/problemset/problem/835/D）palindrome|matrix_dp
1829G（https://codeforces.com/contest/1829/problem/G）matrix_dp|classical|inclusion_exclusion
1077F2（https://codeforces.com/contest/1077/problem/F2）matrix_dp|monotonic_queue|implemention
1133E（https://codeforces.com/contest/1133/problem/E）matrix_dp|preprocess|classical
1183H（https://codeforces.com/contest/1183/problem/H）matrix_dp|classical|hard|different_sub_sequence
1183E（https://codeforces.com/contest/1183/problem/E）matrix_dp|classical|hard|different_sub_sequence
1353F（https://codeforces.com/contest/1353/problem/F）matrix_dp|greedy|monotonic_stack
1409F（https://codeforces.com/contest/1409/problem/F）matrix_dp
1433F（https://codeforces.com/contest/1433/problem/F）matrix_dp
1551E（https://codeforces.com/contest/1551/problem/E）matrix_dp
1593F（https://codeforces.com/contest/1593/problem/F）matrix_dp|specific_plan|md_vector|flatten
1729G（https://codeforces.com/contest/1729/problem/G）matrix_dp
1811G2（https://codeforces.com/contest/1811/problem/G2）matrix_dp|comb
1132F（https://codeforces.com/problemset/problem/1132/F）matrix_dp|classical
1935C（https://codeforces.com/problemset/problem/1935/C）matrix_dp|greedy|sort
1989B（https://codeforces.com/contest/1989/problem/B）continuous_lcs|dp|classical
1517D（https://codeforces.com/contest/1517/problem/D）implemention|brain_teaser|observation|even|matrix_dp|bfs
1625C（https://codeforces.com/problemset/problem/1625/C）matrix_dp|brute_force|implemention
505C（https://codeforces.com/contest/505/problem/C）data_range|limited_operation|matrix_dp|classical|array
570E（https://codeforces.com/problemset/problem/570/E）matrix_dp|implemention
1987D（https://codeforces.com/problemset/problem/1987/D）matrix_dp|brain_teaser|game_dp
339C（https://codeforces.com/problemset/problem/339/C）matrix_dp|specific_plan
598E（https://codeforces.com/problemset/problem/598/E）matrix_dp|classical
711C（https://codeforces.com/problemset/problem/711/C）matrix_dp|prefix_suffix
1582F2（https://codeforces.com/problemset/problem/1582/F2）data_range|matrix_dp|implemention|limited_operation
833B（https://codeforces.com/problemset/problem/833/B）matrix_dp|segment_tree|range_add|range_max
10D（https://codeforces.com/problemset/problem/10/D）lis|lcs|matrix_dp|specific_plan|classical
1864D（https://codeforces.com/problemset/problem/1864/D）matrix_prefix_sum|implemention|matrix_dp

====================================AtCoder=====================================
ABC130E（https://atcoder.jp/contests/abc130/tasks/abc130_e）matrix_prefix_sum|matrix_dp
ABC325F（https://atcoder.jp/contests/abc325/tasks/abc325_f）matrix_dp|brute_force|classical
ABC344F（https://atcoder.jp/contests/abc344/tasks/abc344_f）matrix_dp|greedy|brain_teaser|classical
ABC311F（https://atcoder.jp/contests/abc311/tasks/abc311_f）matrix_dp|prefix_sum_opt|classical|brain_teaser
ABC311E（https://atcoder.jp/contests/abc311/tasks/abc311_e）matrix_dp|classical
ABC298G（https://atcoder.jp/contests/abc298/tasks/abc298_g）matrix_dp|brute_force|classical
ABC281D（https://atcoder.jp/contests/abc281/tasks/abc281_d）matrix_dp
ABC265E（https://atcoder.jp/contests/abc265/tasks/abc265_e）matrix_dp|brain_teaser|classical
ABC264F（https://atcoder.jp/contests/abc264/tasks/abc264_f）matrix_dp|tle
ABC261D（https://atcoder.jp/contests/abc261/tasks/abc261_d）matrix_dp
ABC262D（https://atcoder.jp/contests/abc262/tasks/abc262_d）brute_force|matrix_dp|classical
ABC253E（https://atcoder.jp/contests/abc253/tasks/abc253_e）prefix_sum|matrix_dp|inclusion_exclusion|reverse_thinking|classical
ABC238F（https://atcoder.jp/contests/abc238/tasks/abc238_f）sort|greedy|matrix_dp|implemention|classical
ABC237F（https://atcoder.jp/contests/abc237/tasks/abc237_f）matrix_dp|lis|counter|brain_teaser|classical
ABC227F（https://atcoder.jp/contests/abc227/tasks/abc227_f）matrix_dp|bryte_force|brain_teaser
ABC217G（https://atcoder.jp/contests/abc217/tasks/abc217_g）comb|perm|counter|matrix_dp|comb_dp
ABC212E（https://atcoder.jp/contests/abc212/tasks/abc212_e）graph|matrix_dp|inclusion_exclusion|classical
ABC207E（https://atcoder.jp/contests/abc207/tasks/abc207_e）matrix_dp|prefix_sum
ABC362E（https://atcoder.jp/contests/abc362/tasks/abc362_e）matrix_dp
ABC375E（https://atcoder.jp/contests/abc375/tasks/abc375_e）matrix_dp
ABC192F（https://atcoder.jp/contests/abc192/tasks/abc192_f）matrix_dp

=====================================AcWing=====================================
4378（https://www.acwing.com/problem/content/4381/）classical|matrix_dp
4418（https://www.acwing.com/problem/content/description/4421/）monotonic_queue|matrix_dp
2694（https://www.acwing.com/problem/content/description/2696/）lcs|matrix_dp|counter


=====================================AcWing=====================================
1（https://www.codechef.com/problems/MILKYDARK）matrix_dp|prefix_optimization|classical

"""

import heapq
import math
from collections import defaultdict, deque
from functools import lru_cache
from itertools import permutations, accumulate
from typing import List

from src.basis.diff_array.template import PreFixSumMatrix
from src.data_structure.segment_tree.template import RangeAddRangeSumMinMax
from src.data_structure.tree_array.template import PointDescendPreMin
from src.greedy.longest_increasing_subsequence.template import LcsComputeByLis
from src.mathmatics.comb_perm.template import Combinatorics
from src.mathmatics.number_theory.template import PrimeSieve
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1305(nums1: List[int], nums2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/uncrossed-lines/
        tag: lis|lcs
        """
        return LcsComputeByLis().length_of_lcs(nums1, nums2)

    @staticmethod
    def lc_1143(s1: str, s2: str) -> int:
        """
        url: https://leetcode.cn/problems/longest-common-subsequence/
        tag: lis|lcs
        """
        return LcsComputeByLis().length_of_lcs(s1, s2)

    @staticmethod
    def lc_920(n: int, goal: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-music-playlists/
        tag: matrix_dp|classical|hard|fill_table
        """
        mod = 10 ** 9 + 7

        @lru_cache(None)
        def dfs(i, r):
            if i == goal:
                return 1 if r == n else 0
            res = 0
            if r + 1 <= n:
                res += dfs(i + 1, r + 1) * (n - r)
            if r > k:
                res += dfs(i + 1, r) * (r - k)
            return res % mod

        return dfs(0, 0)

    @staticmethod
    def lc_956(rods: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/tallest-billboard/description/
        tag: matrix_dp|classical|meet_in_middle
        """
        pre = defaultdict(int)
        pre[0] = 0
        for num in rods:
            cur = pre.copy()
            for p in pre:
                cur[p + num] = max(cur[p + num], pre[p])
                cur[p - num] = max(cur[p - num], pre[p] + num)
            pre = cur
        return pre[0]

    @staticmethod
    def lc_1092(str1: str, str2: str) -> str:
        """
        url: https://leetcode.cn/problems/shortest-common-supersequence/
        tag: lis|lcs|specific_plan
        """
        m, n = len(str1), len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                a, b = dp[i + 1][j], dp[i][j + 1]
                a = a if a > b else b
                if str1[i] == str2[j]:
                    b = dp[i + 1][j + 1] + 1
                    a = a if a > b else b
                dp[i][j] = a

        i = j = 0
        ans = ""
        while i < m and j < n:
            if str1[i] == str2[j]:
                ans += str1[i]
                i += 1
                j += 1
            elif dp[i + 1][j + 1] == dp[i + 1][j]:
                ans += str2[j]
                j += 1
            else:
                ans += str1[i]
                i += 1
        ans += str1[i:] + str2[j:]
        return ans

    @staticmethod
    def lc_2435(grid: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/
        tag: matrix_dp|mod
        """
        mod = 10 ** 9 + 7
        m, n = len(grid), len(grid[0])
        dp = [[[0] * k for _ in range(n)] for _ in range(m)]
        dp[0][0][grid[0][0] % k] = 1

        pre = grid[0][0]
        for j in range(1, n):
            pre += grid[0][j]
            dp[0][j][pre % k] = 1

        pre = grid[0][0]
        for i in range(1, m):
            pre += grid[i][0]
            dp[i][0][pre % k] = 1

        for i in range(1, m):
            for j in range(1, n):
                for x in range(k):
                    y = (x - grid[i][j]) % k
                    dp[i][j][x] = (dp[i - 1][j][y] + dp[i][j - 1][y]) % mod
        return dp[-1][-1][0]

    @staticmethod
    def lc_2573(lcp: List[List[int]]) -> str:
        """
        url: https://leetcode.cn/problems/find-the-string-with-lcp/
        tag: greedy|construction|lcp|brain_teaser|classical
        """
        n = len(lcp)
        ans = [""] * n
        ind = 0
        for i in range(n):
            if ans[i]:
                continue
            if ind == 26:
                return ""
            w = chr(ind + ord("a"))
            ans[i] = w
            ind += 1
            for j in range(i + 1, n):
                if lcp[i][j]:
                    ans[j] = w

        ans = "".join(ans)
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if ans[i] == ans[j]:
                    if i + 1 < n and j + 1 < n:
                        x = lcp[i + 1][j + 1] + 1
                    else:
                        x = 1
                else:
                    x = 0
                if x != lcp[i][j]:
                    return ""
        return ans

    @staticmethod
    def cf_2b(ac, n, grid):
        """
        url: https://codeforces.com/problemset/problem/2/B
        tag: matrix_dp
        """

        def f_2(num):
            if not num:
                return 1
            res = 0
            while num and num % 2 == 0:
                num //= 2
                res += 1
            return res

        def f_5(num):
            if not num:
                return 1
            res = 0
            while num and num % 5 == 0:
                num //= 5
                res += 1
            return res

        def check(fun):
            dp = [[math.inf] * n for _ in range(n)]
            dp[0][0] = fun(grid[0][0])
            f = [[-1] * n for _ in range(n)]
            for j in range(1, n):
                f[0][j] = j - 1
                dp[0][j] = dp[0][j - 1] + fun(grid[0][j]) if grid[0][j] else 1
            for i in range(1, n):
                f[i][0] = (i - 1) * n
                dp[i][0] = dp[i - 1][0] + fun(grid[i][0]) if grid[i][0] else 1
                for j in range(1, n):
                    if grid[i][j] == 0:
                        dp[i][j] = 1
                    else:
                        c = fun(grid[i][j])
                        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + c
                    f[i][j] = (i - 1) * n + j if dp[i - 1][j] < dp[i][j - 1] else i * n + j - 1
            cnt = dp[-1][-1]
            path = ""
            x = (n - 1) * n + n - 1
            while f[x // n][x % n] != -1:
                i, j = x // n, x % n
                p = f[i][j]
                if i == p // n:
                    path += "R"
                else:
                    path += "D"
                x = p
            return cnt, path[::-1]

        c1, path1 = check(f_2)
        c2, path2 = check(f_5)
        if c1 <= c2:
            ans = [c1, path1]
        else:
            ans = [c2, path2]

        zero = False
        for ii in range(n):
            for jj in range(n):
                if grid[ii][jj] == 0:
                    zero = True
        if not zero:
            return ans

        if ans[0] > 1:
            for ii in range(n):
                for jj in range(n):
                    if grid[ii][jj] == 0:
                        cur = "D" * ii + "R" * jj + "D" * (n - 1 - ii) + "R" * (n - 1 - jj)
                        ans = [1, cur]
                        return ans
        return ans

    @staticmethod
    def cf_1398d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1398/D
        tag: md_matrix_dp|maximum_mul|maximum_sum
        """
        r, g, b = ac.read_list_ints()
        rr = sorted(ac.read_list_ints(), reverse=True)
        gg = sorted(ac.read_list_ints(), reverse=True)
        bb = sorted(ac.read_list_ints(), reverse=True)

        def idx(i1, i2, i3):
            return i1 * (g + 1) * (b + 1) + i2 * (b + 1) + i3

        dp = [0] * (r + 1) * (g + 1) * (b + 1)

        for i in range(r, -1, -1):
            for j in range(g, -1, -1):
                for k in range(b, -1, -1):
                    res = 0
                    if i < r and j < g:
                        res = max(res, dp[idx(i + 1, j + 1, k)] + rr[i] * gg[j])
                    if i < r and k < b:
                        res = max(res, dp[idx(i + 1, j, k + 1)] + rr[i] * bb[k])
                    if j < g and k < b:
                        res = max(res, dp[idx(i, j + 1, k + 1)] + bb[k] * gg[j])
                    dp[idx(i, j, k)] = res

        ac.st(dp[0])
        return

    @staticmethod
    def lc_2478(s: str, k: int, min_length: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-beautiful-partitions/
        tag: matrix_dp|classical|rever_thinking
        """
        mod = 10 ** 9 + 7
        n = len(s)
        prime = set("2357")
        if not (s[0] in prime and s[-1] not in prime):
            return 0
        if k == 1:
            return 1

        cut = []
        for i in range(min_length - 1, n - min_length):
            if s[i] not in prime and s[i + 1] in prime:
                cut.append(i)

        m = len(cut)
        if m + 1 < k:
            return 0

        pre = [1] * m

        for _ in range(2, k):
            cur = [0] * m
            x = j = 0
            for i in range(m):
                while j < m and cut[i] - cut[j] >= min_length:
                    x += pre[j]
                    x %= mod
                    j += 1
                cur[i] = x
            pre = cur[:]
        return sum(pre) % mod

    @staticmethod
    def lc_2463(robot, factory):
        """
        url: https://leetcode.cn/problems/minimum-total-distance-traveled/
        tag: matrix_dp|refresh_table
        """
        robot.sort()
        factory.sort()
        m, n = len(factory), len(robot)
        dp = [[math.inf] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 0
        for i in range(m):
            for j in range(n + 1):
                if dp[i][j] < math.inf:
                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j])
                    cost = 0
                    for k in range(1, factory[i][1] + 1):
                        if j + k - 1 < n:
                            cost += abs(factory[i][0] - robot[j + k - 1])
                            dp[i + 1][j + k] = min(dp[i + 1][j + k], dp[i][j] + cost)
                        else:
                            break
        return dp[-1][-1]

    @staticmethod
    def lg_p2516(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2516
        tag: lcs|matrix_dp|length_of_lcs|cnt_of_lcs|rolling_array|classical|hard
        """
        s = ac.read_str()[:-1]
        t = ac.read_str()[:-1]
        m, n = len(s), len(t)
        mod = 10 ** 8
        pre_dp = [0] * (n + 1)
        pre_cnt = [1] * (n + 1)
        cur_dp = [0] * (n + 1)
        cur_cnt = [0] * (n + 1)
        pre = 0
        for i in range(m):
            cur = 1 - pre
            cur_dp[0] = 0
            cur_cnt[0] = 1
            for j in range(n):
                cur_dp[j + 1] = 0
                cur_cnt[j + 1] = 0

                if s[i] == t[j]:
                    cur_dp[j + 1] = pre_dp[j] + 1
                    cur_cnt[j + 1] = pre_cnt[j]

                if cur_dp[j] > cur_dp[j + 1]:
                    cur_dp[j + 1] = cur_dp[j]
                    cur_cnt[j + 1] = cur_cnt[j]
                elif cur_dp[j] == cur_dp[j + 1]:
                    cur_cnt[j + 1] += cur_cnt[j]

                if pre_dp[j + 1] > cur_dp[j + 1]:
                    cur_dp[j + 1] = pre_dp[j + 1]
                    cur_cnt[j + 1] = pre_cnt[j + 1]
                elif pre_dp[j + 1] == cur_dp[j + 1]:
                    cur_cnt[j + 1] += pre_cnt[j + 1]

                if pre_dp[j] == cur_dp[j + 1]:
                    cur_cnt[j + 1] -= pre_cnt[j]
                cur_cnt[j + 1] %= mod
            for j in range(n + 1):
                pre_dp[j] = cur_dp[j]
                pre_cnt[j] = cur_cnt[j]
            pre = cur

        ac.st(pre_dp[-1])
        ac.st(pre_cnt[-1])
        return

    @staticmethod
    def lg_p1544(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1544
        tag: matrix_dp
        """
        n, k = ac.read_list_ints()

        pre = [-math.inf] * (k + 1) * n
        cur = [-math.inf] * (k + 1) * n
        pre[0] = 0
        for i in range(1, n + 1):
            lst = ac.read_list_ints()
            for j in range(i):
                for p in range(k + 1):
                    if j and p:
                        a = max(pre[j * (k + 1) + p], pre[(j - 1) * (k + 1) + p]) + lst[j]
                        b = max(pre[j * (k + 1) + p - 1], pre[(j - 1) * (k + 1) + p - 1]) + lst[j] * 3
                        cur[j * (k + 1) + p] = max(a, b)
                    elif j:
                        cur[j * (k + 1) + p] = max(pre[j * (k + 1) + p], pre[(j - 1) * (k + 1) + p]) + lst[j]
                    elif p:
                        cur[j * (k + 1) + p] = max(pre[j * (k + 1) + p] + lst[j],
                                                      pre[j * (k + 1) + p - 1] + lst[j] * 3)
                    else:
                        cur[j * (k + 1) + p] = pre[j * (k + 1) + p] + lst[j]
            for j in range(n * (k + 1)):
                pre[j] = cur[j]
        ac.st(max(pre))
        return

    @staticmethod
    def lg_p1004(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1004
        tag: matrix_dp|classical
        """
        n = ac.read_int()
        grid = [[0] * n for _ in range(n)]
        while True:
            lst = ac.read_list_ints()
            if lst == [0, 0, 0]:
                break
            x, y, z = lst
            grid[x - 1][y - 1] = z
        pos = [[] for _ in range(2 * n - 1)]
        for i in range(n):
            for j in range(n):
                pos[i + j].append(i)

        pre = {(0, 0): grid[0][0]}
        for i in range(1, 2 * n - 1):
            cur = dict()
            for x1 in pos[i]:
                for x2 in pos[i]:
                    val = 0
                    y1, y2 = i - x1, i - x2
                    for a, b in [[x1 - 1, y1], [x1, y1 - 1]]:
                        for c, d in [[x2 - 1, y2], [x2, y2 - 1]]:
                            if 0 <= a < n and 0 <= b < n and 0 <= c < n and 0 <= d < n:
                                val = max(val, pre[(b, d)])
                    val += grid[x1][y1] + grid[x2][y2]
                    if x1 == x2:
                        val -= grid[x1][y1]
                    cur[(y1, y2)] = val
            pre = cur
        ac.st(list(pre.values())[0])
        return

    @staticmethod
    def lg_p1006(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1006
        tag: matrix_dp
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]

        pos = [[] for _ in range(m + n - 1)]
        for i in range(m):
            for j in range(n):
                pos[i + j].append(i)

        pre = {(0, 0): grid[0][0]}
        for i in range(1, m + n - 1):
            cur = dict()
            for x1 in pos[i]:
                for x2 in pos[i]:
                    val = 0
                    y1, y2 = i - x1, i - x2
                    for a, b in [[x1 - 1, y1], [x1, y1 - 1]]:
                        for c, d in [[x2 - 1, y2], [x2, y2 - 1]]:
                            if 0 <= a < m and 0 <= b < n and 0 <= c < m and 0 <= d < n:
                                val = max(val, pre[(b, d)])
                    val += grid[x1][y1] + grid[x2][y2]
                    if y1 == y2 and i < m + n - 2:
                        val = -math.inf
                    cur[(y1, y2)] = val
            pre = cur
        ac.st(list(pre.values())[0])
        return

    @staticmethod
    def lg_p1107(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1107
        tag: matrix_dp|prefix_max
        """
        n, h, d = ac.read_list_ints()
        cnt = [0] * (h + 1) * n
        for i in range(n):
            lst = ac.read_list_ints()
            for j in lst[1:]:
                cnt[i * (h + 1) + j] += 1

        ceil = [0] * (h + 1)
        pre = [0] * n
        cur = [0] * n
        for i in range(h, -1, -1):
            for j in range(n):
                cur[j] = pre[j] + cnt[j * (h + 1) + i]
                if i + d <= h and ceil[i + d] > pre[j]:
                    cur[j] = ceil[i + d] + cnt[j * (h + 1) + i]
            for j in range(n):
                pre[j] = cur[j]
            ceil[i] = max(pre)
        ac.st(ceil[0])
        return

    @staticmethod
    def lg_p1279(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1279
        tag: edit_distance
        """
        s = ac.read_str()
        t = ac.read_str()
        k = ac.read_int()
        m, n = len(s), len(t)

        pre = [j * k for j in range(n + 1)]
        cur = [math.inf] * (n + 1)
        for i in range(m):
            cur[0] = pre[0] + k
            for j in range(n):
                cur[j + 1] = min(pre[j] + abs(ord(s[i]) - ord(t[j])), cur[j] + k, pre[j + 1] + k)
            for j in range(n + 1):
                pre[j] = cur[j]
        ac.st(pre[-1])
        return

    @staticmethod
    def lg_p1353(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1353
        tag: matrix_dp
        """
        n, m = ac.read_list_ints()

        def idx(i1, j1):
            return i1 * (m + 1) + j1

        nums = [ac.read_int() for _ in range(n)]
        dp = [-math.inf] * (m + 1) * (n + 1)
        dp[0] = 0
        for i in range(n):
            dp[idx(i + 1, 0)] = dp[idx(i, 0)]
            for j in range(1, min(i + 2, m + 1)):
                dp[idx(i + 1, 0)] = max(dp[idx(i + 1, 0)], dp[idx(i + 1 - j, j)])
            for j in range(1, m + 1):
                dp[idx(i + 1, j)] = dp[idx(i, j - 1)] + nums[i]
        ac.st(dp[idx(n, 0)])
        return

    @staticmethod
    def lg_p1854(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1854
        tag: prefix_max|matrix_dp|specific_plan
        """
        m, n = ac.read_list_ints()
        grid = []
        for _ in range(m):
            grid.extend(ac.read_list_ints())

        def idx(ii, jj):
            return ii * (n + 1) + jj

        dp = [-math.inf] * (n + 1) * (m + 1)
        for j in range(n + 1):
            dp[j] = 0
        pre = [-1] * (n + 1) * (m + 1)
        for i in range(m):
            x = dp[idx(i, i)]
            ind = i
            for j in range(i, n):
                if dp[idx(i, j)] > x:
                    x = dp[idx(i, j)]
                    ind = j
                if dp[idx(i + 1, j + 1)] < x + grid[i * n + j]:
                    dp[idx(i + 1, j + 1)] = x + grid[i * n + j]
                    pre[idx(i + 1, j + 1)] = ind

        res = max(dp[idx(m, j)] for j in range(n + 1))
        ac.st(res)
        ans = []
        for j in range(n + 1):
            if dp[idx(m, j)] == res:
                ans = [j]
                break
        for i in range(m, 1, -1):
            ans.append(pre[idx(i, ans[-1])])
        ans.reverse()
        ac.lst([x for x in ans])
        return

    @staticmethod
    def lg_p2140(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2140
        tag: matrix_dp
        """
        m, n, u = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        m, n = len(grid), len(grid[0])

        def idx(ii, jj):
            return ii * (n + 1) + jj

        pre = [0] * (n + 1) * (m + 1)
        for i in range(m):
            for j in range(n):
                pre[idx(i + 1, j + 1)] = pre[idx(i, j + 1)] + pre[idx(i + 1, j)] - pre[idx(i, j)] + grid[i][j]

        def idy(ii, jj, kk, pp):
            return ii * n * m * n + jj * m * n + kk * n + pp

        dp = [(-math.inf, -math.inf)] * m * n * m * n

        s = pre[-1]
        for xa in range(m - 1, -1, -1):
            for ya in range(n - 1, -1, -1):
                for xb in range(xa, m):
                    for yb in range(ya, n):
                        w = pre[idx(xb + 1, yb + 1)] - pre[idx(xb + 1, ya)] - pre[idx(xa, yb + 1)] + pre[idx(xa, ya)]
                        if w < s - u:
                            continue
                        res = (1, u - (s - w))

                        for xx in range(xa, xb):
                            nex1 = dp[idy(xa, ya, xx, yb)][:]
                            nex2 = dp[idy(xx + 1, ya, xb, yb)][:]
                            nex = (nex1[0] + nex2[0], min(nex1[1], nex2[1]))
                            if nex > res:
                                res = nex[:]
                        for yy in range(ya, yb):
                            nex1 = dp[idy(xa, ya, xb, yy)][:]
                            nex2 = dp[idy(xa, yy + 1, xb, yb)][:]
                            nex = (nex1[0] + nex2[0], min(nex1[1], nex2[1]))
                            if nex > res:
                                res = nex[:]
                        dp[idy(xa, ya, xb, yb)] = res
        ac.lst(dp[idy(0, 0, m - 1, n - 1)])
        return

    @staticmethod
    def lg_p2217(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2217
        tag: matrix_dp
        """
        m, n, k = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        avg = sum(sum(g) for g in grid) / k
        m, n = len(grid), len(grid[0])
        pre = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                pre[i + 1][j + 1] = pre[i][j + 1] + pre[i + 1][j] - pre[i][j] + grid[i][j]

        # @lru_cache(None)
        # def dfs(i, j, x, y, w):
        #     if w == 1:
        #         return (pre[x + 1][y + 1] - pre[x + 1][j] - pre[i][y + 1] + pre[i][j]-avg)**2
        #     res = math.inf
        #     for a in range(i, x):
        #         for up in range(1, w):
        #             res = min(res, dfs(i, j, a, y, up)+dfs(a+1, j, x, y, w-up))
        #
        #     for b in range(j, y):
        #         for up in range(1, w):
        #             res = min(res, dfs(i, j, x, b, up) + dfs(i, b+1, x, y, w - up))
        #     return res
        # ans = (dfs(0, 0, m-1, n-1, k)/k)**0.5
        # ac.st("%.2f" % ans)

        dp = [[[[[math.inf] * (k + 1) for _ in range(n)] for _ in range(m)] for _ in range(n)] for _ in range(m)]
        for i in range(m - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                for x in range(i, m):
                    for y in range(j, n):
                        for w in range(k + 1):
                            if w == 1:
                                res = (pre[x + 1][y + 1] - pre[x + 1][j] - pre[i][y + 1] + pre[i][j] - avg) ** 2
                                dp[i][j][x][y][w] = res
                                continue
                            res = math.inf
                            for a in range(i, x):
                                for up in range(1, w):
                                    res = min(res, dp[i][j][a][y][up] + dp[a + 1][j][x][y][w - up])
                            for b in range(j, y):
                                for up in range(1, w):
                                    res = min(res, dp[i][j][x][b][up] + dp[i][b + 1][x][y][w - up])
                            dp[i][j][x][y][w] = res
        ans = (dp[0][0][m - 1][n - 1][k] / k) ** 0.5
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p1436(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1436
        tag: md_matrix_dp
        """
        k = ac.read_int()
        m = n = 8
        grid = [ac.read_list_ints() for _ in range(m)]
        pre = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                pre[i + 1][j + 1] = pre[i][j + 1] + pre[i + 1][j] - pre[i][j] + grid[i][j]

        # @lru_cache(None)
        # def dfs(i, j, x, y, w):
        #     if w == 1:
        #         return (pre[x + 1][y + 1] - pre[x + 1][j] - pre[i][y + 1] + pre[i][j])**2
        #     res = math.inf
        #     for a in range(i, x):
        #         res = min(res, dfs(i, j, a, y, 1)+dfs(a+1, j, x, y, w-1))
        #         res = min(res, dfs(i, j, a, y, w-1) + dfs(a + 1, j, x, y, 1))
        #     for b in range(j, y):
        #         res = min(res, dfs(i, j, x, b, 1) + dfs(i, b+1, x, y, w - 1))
        #         res = min(res, dfs(i, j, x, b, w-1) + dfs(i, b + 1, x, y, 1))
        #     return res
        # ans = dfs(0, 0, m-1, n-1, k)
        # ac.st(ans)

        dp = [[[[[math.inf] * (k + 1) for _ in range(n)] for _ in range(m)] for _ in range(n)] for _ in range(m)]
        for i in range(m - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                for x in range(i, m):
                    for y in range(j, n):
                        for w in range(k + 1):
                            if w == 1:
                                res = (pre[x + 1][y + 1] - pre[x + 1][j] - pre[i][y + 1] + pre[i][j]) ** 2
                                dp[i][j][x][y][w] = res
                                continue
                            res = math.inf
                            for a in range(i, x):
                                res = min(res, dp[i][j][a][y][1] + dp[a + 1][j][x][y][w - 1])
                                res = min(res, dp[i][j][a][y][w - 1] + dp[a + 1][j][x][y][1])
                            for b in range(j, y):
                                res = min(res, dp[i][j][x][b][1] + dp[i][b + 1][x][y][w - 1])
                                res = min(res, dp[i][j][x][b][w - 1] + dp[i][b + 1][x][y][1])
                            dp[i][j][x][y][w] = res
        ans = dp[0][0][m - 1][n - 1][k]
        ac.st(ans)
        return

    @staticmethod
    def lg_p5752(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5752
        tag: md_matrix_dp
        """
        k = ac.read_int()
        m = n = 8
        grid = [ac.read_list_ints() for _ in range(m)]
        avg = sum(sum(g) for g in grid) / k
        pre = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                pre[i + 1][j + 1] = pre[i][j + 1] + pre[i + 1][j] - pre[i][j] + grid[i][j]

        # @lru_cache(None)
        # def dfs(i, j, x, y, w):
        #     if w == 1:
        #         return (pre[x + 1][y + 1] - pre[x + 1][j] - pre[i][y + 1] + pre[i][j]-avg)**2
        #     res = math.inf
        #     for a in range(i, x):
        #         res = min(res, dfs(i, j, a, y, 1)+dfs(a+1, j, x, y, w-1))
        #         res = min(res, dfs(i, j, a, y, w-1) + dfs(a + 1, j, x, y, 1))
        #     for b in range(j, y):
        #         res = min(res, dfs(i, j, x, b, 1) + dfs(i, b+1, x, y, w - 1))
        #         res = min(res, dfs(i, j, x, b, w-1) + dfs(i, b + 1, x, y, 1))
        #     return res
        # ans = (dfs(0, 0, m-1, n-1, k)/k)**0.5
        # ac.st("%.3f" % ans)

        dp = [[[[[math.inf] * (k + 1) for _ in range(n)] for _ in range(m)] for _ in range(n)] for _ in range(m)]
        for i in range(m - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                for x in range(i, m):
                    for y in range(j, n):
                        for w in range(k + 1):
                            if w == 1:
                                res = (pre[x + 1][y + 1] - pre[x + 1][j] - pre[i][y + 1] + pre[i][j] - avg) ** 2
                                dp[i][j][x][y][w] = res
                                continue
                            res = math.inf
                            for a in range(i, x):
                                res = min(res, dp[i][j][a][y][1] + dp[a + 1][j][x][y][w - 1])
                                res = min(res, dp[i][j][a][y][w - 1] + dp[a + 1][j][x][y][1])
                            for b in range(j, y):
                                res = min(res, dp[i][j][x][b][1] + dp[i][b + 1][x][y][w - 1])
                                res = min(res, dp[i][j][x][b][w - 1] + dp[i][b + 1][x][y][1])
                            dp[i][j][x][y][w] = res
        ans = (dp[0][0][m - 1][n - 1][k] / k) ** 0.5
        ac.st("%.3f" % ans)
        return

    @staticmethod
    def lg_p2380(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2380
        tag: md_matrix_dp
        """
        # prefix_sum与matrix_dp
        while True:
            m, n = ac.read_list_ints()
            if m == n == 0:
                break

            grid_west = []
            for _ in range(m):
                lst = ac.read_list_ints()
                grid_west.append(ac.accumulate(lst))

            grid_north = [[0] * (n + 1)]
            for _ in range(m):
                lst = ac.read_list_ints()
                grid_north.append([grid_north[-1][i] + lst[i] for i in range(n)])

            dp = [[0] * (n + 1) for _ in range(m + 1)]
            for i in range(m):
                for j in range(n):
                    # 只能往左或者往上挖
                    dp[i + 1][j + 1] = max(dp[i][j + 1] + grid_west[i][j + 1], dp[i + 1][j] + grid_north[i + 1][j])
            ac.st(dp[-1][-1])
        return

    @staticmethod
    def lg_p2401(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2401
        tag: md_matrix_dp
        """
        # matrix_dp|
        n, k = ac.read_list_ints()
        dp = [[0] * (k + 1) for _ in range(2)]
        pre = 0
        dp[pre][0] = 1
        mod = 2015
        for i in range(n):
            cur = 1 - pre
            dp[cur][0] = 1
            for j in range(1, min(i + 1, k + 1)):
                dp[cur][j] = (dp[pre][j] * (j + 1) + dp[pre][j - 1] * (i - j + 1)) % mod
            pre = cur
        ac.st(dp[pre][-1])
        return

    @staticmethod
    def lg_p2528(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2528
        tag: reverse_order_pair|matrix_dp|implemention|construction
        """
        # reverse_order_pair|matrix_dp| 与implementionconstruction
        n, t = ac.read_list_ints()
        dp = [[0] * (t + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(n):
            dp[i + 1][0] = 1
            for j in range(1, t + 1):
                dp[i + 1][j] = sum(dp[i][j - k] for k in range(min(i, j) + 1))
        ac.st(dp[-1][-1])

        lst = list(range(1, n + 1))
        ans = []
        for _ in range(n):
            m = len(lst)
            for i in range(m):
                rest = (m - 1) * (m - 2) // 2 + i
                if rest >= t:
                    ans.append(lst.pop(i))
                    t -= i
                    break
        ac.lst(ans)
        return

    @staticmethod
    def lg_p2733(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2733
        tag: diff_array|matrix_dp|counter|maximum_square
        """
        # DP通过边长与diff_array|正方形子矩阵的个数
        n = ac.read_int()
        grid = [ac.read_str() for _ in range(n)]
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        diff = [0] * (n + 1)
        for i in range(n):
            for j in range(n):
                if grid[i][j] == "1":
                    # 转移公式
                    dp[i + 1][j + 1] = min(dp[i][j], dp[i + 1][j], dp[i][j + 1]) + 1
                    x = dp[i + 1][j + 1]
                    if x >= 2:
                        diff[2] += 1
                        if x + 1 <= n:
                            diff[x + 1] -= 1
        for i in range(2, n + 1):
            diff[i] += diff[i - 1]
            if diff[i] > 0:
                ac.lst([i, diff[i]])
        return

    @staticmethod
    def lg_p2736(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2736
        tag: matrix_dp
        """
        # matrix_dp|
        n, t, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        # @lru_cache(None)
        # def dfs(i, j, pre):
        #     if i == n:
        #         return 0
        #     if j == m:
        #         return 0
        #     res = dfs(i + 1, j, pre)
        #     if pre + nums[i] <= t:
        #         res = max(res, dfs(i + 1, j, pre + nums[i]) + 1)
        #     if nums[i] <= t and j + 1 < m:
        #         res = max(res, dfs(i + 1, j + 1, nums[i]) + 1)
        #     return res
        #
        # ans = dfs(0, 0, 0)
        # ac.st(ans)

        dp = [[[0] * (t + 1) for _ in range(m + 1)] for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            for j in range(m - 1, -1, -1):
                for k in range(t, -1, -1):
                    res = dp[i + 1][j][k]
                    if k + nums[i] <= t:
                        res = max(res, dp[i + 1][j][k + nums[i]] + 1)
                    if nums[i] <= t and j + 1 < m:
                        res = max(res, dp[i + 1][j + 1][nums[i]] + 1)
                    dp[i][j][k] = res
        ac.st(dp[0][0][0])
        return

    @staticmethod
    def lg_p2769(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2769
        tag: matrix_dp
        """
        # matrix_dp| 注意初始化条件
        n = ac.read_int()
        a = ac.read_list_ints()
        a.sort()
        m = ac.read_int()
        b = ac.read_list_ints()
        b.sort()

        # @lru_cache(None)
        # def dfs(i, j, state):
        #     if i == n:
        #         return 0 if j == m-1 and state else math.inf
        #     if not state:
        #         return abs(a[i]-b[j])+dfs(i+1, j, 1)
        #
        #     res = dfs(i+1, j, 1)+abs(a[i]-b[j])
        #     if state and j+1<m:
        #         res = min(res, dfs(i+1, j+1, 1)+abs(a[i]-b[j+1]))
        #     return res
        # ac.st(dfs(0, 0, 0))

        dp = [[math.inf for _ in range(m + 1)] for _ in range(2)]
        pre = 0
        dp[pre][0] = 0
        for i in range(n):
            cur = 1 - pre
            dp[cur][0] = math.inf
            for j in range(m):
                dp[cur][j + 1] = min(dp[pre][j] + abs(a[i] - b[j]), dp[pre][j + 1] + abs(a[i] - b[j]))
            pre = cur
        ac.st(dp[pre][-1])
        return

    @staticmethod
    def lg_p3012(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3012
        tag: matrix_dp
        """
        # matrix_dp| 可以按照顺序转移
        u, l, p = ac.read_list_ints()
        dct = defaultdict(list)
        nodes = set()
        for _ in range(p):
            st = ac.read_str()
            dct[st[0]].append(st[1])
            nodes.add(st[0])
            nodes.add(st[1])
        nodes = list(nodes)
        ind = {w: i for i, w in enumerate(nodes)}
        m = len(ind)
        mod = 97654321

        # 大写字母个数，小写字母个数，当前结尾字母
        dp = [[[0] * m for _ in range(l + 1)] for _ in range(u + 1)]
        for w in nodes:
            if w.isupper():  # 初始化
                dp[1][0][ind[w]] = 1
            else:
                dp[0][1][ind[w]] = 1

        # 从小到大
        for i in range(u + 1):
            for j in range(l + 1):
                for k in range(m):
                    for nex in dct[nodes[k]]:
                        # 状态转移
                        if nex.isupper() and i + 1 <= u:
                            dp[i + 1][j][ind[nex]] += dp[i][j][k]
                            dp[i + 1][j][ind[nex]] %= mod
                        if nex.islower() and j + 1 <= l:
                            dp[i][j + 1][ind[nex]] += dp[i][j][k]
                            dp[i][j + 1][ind[nex]] %= mod
        ac.st(sum(dp[u][l]) % mod)
        return

    @staticmethod
    def lg_p3860(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3860
        tag: matrix_dp|specific_plan
        """
        # matrix_dp| 并具体转移specific_plan
        n, m = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        dp = [[math.inf] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 0
        pre = [[[0, 0] for _ in range(n + 1)] for _ in range(m + 1)]
        for i in range(m):
            dp[i + 1][0] = 0
            for j in range(n):
                cur = post = 0
                for k in range(j, -1, -1):
                    cur += post
                    cur += nums[k]
                    post += nums[k]
                    if cur + dp[i][k] < dp[i + 1][j + 1]:
                        pre[i + 1][j + 1] = [i, k]
                        dp[i + 1][j + 1] = cur + dp[i][k]
        ac.st(dp[m][n])
        ans = [[m, n]]
        while len(ans) < m + 1:
            ans.append(pre[ans[-1][0]][ans[-1][1]])
        ans.reverse()
        x = len(ans)
        for i in range(1, x):
            a, b = ans[i - 1]
            c, d = ans[i]
            ac.st(d - b)
        return

    @staticmethod
    def lg_p4958(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4958
        tag: linear_dp|prefix_sum
        """
        mod = 10 ** 9 + 7  # TLE
        ind = {chr(i + ord("a")): i for i in range(26)}
        ind["#"] = 26
        s = ac.read_str()
        n = len(s)
        dp = [[[0] * (n + 1) for _ in range(27)] for _ in range(27)]
        dp[26][26][0] = 1
        pre = [[0] * (n + 1) for _ in range(27)]
        pre[26][0] = 1
        for w in s:
            x = ind[w]
            for k in range(n - 1, -1, -1):
                for j in range(27):
                    dp[x][j][k + 1] += pre[j][k]
                    dp[x][j][k + 1] %= mod
                    pre[x][k + 1] += pre[j][k]
                    pre[x][k + 1] %= mod
        for _ in range(ac.read_int()):
            n, st = ac.read_list_strs()
            n = int(n)
            i, j = ind[st[1]], ind[st[0]]
            ac.st(dp[i][j][n])
        return

    @staticmethod
    def lg_p5144(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5144
        tag: linear_dp|prefix_xor
        """
        # linear_dp 二维|前缀异或和
        n, m = ac.read_list_ints()
        dp = [[0] * m for _ in range(n)]
        nums = ac.read_list_ints()
        dp[0][0] = nums[0]
        for i in range(1, n):
            dp[i][0] = dp[i - 1][0] ^ nums[i]
            for j in range(1, m):
                if j > i:
                    break
                cur = nums[i]
                for k in range(i - 1, -1, -1):
                    dp[i][j] = max(dp[k][j - 1] + cur, dp[i][j])
                    cur ^= nums[k]
        ac.st(dp[-1][-1])
        return

    @staticmethod
    def lg_p5858(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5858
        tag: matrix_dp|monotonic_queue
        """

        n, w, s = ac.read_list_ints()
        nums = ac.read_list_ints()  # TLE
        dp = [[-math.inf] * w for _ in range(2)]
        pre = 0
        dp[pre][0] = nums[0]
        for i in range(1, n):
            a = nums[i]
            cur = 1 - pre
            stack = deque()
            x = 0
            for j in range(w):
                if j > i + 1:
                    break
                while stack and stack[0][0] < j - 1:
                    stack.popleft()
                while x < w and x <= j + s - 1:
                    while stack and stack[-1][1] <= dp[pre][x]:
                        stack.pop()
                    stack.append([x, dp[pre][x]])
                    x += 1
                if stack:
                    dp[cur][j] = stack[0][1] + (j + 1) * a
            pre = cur
        ac.st(max(dp[pre]))
        return

    @staticmethod
    def lg_p5879(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5879
        tag: matrix_dp|prefix_sum
        """
        # matrix_dp| 后缀和优化
        n = ac.read_int()
        pre = [1] * (n + 1)
        pre[0] = 0
        for x in range(n - 1, 0, -1):
            cur = [0] * (x + 1)
            cnt = pre[-1]
            for j in range(x, -1, -1):
                cnt += pre[j]
                cur[j] = cnt
            pre = cur[:]
        ac.st(sum(pre))
        return

    @staticmethod
    def lg_p6119(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6119
        tag: matrix_dp|lcs
        """
        # matrix_dp| 为 LCS 的变形题
        n = ac.read_int()
        a = [ac.read_int() for _ in range(n)]
        b = [ac.read_int() for _ in range(n)]
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n):
            for j in range(n):
                dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1], dp[i][j] + int(abs(a[i] - b[j]) <= 4))
        ac.st(dp[-1][-1])
        return

    @staticmethod
    def lg_p6323(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6323
        tag: reverse_order_pair|prefix_sum
        """
        #  DP reverse_order_pair|为指定数量时的排列个数prefix_sum优化
        mod = 10 ** 9 + 7
        n, k = ac.read_list_ints()
        dp = [[0] * (k + 1) for _ in range(2)]
        pre = 0
        dp[pre][0] = 1
        for i in range(n):
            cur = 1 - pre
            lst = ac.accumulate(dp[pre])
            for j in range(k + 1):
                left = j - i if j - i >= 0 else 0
                dp[cur][j] = (lst[j + 1] - lst[left]) % mod
            pre = cur
        ac.st(dp[pre][k] % mod)
        return

    @staticmethod
    def lg_p6394(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6394
        tag: matrix_dp|prefix_sum
        """
        # matrix_dp| |prefix_sum优化
        n, k = ac.read_list_ints()
        s = ac.read_list_ints()
        if sum(s) < n:
            ac.st("impossible")
            return
        mod = 10086001
        dp = [[0] * (n + 1) for _ in range(2)]
        pre = ans = 0
        dp[pre][0] = 1
        for i in range(k):
            cur = 1 - pre
            lst = ac.accumulate(dp[pre])
            for j in range(n + 1):
                low = max(0, j - s[i])
                dp[cur][j] = lst[j + 1] - lst[low]
                dp[cur][j] %= mod
            ans += dp[cur][n]
            ans %= mod
            pre = cur
        ac.st(ans)
        return

    @staticmethod
    def lg_p6433(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6433
        tag: greedy|classification_discussion|matrix_dp
        """
        # greedy|classification_discussionmatrix_dp|
        n, m, k = ac.read_list_ints()

        nums = [ac.read_list_ints() for _ in range(n)]
        if sum(x for _, x in nums) <= m:
            lst = [a for a, _ in nums]
            lst.sort(reverse=True)
            lst.pop()
            ans = sum(a * 2 for a in lst[:k]) + sum(lst[k:])
            ac.st(ans)
            return

        # dp[i][j]表示花费时间 i 翻倍次数为 j 时的最大毒瘤程度
        dp = [[0 for _ in range(k + 1)] for _ in range(m + 1)]
        for a, x in nums:
            for i in range(m, -1, -1):
                for j in range(k, -1, -1):
                    cur = dp[i][j]
                    if i >= x:
                        cur = max(cur, dp[i - x][j] + a)
                        if j >= 1:
                            cur = max(cur, dp[i - x][j - 1] + 2 * a)
                    dp[i][j] = cur
        ac.st(dp[m][k])
        return

    @staticmethod
    def lg_p6451(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6451
        tag: md_matrix_dp|brute_force|4-tree
        """
        # 迭代方式实现md_matrix_dp 并brute_force四叉树获取对应最小代价和状态
        n = ac.read_int()
        grid = [[int(w) for w in ac.read_str()] for _ in range(n)]
        pre = PreFixSumMatrix(grid)
        del grid
        states = list(set([tuple(item) for item in permutations([0, 1, 2, 2], 4)]))
        ind = {state: i for i, state in enumerate(states)}  # MLE

        def dfs():
            # 最小代价
            stack = [[0, 0, n - 1, n - 1]]
            while stack:
                x1, y1, x2, y2 = stack.pop()
                if x1 >= 0:
                    if (x1, y1, x2, y2) in dct:
                        continue
                    if x1 == x2 and y1 == y2:
                        dct[(x1, y1, x2, y2)] = [0, 0]
                        continue
                    stack.append([~x1, y1, x2, y2])
                    m = (x2 - x1 + 1) // 2
                    x_mid = x1 + m - 1
                    y_mid = y1 + m - 1
                    sub = [[x1, y1, x_mid, y_mid], [x1, y_mid + 1, x_mid, y2],
                           [x_mid + 1, y1, x2, y_mid], [x_mid + 1, y_mid + 1, x2, y2]]
                    stack.extend(sub)
                else:
                    x1 = ~x1
                    m = (x2 - x1 + 1) // 2
                    x_mid = x1 + m - 1
                    y_mid = y1 + m - 1
                    sub = [[x1, y1, x_mid, y_mid], [x1, y_mid + 1, x_mid, y2],
                           [x_mid + 1, y1, x2, y_mid], [x_mid + 1, y_mid + 1, x2, y2]]
                    res = [0, math.inf]
                    for item in states:
                        cost = 0
                        for i in range(4):
                            xx1, yy1, xx2, yy2 = sub[i]
                            if item[i] == 0:
                                cost += pre.query(xx1, yy1, xx2, yy2)
                            elif item[i] == 1:
                                cost += (yy2 - yy1 + 1) * (xx2 - xx1 + 1) - pre.query(xx1, yy1, xx2, yy2)
                            else:
                                nex = dct[(xx1, yy1, xx2, yy2)]
                                cost += nex[-1]
                        if cost < res[-1]:
                            res = [ind[item], cost]
                    dct[(x1, y1, x2, y2)] = res
            return

        def check():
            # 通过转移状态结果赋值
            stack = [[0, 0, n - 1, n - 1]]
            while stack:
                x1, y1, x2, y2 = stack.pop()
                if x1 == x2 and y1 == y2:
                    ans[x1][y1] = pre.query(x1, y1, x1, y1)
                    continue
                m = (x2 - x1 + 1) // 2
                x_mid = x1 + m - 1
                y_mid = y1 + m - 1
                sub = [[x1, y1, x_mid, y_mid], [x1, y_mid + 1, x_mid, y2],
                       [x_mid + 1, y1, x2, y_mid], [x_mid + 1, y_mid + 1, x2, y2]]
                res = states[dct[(x1, y1, x2, y2)][0]]
                for i in range(4):
                    xx1, yy1, xx2, yy2 = sub[i]
                    if res[i] == 0:
                        continue
                    if res[i] == 1:
                        for w in range(xx1, xx2 + 1):
                            for h in range(yy1, yy2 + 1):
                                ans[w][h] = 1
                    else:
                        stack.append([xx1, yy1, xx2, yy2])
            return

        dct = dict()
        dfs()
        ans = [[0] * n for _ in range(n)]
        check()
        ac.st(dct[(0, 0, n - 1, n - 1)][-1])
        for a in ans:
            ac.st("".join(str(x) for x in a))
        return

    @staticmethod
    def lc_2556(grid: List[List[int]]) -> bool:
        """
        url: https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/description/
        tag: matrix_dp|brain_teaser
        """
        # matrix_dpbrain_teaser|，判断cut_point可行性
        m, n = len(grid), len(grid[0])

        left = [[0] * n for _ in range(m)]
        left[0][0] = 1
        for i in range(m):
            for j in range(n):
                if i == j == 0 or grid[i][j] == 0:
                    continue
                if i - 1 >= 0 and left[i - 1][j]:
                    left[i][j] = 1
                if j - 1 >= 0 and left[i][j - 1]:
                    left[i][j] = 1
        if left[-1][-1] == 0:
            return True

        right = [[0] * n for _ in range(m)]
        right[-1][-1] = 1
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if (i == m - 1 and j == n - 1) or grid[i][j] == 0:
                    continue
                if i + 1 < m and right[i + 1][j]:
                    right[i][j] = 1
                if j + 1 < n and right[i][j + 1]:
                    right[i][j] = 1
        if right[0][0] == 0:
            return True

        dct = defaultdict(int)
        for i in range(m):
            for j in range(n):
                if (i == m - 1 and j == n - 1) or (i == 0 and j == 0):
                    continue
                if left[i][j] and right[i][j]:
                    dct[i + j] += 1
        return True if dct and min(dct.values()) == 1 else False

    @staticmethod
    def lc_2617_1(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/
        tag: reverse_order|matrix_dp|tree_array|prefix_min
        """
        # reverse_order|matrix_dp| 并tree_array|记录更新前缀最小值
        m, n = len(grid), len(grid[0])
        dp = [[math.inf] * n for _ in range(m)]
        dp[-1][-1] = 1
        row = [PointDescendPreMin(n) for _ in range(m)]
        col = [PointDescendPreMin(m) for _ in range(n)]
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if i == m - 1 and j == n - 1:
                    row[i].point_descend(n, 1)
                    col[j].point_descend(m, 1)
                    continue
                right = grid[i][j] + j + 1 if grid[i][j] + j + 1 < n else n
                val1 = row[i].pre_min(right)

                down = grid[i][j] + i + 1 if grid[i][j] + i + 1 < m else m
                val2 = col[j].pre_min(down)
                dp[i][j] = val1 + 1 if val1 < val2 else val2 + 1
                row[i].point_descend(j + 1, dp[i][j])
                col[j].point_descend(i + 1, dp[i][j])
        return dp[0][0] if dp[0][0] < math.inf else -1

    @staticmethod
    def lc_2617_2(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/
        tag: reverse_order|matrix_dp|tree_array|prefix_min
        """
        # matrix_dp| priority_queue或者monotonic_queue
        m, n = len(grid), len(grid[0])
        dp = [[math.inf] * n for _ in range(m)]
        dp[0][0] = 1
        row = [[] for _ in range(m)]
        col = [[] for _ in range(n)]
        heapq.heappush(row[0], [1, grid[0][0]])
        heapq.heappush(col[0], [1, grid[0][0]])
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    continue
                while row[i] and row[i][0][1] < j:
                    heapq.heappop(row[i])
                while col[j] and col[j][0][1] < i:
                    heapq.heappop(col[j])
                val = math.inf if not row[i] else row[i][0][0]
                val = val if not col[j] or col[j][0][0] > val else col[j][0][0]
                dp[i][j] = val + 1
                heapq.heappush(row[i], [val + 1, grid[i][j] + j])
                heapq.heappush(col[j], [val + 1, grid[i][j] + i])
        return dp[-1][-1] if dp[-1][-1] < math.inf else -1

    @staticmethod
    def lc_2617_3(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/
        tag: reverse_order|matrix_dp|tree_array|prefix_min
        """
        # matrix_dp|  bfs |union_find的方式
        m, n = len(grid), len(grid[0])
        row = [list(range(1, n + 1)) for _ in range(m)]
        col = [list(range(1, m + 1)) for _ in range(n)]
        dp = [[math.inf] * n for _ in range(m)]
        dp[0][0] = 1
        stack = deque([[0, 0]])
        while stack:
            i, j = stack.popleft()
            d = dp[i][j]
            if i == m - 1 and j == n - 1:
                return d
            val = grid[i][j]

            # union_find或者类似linked_list|合并
            lst = [j]
            # 查到下一个就可以移动到的未访问格子
            while lst[-1] <= j + val and lst[-1] < n:
                lst.append(row[i][lst[-1]])
            last = lst[-1]
            for x in lst[1:-1]:
                if dp[i][x] == math.inf:
                    dp[i][x] = d + 1
                    stack.append([i, x])
                row[i][x] = last
            row[i][j] = last

            # union_find或者类似linked_list|合并
            lst = [i]
            while lst[-1] <= i + val and lst[-1] < m:
                lst.append(col[j][lst[-1]])
            last = lst[-1]
            for x in lst[1:-1]:
                if dp[x][j] == math.inf:
                    dp[x][j] = d + 1
                    stack.append([x, j])
                col[j][x] = last
            col[j][i] = last

        return -1

    @staticmethod
    def lg_p6509(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6509
        tag: classical|matrix_dp|specific_plan
        """
        # classicalmatrix_dp| 并记录对应的状态转移
        s = ac.read_str().split("=")
        b = int(s[1])
        s = s[0]
        n = len(s)
        dp = [[math.inf] * (b + 1) for _ in range(n + 1)]
        dp[0][0] = -1
        pre = [0] * n
        ind = 0
        for i in range(n):
            pre[i] = ind
            if s[i] != "0":
                ind = i
        change = [[[-1, -1] for _ in range(b + 1)] for _ in range(n + 1)]
        for i in range(n):
            j = -1
            for j in range(i, max(-1, i - 5), -1):
                val = int(s[j:i + 1])
                for x in range(b + 1 - val):
                    if dp[j][x] + 1 < dp[i + 1][x + val]:
                        dp[i + 1][x + val] = dp[j][x] + 1
                        change[i + 1][x + val] = [j, x]
            if pre[j] < i - 5:
                j = pre[j] + 1
                val = int(s[j: i + 1])
                for x in range(b + 1 - val):
                    if dp[j][x] + 1 < dp[i + 1][x + val]:
                        dp[i + 1][x + val] = dp[j][x] + 1
                        change[i + 1][x + val] = [j, x]
        ans = list(s)
        x, val = n, b
        while [x, val] != [0, 0]:
            x, val = change[x][val]
            if x:
                ans[x] = "+" + ans[x]
        ac.st("".join(ans) + "=" + str(b))
        return

    @staticmethod
    def lg_p6870(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6870
        tag: matrix_dp|comb|counter|classical|inclusion_exclusion
        """

        n = ac.read_int()  # TLE
        mod = 10 ** 9 + 7
        cb = Combinatorics(n, mod)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(1, n + 1):
            for j in range(n + 1):
                for k in range(n + 1 - j):
                    if k == i:
                        continue
                    dp[i][j + k] += dp[i - 1][j] * cb.comb(j + k, k)
                    dp[i][j + k] %= mod

        ans = pow(n, n, mod)
        ac.st((ans - dp[n][n]) % mod)
        return

    @staticmethod
    def ac_4418(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4421/
        tag: monotonic_queue|matrix_dp
        """
        # monotonic_queuematrix_dp
        n, k, x = ac.read_list_ints()
        nums = ac.read_list_ints()
        # dp[i][j]表示选第i个元素，且选了j个元素的最大和
        dp = [[-math.inf] * (x + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        stack = [deque() for _ in range(x + 1)]
        stack[0].append((0, 0))
        for i in range(1, n + 1):
            for j in range(x, 0, -1):
                while stack[j - 1] and stack[j - 1][0][0] < i - k:
                    stack[j - 1].popleft()
                if stack[j - 1]:
                    dp[i][j] = stack[j - 1][0][1] + nums[i - 1]
                while stack[j] and stack[j][-1][1] <= dp[i][j]:
                    stack[j].pop()
                stack[j].append((i, dp[i][j]))

        ans = max(dp[i][x] for i in range(n - k + 1, n + 1))
        ac.st(ans if ans > -math.inf else -1)
        return

    @staticmethod
    def lc_1216(s: str, k: int) -> bool:
        """
        url: https://leetcode.cn/problems/valid-palindrome-iii/
        tag: matrix_dp|longest_palindrome_subsequence
        """
        # DP求最长回文子序列
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            if i + 1 < n:
                dp[i][i + 1] = 2 if s[i] == s[i + 1] else 1
            for j in range(i + 2, n):
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                a, b = dp[i + 1][j], dp[i][j - 1]
                a = a if a > b else b
                if a > dp[i][j]:
                    dp[i][j] = a
        return n - dp[0][n - 1] <= k

    @staticmethod
    def lg_p7995(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7995
        tag: matrix_dp
        """
        # matrix_dp|
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            k += 1
            grid = [ac.read_str() for _ in range(n)]
            dp = [[[[0, 0, 0] for _ in range(k + 1)] for _ in range(n)] for _ in range(n)]
            dp[0][0][0] = [1, 0, 0]
            for i in range(n):
                for j in range(n):
                    if grid[i][j] == "H":
                        continue
                    if i:
                        d = 1
                        for x in range(k + 1):
                            for y in range(3):
                                kk = x + int(y != d)
                                if kk <= k:
                                    dp[i][j][kk][d] += dp[i - 1][j][x][y]
                    if j:
                        d = 2
                        for x in range(k + 1):
                            for y in range(3):
                                kk = x + int(y != d)
                                if kk <= k:
                                    dp[i][j][kk][d] += dp[i][j - 1][x][y]
            ans = 0
            for x in range(k + 1):
                ans += sum(dp[-1][-1][x])
            ac.st(ans)

        return

    @staticmethod
    def lg_p8325(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8325
        tag: brute_force|matrix_dp|maximum_square
        """
        # 动态规划brute_force，类似最大正方形matrix_dp| 变形
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]

        up = [[0] * n for _ in range(m)]
        for i in range(1, m):
            pre = [-1] * n
            post = [-1] * n
            ind = -1
            for j in range(n):
                pre[j] = ind
                if grid[i][j] == "#":
                    ind = j

            ind = -1
            for j in range(n - 1, -1, -1):
                post[j] = ind
                if grid[i][j] == "#":
                    ind = j

            for j in range(n):
                if grid[i][j] == "." and pre[j] != -1 and post[j] != -1:
                    left = j - pre[j]
                    right = post[j] - j
                    if left == right > 1 and up[i - 1][j] == right - 1:
                        up[i][j] = right
                    if left == right == 1 and grid[i - 1][j] == "#":
                        up[i][j] = 1
        ans = 0
        down = [[0] * n for _ in range(m)]
        for i in range(m - 2, -1, -1):
            pre = [-1] * n
            post = [-1] * n
            ind = -1
            for j in range(n):
                pre[j] = ind
                if grid[i][j] == "#":
                    ind = j

            ind = -1
            for j in range(n - 1, -1, -1):
                post[j] = ind
                if grid[i][j] == "#":
                    ind = j

            for j in range(n):
                if grid[i][j] == "." and pre[j] != -1 and post[j] != -1:
                    left = j - pre[j]
                    right = post[j] - j
                    if left == right > 1 and down[i + 1][j] == right - 1 and right >= 2:
                        down[i][j] = right
                    if left == right == 1 and grid[i + 1][j] == "#":
                        down[i][j] = 1
                if up[i][j] == down[i][j] > 0:
                    ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p8614(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8614
        tag: matrix_dp|mod
        """
        # matrix_dp| 关键在于mod|作为一维状态
        n, s, a, b = ac.read_list_ints()
        mod = 100000007
        dp = [[0] * n for _ in range(n)]
        pre = 0
        dp[pre][0] = 1
        for i in range(1, n):
            cur = 1 - pre
            for j in range(n):
                dp[cur][j] = dp[pre][(j - i * a) % n] + dp[pre][(j + i * b) % n]
                dp[cur][j] %= mod
            pre = cur
        ac.st(dp[pre][s % n])
        return

    @staticmethod
    def lg_p8638(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8638
        tag: matrix_dp|longest_palindrome_sequence
        """
        # matrix_dp| 最长回文子序列
        s = ac.read_str()
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, n):
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
                if s[i] == s[j] and dp[i + 1][j - 1] + 2 > dp[i][j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
        ac.st(n - dp[0][n - 1])
        return

    @staticmethod
    def lg_p8786(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8786
        tag: classical|md_matrix_dp| implemention|memory_search
        """

        # classical三维matrix_dp| implementionmemory_search

        @lru_cache(None)
        def dfs(x, y, wine):
            if x == 0:
                return 1 if y == wine else 0
            if y == 0 or wine < 0:
                return 0

            res = 0
            if wine * 2 <= y:
                res += dfs(x - 1, y, wine * 2)
            if wine:
                res += dfs(x, y - 1, wine - 1)
            return res % mod

        mod = 10 ** 9 + 7
        n, m = ac.read_list_ints()
        ans = dfs(n, m, 2)
        ac.st(ans)
        return

    @staticmethod
    def lc_2088(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/count-fertile-pyramids-in-a-land/
        tag: matrix_dp
        """

        # 类似求正方形的边长和面积matrix_dp
        def check():
            nonlocal ans
            dp = [[0] * n for _ in range(m)]
            for i in range(m):
                for j in range(n):
                    if grid[i][j]:
                        pre = []
                        for x, y in [[i - 1, j - 1], [i - 1, j], [i - 1, j + 1]]:
                            if 0 <= x < m and 0 <= y < n:
                                pre.append(dp[x][y])
                            else:
                                pre.append(0)
                        dp[i][j] = min(pre) + 1
                        ans += dp[i][j] - 1
            return

        m, n = len(grid), len(grid[0])
        ans = 0
        check()
        grid = grid[::-1]
        check()
        return ans

    @staticmethod
    def lc_2430(s: str) -> int:
        """
        url: https://leetcode.cn/problems/maximum-deletions-on-a-string/
        tag: lcp|matrix_dp
        """
        # 双重DPLCP与matrix_dp
        n = len(s)
        lcp = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    lcp[i][j] = lcp[i + 1][j + 1] + 1

        dp = [1] * (n + 1)
        for i in range(n - 1, -1, -1):
            for j in range(1, (n - i) // 2 + 1):
                if lcp[i][i + j] >= j:
                    dp[i] = dp[i] if dp[i] > dp[i + j] + 1 else dp[i + j] + 1
        return dp[0]

    @staticmethod
    def ac_4378(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4381/
        tag: classical|matrix_dp
        """
        # classicalmatrix_dp
        n, m, k = ac.read_list_ints()
        dp = [[-math.inf] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        nums = ac.read_list_ints()
        pre = ac.accumulate(nums)
        if m == 1:
            nums.sort()
            ac.st(sum(nums[-k:]))
            return
        for i in range(n):
            dp[i + 1][0] = 0
            if i >= m - 1:
                for j in range(1, k + 1):
                    a, b = dp[i][j], dp[i - m + 1][j - 1] + \
                                     pre[i + 1] - pre[i - m + 1]
                    dp[i + 1][j] = a if a > b else b
        ac.st(dp[n][k])
        return

    @staticmethod
    def abc_130e(ac=FastIO()):
        # matrix_prefix_sum|优化matrix_dp
        m, n = ac.read_list_ints()
        mod = 10 ** 9 + 7
        s = ac.read_list_ints()
        t = ac.read_list_ints()
        dp = [[0] * n for _ in range(m)]
        pre = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m):
            for j in range(n):
                if s[i] == t[j]:
                    dp[i][j] = (pre[i][j] + 1) % mod
            for j in range(n):
                pre[i + 1][j + 1] = (pre[i + 1][j] + pre[i][j + 1] - pre[i][j] + dp[i][j]) % mod
        ans = sum(sum(d) for d in dp) + 1
        ac.st(ans % mod)
        return

    @staticmethod
    def ac_2694(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/2696/
        tag: lcs|matrix_dp|counter
        """
        # 问题求解最长公共子序列LCS的长度与个数
        a = ac.read_str()[:-1]
        b = ac.read_str()[:-1]
        mod = 10 ** 8

        # 滚动数组优化
        m, n = len(a), len(b)
        dp = [[0] * (n + 1) for _ in range(2)]
        cnt = [[0] * (n + 1) for _ in range(2)]
        t = 0
        for i in range(n + 1):
            cnt[0][i] = 1
        cnt[1][0] = 1

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                cnt[t ^ 1][j] = 0
                if a[i - 1] == b[j - 1]:
                    dp[t ^ 1][j] = dp[t][j - 1] + 1
                    cnt[t ^ 1][j] += cnt[t][j - 1]
                else:
                    dp[t ^ 1][j] = max(dp[t][j], dp[t ^ 1][j - 1])
                # 注意个数去重
                if dp[t ^ 1][j] == dp[t ^ 1][j - 1]:
                    cnt[t ^ 1][j] += cnt[t ^ 1][j - 1]
                if dp[t ^ 1][j] == dp[t][j]:
                    cnt[t ^ 1][j] += cnt[t][j]
                if a[i - 1] != b[j - 1] and dp[t ^ 1][j] == dp[t][j - 1]:
                    cnt[t ^ 1][j] -= cnt[t][j - 1]
                cnt[t ^ 1][j] %= mod
            t ^= 1

        ac.st(dp[t][n])
        ac.st((cnt[t][n] + mod) % mod)
        return

    @staticmethod
    def lc_1594(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/
        tag: matrix_dp|maximum_mul|minimum_mul
        """
        # matrix_dp最大与最小乘积转移
        m, n = len(grid), len(grid[0])

        @lru_cache(None)
        def dfs(i, j):
            if i == m - 1 and j == n - 1:
                return [grid[i][j], grid[i][j]]
            low = math.inf
            high = -math.inf
            x = grid[i][j]
            for a, b in [[i + 1, j], [i, j + 1]]:
                if a < m and j < n:
                    res = dfs(a, b)
                    for w in res:
                        low = min(low, w * x)
                        high = max(high, w * x)
            return [low, high]

        ans = dfs(0, 0)[1]
        if ans < 0:
            return -1
        return ans % (10 ** 9 + 7)

    @staticmethod
    def lc_1639(words: List[str], target: str) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/
        tag: prefix_sum|matrix_dp
        """
        # prefix_sum优化matrix_dp|
        dct = defaultdict(lambda: defaultdict(int))
        n = len(words[0])
        for word in words:
            for i, w in enumerate(word):
                dct[w][i] += 1

        m = len(target)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        mod = 10 ** 9 + 7
        for i in range(m):
            dp[i + 1][0] = 0
            pre = dp[i][0]
            for j in range(n):
                c = dct[target[i]][j]
                dp[i + 1][j + 1] = (pre * c) % mod
                pre += dp[i][j + 1]
        return sum(dp[-1]) % mod

    @staticmethod
    def lc_1745(s: str) -> bool:
        """
        url: https://leetcode.cn/problems/palindrome-partitioning-iv/description/
        tag: matrix_dp|palindrome_substring|manacher|brute_force
        """
        # matrix_dp判断是否为palindrome_substring，或者manacher然后brute_force
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            if i + 1 < n:
                dp[i][i + 1] = int(s[i] == s[i + 1])
            for j in range(i + 2, n):
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = 1

        for i in range(1, n - 1):
            for j in range(i, n - 1):
                if dp[i][j] and dp[0][i - 1] and dp[j + 1][n - 1]:
                    return True
        return False

    @staticmethod
    def lc_1771(word1: str, word2: str) -> int:
        """
        url: https://leetcode.cn/problems/maximize-palindrome-length-from-subsequences/
        tag: longest_palindrome_subsequence|matrix_dp
        """
        # 最长回文子序列matrix_dp
        m, n = len(word1), len(word2)
        s = word1 + word2
        ans = 0
        dp = [[0] * (m + n) for _ in range(m + n)]
        for i in range(m + n - 1, -1, -1):
            dp[i][i] = 1
            if i + 1 < m + n:
                dp[i][i + 1] = 2 if s[i] == s[i + 1] else 1
            for j in range(i + 2, m + n):
                a, b = dp[i + 1][j], dp[i][j - 1]
                dp[i][j] = a if a > b else b
                if s[i] == s[j]:
                    a, b = dp[i][j], dp[i + 1][j - 1] + 2
                    dp[i][j] = a if a > b else b
        for i in range(m):
            for j in range(m + n - 1, m - 1, -1):
                if s[i] == s[j]:
                    a, b = ans, dp[i + 1][j - 1] + 2
                    ans = a if a > b else b
                    break
        return ans

    @staticmethod
    def lc_1937(points: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-points-with-cost/
        tag: prefix_sum|matrix_dp
        """
        # 矩阵prefix_sum后缀和优化的DP
        m, n = len(points), len(points[0])
        pre = points[0][:]

        for i in range(1, m):
            left = [0] * n
            for j in range(n):
                a = -math.inf if not j else left[j - 1]
                b = pre[j] + j
                left[j] = a if a > b else b

            right = [0] * n
            for j in range(n - 1, -1, -1):
                a = -math.inf if j == n - 1 else right[j + 1]
                b = pre[j] - j
                right[j] = a if a > b else b

            for j in range(n):
                a = left[j] - j + points[i][j]
                b = right[j] + j + points[i][j]
                pre[j] = a if a > b else b

        return max(pre)

    @staticmethod
    def lc_1977(num: str) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-separate-numbers/
        tag: matrix_dp|lcp|prefix_sum
        """
        # 两个matrix_dp含LCP优化，或者前缀优化DP
        mod = 10 ** 9 + 7
        n = len(num)
        lcp = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n - 1, -1, -1):
            lcp[i][i] = n - i
            for j in range(i + 1, n):
                lcp[i][j] = 0 if num[i] != num[j] else lcp[i + 1][j + 1] + 1

        # 以索引 i 结尾且末尾数字长为 j 的specific_plan数
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0] = [1] * (n + 1)  # 边界条件prefix_sum
        for i in range(1, n + 1):
            # i 从 1 到 n 表示
            for j in range(1, i + 1):
                if num[i - j] == "0":  # 只能是没有前导零的正整数
                    continue
                if i - 2 * j >= 0:
                    x = lcp[i - 2 * j][i - j]
                    if x >= j or num[i - 2 * j + x] <= num[i - j + x]:
                        dp[i][j] = dp[i - j][j]  # 只有这时才满足 num[i-2*j:i-j] <= num[i-j:i]
                    else:
                        dp[i][j] = dp[i - j][j - 1]
                else:
                    dp[i][j] = dp[i - j][j - 1]
            for j in range(1, n + 1):
                # prefix_sum优化
                dp[i][j] += dp[i][j - 1]
                dp[i][j] %= mod
        return dp[n][n]

    @staticmethod
    def lc_2060(s1: str, s2: str) -> bool:
        """
        url: https://leetcode.cn/problems/check-if-an-original-string-exists-given-two-encoded-strings/description/
        tag: matrix_dp|brute_force|memory_search
        """

        # 二维matrix_dpbrute_forcememory_search

        def check(st):
            if len(st) == 1:
                return [int(st)]
            if len(st) == 2:
                return [int(st), int(st[0]) + int(st[1])]
            return [int(st), int(st[:2]) + int(st[2]), int(st[0]) + int(st[1:]), int(st[0]) + int(st[1]) + int(st[2])]

        def depart(s):
            k = len(s)
            i = 0
            res = []
            while i < k:
                if s[i].isnumeric():
                    cur = ""
                    while i < k and s[i].isnumeric():
                        cur += s[i]
                        i += 1
                    res.append([str(x) for x in check(cur)])
                else:
                    res.append([s[i]])
                    i += 1
            post = []
            for ls in res:
                post.append(max(int(w) if w.isnumeric() else 1 for w in ls))
            return res, list(accumulate(post, initial=0))

        lst1, pre1 = depart(s1)
        lst2, pre2 = depart(s2)
        m, n = len(lst1), len(lst2)

        @lru_cache(None)
        def dfs(i, j, x):
            if pre2[-1] - pre2[j] < x:
                return False
            if pre1[-1] - pre1[i] < -x:
                return False

            if x == 0:
                if i == m and j == n:
                    return True
                if i == m or j == n:
                    return False
                for a in lst1[i]:
                    for b in lst2[j]:
                        if a.isnumeric() and b.isnumeric():
                            if dfs(i + 1, j + 1, int(a) - int(b)):
                                return True
                        elif not a.isnumeric() and not b.isnumeric():
                            if a == b and dfs(i + 1, j + 1, 0):
                                return True
                        elif a.isnumeric() and not b.isnumeric():
                            if dfs(i + 1, j + 1, int(a) - 1):
                                return True
                        else:
                            if dfs(i + 1, j + 1, 1 - int(b)):
                                return True
                return False

            elif x > 0:
                if j == n:
                    return False
                for b in lst2[j]:
                    if b.isnumeric() and dfs(i, j + 1, x - int(b)):
                        return True
                    if not b.isnumeric() and dfs(i, j + 1, x - 1):
                        return True
            else:
                if i == m:
                    return False
                for a in lst1[i]:
                    if a.isnumeric() and dfs(i + 1, j, x + int(a)):
                        return True
                    if not a.isnumeric() and dfs(i + 1, j, x + 1):
                        return True
            return False

        return dfs(0, 0, 0)

    @staticmethod
    def cf_1003f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1003/problem/F
        tag: con_lcp|matrix_dp|string_hash|brute_force
        """
        n = ac.read_int()
        words = ac.read_list_strs()
        lst = [len(w) for w in words]
        eq = [0] * n * n
        for i in range(n):
            eq[i * n + i] = 1
            for j in range(i + 1, n):
                if words[i] == words[j]:
                    eq[i * n + j] = eq[j * n + i] = 1

        dp = [0] * (n + 1) * (n + 1)
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if eq[i * n + j]:
                    dp[i * (n + 1) + j] = dp[(i + 1) * (n + 1) + j + 1] + 1

        ans = sum(len(word) for word in words) + n - 1
        for i in range(n):
            for j in range(i, n):
                x = cnt = 0
                cur = -1
                length = j - i + 1
                while x < n:
                    if dp[i * (n + 1) + x] >= length:
                        cur += 1 + length
                        x += length
                        cnt += 1
                    else:
                        cur += 1 + lst[x]
                        x += 1
                if cnt > 1:
                    ans = min(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def lc_2809(nums1: List[int], nums2: List[int], x: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-make-array-sum-at-most-x/
        tag: matrix_dp|greedy|implemention
        """
        n = len(nums2)
        ind = list(range(n))
        ind.sort(key=lambda it: nums2[it])

        dp = [[0] * (n + 1) for _ in range(2)]
        pre = 0
        for i in range(n):
            cur = 1 - pre
            for j in range(1, i + 2):
                dp[cur][j] = max(dp[pre][j], dp[pre][j - 1] + nums2[ind[i]] * j + nums1[ind[i]])
            pre = cur
        s1 = sum(nums1)
        s2 = sum(nums2)
        for j in range(n + 1):
            if s1 + s2 * j - dp[pre][j] <= x:
                return j
        return -1

    @staticmethod
    def cf_835d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/835/D
        tag: palindrome|matrix_dp
        """
        s = ac.read_str()
        n = len(s)
        dp = [[0] * n for _ in range(2)]
        ans = [0] * (n + 1)
        pre = 0
        for i in range(n - 1, -1, -1):
            cur = 1 - pre
            for j in range(n):
                dp[cur][j] = 0
            dp[cur][i] = 1
            ans[1] += 1
            if i + 1 < n and s[i] == s[i + 1]:
                dp[cur][i + 1] = 2
                ans[2] += 1
            for j in range(i + 2, n):
                if not dp[pre][j - 1] or s[i] != s[j]:
                    continue
                dp[cur][j] = dp[cur][i + (j - i + 1) // 2 - 1] + 1
                ans[dp[cur][j]] += 1
            pre = cur
        for i in range(n - 1, -1, -1):
            ans[i] += ans[i + 1]
        ac.lst(ans[1:])
        return

    @staticmethod
    def cf_1829g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1829/problem/G
        tag: matrix_dp|classical|inclusion_exclusion
        """
        n = 10 ** 6
        dp = [0] * (n + 1)
        pre = [1]
        dp[1] = 1
        x = 2
        father = [[] for _ in range(n + 1)]
        while x <= n:
            cur = list(range(x, x + len(pre) + 1))
            m = len(cur)
            for i in range(m):
                if cur[i] > n:
                    break
                lst = []
                if i:
                    lst.append(pre[i - 1])
                if i < m - 1:
                    lst.append(pre[i])
                father[cur[i]] = lst
                s = sum(dp[y] for y in lst)
                if len(lst) == 2:
                    lst1 = father[lst[0]]
                    lst2 = father[lst[1]]
                    for x1 in lst1:
                        if x1 in lst2:
                            s -= dp[x1]
                dp[cur[i]] = s + cur[i] ** 2
            x += len(pre) + 1
            pre = cur
        for _ in range(ac.read_int()):
            ac.st(dp[ac.read_int()])
        return

    @staticmethod
    def cf_1183h(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1183/problem/H
        tag: matrix_dp|classical|hard|different_sub_sequence
        """
        n, k = ac.read_list_ints()
        s = ac.read_str()
        pre = [-1] * n
        last = [-1] * 26
        for i in range(n):
            w = s[i]
            x = ord(w) - ord("a")
            pre[i] = last[x]
            last[x] = i

        dp = [[0] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(n):
            dp[i + 1][0] = dp[i][0]
            for j in range(1, i + 2):
                dp[i + 1][j] = dp[i][j] + dp[i][j - 1]
                if pre[i] != -1:
                    dp[i + 1][j] -= dp[pre[i]][j - 1]
        ans = 0
        for j in range(n, -1, -1):
            x = min(k, dp[n][j])
            ans += x * (n - j)
            k -= x
        ac.st(ans if not k else -1)
        return

    @staticmethod
    def cf_1353f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1353/problem/F
        tag: matrix_dp|greedy|monotonic_stack
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_list_ints() for _ in range(m)]
            dp = [[] for _ in range(n)]
            tot = m + n - 1
            for i in range(m - 1, -1, -1):
                ndp = [[] for _ in range(n)]
                for j in range(n - 1, -1, -1):
                    if i == m - 1 and j == n - 1:
                        ndp[j] = [(grid[i][j], grid[i][j])]
                        continue
                    lst = []
                    if i + 1 < m:
                        for s, p in dp[j]:
                            cur_s = s + grid[i][j]
                            cur_p = min(p - 1, grid[i][j])
                            lst.append((cur_s, cur_p))
                    if j + 1 < n:
                        for s, p in ndp[j + 1]:
                            cur_s = s + grid[i][j]
                            cur_p = min(p - 1, grid[i][j])
                            lst.append((cur_s, cur_p))
                    lst.sort()
                    cur = []
                    for s, p in lst:
                        if not cur or cur[-1][-1] < p:
                            cur.append((s, p))
                    ndp[j] = cur
                dp = ndp
            ans = 10 ** 18
            for s, p in dp[0]:
                ans = min(ans, s - (p + p + tot - 1) * tot // 2)
            ac.st(ans)
        return

    @staticmethod
    def cf_1593f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1593/problem/F
        tag: matrix_dp|specific_plan|md_vector|flatten
        """

        def get(iii, jjj, ppp, qqq):
            return iii * a * b * (n + 1) + jjj * a * (n + 1) + ppp * (n + 1) + qqq

        for _ in range(ac.read_int()):
            n, a, b = ac.read_list_ints()
            lst = [int(w) for w in ac.read_str()]
            dp = [0] * (n + 1) * a * b * (n + 1)
            dp[get(0, 0, 0, 0)] = 1
            nex_a = [[0] * 10 for _ in range(a)]
            for i in range(a):
                for j in range(10):
                    nex_a[i][j] = (i * 10 + j) % a
            nex_b = [[0] * 10 for _ in range(b)]
            for i in range(b):
                for j in range(10):
                    nex_b[i][j] = (i * 10 + j) % b

            for i in range(n):
                x = lst[i]
                for j in range(b):
                    for p in range(a):
                        for q in range(n + 1):
                            if dp[get(i, j, p, q)]:
                                dp[get(i + 1, j, nex_a[p][x], q + 1)] = 1
                                dp[get(i + 1, nex_b[j][x], p, q)] = 1
            ans = math.inf
            qq = -1
            for i in range(1, n):
                if dp[get(n, 0, 0, i)]:
                    if abs(n - 2 * i) < ans:
                        ans = abs(n - 2 * i)
                        qq = i
            if ans == math.inf:
                ac.st(-1)
                continue

            ans = []
            jj = pp = 0
            for i in range(n - 1, -1, -1):
                flag = 0
                x = lst[i]
                for j in range(b):
                    if flag:
                        break
                    for p in range(a):
                        if flag:
                            break
                        for q in range(n + 1):
                            if dp[get(i, j, p, q)]:
                                if (nex_b[j][x], p, q) == (jj, pp, qq):
                                    ans.append("B")
                                    jj, pp, qq = j, p, q
                                    flag = 1
                                    break
                                if (j, nex_a[p][x], q + 1) == (jj, pp, qq):
                                    ans.append("R")
                                    jj, pp, qq = j, p, q
                                    flag = 1
                                    break

            ans.reverse()
            ac.st("".join(ans))
        return

    @staticmethod
    def abc_325f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc325/tasks/abc325_f
        tag: matrix_dp|brute_force|classical
        """
        n = ac.read_int()
        dis = ac.read_list_ints()
        l1, c1, k1 = ac.read_list_ints()
        l2, c2, k2 = ac.read_list_ints()
        dp = [0] * (k1 + 1)
        for i in range(n):
            d = dis[i]
            ndp = [math.inf] * (k1 + 1)
            for j in range(k1 + 1):
                if dp[j] < math.inf:
                    for x in range(k1 - j + 1):
                        need = max(0, math.ceil((d - x * l1) / l2))
                        ndp[j + x] = min(ndp[j + x], dp[j] + need)
            dp = ndp
        ans = math.inf
        for i in range(k1 + 1):
            if dp[i] <= k2:
                ans = min(ans, i * c1 + dp[i] * c2)
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc344f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc344/tasks/abc344_f
        tag: matrix_dp|greedy|brain_teaser|classical
        """
        n = ac.read_int()
        pp = [ac.read_list_ints() for _ in range(n)]
        rr = [ac.read_list_ints() for _ in range(n)]
        dd = [ac.read_list_ints() for _ in range(n - 1)]

        dp = [defaultdict(lambda: (math.inf, math.inf)) for _ in range(n)]
        for i in range(n):
            ndp = [defaultdict(lambda: (math.inf, math.inf)) for _ in range(n)]
            for j in range(n):
                if i == j == 0:
                    ndp[0][pp[0][0]] = (0, 0)
                    dp[0][pp[0][0]] = (0, 0)
                    continue
                cur = defaultdict(lambda: (math.inf, math.inf))
                if i - 1 >= 0:
                    for ceil in dp[j]:
                        step, money = dp[j][ceil]
                        money = -money
                        need = dd[i - 1][j]
                        if need > money:
                            cost = (need - money + ceil - 1) // ceil
                        else:
                            cost = 0
                        cur[max(ceil, pp[i][j])] = min(cur[max(ceil, pp[i][j])],
                                                       (step + cost + 1, -(money + cost * ceil - need)))
                if j - 1 >= 0:
                    for ceil in ndp[j - 1]:
                        step, money = ndp[j - 1][ceil]
                        money = -money
                        need = rr[i][j - 1]
                        if need > money:
                            cost = (need - money + ceil - 1) // ceil
                        else:
                            cost = 0
                        cur[max(ceil, pp[i][j])] = min(cur[max(ceil, pp[i][j])],
                                                       (step + cost + 1, -(money + cost * ceil - need)))
                ndp[j] = cur
            dp = ndp
        ans = math.inf
        for ceil in dp[-1]:
            step, money = dp[-1][ceil]
            ans = min(ans, step)
        ac.st(ans)
        return

    @staticmethod
    def abc_311f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc311/tasks/abc311_f
        tag: matrix_dp|prefix_sum_opt|classical|brain_teaser
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        mod = 998244353

        dp = [0] * (m + 1)
        dp[0] = 1
        for j in range(n):
            ndp = [0] * (m + 1)
            pre = ac.accumulate(dp)
            for i in range(m):
                ndp[m - i] = pre[min(m + 1, m - i + 2)]
                if grid[i][j] == "#":
                    break
            else:
                ndp[0] += pre[2]
            dp = [x % mod for x in ndp]
        ac.st(sum(dp) % mod)
        return

    @staticmethod
    def abc_265e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc265/tasks/abc265_e
        tag: matrix_dp|brain_teaser|classical
        """
        mod = 998244353
        n, m = ac.read_list_ints()
        a, b, c, d, e, f = ac.read_list_ints()
        lst = [(a, b), (c, d), (e, f)]
        obs = [ac.read_list_ints() for _ in range(m)]
        obs = set((x, y) for x, y in obs)
        dp = [0] * (n + 1) * (n + 1)
        dp[0] = 1
        for i in range(1, n + 1):
            ndp = [0] * (n + 1) * (n + 1)
            for p in range(i):
                for q in range(i - p):
                    r = i - 1 - p - q
                    aa = p * a + q * c + r * e
                    bb = p * b + q * d + r * f
                    x, y = lst[0]
                    if (x + aa, y + bb) not in obs:
                        ndp[(p + 1) * (n + 1) + q] = (ndp[(p + 1) * (n + 1) + q] + dp[p * (n + 1) + q]) % mod

                    x, y = lst[1]
                    if (x + aa, y + bb) not in obs:
                        ndp[p * (n + 1) + q + 1] = (ndp[p * (n + 1) + q + 1] + dp[p * (n + 1) + q]) % mod

                    x, y = lst[2]
                    if (x + aa, y + bb) not in obs:
                        ndp[p * (n + 1) + q] = (ndp[p * (n + 1) + q] + dp[p * (n + 1) + q]) % mod
            dp = ndp
        ac.st(sum(dp) % mod)
        return

    @staticmethod
    def abc_262d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc262/tasks/abc262_d
        tag: brute_force|matrix_dp|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = 998244353

        ans = 0
        dp = [[0] * n for _ in range(n + 1)]
        for m in range(1, n + 1):
            for i in range(m + 1):
                for j in range(m):
                    dp[i][j] = 0
            dp[0][0] = 1
            for num in nums:
                for j in range(m, 0, -1):
                    for x in range(m):
                        w = (x + num) % m
                        dp[j][w] += dp[(j - 1)][x]
                        dp[j][w] %= mod
            ans += dp[m][0]
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_253e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc253/tasks/abc253_e
        tag: prefix_sum|matrix_dp|inclusion_exclusion|reverse_thinking|classical
        """
        mod = 998244353
        n, m, k = ac.read_list_ints()
        dp = [0] + [1] * m
        for _ in range(1, n):
            pre = ac.accumulate(dp)
            for i in range(1, m + 1):
                low = max(i - (k - 1), 1)
                high = min(k - 1 + i, m)
                if low <= high:
                    dp[i] = (pre[-1] - (pre[high + 1] - pre[low])) % mod
                else:
                    dp[i] = pre[-1] % mod

        ac.st(sum(dp) % mod)
        return

    @staticmethod
    def lc_1883(dist: List[int], speed: int, hours: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/
        tag: matrix_dp|high_precision|bag_dp
        """
        n = len(dist)
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        s = speed
        for d in dist:
            for i in range(n, 0, -1):
                dp[i] = min(dp[i - 1] + d, s * ((dp[i] + s - 1) // s) + d)
            dp[0] = s * ((dp[0] + s - 1) // s) + d
        for i in range(n + 1):
            if dp[i] <= hours * s:
                return i
        return -1

    @staticmethod
    def abc_238f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc238/tasks/abc238_f
        tag: sort|greedy|matrix_dp|implemention|classical
        """
        n, k = ac.read_list_ints()
        p = ac.read_list_ints()
        q = ac.read_list_ints()
        ind = list(range(n))
        ind.sort(key=lambda it: -p[it])
        p = [p[i] for i in ind]
        q = [q[i] for i in ind]
        mod = 998244353

        dp = [[0] * (k + 2) for _ in range(n + 1)]
        for j in range(n + 1):
            dp[j][k] = 1
        for i in range(n - 1, -1, -1):
            ndp = [[0] * (k + 2) for _ in range(n + 1)]
            for j in range(n + 1):
                for x in range(k + 1):
                    if j > q[i]:
                        ndp[j][x] = dp[j][x + 1]
                    else:
                        res = dp[q[i]][x + 1]
                        res += dp[j][x]
                        ndp[j][x] = res % mod
            dp = [[x % mod for x in ls] for ls in ndp]
        ac.st(dp[0][0])
        return

    @staticmethod
    def abc_237f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc237/tasks/abc237_f
        tag: matrix_dp|lis|counter|brain_teaser|classical
        """
        n, m = ac.read_list_ints()
        mod = 998244353
        dp = [[[0] * (m + 1) for _ in range(m + 1)] for _ in range(m + 1)]
        dp[m][m][m] = 1
        for _ in range(n):
            ndp = [[[0] * (m + 1) for _ in range(m + 1)] for _ in range(m + 1)]
            for a in range(m + 1):
                for b in range(m + 1):
                    for c in range(m + 1):
                        for x in range(m):
                            if x <= a:
                                ndp[x][b][c] += dp[a][b][c]
                            elif x <= b:
                                ndp[a][x][c] += dp[a][b][c]
                            elif x <= c:
                                ndp[a][b][x] += dp[a][b][c]
            dp = [[[xx % mod for xx in x] for x in ls] for ls in ndp]
        ans = 0
        for a in range(m):
            for b in range(a + 1, m):
                for c in range(b + 1, m):
                    ans += dp[a][b][c]
        ac.st(ans % mod)
        return

    @staticmethod
    def abc_227f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc227/tasks/abc227_f
        tag: matrix_dp|bryte_force|brain_teaser
        """
        m, n, k = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        ans = math.inf
        nums = []
        for g in grid:
            nums.extend(g)
        for num in nums:
            dp = [[math.inf] * (k + 1) for _ in range(n)]
            dp[0][0] = 0
            for i in range(m):
                ndp = [[math.inf] * (k + 1) for _ in range(n)]
                for j in range(n):
                    for x in range(k + 1):
                        if x and grid[i][j] >= num:
                            ndp[j][x] = min(ndp[j][x], ndp[j - 1][x - 1] if j else math.inf, dp[j][x - 1]) + grid[i][j]
                        if grid[i][j] <= num:
                            ndp[j][x] = min(ndp[j][x], min(ndp[j - 1][x] if j else math.inf, dp[j][x]))
                dp = [ls[:] for ls in ndp]
            ans = min(ans, dp[-1][k])
        ac.st(ans)
        return

    @staticmethod
    def abc_217g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc217/tasks/abc217_g
        tag: comb|perm|counter|matrix_dp|comb_dp
        """
        n, m = ac.read_list_ints()
        mod = 998244353
        cb = Combinatorics(n + 10, mod)
        group = [0 for _ in range(m)]
        for x in range(1, n + 1):
            group[x % m] += 1
        dp = [0] * (n + 1)
        dp[0] = 1
        for x in group:
            if not x:
                continue
            ndp = [0] * (n + 1)
            for i in range(n + 1):
                if dp[i]:
                    for j in range(max(i, x), min(i + x + 1, n + 1)):
                        in_ = x - j + i
                        ndp[j] += dp[i] * cb.comb(i, in_) * cb.comb(x, in_) * cb.perm[in_]
                        ndp[j] %= mod
            dp = ndp[:]
        for x in range(1, n + 1):
            ac.st(dp[x])
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/MILKYDARK
        tag: matrix_dp|prefix_optimization|classical
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            pre_a = 0
            pre_b = 0
            dp = [math.inf] * (k + 1)
            dp[0] = 0
            low_a = [math.inf] * (k + 1)
            low_a[0] = 0
            low_b = [math.inf] * (k + 1)
            low_b[0] = 0
            for i in range(n):
                ndp = [math.inf] * (k + 1)
                pre_a += a[i]
                pre_b += b[i]
                for x in range(1, k + 1):
                    ndp[x] = min(pre_a + low_a[x - 1], pre_b + low_b[x - 1])
                for x in range(k + 1):
                    low_a[x] = min(low_a[x], ndp[x] - pre_a)
                    low_b[x] = min(low_b[x], ndp[x] - pre_b)
                dp = ndp[:]
            ans = dp[k]
            ac.st(ans)
        return

    @staticmethod
    def abc_212e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc212/tasks/abc212_e
        tag: graph|matrix_dp|inclusion_exclusion|classical
        """
        mod = 998244353
        n, m, k = ac.read_list_ints()

        edges = [ac.read_list_ints_minus_one() for _ in range(m)]

        dp = [1] + [0] * (n - 1)
        for _ in range(k):
            pre = sum(dp) % mod
            ndp = [pre - dp[i] for i in range(n)]
            for i, j in edges:
                ndp[j] -= dp[i]
                ndp[i] -= dp[j]
            dp = [x % mod for x in ndp]
        ac.st(dp[0])
        return

    @staticmethod
    def lc_100327(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-the-maximum-length-of-a-good-subsequence-ii/
        tag: matrix_dp|bag_dp|brain_teaser
        """
        pre = [defaultdict(int) for _ in range(k + 1)]
        dp = [0 for _ in range(k + 1)]
        for num in nums:
            for c in range(k, -1, -1):
                pre[c][num] += 1
                if c + 1 <= k:
                    pre[c + 1][num] = pre[c + 1][num] if pre[c + 1][num] > dp[c] + 1 else dp[c] + 1
                    dp[c + 1] = pre[c + 1][num] if pre[c + 1][num] > dp[c + 1] else dp[c + 1]
                dp[c] = pre[c][num] if pre[c][num] > dp[c] else dp[c]
        return max(dp)

    @staticmethod
    def abc_207e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc207/tasks/abc207_e
        tag: matrix_dp|prefix_sum
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = 10 ** 9 + 7
        p = ans = 0
        tot = [[0] * (n + 1) for _ in range(n + 1)]
        tot[0][0] = 1
        for i in range(n):
            p += nums[i]
            cur = [0] * (n + 1)
            for j in range(1, n + 1):
                cur[j] = tot[p % j][j - 1]
            for j in range(1, n + 1):
                tot[p % j][j - 1] += cur[j - 1]
                tot[p % j][j - 1] %= mod
            ans = sum(cur) % mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1132f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1132/F
        tag: matrix_dp|classical
        """
        n = ac.read_int()
        s = ac.read_str()
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, n):
                cur = dp[i + 1][j] + 1 if i + 1 < n else 1
                for k in range(i + 1, j + 1):
                    if s[k] == s[i]:
                        cur = min(cur, dp[i + 1][k - 1] + dp[k][j])
                dp[i][j] = cur
        ac.st(dp[0][n - 1])
        return

    @staticmethod
    def cf_1935c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1935/C
        tag: matrix_dp|greedy|sort
        """

        for _ in range(ac.read_int()):
            n, ll = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(n)]
            nums.sort(key=lambda it: it[1])

            pre = [math.inf for _ in range(n + 1)]
            pre[0] = 0
            dp = [math.inf] * (n + 1)
            dp[0] = [0] * (n + 1)
            ans = 0
            for i in range(n):
                a, b = nums[i]
                for j in range(i + 1, 0, -1):
                    cur = pre[j - 1] + b + a if j > 1 else a
                    if cur <= ll:
                        dp[j] = min(dp[j], cur)
                        ans = max(ans, j)
                        pre[j] = min(pre[j], cur - b)
            ac.st(ans)
        return

    @staticmethod
    def cf_1989b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1989/problem/B
        tag: continuous_lcs|dp|classical
        """

        for _ in range(ac.read_int()):
            a = ac.read_str()
            b = ac.read_str()
            m = len(a)
            n = len(b)
            dp = [0] * (n + 1)
            for i in range(m):
                for j in range(n - 1, -1, -1):
                    if a[i] == b[j]:
                        dp[j + 1] = max(dp[j + 1], dp[j] + 1)
            ans = m + n - max(dp)
            ac.st(ans)
        return

    @staticmethod
    def cf_1517d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1517/problem/D
        tag: implemention|brain_teaser|observation|even|matrix_dp|bfs
        """
        m, n, k = ac.read_list_ints()
        col = []
        for _ in range(m):
            col.extend(ac.read_list_ints() + [0])

        row = []
        for _ in range(m - 1):
            row.extend(ac.read_list_ints())
        row.extend([0] * n)

        if k % 2:
            for _ in range(m):
                ac.lst([-1] * n)
            return
        pre = [0] * m * n
        for _ in range(k // 2):
            cur = [math.inf] * m * n
            for x in range(m):
                for y in range(n):
                    if x:
                        cur[(x - 1) * n + y] = min(cur[(x - 1) * n + y], pre[x * n + y] + row[(x - 1) * n + y])
                    if x + 1 < m:
                        cur[(x + 1) * n + y] = min(cur[(x + 1) * n + y], pre[x * n + y] + row[x * n + y])
                    if y:
                        cur[x * n + y - 1] = min(cur[x * n + y - 1], pre[x * n + y] + col[x * n + y - 1])
                    if y + 1 < n:
                        cur[x * n + y + 1] = min(cur[x * n + y + 1], pre[x * n + y] + col[x * n + y])
            pre = cur[:]
        for i in range(m):
            ans = [pre[i * n + j] * 2 if pre[i * n + j] < math.inf else -1 for j in range(n)]
            ac.lst(ans)
        return

    @staticmethod
    def lc_100358(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-the-maximum-length-of-valid-subsequence-ii/
        tag: matrix_dp|implemention
        """
        ans = 0
        dp = [[0] * k for _ in range(k)]
        for num in nums:
            y = num % k
            for i in range(k):
                dp[i][y] = max(dp[i][y], dp[y][i] + 1)

        for ls in dp:
            for num in ls:
                ans = max(ans, num)
        return ans

    @staticmethod
    def cf_1625c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1625/C
        tag: matrix_dp|brute_force|implemention
        """
        n, ll, kk = ac.read_list_ints()
        d = ac.read_list_ints()
        a = ac.read_list_ints()
        dp = [[math.inf] * (kk + 1) for _ in range(n)]
        dp[0][0] = 0
        for i in range(1, n):
            for j in range(i):
                skip = i - j - 1
                dis = d[i] - d[j]
                for x in range(0, min(i, kk + 1) - skip):
                    dp[i][x + skip] = min(dp[i][x + skip], dp[j][x] + a[j] * dis)
        ans = math.inf
        for i in range(n):
            for j in range(kk + 1):
                if j + n - i - 1 <= kk:
                    ans = min(ans, dp[i][j] + (ll - d[i]) * a[i])
        ac.st(ans)
        return

    @staticmethod
    def cf_505c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/505/problem/C
        tag: data_range|limited_operation|matrix_dp|classical|array
        """
        n, d = ac.read_list_ints()
        tot = 3 * 10 ** 4
        cnt = [0] * (tot + 1)
        for _ in range(n):
            x = ac.read_int()
            cnt[x] += 1

        change = int(60000 ** 0.5) + 1
        dp = [-1] * (change * 2) * (tot + 1)
        dp[d * 2 * change] = cnt[d]
        for i in range(d, tot + 1):
            for j in range(-change, change):
                vv = dp[i * 2 * change + j]
                if vv == -1:
                    continue
                step = d + j
                for yy in [step - 1, step, step + 1]:
                    if i < i + yy <= tot:
                        dp[(i + yy) * 2 * change + yy - d] = max(dp[(i + yy) * 2 * change + yy - d], vv + cnt[i + yy])
        ans = max(dp)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1128(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1128
        tag: brain_teaser|data_range|brute_force|matrix_dp|high_precision|specific_plan
        """
        prime_numbers = PrimeSieve().euler_sieve(300)[:20]
        log = [math.log(p) for p in prime_numbers]
        n = ac.read_int()
        pf = PrimeFactor(n)
        dp = [[math.inf] * (n + 1) for _ in range(21)]
        dp[0][1] = 0
        pre = [[[] for _ in range(n + 1)] for _ in range(21)]
        for i in range(1, 21):
            p = prime_numbers[i - 1]
            for j in range(n + 1):
                dp[i][j] = dp[i - 1][j]
                pre[i][j] = (-1, j)
            for j in range(1, n + 1):
                for x in pf.all_factor[j]:
                    x -= 1
                    if x * log[i - 1] > dp[i][j]:
                        break
                    if dp[i - 1][j // (x + 1)] + x * log[i - 1] < dp[i][j]:
                        dp[i][j] = dp[i - 1][j // (x + 1)] + x * log[i - 1]
                        pre[i][j] = (p, x)
        i, j = 20, n
        ans = 1
        while pre[i][j]:
            p, x = pre[i][j]
            if p == -1:
                i -= 1
                continue
            ans *= p ** x
            j = j // (x + 1)
            i -= 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p1373(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1373
        tag: matrix_dp
        """
        m, n, k = ac.read_list_ints()
        mod = 10 ** 9 + 7
        k += 1
        tmp = []
        while True:
            cur = ac.read_list_ints()
            tmp.extend(cur)
            if len(tmp) == m * n:
                break
        assert len(tmp) == m * n
        dp = [[[0] * 2 for _ in range(k)] for _ in range(n + 1)]
        ans = 0
        for i in range(m):
            ndp = [[[0] * 2 for _ in range(k)] for _ in range(n + 1)]
            lst = tmp[i * n:i * n + n]
            for j in range(n):
                ndp[j + 1][lst[j] % k][0] = 1
                for x in range(k):
                    ndp[j + 1][x][0] += (dp[j + 1][(x - lst[j] + k) % k][1] + ndp[j][(x - lst[j] + k) % k][1])
                    dp[j + 1][x][0] %= mod

                    ndp[j + 1][x][1] += (dp[j + 1][(x + lst[j] + k) % k][0] + ndp[j][(x + lst[j] + k) % k][0])
                    dp[j + 1][x][1] %= mod

                ans += ndp[j + 1][0][1]
                ans %= mod
            dp = [[ls[:] for ls in lst] for lst in ndp]
        ac.st(ans)
        return

    @staticmethod
    def lg_p2028(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2028
        tag: bag_dp|math|comb|matrix_dp|second_stirling_num
        """
        n, k, p = ac.read_list_ints()
        dp = [0] * (k + 1)
        dp[0] = 1
        for i in range(n):
            for j in range(min(k, i + 1), 0, -1):
                dp[j] = (dp[j] * j + dp[j - 1]) % p
            dp[0] = 0
        ac.st(dp[k])
        return

    @staticmethod
    def lg_p2132(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2132
        tag: matrix_dp|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        while len(nums) < 5:
            nums.append(0)

        @lru_cache(None)
        def dfs(a, b, c, d, e):
            if a + b + c + d + e == 0:
                return 1
            res = 0
            if a > b:
                res += dfs(a - 1, b, c, d, e)
            if b > c:
                res += dfs(a, b - 1, c, d, e)
            if c > d:
                res += dfs(a, b, c - 1, d, e)
            if d > e:
                res += dfs(a, b, c, d - 1, e)
            if e:
                res += dfs(a, b, c, d, e - 1)
            return res

        ans = dfs(nums[0], nums[1], nums[2], nums[3], nums[4])
        ac.st(ans)
        return

    @staticmethod
    def lg_p5888(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5888
        tag: observation|matrix_dp|inclusion_exclusion|implemention
        """
        n, m, k = ac.read_list_ints()
        edges = [ac.read_list_ints_minus_one() for _ in range(k)]
        nodes = {0}
        for i, j in edges:
            nodes.add(i)
            nodes.add(j)
        nodes = sorted(nodes)
        rest = n - len(nodes)
        mod = 998244353
        ind = {num: i for i, num in enumerate(nodes)}
        s = len(ind) + 1
        dct = [{i} for i in range(s)]
        for i, j in edges:
            dct[ind[j]].add(ind[i])
        dp = [[0] * s for _ in range(2)]
        dp[0][ind[0]] = 1
        for _ in range(m):
            tot = sum(dp[0][:-1]) + dp[0][-1] * rest
            for j in range(s):
                cur = tot
                for x in dct[j]:
                    cur -= dp[0][x]
                cur %= mod
                dp[1][j] = cur
            for j in range(s):
                dp[0][j] = dp[1][j]
        ans = dp[0][0]
        ac.st(ans)
        return

    @staticmethod
    def lg_p7248(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7248
        tag: matrix_dp|classical|regular_bracket
        """
        n = ac.read_int()
        s = ac.read_str()
        mod = 10 ** 9 + 9
        dp = [[0] * n for _ in range(2)]
        dp[0][0] = 1

        for i in range(1, n + 1):
            m = min(i, n - i)
            w = s[i - 1]
            for j in range(m + 1):
                if w == ")" or j == 0:
                    dp[i & 1][j] = dp[(i + 1) & 1][j + 1] % mod
                else:
                    dp[i & 1][j] = (dp[(i + 1) & 1][j + 1] + dp[(i + 1) & 1][j - 1]) % mod
        ac.st(dp[n & 1][0])
        return

    @staticmethod
    def cf_339c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/339/C
        tag: matrix_dp|specific_plan
        """
        s = ac.read_str()
        lst = [i + 1 for i in range(10) if s[i] == "1"]
        m = ac.read_int()
        dp = [[[0] * 11 for _ in range(23)] for _ in range(m)]
        pre = [[[(-1, -1) for _ in range(11)] for _ in range(23)] for _ in range(m)]
        last = (-1, -1)
        for x in lst:
            dp[0][x][x] = 1
            last = (x, x)
        if last == (-1, -1):
            ac.st("NO")
            return
        for i in range(1, m):
            last = (-1, -1)
            if i % 2 == 0:
                for j in lst:
                    for x in range(-10, 0, 1):
                        for y in lst:
                            if 1 <= (x + y) <= 10 and y != j and dp[i - 1][x][j]:
                                dp[i][x + y][y] = 1
                                pre[i][x + y][y] = (x, j)
                                last = (x + y, y)
            else:
                for j in lst:
                    for x in range(1, 11):
                        for y in lst:
                            if -10 <= (x - y) <= -1 and y != j and dp[i - 1][x][j]:
                                dp[i][x - y][y] = 1
                                pre[i][x - y][y] = (x, j)
                                last = (x - y, y)
        if last == (-1, -1):
            ac.st("NO")
        else:
            ac.st("YES")
            ans = []
            ind = m - 1
            while last != (-1, -1):
                ans.append(last[-1])
                last = pre[ind][last[0]][last[1]]
                ind -= 1
            ans.reverse()
            ac.lst(ans)
        return

    @staticmethod
    def cf_598e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/598/E
        tag: matrix_dp|classical
        """

        m = n = 30
        k = 50
        dp = [[[math.inf] * (k + 1) for _ in range(n + 1)] for _ in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                for p in range(k + 1):
                    if p == 0:
                        dp[i][j][p] = 0
                    if i * j < p:
                        continue
                    if i * j == p:
                        dp[i][j][p] = 0

                    res = math.inf
                    for x in range(1, i):
                        for k1 in range(max(0, p - (i - x) * j), min(p, x * j) + 1):
                            cur = dp[x][j][k1] + dp[i - x][j][p - k1] + j * j
                            res = min(res, cur)
                    for y in range(1, j):
                        for k1 in range(max(0, p - (j - y) * i), min(p, y * i) + 1):
                            cur = dp[i][y][k1] + dp[i][j - y][p - k1] + i * i
                            res = min(res, cur)

                    dp[i][j][p] = min(dp[i][j][p], res)

        for _ in range(ac.read_int()):
            mm, nn, kk = ac.read_list_ints()
            ans = dp[mm][nn][kk]
            ac.st(ans)
        return
    @staticmethod
    def cf_833b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/833/B
        tag: matrix_dp|segment_tree|range_add|range_max
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints_minus_one()  # TLE
        dp = [0] * (n + 1)
        dp[0] = 0
        pre = [-1] * n
        tree = RangeAddRangeSumMinMax(n + 1)
        for _ in range(k):
            tree.build(dp)
            for i in range(n):
                pre[i] = -1
            for i in range(n):
                tree.range_add(pre[nums[i]] + 1, i, 1)
                dp[i + 1] = tree.range_max(0, i)
                pre[nums[i]] = i
        ans = dp[n]
        ac.st(ans)
        return

    @staticmethod
    def cf_10d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/10/D
        tag: lis|lcs|matrix_dp|specific_plan|classical
        """
        m = ac.read_int()
        a = ac.read_list_ints()
        n = ac.read_int()
        b = ac.read_list_ints()
        dp = [0] * m * n
        plan = [-1] * m * n
        for i in range(m):
            if i == 0:
                for j in range(n):
                    dp[i * n + j] = int(a[i] == b[j])
                continue
            pre = 0
            ind = -1
            for j in range(n):
                if a[i] == b[j]:
                    dp[i * n + j] = pre + 1
                    plan[i * n + j] = ind
                else:
                    dp[i * n + j] = dp[(i - 1) * n + j]
                    plan[i * n + j] = (i - 1) * n + j
                if b[j] < a[i] and dp[(i - 1) * n + j] > pre:
                    pre = dp[(i - 1) * n + j]
                    ind = (i - 1) * n + j
        ans = max(dp)
        i = dp.index(ans)
        res = [i]
        j = i
        while plan[j] != -1:
            j = plan[j]
            if dp[j] < dp[res[-1]]:
                res.append(j)
        ac.st(ans)
        if ans:
            res.reverse()
            ac.lst([b[x % n] for x in res])
        return

    @staticmethod
    def cf_1864d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1864/D
        tag: matrix_prefix_sum|implemention|matrix_dp
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            left = [0] * 2 * n
            right = [0] * 2 * n
            ans = 0
            up = [0] * n
            for i in range(n):
                for j in range(n):
                    up[j] += left[i - j + n]
                    up[j] += right[i + j]
                    up[j] %= 2
                s = ac.read_str()
                for j in range(n):
                    if up[j] != int(s[j]):
                        up[j] += 1
                        up[j] %= 2
                        left[i - j + n] += 1
                        right[i + j] += 1
                        ans += 1
                        left[i - j + n] %= 2
                        right[i + j] %= 2
            ac.st(ans)
        return
"""
Algorithm：outline_dp
Description：make the matrix_state_dp change to outline_dp with flatten matrix to linear

====================================LeetCode====================================
4（https://leetcode.cn/problems/broken-board-dominoes/）outline_dp|classical|hungarian
1349（https://leetcode.cn/problems/maximum-students-taking-exam/）outline_dp|classical
1659（https://leetcode.cn/problems/maximize-grid-happiness/）outline_dp|classical


=====================================LuoGu======================================
P2704（https://www.luogu.com.cn/problem/P2704）outline_dp|classical

===================================CodeForces===================================
xx（xxx）xxxxxxxxxxxxxxxxxxxx


=======================================Other====================================
1400（https://vjudge.net/problem/HDU-1400）outline_dp|classical

"""
from collections import defaultdict
from typing import List

from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1659(m: int, n: int, introverts: int, extroverts: int) -> int:
        """
        url: https://leetcode.cn/problems/maximize-grid-happiness/
        tag: outline_dp|classical
        """
        pre = {(0, introverts, extroverts): 0}
        mask = 3 ** (n - 1)

        for i in range(m):
            for j in range(n):
                cur = defaultdict(int)
                for s, intro, ext in pre:
                    cur[(s % mask) * 3, intro, ext] = max(cur[(s % mask) * 3, intro, ext], pre[(s, intro, ext)])
                    left = s % 3
                    up = s // mask
                    if ext:
                        val = 40
                        if left and j:
                            val += 20 + 50 * left - 80
                        if up and i:
                            val += 20 + 50 * up - 80
                        cur[((s % mask) * 3 + 2, intro, ext - 1)] = max(cur[((s % mask) * 3 + 2, intro, ext - 1)],
                                                                        pre[(s, intro, ext)] + val)
                    if intro:
                        val = 120
                        if left and j:
                            val += -30 + 50 * left - 80
                        if up and i:
                            val += -30 + 50 * up - 80
                        cur[((s % mask) * 3 + 1, intro - 1, ext)] = max(cur[((s % mask) * 3 + 1, intro - 1, ext)],
                                                                        pre[(s, intro, ext)] + val)
                pre = cur
        return max(pre.values())

    @staticmethod
    def lc_1349(seats: List[List[str]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-students-taking-exam/
        tag: outline_dp|classical
        """
        m, n = len(seats), len(seats[0])
        pre = {0: 0}
        mask = (1 << (n + 1)) - 1
        for i in range(m):
            for j in range(n):
                cur = defaultdict(int)
                x = seats[i][j]
                for p in pre:
                    cur[(p << 1) & mask] = max(cur[(p << 1) & mask], pre[p])
                    if x == ".":
                        if j and p & 1:
                            continue
                        if i and j and p & (1 << n):
                            continue
                        if i and j + 1 < n and p & (1 << (n - 2)):
                            continue
                        cur[((p << 1) | 1) & mask] = max(cur[((p << 1) | 1) & mask], pre[p] + 1)
                pre = cur
        ans = max(pre.values())
        return ans

    @staticmethod
    def lc_4(n: int, m: int, broken: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/broken-board-dominoes/
        tag: outline_dp|classical|hungarian
        """
        pre = {0: 0}
        grid = [[0] * n for _ in range(m)]
        for i, j in broken:
            grid[i][j] = 1
        mask = (1 << n) - 1
        for i in range(m):
            for j in range(n):
                cur = defaultdict(int)
                for p in pre:
                    cur[(p << 1) & mask] = max(cur[(p << 1) & mask], pre[p])
                    if not grid[i][j]:
                        if j and not grid[i][j - 1] and not p & 1:
                            cur[((p << 1) | 3) & mask] = max(cur[((p << 1) | 3) & mask], pre[p] + 1)
                        if i and not grid[i - 1][j] and not p & (1 << (n - 1)):
                            cur[((p << 1) | 1) & mask] = max(cur[((p << 1) | 1) & mask], pre[p] + 1)
                pre = cur
        return max(pre.values())

    @staticmethod
    def lg_p2704(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2704
        tag: outline_dp|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        pre = defaultdict(int)
        pre[0] = ans = 0
        mask = (1 << (2 * n)) - 1
        for i in range(m):
            for j in range(n):
                cur = defaultdict(int)
                for p in pre:
                    pp = (p & mask) << 1
                    cur[pp] = max(cur[pp], pre[p])
                    if grid[i][j] == "P":
                        pp = ((p & mask) << 1) | 1
                        if j - 1 >= 0 and pp & 2:
                            continue
                        if j - 2 >= 0 and pp & 4:
                            continue
                        if pp & (1 << (2 * n)):
                            continue
                        if pp & (1 << n):
                            continue
                        cur[pp] = max(cur[pp], pre[p] + 1)
                        ans = max(ans, cur[pp])
                pre = cur
        ac.st(ans)
        return
"""
Algorithm：prob_dp
Description：comb|specific_plan|prob|expectation

====================================LeetCode====================================
1227（https://leetcode.cn/problems/airplane-seat-assignment-probability/）prob_dp

=====================================LuoGu======================================
P1291（https://www.luogu.com.cn/problem/P1291）liner_dp|expectation
P4316（https://www.luogu.com.cn/problem/P4316）expectation|reverse_graph|topological_sort
P6154（https://www.luogu.com.cn/problem/P6154）reverse_graph|expectation|tree_dp|float|mod

=====================================AtCoder======================================
ABC342F（https://atcoder.jp/contests/abc342/tasks/abc342_f）prob_dp
ABC333F（https://atcoder.jp/contests/abc333/tasks/abc333_f）matrix_dp|equation|prob_dp|math|implemention
ABC326E（https://atcoder.jp/contests/abc326/tasks/abc326_e）prob_dp|contribution_method
ABC323E（https://atcoder.jp/contests/abc323/tasks/abc323_e）linear_dp|prob_dp|brute_force|classical
ABC300E（https://atcoder.jp/contests/abc300/tasks/abc300_e）prob_dp|math|classical|brain_teaser
ABC298E（https://atcoder.jp/contests/abc298/tasks/abc298_e）prob_dp
ABC297F（https://atcoder.jp/contests/abc297/tasks/abc297_f）matrix_dp|inclusion_exclusion|prob_dp
ABC280E（https://atcoder.jp/contests/abc280/tasks/abc280_e）prob_dp|expectation_dp|classical
ABC275E（https://atcoder.jp/contests/abc275/tasks/abc275_e）prob_dp|linear_dp|classical
ABC266E（https://atcoder.jp/contests/abc266/tasks/abc266_e）expectation_dp|brain_teaser|classical
ABC263E（https://atcoder.jp/contests/abc263/tasks/abc263_e）expectation_dp|reverse_order|math|brain_teaser|classical
ABC243F（https://atcoder.jp/contests/abc243/tasks/abc243_f）matrix_dp|prob_dp|brain_teaser|comb|math
ABC360E（https://atcoder.jp/contests/abc360/tasks/abc360_e）prob_dp|implemention|math
ABC194D（https://atcoder.jp/contests/abc194/tasks/abc194_d）prob_dp
ABC193D（https://atcoder.jp/contests/abc193/tasks/abc193_d）prob|math

===================================CodeForces===================================
540D（https://codeforces.com/problemset/problem/540/D）prob_dp|bag_dp|math|game_dp
1265E（https://codeforces.com/problemset/problem/1265/E）expectation_dp|math|classical|circle_dp|prob_dp
2020E（https://codeforces.com/contest/2020/problem/E）expectation_dp|implemention|data_range
1753F（https://codeforces.com/problemset/problem/1753/C）expectation_dp|comb|inv|prefix_sum
518D（https://codeforces.com/contest/518/problem/D）bag_dp|expectation_dp|prob_dp
453A（https://codeforces.com/problemset/problem/453/A）expectation_dp|prob_dp|inclusion_exclusion|float_fast_power
442B（https://codeforces.com/problemset/problem/442/B）prob_dp|math|greedy

=====================================AcWing=====================================
5058（https://www.acwing.com/problem/content/description/5061/）prob_dp


"""
import math
from collections import deque

from src.mathmatics.comb_perm.template import Combinatorics
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1291(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1291
        tag: liner_dp|expectation
        """
        n = ac.read_int()
        ans = [1, 1]
        for x in range(2, n + 1):
            a, b = ans
            c, d = 1, x
            g = math.gcd(b, d)
            lcm = b * d // g
            a, b = a * lcm // b + c * lcm // d, lcm
            g = math.gcd(a, b)
            ans = [a // g, b // g]
        a, b = ans
        a *= n
        x = a // b
        a %= b
        if a == 0:
            ac.st(x)
            return
        g = math.gcd(a, b)
        ans = [a // g, b // g]
        a, b = ans
        ac.st(len(str(x)) * " " + str(a))
        ac.st(str(x) + "-" * len(str(b)))
        ac.st(len(str(x)) * " " + str(b))
        return

    @staticmethod
    def lg_p4316(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4316
        tag: expectation|reverse_graph|topological_sort|float
        """
        n, m = ac.read_list_ints()
        dp = [0 for _ in range(n)]
        degree = [0] * n
        dct = [dict() for _ in range(n)]
        for _ in range(m):
            a, b, w = ac.read_list_ints()
            a -= 1
            b -= 1
            dct[b][a] = w
            degree[a] += 1
        cnt = degree[:]

        stack = deque([n - 1])
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                dp[j] += dp[i] + dct[i][j]
                degree[j] -= 1
                if not degree[j]:
                    dp[j] /= cnt[j]
                    stack.append(j)
        ans = "%.2f" % (dp[0])
        ac.st(ans)
        return

    @staticmethod
    def lg_p6154(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6154
        tag: reverse_graph|expectation|tree_dp|float|mod
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            dct[y].append(x)
            degree[x] += 1
        length_sum = [0] * n
        path_cnt = [0] * n
        mod = 998244353
        stack = deque([i for i in range(n) if not degree[i]])
        for i in stack:
            path_cnt[i] = 1
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                degree[j] -= 1
                length_sum[j] += path_cnt[i] + length_sum[i]
                path_cnt[j] += path_cnt[i]
                if not degree[j]:
                    path_cnt[j] += 1
                    path_cnt[j] %= mod
                    length_sum[j] %= mod
                    stack.append(j)
        total_length = sum(length_sum) % mod
        total_cnt = sum(path_cnt) % mod
        ac.st(total_length * pow(total_cnt, -1, mod) % mod)
        return

    @staticmethod
    def ac_5058(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/5061/
        tag: prob_dp
        """
        w, b = ac.read_list_ints()
        dp = [[0] * (b + 1) for _ in range(w + 1)]
        for i in range(1, w + 1):
            dp[i][0] = 1
        for i in range(1, w + 1):
            for j in range(1, b + 1):
                p = i / (i + j)
                if j > 1:
                    p += j / (i + j) * (j - 1) / (i + j - 1) * i / (i + j - 2) * dp[i - 1][j - 2]
                if j > 2:
                    p += j / (i + j) * (j - 1) / (i + j - 1) * (j - 2) / (i + j - 2) * dp[i][j - 3]
                dp[i][j] = p
        ac.st(dp[w][b])
        return

    @staticmethod
    def abc_333f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc333/tasks/abc333_f
        tag: matrix_dp|equation|prob_dp|math|implemention
        """
        n = ac.read_int()
        mod = 998244353
        pp = [pow(2, i, mod) for i in range(3001)]
        pv = [0 for _ in range(3001)]
        x = 1
        for i in range(1, 3001):
            pv[i] = pow(x, -1, mod)
            x = (x * 2 + 1) % mod
        p1 = pow(2, -1, mod)
        dp = [0] * n
        dp[0] = 1
        for i in range(1, n):
            ndp = [0] * n
            ndp[0] = sum(dp[j] * pp[j] for j in range(i)) * pow(2 ** (i + 1) - 1, -1, mod) % mod
            for j in range(1, i + 1):
                ndp[j] = (p1 * (dp[j - 1] + ndp[j - 1])) % mod
            dp = ndp
        ac.lst([x for x in dp])
        return

    @staticmethod
    def abc_323e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc323/tasks/abc323_e
        tag: linear_dp|prob_dp|brute_force|classical
        """
        n, x = ac.read_list_ints()
        t = ac.read_list_ints()
        dp = [0] * (x + 1)
        dp[0] = 1
        mod = 998244353
        pp = pow(n, -1, mod)
        for i in range(1, x + 1):
            for j in range(n):
                if i >= t[j]:
                    dp[i] += dp[i - t[j]] * pp
            dp[i] %= mod
        res = 0
        for i in range(x + 1):
            if i + t[0] > x:
                res += dp[i]
        res = (res * pp) % mod
        ac.st(res)
        return

    @staticmethod
    def abc_280e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc280/tasks/abc280_e
        tag: prob_dp|expectation_dp|classical
        """
        n, p = ac.read_list_ints()
        mod = 998244353
        p2 = p * pow(100, -1, mod) % mod
        p1 = (100 - p) * pow(100, -1, mod) % mod
        dp = [0] * (n + 2)
        dp[1] = 1
        for i in range(2, n + 1):
            dp[i] = (dp[i - 1] * p1 + dp[i - 2] * p2 + 1) % mod
        ac.st(dp[n])
        return

    @staticmethod
    def abc_275e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc275/tasks/abc275_e
        tag: prob_dp|linear_dp|classical
        """
        mod = 998244353
        n, m, k = ac.read_list_ints()
        dp = [0] * (n + 1)
        dp[0] = 1
        ans = 0
        p = pow(m, -1, mod)
        for _ in range(k):
            ndp = [0] * (n + 1)
            for i in range(n):
                for j in range(1, m + 1):
                    x = i + j
                    if x > n:
                        x = n - (x - n)
                    ndp[x] += dp[i] * p % mod
            dp = [x % mod for x in ndp]
            ans += dp[-1]
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_266e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc266/tasks/abc266_e
        tag: expectation_dp|brain_teaser|classical
        """
        n = ac.read_int()
        pre = 0
        for i in range(1, n + 1):
            cur = 0
            for j in range(1, 6 + 1):
                if j > pre:
                    cur += j
                else:
                    cur += pre
            pre = cur / 6
        ac.st(pre)
        return

    @staticmethod
    def abc_263e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc263/tasks/abc263_e
        tag: expectation_dp|reverse_order|math|brain_teaser|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        post = [0] * (n + 1)
        mod = 998244353
        cb = Combinatorics(n + 10, mod)
        dp = [0] * n
        for i in range(n - 2, -1, -1):
            x = min(n - 1, i + nums[i])
            p = post[i + 1] - post[x + 1]
            dp[i] = (p + nums[i] + 1) * cb.inv[nums[i]]
            dp[i] %= mod
            post[i] = (post[i + 1] + dp[i]) % mod
        ac.st(dp[0])
        return

    @staticmethod
    def abc_243f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc243/tasks/abc243_f
        tag: matrix_dp|prob_dp|brain_teaser|comb|math
        """
        mod = 998244353
        cb = Combinatorics(50, mod)

        n, m, k = ac.read_list_ints()
        w = [ac.read_int() for _ in range(n)]
        tot = sum(w)
        p = pow(tot, -1, mod)
        pp = [ww * p % mod for ww in w]
        dp = [[0] * (m + 1) for _ in range(k + 1)]
        dp[k][m] = 1
        for i in range(n - 1, -1, -1):
            ndp = [[0] * (m + 1) for _ in range(k + 1)]
            for j in range(k + 1):
                for x in range(m + 1):
                    res = dp[j][x]
                    if x + 1 <= m:
                        for c in range(1, k - j + 1):
                            res += dp[j + c][x + 1] * cb.comb(j + c, c) * pow(pp[i], c, mod)
                    ndp[j][x] = res % mod
            dp = [[x % mod for x in ls] for ls in ndp]
        ac.st(dp[0][0])
        return

    @staticmethod
    def abc_360e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc360/tasks/abc360_e
        tag: prob_dp|implemention|math
        """
        n, k = ac.read_list_ints()

        if n == 1:
            ac.st(1)
            return
        mod = 998244353
        nn = pow(n * n, -1, mod)
        pp = pow(n - 1, -1, mod)
        a = (n * n - 2 * n) * nn % mod
        b = 2 * nn % mod
        ak = pow(a, k, mod)
        one = (ak + b * (ak - 1) * pow(a - 1, -1, mod)) % mod
        zero = ((1 - one) * pp) % mod
        ans = (one + zero * (n * (n + 1) // 2 - 1)) % mod
        ac.st(ans)
        return

    @staticmethod
    def cf_540d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/540/D
        tag: prob_dp|bag_dp|math|game_dp
        """

        r, s, p = ac.read_list_ints()
        n = r + s + p

        dp = [[[0, 0, 0] for _ in range(s + 1)] for _ in range(r + 1)]

        for i in range(n - 1, -1, -1):
            for a in range(min(r, n - i), -1, -1):
                for b in range(min(s, n - i - a), -1, -1):
                    c = n - i - a - b
                    if a == b == 0:
                        dp[a][b] = [0, 0, 1]
                    elif b == c == 0:
                        dp[a][b] = [1, 0, 0]
                    elif a == c == 0:
                        dp[a][b] = [0, 1, 0]
                    else:
                        prob = a * b + b * c + c * a
                        res = [0, 0, 0]
                        if a and b:
                            nex = dp[a][b - 1]
                            for j in range(3):
                                res[j] += a * b * nex[j] / prob
                        if a and c:
                            nex = dp[a - 1][b]
                            for j in range(3):
                                res[j] += a * c * nex[j] / prob
                        if b and c:
                            nex = dp[a][b]
                            for j in range(3):
                                res[j] += c * b * nex[j] / prob
                        dp[a][b] = res
        ans = dp[r][s]
        tot = sum(ans)
        ac.lst([x / tot for x in ans])
        return

    @staticmethod
    def cf_1265e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1265/E
        tag: expectation_dp|math|classical|circle_dp|prob_dp
        """
        mod = 998244353
        ac.read_int()
        rev = [pow(x, -1, mod) for x in range(1, 101)]
        ans = 0
        p = ac.read_list_ints_minus_one()
        for x in p:
            ans = (ans + 1) * 100 * rev[x] % mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1753f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1753/C
        tag: expectation_dp|comb|inv|prefix_sum
        """
        mod = 998244353
        cb = Combinatorics(2 * 10 ** 5, mod)
        lst = [x * x % mod for x in cb.inv[1:]]
        pre = ac.accumulate(lst)
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            cnt = sum(nums)
            x = sum(nums[:n - cnt])
            if x == 0:
                ac.st(0)
                continue
            ans = pre[x] * n * (n - 1) // 2
            ac.st(ans % mod)
        return

    @staticmethod
    def cf_453a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/453/A
        tag: expectation_dp|prob_dp|inclusion_exclusion|float_fast_power
        """
        m, n = ac.read_list_ints()
        dp = [0] * (m + 1)
        for x in range(1, m + 1):
            dp[x] = pow(x / m, n)
        ans = sum((dp[i] - dp[i - 1]) * i for i in range(1, m + 1))
        ac.st(ans)
        return
"""
Algorithm：sos_dp
Description：sum_of_subsets_dp|md_prefix_sum
Reference：https://codeforces.com/blog/entry/45223


====================================LeetCode====================================


=====================================AtCoder======================================
ABC100C（https://atcoder.jp/contests/arc100/tasks/arc100_c）sos_dp|classical|state_dp|bit_operation


=====================================LuoGu======================================

===================================CodeForces===================================
1234F（https://codeforces.com/contest/1234/problem/F）sos_dp|classical|state_dp|bit_operation
449D（https://codeforces.com/problemset/problem/449/D）sos_dp|fill_table|prefix_sum|diff_array|data_range|classical
1208F（https://codeforces.com/problemset/problem/1208/F）
383E（https://codeforces.com/contest/383/problem/E）sos_dp|classical|state_dp|bit_operation
165E（https://codeforces.com/contest/165/problem/E）sos_dp|classical|state_dp|bit_operation

"""

from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1234f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1234/problem/F
        tag: sos_dp|classical|state_dp|bit_operation
        """
        lst = [ord(w) - ord("a") for w in ac.read_str()]
        n = len(lst)
        dp = [0] * (1 << 20)
        for i in range(n):
            cur = 1 << lst[i]
            dp[cur] = 1
            for j in range(i + 1, n):
                if cur & (1 << lst[j]):
                    break
                cur |= (1 << lst[j])
                dp[cur] = j - i + 1

        for i in range(1 << 20):
            for j in range(20):
                if not i & (1 << j):
                    dp[i | (1 << j)] = max(dp[i | (1 << j)], dp[i])

        ans = 1
        tot = (1 << 20) - 1
        for i in range(n):
            cur = 1 << lst[i]
            for j in range(i + 1, n):
                if cur & (1 << lst[j]):
                    break
                cur |= 1 << lst[j]
                ans = max(ans, j - i + 1 + dp[tot ^ cur])
        ac.st(ans)
        return

    @staticmethod
    def cf_165e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/165/problem/E
        tag: sos_dp|classical|state_dp|bit_operation
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [-1] * (1 << 22)
        for num in nums:
            dp[num] = num
        for i in range(1 << 22):
            if dp[i] == -1:
                continue
            for j in range(22):
                if not i & (1 << j):
                    dp[i | (1 << j)] = dp[i]
        ans = [-1] * n
        tot = (1 << 22) - 1
        for i in range(n):
            ans[i] = dp[nums[i] ^ tot]
        ac.lst(ans)
        return

    @staticmethod
    def cf_383e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/383/problem/E
        tag: sos_dp|classical|state_dp|bit_operation
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dp = [-1] * (1 << 22)
        for num in nums:
            dp[num] = num
        for i in range(1 << 22):
            if dp[i] == -1:
                continue
            for j in range(22):
                if not i & (1 << j):
                    dp[i | (1 << j)] = dp[i]
        ans = [-1] * n
        tot = (1 << 22) - 1
        for i in range(n):
            ans[i] = dp[nums[i] ^ tot]
        ac.lst(ans)
        return

    @staticmethod
    def arc_100c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/arc100/tasks/arc100_c
        tag: sos_dp|classical|state_dp|bit_operation
        """
        n = ac.read_int()
        nums = ac.read_list_ints()

        def merge(x1, y1, x2, y2):
            if x1 >= x2:
                return x1, max(x2, y1)
            return x2, max(x1, y2)

        maximum = nums[:]
        second = [0] * (1 << n)
        for j in range(n):
            for i in range(1 << n):
                if i & (1 << j):
                    x, y = maximum[i], second[i]
                    a, b = maximum[i ^ (1 << j)], second[i ^ (1 << j)]
                    maximum[i], second[i] = merge(x, y, a, b)
        ans = 0
        for i in range(1, 1 << n):
            ans = max(ans, maximum[i] + second[i])
            ac.st(ans)
        return

    @staticmethod
    def cf_449d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/449/D
        tag: sos_dp|fill_table|prefix_sum|diff_array|data_range|classical
        """
        n = ac.read_int()
        mod = 10 ** 9 + 7
        m = 20
        nums = ac.read_list_ints()
        ceil = 1 << m
        p = [1] * (n + 1)
        for i in range(1, n + 1):
            p[i] = (p[i - 1] * 2) % mod
        dp = [0] * ceil
        for num in nums:
            dp[num] += 1
        for j in range(m):
            for i in range(ceil - 1, -1, -1):
                if not (i >> j) & 1:
                    dp[i] += dp[i | (1 << j)]
        assert dp[0] == n
        for i in range(ceil - 1, -1, -1):
            dp[i] = (p[dp[i]] - 1) % mod
        for j in range(m):
            for i in range(ceil - 1, -1, -1):
                if not (i >> j) & 1:
                    dp[i] -= dp[i | (1 << j)]
                    dp[i] %= mod
        ac.st(dp[0])
        return
"""
Algorithm：state_dp|outline_dp、memory_search|refresh_table|fill_table
Description：state_dp|dfs|back_trace|brute_force|sub_set|bit_operation|brute_force

====================================LeetCode====================================
465（https://leetcode.cn/problems/optimal-account-balancing/）brute_force|sub_set|state_dp
1349（https://leetcode.cn/problems/maximum-students-taking-exam/）brute_force|state_dp
1723（https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/）bit_operation|minimum_maximum|brute_force|classical|sub_set
1986（https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/）sub_set|preprocess|brute_force|state_dp
698（https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/））sub_set|preprocess|brute_force|state_dp
2172（https://leetcode.cn/problems/maximum-and-sum-of-array/）bit_operation|state_dp|3-base|state_dp
1255（https://leetcode.cn/problems/maximum-score-words-formed-by-letters/）state_dp
2403（https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/）state_dp
1681（https://leetcode.cn/problems/minimum-incompatibility/）state_dp|group_bag_dp|state_dp|comb
1125（https://leetcode.cn/problems/smallest-sufficient-team/）state_dp
1467（https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/）memory_search|counter
1531（https://leetcode.cn/problems/string-compression-ii/submissions/）liner_dp|implemention
1595（https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/）state_dp
1655（https://leetcode.cn/problems/distribute-repeating-integers/）state_dp
1879（https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/）state_dp
2019（https://leetcode.cn/problems/the-score-of-students-solving-math-expression/）memory_search|fill_table
943（https://leetcode.cn/problems/find-the-shortest-superstring/）string|greedy|state_dp
1434（https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/description/）state_dp|reverse_thinking
847（https://leetcode.cn/problems/shortest-path-visiting-all-nodes/）shortest_path|floyd|dijkstra|preprocess|state_dp
2741（https://leetcode.cn/problems/special-permutations/description/）state_dp
2305（https://leetcode.cn/problems/fair-distribution-of-cookies/description/）classical|state_dp|brute_force|sub_set
980（https://leetcode.cn/problems/unique-paths-iii/description/）classical|state_dp|back_trace
2571（https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/description/）brain_teaser|memory_search
100312（https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/description/）specific_plan|state_dp

=====================================LuoGu======================================
P1896（https://www.luogu.com.cn/problem/P1896）brute_force|state_dp
P2704（https://www.luogu.com.cn/problem/P2704）state_dp

P2196（https://www.luogu.com.cn/problem/P2196）longest_path|state_dp
P1690（https://www.luogu.com.cn/problem/P1690）shortest_path|state_dp
P1294（https://www.luogu.com.cn/problem/P1294）state_dp|longest_diameter
P1123（https://www.luogu.com.cn/problem/P1123）state_dp
P1433（https://www.luogu.com.cn/problem/P1433）state_dp
P1896（https://www.luogu.com.cn/problem/P1896）state_dp
P1556（https://www.luogu.com.cn/problem/P1556）state_dp|shortest_path|specific_plan
P3052（https://www.luogu.com.cn/problem/P3052）state_dp|matrix_dp
P5997（https://www.luogu.com.cn/problem/P5997）greedy|bag_dp|state_dp
P6883（https://www.luogu.com.cn/problem/P6883）classical|state_dp
P8687（https://www.luogu.com.cn/problem/P8687）state_dp|bag_dp
P8733（https://www.luogu.com.cn/problem/P8733）floyd|shortest_path|state_dp|classical

===================================CodeForces===================================
580D（https://codeforces.com/problemset/problem/580/D）state_dp
165E（https://codeforces.com/problemset/problem/165/E）liner_dp|state_dp|brute_force
11D（https://codeforces.com/contest/11/problem/D）state_dp|undirected|counter
1102F（https://codeforces.com/contest/1102/problem/F）state_dp|classical|brute_force|fill_table|refresh_table
453B（https://codeforces.com/problemset/problem/453/B）state_dp|specific_plan|math|number_theory
16E（https://codeforces.com/problemset/problem/16/E）state_dp|prob_dp|refresh_table
1316E（https://codeforces.com/problemset/problem/1316/E）state_dp|greedy|sort|brain_teaser|classical

=====================================AtCoder====================================
ABC332E（https://atcoder.jp/contests/abc332/tasks/abc332_e）math|state_dp|classical
ABC338F（https://atcoder.jp/contests/abc338/tasks/abc338_f）floyd|shortest_path|state_dp|fill_table|refresh_table|classical
ABC318D（https://atcoder.jp/contests/abc318/tasks/abc318_d）state_dp|brute_force
ABC301E（https://atcoder.jp/contests/abc301/tasks/abc301_e）state_dp|build_graph
ABC278F（https://atcoder.jp/contests/abc278/tasks/abc278_f）state_dp|classical
ABC274E（https://atcoder.jp/contests/abc274/tasks/abc274_e）state_dp|classical
ABC232F（https://atcoder.jp/contests/abc232/tasks/abc232_f）state_dp|brain_teaser|classical
ABC352F（https://atcoder.jp/contests/abc352/tasks/abc352_f）union_find|brute_force|state_dp|classical
ABC354E（https://atcoder.jp/contests/abc354/tasks/abc354_e）state_dp
ABC215E（https://atcoder.jp/contests/abc215/tasks/abc215_e）state_dp
ABC199E（https://atcoder.jp/contests/abc199/tasks/abc199_e）state_dp
ABC199D（https://atcoder.jp/contests/abc199/tasks/abc199_d）state_dp
ABC195F（https://atcoder.jp/contests/abc195/tasks/abc195_f）state_dp|data_range|classical|brain_teaser|prime_factor

=====================================AcWing=====================================
3735（https://www.acwing.com/problem/content/3738/）reverse_order|state_dp|specific_plan


"""
import heapq
import math
from collections import Counter
from functools import lru_cache
from functools import reduce
from itertools import combinations, accumulate
from operator import or_
from typing import List

from src.mathmatics.number_theory.template import PrimeSieve
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO



class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_1681(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-incompatibility/
        tag: state_dp|group_bag_dp|state_dp|comb|fill_table
        """
        n = len(nums)
        if n % k:
            return -1
        group = dict()
        ceil = [0] * (1 << n)
        floor = [math.inf] * (1 << n)
        ind = {1 << i: i for i in range(n)}
        m = n // k
        for i in range(1, 1 << n):
            x = nums[ind[i & (-i)]]
            ceil[i] = max(ceil[i & (i - 1)], x)
            floor[i] = min(floor[i & (i - 1)], x)
            if i.bit_count() == m:
                lst = [nums[j] for j in range(n) if i & (1 << j)]
                if len(set(lst)) == m:
                    group[i] = ceil[i] - floor[i]

        dp = [math.inf] * (1 << n)
        dp[0] = 0
        for i in range(1 << n):
            if dp[i] == math.inf:
                continue
            not_seen = {nums[j]: j for j in range(n) if not i & (1 << j)}
            mask = sum(1 << x for x in not_seen.values())
            sub = mask
            while sub:
                if sub in group:
                    dp[i | sub] = min(dp[i | sub], dp[i] + group[sub])
                sub = (sub - 1) & mask
        return dp[-1] if dp[-1] < math.inf else -1

    @staticmethod
    def lc_1723(jobs: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/
        tag: bit_operation|minimum_maximum|brute_force|classical|sub_set|refresh_table
        """
        n = len(jobs)
        ind = {1 << i: i for i in range(n)}
        cost = [0] * (1 << n)
        for i in range(1, 1 << n):
            cost[i] = cost[i & (i - 1)] + jobs[ind[i & (-i)]]
        pre = cost[:]
        cur = cost[:]
        for _ in range(k - 1):
            for i in range(1, 1 << n):
                sub = i
                while sub:
                    if cost[sub] < cur[i] and pre[i ^ sub] < cur[i]:
                        cur[i] = max(pre[i ^ sub], cost[sub])
                    sub = (sub - 1) & i
            for i in range(1 << n):
                pre[i] = cur[i]
        return pre[-1]

    @staticmethod
    def lc_1879_1(nums1: List[int], nums2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/
        tag: state_dp|refresh_table
        """
        n = len(nums1)
        s = sum(nums1) + sum(nums2)
        dp = [s] * (1 << n)
        dp[0] = 0
        for state in range(1 << n):
            i = state.bit_count()
            for j in range(n):
                if not state & (1 << j):
                    a, b = dp[state | (1 << j)], (nums1[i] ^ nums2[j]) + dp[state]
                    dp[state | (1 << j)] = a if a < b else b
        return dp[-1]

    @staticmethod
    def lc_1879_2(nums1: List[int], nums2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/
        tag: state_dp|fill_table

        """
        n = len(nums1)
        s = sum(nums1) + sum(nums2)
        dp = [s] * (1 << n)
        dp[0] = 0
        for state in range(1, 1 << n):
            i = state.bit_count()
            for j in range(n):
                if state & (1 << j):
                    a, b = dp[state], (nums1[i - 1] ^ nums2[j]) + dp[state ^ (1 << j)]
                    dp[state] = a if a < b else b
        return dp[-1]

    @staticmethod
    def cf_165e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/165/E
        tag: liner_dp|state_dp|brute_force
        """
        # 线性state_dpDP，类似子集思想求解可能存在的与为0的数对
        n = ac.read_int()
        nums = ac.read_list_ints()
        ceil = max(nums).bit_length()
        dp = [-1] * (1 << ceil)
        for num in nums:
            dp[num] = num

        for i in range(1, 1 << ceil):
            if dp[i] == -1:
                for j in range(i.bit_length()):
                    if i & (1 << j) and dp[i ^ (1 << j)] != -1:
                        dp[i] = dp[i ^ (1 << j)]
                        break

        ans = [-1] * n
        for i in range(n):
            num = nums[i]
            x = num ^ ((1 << ceil) - 1)
            ans[i] = dp[x]
        ac.lst(ans)
        return

    @staticmethod
    def cf_580d(ac):
        """
        url: https://codeforces.com/problemset/problem/580/D
        tag: state_dp
        """
        # bitmaskbit_operationstate_dp转移，从 1 少的状态向多的转移，并brute_force前一个 1 的位置增益
        n, m, k = ac.read_list_ints()
        ind = {1 << i: i for i in range(n + 1)}
        nums = ac.read_list_ints()
        dp = [[0] * (n + 1) for _ in range(1 << n)]
        edge = [[0] * (n + 1) for _ in range(n + 1)]
        for _ in range(k):
            x, y, c = ac.read_list_ints()
            x -= 1
            y -= 1
            edge[x][y] = c

        ans = 0
        for i in range(1, 1 << n):
            if bin(i).count("1") > m:
                continue
            res = 0
            mask = i
            while mask:
                j = ind[mask & (-mask)]
                cur = max(dp[i ^ (1 << j)][k] + edge[k][j] for k in range(n) if i & (1 << k)) + nums[j]
                res = max(res, cur)
                mask &= (mask - 1)
                dp[i][j] = cur
            if bin(i).count("1") == m:
                ans = max(ans, res)
        ac.st(ans)
        return

    @staticmethod
    def lc_847(graph: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/shortest-path-visiting-all-nodes/
        tag: shortest_path|floyd|dijkstra|preprocess|state_dp
        """
        # shortest_pathFloyd或者Dijkstrapreprocessshortest_path|state_dp
        n = len(graph)
        dis = [[math.inf] * n for _ in range(n)]
        for i in range(n):
            for j in graph[i]:
                dis[i][j] = dis[j][i] = 1
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])

        dp = [[math.inf] * n for _ in range(1 << n)]
        for i in range(n):
            dp[1 << i][i] = 0

        for i in range(1 << n):
            for j in range(n):
                if dp[i][j] < math.inf and i & (1 << j):
                    for k in range(n):
                        if not i & (1 << k):
                            dp[i ^ (1 << k)][k] = min(dp[i ^ (1 << k)][k], dp[i][j] + dis[j][k])
        return min(dp[-1])

    @staticmethod
    def lc_1349(seats: List[List[str]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-students-taking-exam/
        tag: brute_force|state_dp
        """
        # 考试就座state_dp DP

        lst = []
        for se in seats:
            st = "".join(["0" if x == "." else "1" for x in se])
            lst.append(int("0b" + st, 2))

        @lru_cache(None)
        def dfs(state, i):
            if i >= m:
                return 0
            if i < m - 1:
                res = dfs(lst[i + 1], i + 1)
            else:
                res = 0
            ind = [j for j in range(n) if not state & (1 << j)]
            for k in range(1, len(ind) + 1):
                for item in combinations(ind, k):
                    if all(item[x + 1] - item[x] > 1 for x in range(k - 1)):
                        if i < m - 1:
                            sta = lst[i + 1]
                            for x in item:
                                for y in [x - 1, x + 1]:
                                    if 0 <= y < n:
                                        sta |= (1 << y)
                            nex = k + dfs(sta, i + 1)
                        else:
                            nex = k
                        res = res if res > nex else nex
            return res

        m = len(seats)
        n = len(seats[0])
        return dfs(lst[0], 0)

    @staticmethod
    def lc_1434_1(hats: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/description/
        tag: state_dp|reverse_thinking
        """
        # state_compressreverse_thinking，memory_search实现
        mod = 10 ** 9 + 7
        n = len(hats)
        people = [[] for _ in range(40)]
        for u in range(n):
            for v in hats[u]:
                people[v - 1].append(u)

        @lru_cache(None)
        def dfs(state, i):
            if not state:
                return 1
            if i == 40:
                return 0
            res = dfs(state, i + 1)
            for j in people[i]:
                if (1 << j) & state:
                    res += dfs(state ^ (1 << j), i + 1)
                    res %= mod
            return res

        return dfs((1 << n) - 1, 0)

    @staticmethod
    def lc_1434_2(hats: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/description/
        tag: state_dp|reverse_thinking
        """
        # state_compressreverse_thinking，fill_table迭代实现
        mod = 10 ** 9 + 7
        n = len(hats)
        people = [[] for _ in range(40)]
        for u in range(n):
            for v in hats[u]:
                people[v - 1].append(u)

        dp = [[0] * (1 << n) for _ in range(41)]
        dp[0][0] = 1
        for i in range(40):
            for j in range(1 << n):
                dp[i + 1][j] = dp[i][j]
                for x in people[i]:
                    if (1 << x) & j:
                        dp[i + 1][j] += dp[i][j ^ (1 << x)]
                        dp[i + 1][j] %= mod

        return dp[-1][-1]

    @staticmethod
    def lc_2403_1(power: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/
        tag: state_dp
        """
        # state_dpDP数组形式
        m = len(power)
        dp = [0] * (1 << m)
        for state in range(1, 1 << m):
            gain = m - state.bit_count() + 1
            res = math.inf
            for i in range(m):
                if state & (1 << i):
                    cur = (power[i] + gain - 1) // gain + dp[state ^ (1 << i)]
                    res = res if res < cur else cur
            dp[state] = res
        return dp[-1]

    @staticmethod
    def lc_2403_2(power: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/
        tag: state_dp
        """

        # state_dpDPmemory_search形式

        @lru_cache(None)
        def dfs(state):
            if not state:
                return 0
            gain = m - bin(state).count("1") + 1
            res = math.inf
            for i in range(m):
                if state & (1 << i):
                    cur = math.ceil(power[i] / gain) + dfs(state ^ (1 << i))
                    res = res if res < cur else cur
            return res

        m = len(power)
        return dfs((1 << m) - 1)

    @staticmethod
    def lg_p1896(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1896
        tag: state_dp
        """
        # state_compress迭代写法
        n, k = ac.read_list_ints()
        dp = [[[0] * (k + 1) for _ in range(1 << n)] for _ in range(n + 1)]
        dp[0][0][0] = 1

        for i in range(n):  # 行
            for j in range(1 << n):
                for num in range(k + 1):
                    cur = [x for x in range(n) if not j & (1 << x) and (x == 0 or not j & (1 << (x - 1))) and (
                            x == n - 1 or not j & (1 << (x + 1)))]
                    for y in range(1, len(cur) + 1):
                        if num + y <= k:
                            for item in combinations(cur, y):
                                if all(item[p] - item[p - 1] != 1 for p in range(1, y)):
                                    state = reduce(or_, [1 << z for z in item])
                                    dp[i + 1][state][num + y] += dp[i][j][num]
                    dp[i + 1][0][num] += dp[i][j][num]
        ans = sum(dp[n][j][k] for j in range(1 << n))
        ac.st(ans)
        return

    @staticmethod
    def cf_11d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/11/problem/D
        tag: state_dp|undirected|counter
        """
        # state_compress无向图简单环counter
        n, m = ac.read_list_ints()

        # build_graph|
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)

        # 初始化
        dp = [[0] * n for _ in range(1 << n)]
        for i in range(n):
            dp[1 << i][i] = 1

        ans = 0
        for i in range(1, 1 << n):  # 经过的点状态，lowest_bit为起点
            for j in range(n):
                if not dp[i][j]:
                    continue
                for k in dct[j]:
                    # 下一跳必须不能比起点序号小
                    if (i & -i) > (1 << k):
                        continue
                    if i & (1 << k):
                        # 访问过且是起点则形成环
                        if (i & -i) == 1 << k:
                            ans += dp[i][j]
                    else:
                        # 未访问过传到下一状态
                        dp[i ^ (1 << k)][k] += dp[i][j]

        # 去除一条边的环以及是无向图需要除以二
        ans = (ans - m) // 2
        ac.st(ans)
        return

    @staticmethod
    def lg_p1433(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1433
        tag: state_dp
        """
        # state_dp
        n = ac.read_int()
        lst = [[0, 0]]
        for _ in range(n):
            x, y = [float(w) for w in ac.read_list_strs() if w]
            if not x == y == 0:
                lst.append([x, y])

        n = len(lst)
        grid = [[0.0] * n for _ in range(n)]
        for i in range(n):
            a, b = lst[i]
            for j in range(i + 1, n):
                c, d = lst[j]
                cur = math.sqrt((a - c) * (a - c) + (b - d) * (b - d))
                grid[i][j] = cur
                grid[j][i] = cur

        dp = [[math.inf] * n for _ in range(1 << n)]
        for i in range((1 << n) - 1):
            for pre in range(n):
                if not i:
                    dp[i][pre] = 0
                    continue
                res = math.inf
                for j in range(n):
                    if i & (1 << j):
                        cur = dp[i ^ (1 << j)][j] + grid[pre][j]
                        res = min(res, cur)
                dp[i][pre] = res
        ans = dp[(1 << n) - 2][0]
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p1556(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1556
        tag: state_dp|shortest_path|specific_plan
        """
        # state_dpshortest_path
        n = ac.read_int()
        # 增|虚拟的起终点
        nums = [[0, 0]] + [ac.read_list_ints() for _ in range(n)] + [[0, 0]]
        n += 2
        # 根据题意build_graph|，表示起终点与方向
        dct = [[] for _ in range(n)]
        for i in range(n):
            a, b = nums[i]
            for j in range(n):
                if i != j:
                    # 只有在同一行或者同一列时可以build_graph|连边
                    c, d = nums[j]
                    if a == c:
                        dct[i].append([j, 4] if b < d else [j, 2])
                    if b == d:
                        dct[i].append([j, 1] if a < c else [j, 3])

        # 状态 当前点 方向
        dp = [[[0] * 5 for _ in range(n)] for _ in range((1 << n) - 1)]
        dp[0][n - 1] = [0, 1, 1, 1, 1]
        for state in range(1, (1 << n) - 1):
            for x in range(n):
                for f in range(5):
                    if x == n - 1:
                        dp[state][x][f] = 1 if not state else 0
                    res = 0
                    # brute_force上一个点与方向是否可以转移过来
                    for y, ff in dct[x]:
                        if state & (1 << y) and ff != f:
                            res += dp[state ^ (1 << y)][y][ff]
                    dp[state][x][f] = res
        #  0 表示初始任意不同于 1234 的方向总和
        ac.st(dp[(1 << n) - 1 - 1][0][0])
        return

    @staticmethod
    def lg_p3052(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3052
        tag: state_dp|matrix_dp
        """
        # state_dp DP 二维优化
        n, w = ac.read_list_ints()
        nums = []
        while len(nums) < n:
            nums.extend(ac.read_list_ints())
        f = [math.inf] * (1 << n)  # 当前状态下的分组
        f[0] = 1
        g = [0] * (1 << n)  # 当前状态下最后一组占用的重量
        for i in range(1, 1 << n):
            for j in range(n):
                if i & (1 << j):
                    pre = i ^ (1 << j)
                    # 装在当前最后一组
                    if g[pre] + nums[j] <= w and [f[i], g[i]] > [f[pre], g[pre] + nums[j]]:
                        f[i] = f[pre]
                        g[i] = g[pre] + nums[j]
                    # 新开组
                    elif [f[i], g[i]] > [f[pre] + 1, nums[j]]:
                        f[i] = f[pre] + 1
                        g[i] = nums[j]
        ac.st(f[-1])
        return

    @staticmethod
    def lg_p5997(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5997
        tag: greedy|bag_dp|state_dp
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        c = ac.read_list_ints()
        c.sort(reverse=True)
        dp = [m + 1] * (1 << n)  # MLE
        dp[0] = 0
        rest = [0] * (1 << n)
        for i in range(1, 1 << n):
            for j in range(n):
                if i & (1 << j):
                    dd, rr = dp[i ^ (1 << j)], rest[i ^ (1 << j)]
                    if rr >= a[j]:
                        if dp[i] > dd or (dp[i] == dd and rest[i] < rr - a[j]):
                            dp[i] = dd
                            rest[i] = rr - a[j]
                    if dd + 1 <= m:
                        rr = c[dd]
                        if rr >= a[j]:
                            if dp[i] > dd + 1 or (dp[i] == dd + 1 and rest[i] < rr - a[j]):
                                dp[i] = dd + 1
                                rest[i] = rr - a[j]
        ac.st(dp[-1] if dp[-1] < m + 1 else "NIE")
        return

    @staticmethod
    def lg_p6883(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6883
        tag: classical|state_dp
        """

        n, k = ac.read_list_ints()  # TLE
        grid = [ac.read_list_ints() for _ in range(n)]
        dp = [math.inf] * (1 << n)
        dp[-1] = 0
        ans = math.inf
        for i in range((1 << n) - 1, -1, -1):
            lst = [j for j in range(n) if (1 << j) & i]
            if len(lst) <= k:
                ans = min(ans, dp[i])
                continue
            for j in lst:
                c = min(grid[j][k] for k in lst if k != j)
                dp[i ^ (1 << j)] = min(dp[i ^ (1 << j)], dp[i] + c)
        ac.st(ans)
        return

    @staticmethod
    def lg_p8687(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8687
        tag: state_dp|bag_dp
        """
        # state_dp 结合背包 DP 思想
        n, m, k = ac.read_list_ints()
        dp = [math.inf] * (1 << m)
        dp[0] = 0
        for i in range(n):
            nums = ac.read_list_ints_minus_one()
            cur = reduce(or_, [1 << x for x in nums])
            for j in range(1 << m):
                if dp[j | cur] > dp[j] + 1:
                    dp[j | cur] = dp[j] + 1
        ac.st(dp[-1] if dp[-1] < math.inf else -1)
        return

    @staticmethod
    def lc_1467(balls: List[int]) -> float:
        """
        url: https://leetcode.cn/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/
        tag: memory_search|counter
        """

        # memory_search与组合mathcounter

        @lru_cache(None)
        def dfs(i, s, c1, c2):
            if i == m:
                return c1 == c2 and s == n // 2
            res = 0
            t = pre[i] - s
            for x in range(0, balls[i] + 1):
                if s + x <= n // 2 and t + balls[i] - x <= n // 2:
                    cnt = math.comb((n // 2 - s), x) * math.comb((n // 2 - t), balls[i] - x)
                    res += dfs(i + 1, s + x, c1 + int(x > 0), c2 + int(x < balls[i])) * cnt
            return res

        m = len(balls)
        n = sum(balls)
        total = 1
        rest = n
        for num in balls:
            total *= math.comb(rest, num)
            rest -= num
        pre = list(accumulate(balls, initial=0))
        return dfs(0, 0, 0, 0) / total

    @staticmethod
    def lc_1595(cost: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/
        tag: state_dp
        """
        # state_dp，需要一点变形
        m, n = len(cost), len(cost[0])
        low = [min(cost[i][j] for i in range(m)) for j in range(n)]

        @lru_cache(None)
        def dfs(i, state):
            if i == m:
                res = 0
                for j in range(n):
                    if not state & (1 << j):
                        res += low[j]
                return res
            return min(dfs(i + 1, state | (1 << j)) + cost[i][j] for j in range(n))

        return dfs(0, 0)

    @staticmethod
    def lc_1655(nums: List[int], quantity: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/distribute-repeating-integers/
        tag: state_dp
        """

        # 线性索引|brute_force子集state_compress
        @lru_cache(None)
        def dfs(i, state):
            if not state:
                return True
            if i == m:
                return False
            x = cnt[i]
            sub = state
            while sub:
                cost = sum(quantity[j] for j in range(n) if sub & (1 << j))
                if cost <= x and dfs(i + 1, state ^ sub):
                    return True
                sub = (sub - 1) & state
            return False

        cnt = list(Counter(nums).values())
        n = len(quantity)
        cnt = heapq.nlargest(n, cnt)
        m = len(cnt)
        return dfs(0, (1 << n) - 1)

    @staticmethod
    def lc_2019(s: str, answers: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/the-score-of-students-solving-math-expression/
        tag: memory_search|fill_table
        """

        # 类似divide_and_conquer的思想memory_search
        @lru_cache(None)
        def dfs(state):
            if len(state) == 1:
                return set(state)
            m = len(state)
            cur = set()
            for i in range(m):
                if isinstance(state[i], str) and state[i] in "+*":
                    op = state[i]
                    pre = dfs(state[:i])
                    post = dfs(state[i + 1:])
                    for x in pre:
                        for y in post:
                            z = x + y if op == "+" else x * y
                            if z <= 1000:
                                cur.add(z)
            return cur

        lst = [int(w) if w.isnumeric() else w for w in s]
        res = dfs(tuple(lst))
        real = eval(s)
        return sum(5 if w == real else 2 if w in res else 0 for w in answers)

    @staticmethod
    def lc_1986_1(tasks: List[int], session: int):
        """
        url: https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/
        tag: sub_set|preprocess|brute_force|state_dp
        """
        # preprocess子集后memory_search状态转移，子集brute_force，也可两个状态
        n = len(tasks)
        valid = [False] * (1 << n)
        for mask in range(1, 1 << n):
            cost = 0
            for i in range(n):
                if mask & (1 << i):
                    cost += tasks[i]
            if cost <= session:
                valid[mask] = True

        f = [math.inf] * (1 << n)
        f[0] = 0
        for mask in range(1, 1 << n):
            subset = mask
            while subset:  # 状压子集brute_force
                if valid[subset]:
                    a, b = f[mask], f[mask ^ subset] + 1
                    f[mask] = a if a < b else b
                subset = (subset - 1) & mask
        return f[(1 << n) - 1]

    @staticmethod
    def lc_1986_2(tasks: List[int], session: int):
        """
        url: https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/
        tag: sub_set|preprocess|brute_force|state_dp
        """

        # preprocess子集后memory_search状态转移，子集brute_force，也可两个状态

        @lru_cache(None)
        def dfs(state, rest):
            if not state:
                return 0
            res = math.inf
            for i in range(n):
                if state & (1 << i):
                    if rest >= tasks[i]:
                        cur = dfs(state ^ (1 << i), rest - tasks[i])
                    else:
                        cur = 1 + dfs(state ^ (1 << i), session - tasks[i])
                    if cur < res:
                        res = cur
            return res

        n = len(tasks)
        return dfs((1 << n) - 1, 0)

    @staticmethod
    def abc_332e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc332/tasks/abc332_e
        tag: math|state_dp|classical
        """
        n, d = ac.read_list_ints()
        nums = ac.read_list_ints()
        cost = [0] * (1 << n)
        ind = {1 << i: i for i in range(n)}
        for i in range(1, 1 << n):
            cost[i] = cost[i & (i - 1)] + nums[ind[i & (-i)]]

        dp = [x * x for x in cost]
        for _ in range(d - 1):
            for state in range((1 << n) - 1, -1, -1):
                mask = state
                while mask:
                    c = dp[state ^ mask] + cost[mask] * cost[mask]
                    if c < dp[state]:
                        dp[state] = c
                    mask = (mask - 1) & state

        ans = dp[-1]
        s = sum(nums)
        ac.st(((d * ans) - s * s) / d / d)
        return

    @staticmethod
    def ac_3735(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3738/
        tag: reverse_order|state_dp|specific_plan
        """
        # reverse_order|state_compress与输出specific_plan
        n, m = ac.read_list_ints()
        if m == n * (n - 1) // 2:
            ac.st(0)
            return
        group = [0] * n
        for i in range(n):
            group[i] |= (1 << i)
        for _ in range(m):
            i, j = ac.read_list_ints()
            i -= 1
            j -= 1
            group[i] |= (1 << j)
            group[j] |= (1 << i)

        dp = [math.inf] * (1 << n)
        pre = [[-1, -1] for _ in range(1 << n)]
        for i in range(n):
            dp[group[i]] = 1
            pre[group[i]] = [i, -1]  # use, from

        for i in range(1 << n):
            if dp[i] == math.inf:
                continue

            for j in range(n):
                if i & (1 << j):
                    nex = i | group[j]
                    if dp[nex] > dp[i] + 1:
                        dp[nex] = dp[i] + 1
                        pre[nex] = [j, i]  # use, from

        s = (1 << n) - 1
        ans = []
        while s > 0:
            ans.append(pre[s][0] + 1)
            s = pre[s][1]
        ac.st(len(ans))
        ac.lst(ans)
        return

    @staticmethod
    def lc_2172(nums: List[int], num_slots: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-and-sum-of-array/
        tag: bit_operation|state_dp|3-base|state_dp
        """

        # bit_operation和state_dp转移，三进制state_compress（天平就是三进制）

        def get_k_bin_of_n(n: int, k: int, m: int):  # 进制与数字转换state_compress
            lst = []
            while n:
                lst.append(n % k)
                n //= k
            lst = lst + [0] * (m - len(lst))
            return lst

        length = len(nums)
        dp = [0] * (3 ** num_slots)
        for sub in range(3 ** num_slots):
            cnt = get_k_bin_of_n(sub, 3, num_slots)
            pre = sum(cnt)
            if pre >= length:
                continue
            for j in range(num_slots):
                if cnt[j] < 2:
                    cur = dp[sub] + (nums[pre] & (j + 1))
                    dp[sub + 3 ** j] = max(dp[sub + 3 ** j], cur)
        return max(dp)

    @staticmethod
    def cf_1102f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1102/problem/F
        tag: state_dp|classical|brute_force|fill_table|refresh_table
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        if m == 1:
            ans = min(abs(grid[0][j + 1] - grid[0][j]) for j in range(n - 1))
            ac.st(ans)
            return

        cost = [[math.inf] * m for _ in range(m)]
        end = [[math.inf] * m for _ in range(m)]
        for i in range(m):
            for j in range(i + 1, m):
                cost[i][j] = cost[j][i] = min(abs(grid[i][x] - grid[j][x]) for x in range(n))
            if n > 1:
                for j in range(m):
                    if j != i:
                        end[i][j] = min(abs(grid[i][x - 1] - grid[j][x]) for x in range(1, n))
        ans = 0
        for i in range(m):
            dp = [[0] * (1 << m) for _ in range(m)]
            dp[i][1 << i] = math.inf
            for s in range(1, 1 << m):
                tmp_s = [y for y in range(m) if not s & (1 << y)]
                for x in range(m):
                    if dp[x][s]:
                        for y in tmp_s:
                            dp[y][s | (1 << y)] = max(dp[y][s | (1 << y)], min(dp[x][s], cost[x][y]))
            for x in range(m):
                cur = dp[x][-1]
                if n > 1:
                    cur = min(cur, end[x][i])
                if cur > ans:
                    ans = cur
        ac.st(ans)
        return

    @staticmethod
    def abc_338f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc338/tasks/abc338_f
        tag: floyd|shortest_path|state_dp|fill_table|refresh_table|classical
        """
        n, m = ac.read_list_ints()
        dis = [[math.inf] * n for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            dis[u - 1][v - 1] = w
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    if dis[i][k] < math.inf and dis[k][j] < math.inf:
                        dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])
        m = 1 << n
        dp = [math.inf] * m * n

        for i in range(n):
            dp[i * m + (1 << i)] = 0
        for s in range(1 << n):
            for j in range(n):
                if dp[j * m + s] == math.inf or not (s >> j) & 1:
                    continue
                for k in range(n):
                    if dis[j][k] == math.inf or (s >> k) & 1:
                        continue
                    dp[k * m + (s | (1 << k))] = min(dp[k * m + (s | (1 << k))], dp[j * m + s] + dis[j][k])
        ans = min(dp[i * m + m - 1] for i in range(n))
        ac.st(ans if ans < math.inf else "No")
        return

    @staticmethod
    def abc_301e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc301/tasks/abc301_e
        tag: state_dp|build_graph
        """
        m, n, t = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        candy = []
        start = []
        end = []
        for i in range(m):
            for j in range(n):
                w = grid[i][j]
                if w == "S":
                    start.append((i, j))
                elif w == "G":
                    end.append((i, j))
                elif w == "o":
                    candy.append((i, j))
        lst = start + candy + end
        k = len(lst)
        dct = [[math.inf] * k for _ in range(k)]
        for i in range(k):
            x, y = lst[i]
            visit = [[math.inf] * n for _ in range(m)]
            visit[x][y] = 0
            stack = [(x, y)]
            while stack:
                nex = []
                for x, y in stack:
                    for a, b in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                        if 0 <= a < m and 0 <= b < n and grid[a][b] != "#" and visit[a][b] == math.inf:
                            visit[a][b] = visit[x][y] + 1
                            nex.append((a, b))
                stack = nex[:]
            for j in range(k):
                if j != i:
                    a, b = lst[j]
                    dct[i][j] = visit[a][b]

        target = (1 << k) - 1
        dp = [[math.inf] * (1 << k) for _ in range(k)]
        dp[0][target ^ (1 << 0)] = 0
        ans = -1
        for state in range(target - 1, -1, -1):
            pre = [j for j in range(k) if not state & (1 << j)]
            for x in pre:
                for y in pre:
                    if x != y:
                        dp[x][state] = min(dp[x][state], dp[y][state | (1 << x)] + dct[y][x])
        for state in range(1 << k):
            if dp[-1][state] <= t:
                cur = sum(not state & (1 << j) for j in range(k)) - 2
                ans = max(ans, cur)
        ac.st(ans)
        return

    @staticmethod
    def abc_274e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc274/tasks/abc274_e
        tag: state_dp|classical
        """
        n, m = ac.read_list_ints()
        nums = [[0, 0]] + [ac.read_list_ints() for _ in range(n)] + [ac.read_list_ints() for _ in range(m)]
        n = len(nums)
        dis = [[0] * n for _ in range(n)]
        for i in range(n):
            x1, y1 = nums[i]
            for j in range(i + 1, n):
                x2, y2 = nums[j]
                dis[i][j] = dis[j][i] = ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) ** 0.5

        s = [math.inf] * (1 << n)
        for i in range(1 << n):
            c = sum(not i & (1 << j) for j in range(n - m, n))
            s[i] = 1 << c

        dp = [[math.inf] * (1 << n) for _ in range(n)]
        tot = ((1 << n) - 1) ^ 1
        dp[0][tot] = 0
        target = (1 << (n - m)) - 1
        ans = math.inf
        for state in range((1 << n) - 1, -1, -1):
            pre = []
            post = []
            for i in range(n):
                if not state & (1 << i):
                    pre.append(i)
                else:
                    post.append(i)
            for x in pre:
                for y in post:
                    dp[y][state ^ (1 << y)] = min(dp[y][state ^ (1 << y)], dis[x][y] / s[state] + dp[x][state])
            if not state & target:
                for i in range(n):
                    ans = min(ans, dp[i][state] + dis[i][0] / s[state])
        ac.st(ans)
        return

    @staticmethod
    def abc_232f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc232/tasks/abc232_f
        tag: state_dp|brain_teaser|classical
        """
        n, x, y = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        dp = [math.inf] * (1 << n)
        dp[0] = 0
        for state in range(1, 1 << n):
            res = math.inf
            lst = [j for j in range(n) if state & (1 << j)]
            m = len(lst)
            for rk, j in enumerate(lst):
                cur = dp[state ^ (1 << j)]
                cur += (j - rk) * y + abs(a[m - 1] - b[j]) * x
                res = min(res, cur)
            dp[state] = res
        ac.st(dp[-1])
        return

    @staticmethod
    def abc_352f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc352/tasks/abc352_f
        tag: union_find|brute_force|state_dp|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            a -= 1
            b -= 1
            dct[a].append((b, c))
            dct[b].append((a, -c))

        roots = []
        group = []
        pre = []
        visit = [n] * n
        for g in range(n):
            if visit[g] == n:
                visit[g] = 0
                stack = [g]
                lst = [g]
                roots.append(g)
                while stack:
                    x = stack.pop()
                    for b, w in dct[x]:
                        if visit[b] == n:
                            visit[b] = visit[x] - w
                            stack.append(b)
                            lst.append(b)
                low = min(visit[x] for x in lst)
                cur = 0
                for x in lst:
                    visit[x] -= low
                    cur |= 1 << visit[x]
                pre.append(cur)
                group.append(lst[:])

        @lru_cache(None)
        def dfs(rest_group, rest_ind):
            if rest_ind == 0:
                return rest_group == 0
            for ind in range(k):
                if rest_ind & (1 << ind):
                    for y in range(n):
                        if (rest_group & (pre[ind] << y)) == (pre[ind] << y) and dfs(rest_group ^ (pre[ind] << y),
                                                                                     rest_ind ^ (1 << ind)):
                            return True
                    break
            return False

        k = len(roots)
        ans = [[] for _ in range(k)]
        tot = (1 << n) - 1
        index = (1 << k) - 1

        for i in range(k):
            for x in range(n):
                if ((pre[i] << x) & tot) == (pre[i] << x):
                    rest = tot ^ (pre[i] << x)
                    if dfs(rest, index ^ (1 << i)):
                        ans[i].append(x)
                        if len(ans[i]) >= 2:
                            break
        for i in range(k):
            if len(ans[i]) == 1:
                for r in group[i]:
                    visit[r] += ans[i][0] + 1
            else:
                for r in group[i]:
                    visit[r] = -1
        ac.lst(visit)
        return

    @staticmethod
    def lc_100312(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/find-the-minimum-cost-array-permutation/description/
        tag: specific_plan|state_dp
        """

        @lru_cache(None)
        def one(ss):
            return [j for j in range(14) if ss & (1 << j)]

        @lru_cache(None)
        def zero(ss):
            return [j for j in range(14) if not ss & (1 << j)]

        m = 14
        dp = [[0] * m for _ in range((1 << m) - 1)]
        tp = [[0] * m for _ in range((1 << m) - 1)]

        n = len(nums)
        for state in range((1 << n) - 1):
            if state == 0:
                for pre in range(n):
                    dp[state][pre] = abs(pre - nums[0])
                    tp[state][pre] = pre
                continue
            for pre in zero(state):
                if pre >= n:
                    break
                cur_cost = math.inf
                cur_tp = ()
                for i in one(state):
                    if i >= n:
                        break
                    c = dp[state ^ (1 << i)][i] + abs(pre - nums[i])
                    if c < cur_cost:
                        cur_cost = c
                        cur_tp = i
                dp[state][pre] = cur_cost
                tp[state][pre] = cur_tp
        ans = []
        pre = 0
        state = (1 << n) - 2
        while state:
            ans.append(pre)
            pre = tp[state][pre]
            state = state ^ (1 << pre)

        ans.append(pre)
        return ans

    @staticmethod
    def abc_199d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc199/tasks/abc199_d
        tag: state_dp
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            if i > j:
                i, j = j, i
            dct[i].append(j)

        @lru_cache(None)
        def dfs(x, post):
            if x == n:
                return 1
            res = 0
            for state in range(3):
                lst = list(post)
                if lst[state]:
                    for y in dct[x]:
                        lst[(y - x) * 3 + state] = 0
                    res += dfs(x + 1, tuple(lst[3:]))
            return res

        ans = dfs(0, tuple([1] * 3 * n))
        ac.st(ans)
        return

    @staticmethod
    def cf_453b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/453/B
        tag: state_dp|specific_plan|math|number_theory
        """
        primes = [1] + PrimeSieve().eratosthenes_sieve(58)
        pf = PrimeFactor(58)
        ind = {num: i for i, num in enumerate(primes)}
        states = [0]
        for num in range(1, 59):
            s = 0
            for x, _ in pf.prime_factor[num]:
                s |= 1 << ind[x]
            states.append(s)
        m = 17
        n = ac.read_int()
        nums = ac.read_list_ints()

        dp = [math.inf] * (1 << m)
        pre_num = [[0 for _ in range(1 << m)] for _ in range(n + 1)]
        pre_state = [[0 for _ in range(1 << m)] for _ in range(n + 1)]
        nex_num = [[] for _ in range(1 << m)]

        for state in range(1 << m):
            for num in range(1, 59):
                s = states[num]
                if state & s == s:
                    nex_num[state].append(num)

        dp[-1] = 0
        for i in range(n):
            ndp = [math.inf] * (1 << m)
            for state in range(1 << m):
                for num in nex_num[state]:
                    cur = dp[state] + abs(nums[i] - num)
                    s = states[num]
                    if cur < ndp[state ^ s]:
                        ndp[state ^ s] = cur
                        pre_num[i + 1][state ^ s] = num
                        pre_state[i + 1][state ^ s] = state
            dp = ndp[:]
        state = dp.index(min(dp))
        ans = []
        for i in range(n, 0, -1):
            ans.append(pre_num[i][state])
            state = pre_state[i][state]
        ac.lst(ans[::-1])
        return

    @staticmethod
    def abc_195f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc195/tasks/abc195_f
        tag: state_dp|data_range|classical|brain_teaser|prime_factor
        """
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]
        m = len(primes)
        a, b = ac.read_list_ints()
        dp = [0] * (1 << m)
        dp[0] = 1
        for num in range(a, b + 1):
            cur = 0
            for j in range(m):
                if num % primes[j] == 0:
                    cur |= 1 << j
            for x in range((1 << m) - 1, -1, -1):
                if x & cur == cur:
                    dp[x] += dp[x ^ cur]
        ans = sum(dp)
        ac.st(ans)
        return

    @staticmethod
    def cf_1316e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1316/E
        tag: state_dp|greedy|sort|brain_teaser|classical
        """
        n, p, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums = [num * n + i for i, num in enumerate(nums)]
        nums.sort(reverse=True)
        s = [ac.read_list_ints() for _ in range(n)]
        dp = [-math.inf] * (1 << p)
        dp[0] = 0
        lst = []
        for x in range(1 << p):
            lst.append([j for j in range(p) if (x >> j) & 1])
        cnt = [len(ls) for ls in lst]
        for j, val in enumerate(nums):
            num, i = val // n, val % n
            for x in range((1 << p) - 1, -1, -1):
                cur = cnt[x]
                if j + 1 - cur <= k:
                    dp[x] = max(dp[x], dp[x] + num)
                for r in lst[x]:
                    dp[x] = max(dp[x], dp[x ^ (1 << r)] + s[i][r])
        ac.st(dp[-1])
        return
"""
Algorithm：tree_dp|tree_diameter|tree_diff_array|tree_centroid
Description：reroot_dp|up_to_down|down_to_up

====================================LeetCode====================================
2440（https://leetcode.cn/problems/create-components-with-same-value/）tree_dp|number_theory|recursion|union_find|brute_force
1569 https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/solution/）counter|comb|binary_search_tree|tree_dp
968（https://leetcode.cn/problems/binary-tree-cameras/）tree_dp
2538（https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/）reroot_dp|tree_diameter
124（https://leetcode.cn/problems/binary-tree-maximum-path-sum/）tree_dp
2378（https://leetcode.cn/problems/choose-edges-to-maximize-score-in-a-tree/）tree_dp
2445（https://leetcode.cn/problems/number-of-nodes-with-value-one/）up_to_down|tree_dp|implemention
834（https://leetcode.cn/problems/sum-of-distances-in-tree/）tree_dis|tree_centroid
2003（https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/）tree_dp|heuristic_merge|classical
2673（https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/）tree_dp|greedy
1367（https://leetcode.cn/problems/linked-list-in-binary-tree/description/）classical|2-tree|linked_list|memory_dp
979（https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/）tree_dp|greedy
1373（https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/）tree_dp|2-tree
971（https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/description/）tree_dp|greedy|implemention
100041（https://www.acwing.com/problem/content/description/4384/）reroot_dp|dfs_order|diff_array
100047（https://leetcode.cn/problems/count-valid-paths-in-a-tree/description/）tree_dp|union_find|bfs
3241（https://leetcode.cn/problems/time-taken-to-mark-all-nodes/）reroot_dp|classical

=====================================LuoGu======================================
P1395（https://www.luogu.com.cn/problem/P1395）tree_dis|tree_centroid|reroot_dp|classical|up_to_down|down_to_up
P1352（https://www.luogu.com.cn/problem/P1352）tree_dp|mis|maximum_independent_set
P1922（https://www.luogu.com.cn/problem/P1922）tree_dp|greedy
P2016（https://www.luogu.com.cn/problem/P2016）tree_dp|classical
P1122（https://www.luogu.com.cn/problem/P1122）tree_dp|union_find
P2932（https://www.luogu.com.cn/problem/P2932）tree_dp|greedy
P2996（https://www.luogu.com.cn/problem/P2996）tree_dp
P3074（https://www.luogu.com.cn/problem/P3074）longest_path|tree_dp
P3884（https://www.luogu.com.cn/problem/P3884）tree_dp
P3915（https://www.luogu.com.cn/problem/P3915）recursion|union_find|brute_force
P4615（https://www.luogu.com.cn/problem/P4615）tree_dp
P5002（https://www.luogu.com.cn/problem/P5002）tree_dp|inclusion_exclusion|counter
P5651（https://www.luogu.com.cn/problem/P5651）brain_teaser|union_find|tree_dp|simple_path_xor
P6591（https://www.luogu.com.cn/problem/P6591）reroot_dp|recursion
P7159（https://www.luogu.com.cn/problem/P7159）tree_dp|brute_force|counter|fast_power
P2015（https://www.luogu.com.cn/problem/P2015）tree_dp|tree_bag_dp
P2014（https://www.luogu.com.cn/problem/P2014）tree_dp
P4316（https://www.luogu.com.cn/problem/P4316）reverse_graph|topological_sort|dag_dp
P1351（https://www.luogu.com.cn/problem/P1351）tree_dp
P3408（https://www.luogu.com.cn/problem/P3408）tree_dp
P3478（https://www.luogu.com.cn/problem/P3478）tree_centroid
P3931（https://www.luogu.com.cn/problem/P3931）classical|tree_dp
P4084（https://www.luogu.com.cn/problem/P4084）classical|tree_dp
P4395（https://www.luogu.com.cn/problem/P4395）tree_dp|greedy
P5765（https://www.luogu.com.cn/problem/P5765）tree_dp|P4395
P8602（https://www.luogu.com.cn/problem/P8602）tree_diameter|bfs|tree_dp
P8625（https://www.luogu.com.cn/problem/P8625）tree_dp|classical
P8744（https://www.luogu.com.cn/problem/P8744）tree_dp
P3047（https://www.luogu.com.cn/problem/P3047）reroot_dp|classical
U420033（https://www.luogu.com.cn/problem/U420033）reroot_dp|classical

====================================AtCoder=====================================
ABC222F（https://atcoder.jp/contests/abc222/tasks/abc222_f）reroot_dp
ABC333D（https://atcoder.jp/contests/abc333/tasks/abc333_d）tree_dp|greedy
ABC329F（https://atcoder.jp/contests/abc329/tasks/abc329_f）heuristic_merge|classical|implemention
ABC348E（https://atcoder.jp/contests/abc348/tasks/abc348_e）reroot_dp|classical
ABC259F（https://atcoder.jp/contests/abc259/tasks/abc259_f）tree_dp|brain_teaser|greedy
ABC239E（https://atcoder.jp/contests/abc239/tasks/abc239_e）tree_dp|classical
ABC222F（https://atcoder.jp/contests/abc222/tasks/abc222_f）reroot_dp|classical
ABC220F（https://atcoder.jp/contests/abc220/tasks/abc220_f）reroot_dp|classical
ABC218F（https://atcoder.jp/contests/abc218/tasks/abc218_f）tree_dp|game_dp|implemention|dfs_order|median
ABC359G（https://atcoder.jp/contests/abc359/tasks/abc359_g）heuristic_merge|classical

===================================CodeForces===================================
1388C（https://codeforces.com/problemset/problem/1388/C）tree_dp|implemention|recursion|down_to_up|up_to_down
1324F（https://codeforces.com/problemset/problem/1324/F）reroot_dp|dfs|down_to_up|up_to_down
337D（https://codeforces.com/problemset/problem/337/D）reroot_dp|dfs|down_to_up|up_to_down
1187E（https://codeforces.com/problemset/problem/1187/E）reroot_dp|dfs|down_to_up|up_to_down
600E（https://codeforces.com/problemset/problem/600/E）dfs_order|heuristic_merge
1676G（https://codeforces.com/contest/1676/problem/G）tree_dp
1822F（https://codeforces.com/contest/1822/problem/F）tree_dis|reroot_dp|down_to_up|up_to_down
219D（https://codeforces.com/contest/219/problem/D）reroot_dp|dfs_order|diff_array
1092F（https://codeforces.com/contest/1092/problem/F）tree_dis|reroot_dp
1472G（https://codeforces.com/contest/1472/problem/G）shortest_path|dfs|down_to_up|up_to_down|brain_teaser
1833G（https://codeforces.com/contest/1833/problem/G）tree_dp|construction
1881F（https://codeforces.com/contest/1881/problem/F）reroot_dp|tree_dp
1926G（https://codeforces.com/contest/1926/problem/G）tree_dp|classical
161D（https://codeforces.com/problemset/problem/161/D）tree_dp|counter
1923E（https://codeforces.com/contest/1923/problem/E）heuristic_merge|tree_dp|counter|classical
1984E（https://codeforces.com/contest/1984/problem/E）reroot_dp|mis|maximum_independent_set
1363E（https://codeforces.com/problemset/problem/1363/E）greedy|implemention|observation
1406C（https://codeforces.com/problemset/problem/1406/C）link_cut_centroids|tree_centroids|greedy|implemention|construction|classical
461B（https://codeforces.com/problemset/problem/461/B）classical|tree_dp|observation
1551F（https://codeforces.com/problemset/problem/1551/F）tree_dp|bag_dp|brute_force
486D（https://codeforces.com/problemset/problem/486/D）multiplication_method|tree_dp|contribution_method|brute_force
1988D（https://codeforces.com/problemset/problem/1988/D）tree_dp|classical|observation|data_range
1101D（https://codeforces.com/problemset/problem/1101/D）tree_dp|prime_factor|classical|observation
1997D（https://codeforces.com/problemset/problem/1997/D）tree_dp|greedy
1083A（https://codeforces.com/problemset/problem/1083/A）tree_dp|greedy|implemention|weighted_tree|classical
982C（https://codeforces.com/problemset/problem/982/C）tree_dp|greedy|classical
1856E1（https://codeforces.com/problemset/problem/1856/E1）tree_dp|greedy|down_to_up|classical
1153D（https://codeforces.com/problemset/problem/1153/D）tree_dp|greedy|brain_teaser
274B（https://codeforces.com/problemset/problem/274/B）tree_dp|greedy|brain_teaser|classical
369C（https://codeforces.com/contest/369/problem/C）tree_dp|greedy|classical

=====================================AcWing=====================================
3760（https://www.acwing.com/problem/content/description/3763/）brain_teaser|tree_dp
4381（https://www.acwing.com/problem/content/description/4384/）reroot_dp|dfs|dfs_order|diff_array

"""
import math
from collections import deque, Counter
from functools import lru_cache
from typing import List, Optional

from src.basis.tree_node.template import TreeNode
from src.data_structure.list_node.template import ListNode
from src.data_structure.sorted_list.template import SortedList
from src.dp.tree_dp.template import ReRootDP, WeightedTree
from src.mathmatics.prime_factor.template import PrimeFactor
from src.search.dfs.template import UnWeightedTree
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1676g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1676/problem/G
        tag: tree_dp
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            parent = ac.read_list_ints_minus_one()
            color = ac.read_str()
            dct = [[] for _ in range(n)]
            for i in range(n - 1):
                dct[parent[i]].append(i + 1)
            ans = 0
            sub = [0] * n
            stack = [0]
            while stack:
                i = stack.pop()
                if i >= 0:
                    stack.append(~i)
                    stack.extend(dct[i])
                else:
                    i = ~i
                    x = sum(sub[j] for j in dct[i])
                    x += 1 if color[i] == "B" else -1
                    sub[i] = x
                    ans += x == 0
            ac.st(ans)
        return

    @staticmethod
    def lc_2003(parents: List[int], nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree/
        tag: tree_dp|heuristic_merge|classical
        """
        n = len(nums)
        dct = [[] for _ in range(n)]
        for i in range(1, n):
            dct[parents[i]].append(i)

        sub = [set() for _ in range(n)]
        stack = [0]
        ans = [-1] * n
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                stack.extend(dct[i])
            else:
                i = ~i
                x = 1
                pre = {nums[i]}
                for j in dct[i]:
                    cur = sub[j]
                    if len(cur) > len(pre):
                        pre, cur = cur, pre
                    pre.update(cur)
                    sub[j] = set()
                    if ans[j] > x:
                        x = ans[j]
                while x in pre:
                    x += 1
                ans[i] = x
                sub[i] = pre
        return ans

    @staticmethod
    def cf_1388c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1388/C
        tag: tree_dp|implemention|recursion|down_to_up|up_to_down
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            person = ac.read_list_ints()
            h = ac.read_list_ints()
            edge = [[] for _ in range(n)]
            for _ in range(n - 1):
                x, y = ac.read_list_ints_minus_one()
                edge[x].append(y)
                edge[y].append(x)

            ans = 1
            pos = [0] * n
            neg = [0] * n
            stack = [(0, -1)]
            while stack and ans:
                i, fa = stack.pop()
                if i >= 0:
                    stack.append((~i, fa))
                    for j in edge[i]:
                        if j != fa:
                            stack.append((j, i))
                else:
                    i = ~i
                    a = b = 0
                    for j in edge[i]:
                        if j != fa:
                            a += pos[j]
                            b += neg[j]
                    if (h[i] + person[i] + b + a) % 2:
                        ans = 0
                        break
                    good = (h[i] + person[i] + b + a) // 2
                    bad = person[i] + a + b - good
                    if good < 0 or bad < 0 or bad > person[i] + b:
                        ans = 0
                        break
                    pos[i] = good
                    neg[i] = bad

            ac.st("YES" if ans else "NO")
        return

    @staticmethod
    def cf_161d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/161/D
        tag: tree_dp|counter
        """
        n, k = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edge[x].append(y)
            edge[y].append(x)

        def idx(ii, jj):
            return ii * (k + 1) + jj

        dp = [0] * (k + 1) * n
        stack = [(0, -1)]
        ans = 0
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in edge[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                for j in edge[i]:
                    if j != fa:
                        for s in range(1, k + 1):
                            dp[idx(i, s)] += dp[idx(j, s - 1)]
                dp[idx(i, 0)] = 1
                ans += dp[idx(i, k)]
                cur = 0
                for j in edge[i]:
                    if j != fa:
                        for s in range(1, k):
                            cur += dp[idx(j, s - 1)] * (dp[idx(i, k - s)] - dp[idx(j, k - s - 1)])
                ans += cur // 2
        ac.st(ans)
        return

    @staticmethod
    def cf_1324f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1324/F
        tag: reroot_dp|dfs|down_to_up|up_to_down
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edge[x].append(y)
            edge[y].append(x)
        sub = [0] * n
        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in edge[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                cur = 2 * a[i] - 1
                for j in edge[i]:
                    if j != fa:
                        cur += max(sub[j], 0)
                sub[i] = cur

        ans = [0] * n
        stack = [(0, -1, 0)]
        while stack:
            i, fa, d = stack.pop()
            ans[i] = d + sub[i]
            for j in edge[i]:
                if j != fa:
                    if sub[j] > 0:
                        nex = sub[i] - sub[j] + d
                    else:
                        nex = sub[i] + d
                    nex = max(nex, 2 * a[i] - 1)
                    stack.append((j, i, max(0, nex)))
        ac.lst(ans)
        return

    @staticmethod
    def cf_337d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/337/D
        tag: reroot_dp|dfs|down_to_up|up_to_down
        """
        n, m, d = ac.read_list_ints()
        sub = [-math.inf] * n
        evil = [0] * n
        for i in ac.read_list_ints_minus_one():
            sub[i] = 0
            evil[i] = 1
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append(v)
            edge[v].append(u)

        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in edge[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                cur = -math.inf
                for j in edge[i]:
                    if j != fa:
                        cur = max(cur, sub[j] + 1)
                sub[i] = max(sub[i], cur)

        stack = [(0, -1, -math.inf)]
        while stack:
            i, fa, up = stack.pop()
            sub[i] = max(sub[i], up)
            if evil[i]:
                up = max(0, up)
            a = b = -math.inf
            for j in edge[i]:
                if j != fa:
                    if sub[j] > a:
                        a, b = sub[j], a
                    elif sub[j] > b:
                        b = sub[j]
            for j in edge[i]:
                if j != fa:
                    if sub[j] == a:
                        stack.append((j, i, max(b + 2, up + 1)))
                    else:
                        stack.append((j, i, max(a + 2, up + 1)))
        ac.st(sum(x <= d for x in sub))
        return

    @staticmethod
    def cf_1092f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1092/problem/F
        tag: tree_dis|reroot_dp
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(y)
            dct[y].append(x)
        ans = ReRootDP().get_tree_distance_weight(dct, nums)
        ac.st(max(ans))
        return

    @staticmethod
    def lc_968(root: Optional[TreeNode]) -> int:
        """
        url: https://leetcode.cn/problems/binary-tree-cameras/
        tag: tree_dp
        """

        # tree_dp
        def dfs(node):
            # 不装被监控，装被监控，不装不被监控
            if not node:
                return [0, math.inf, 0]
            left = dfs(node.left)
            right = dfs(node.right)
            res = [math.inf, math.inf, math.inf]
            res[0] = min(left[1] + min(right[0], right[1]), right[1] + min(left[0], left[1]))
            res[1] = 1 + min(left) + min(right)
            res[2] = left[0] + right[0]
            return res

        ans = dfs(root)
        return min(ans[0], ans[1])

    @staticmethod
    def lc_1367(head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        """
        url: https://leetcode.cn/problems/linked-list-in-binary-tree/description/
        tag: classical|2-tree|linked_list|memory_dp
        """

        # classical二叉树与linked_list|比较的memory_searchDP

        @lru_cache(None)
        def dfs(lst, node):
            if not lst:
                return True
            if not node:
                return False
            if lst.val == node.val:
                if dfs(lst.next, node.left) or dfs(lst.next, node.right):
                    return True
            return dfs(head, node.left) or dfs(head, node.right)

        return dfs(head, root)

    @staticmethod
    def cf_1187e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1187/E
        tag: reroot_dp|dfs|down_to_up|up_to_down
        """
        # reroot_dp题最佳结果
        n = ac.read_int()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append(v)
            edge[v].append(u)

        @ac.bootstrap
        def dfs(i, fa):
            for j in edge[i]:
                if j != fa:
                    yield dfs(j, i)
                    down[i] += down[j]
                    son[i] += son[j]
            son[i] += 1
            down[i] += son[i]
            yield

        down = [0] * n
        son = [0] * n
        dfs(0, -1)

        @ac.bootstrap
        def dfs2(i, fa, pre):
            up[i] = pre
            res = sum(down[j] for j in edge[i] if j != fa)
            for j in edge[i]:
                if j != fa:
                    yield dfs2(j, i, (n - son[j]) + pre + (res - down[j]))
            yield

        up = [0] * n
        dfs2(0, -1, 0)
        ac.st(max(up[i] + (down[i] - son[i]) + n for i in range(n)))
        return

    @staticmethod
    def cf_600e_bfs(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/600/E
        tag: dfs_order|heuristic_merge
        """
        # 自下而上recursion的迭代写法，从小到大heuristic_merge
        n = ac.read_int()
        colors = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            edge[i].append(j)
            edge[j].append(i)
        # dfs_order自下而上以及父子信息获取
        stack = [[0, -1]]
        parent = [-1] * n
        down_to_up_order = []
        while stack:
            i, fa = stack.pop()
            down_to_up_order.append(i)
            for j in edge[i]:
                if j != fa:
                    stack.append([j, i])
                    parent[j] = i
        down_to_up_order.reverse()

        # 维护一个最大值的出现次数
        mx = [0] * n
        ans = [0] * n
        dp = [None] * n
        for i in down_to_up_order:
            dp[i] = Counter()
            dp[i][colors[i]] += 1
            mx[i] = 1
            ans[i] = colors[i]
            for j in edge[i]:
                if dp[j]:
                    if len(dp[j]) > len(dp[i]):
                        # 从小到大
                        dp[i], dp[j] = dp[j], dp[i]
                        mx[i] = mx[j]
                        ans[i] = ans[j]
                    for w in dp[j]:
                        # heuristic_merge
                        dp[i][w] += dp[j][w]
                        if dp[i][w] == mx[i]:
                            ans[i] += w
                        elif dp[i][w] > mx[i]:
                            mx[i] = dp[i][w]
                            ans[i] = w
                    # 及时清空
                    dp[j] = None
        ac.lst(ans)
        return

    @staticmethod
    def cf_600e_dfs(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/600/E
        tag: dfs_order|heuristic_merge
        """
        # 自下而上recursion的recursion写法，从小到大heuristic_merge
        n = ac.read_int()
        nums = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append(v)
            edge[v].append(u)

        @ac.bootstrap
        def dfs(i, fa):
            dp[i] = Counter()
            dp[i][nums[i]] += 1
            ceil[i] = 1
            cur = nums[i]
            for j in edge[i]:
                if j != fa:
                    yield dfs(j, i)
                    if len(dp[j]) > len(dp[i]):
                        dp[i], dp[j] = dp[j], dp[i]
                        cur = ans[j]
                        ceil[i] = ceil[j]
                    for num in dp[j]:
                        dp[i][num] += dp[j][num]
                        if dp[i][num] > ceil[i]:
                            ceil[i] = dp[i][num]
                            cur = num
                        elif dp[i][num] == ceil[i]:
                            cur += num
                    dp[j] = None
            ans[i] = cur
            yield

        dp = [None] * n
        ans = [0] * n
        ceil = [0] * n
        dfs(0, -1)
        ac.lst(ans)
        return

    @staticmethod
    def lg_p1395_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1395
        tag: tree_dis|tree_centroid|reroot_dp|classical|up_to_down|down_to_up
        """
        # tree_centroid为最大子树节点数最小
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints()
            dct[i - 1].append(j - 1)
            dct[j - 1].append(i - 1)

        root = ReRootDP().get_tree_centroid(dct)

        def bfs_diameter(src):
            ans = 0
            stack = [[src, 0]]
            parent = [-1] * n
            while stack:
                u, dis = stack.pop()
                ans += dis
                for v in dct[u]:
                    if v != parent[u]:
                        parent[v] = u
                        stack.append([v, dis + 1])
            return ans

        ac.lst([root + 1, bfs_diameter(root)])
        return

    @staticmethod
    def lg_p1395_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1395
        tag: tree_dis|tree_centroid|reroot_dp|classical|up_to_down|down_to_up
        """
        # tree_centroid为距离其余所有节点
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints()
            dct[i - 1].append(j - 1)
            dct[j - 1].append(i - 1)

        ans = ReRootDP().get_tree_distance(dct)
        dis = min(ans)
        ac.lst([ans.index(dis) + 1, dis])
        return

    @staticmethod
    def cf_1822f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1822/problem/F
        tag: tree_dis|reroot_dp|down_to_up|up_to_down
        """
        # 换根 DP 树中节点其余节点最大的距离
        for _ in range(ac.read_int()):
            n, k, c = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)

            dis = ReRootDP().get_tree_distance_max(dct)

            ans = -math.inf
            stack = [[0, 0, -1]]
            while stack:
                i, d, fa = stack.pop()
                cur = dis[i] * k - d
                ans = max(ans, cur)
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, d + c, i])
            ac.st(ans)
        return

    @staticmethod
    def lg_p1352(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1352
        tag: tree_dp|mis|maximum_independent_set
        """

        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]

        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            dct[y].append(x)
            degree[x] += 1

        root = [i for i in range(n) if not degree[i]][0]
        dp = [[0, 0] for _ in range(n)]
        stack = [[root, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                x = nums[i] if nums[i] > 0 else 0
                y = 0
                for j in dct[i]:
                    if j != fa:
                        a, b = dp[j]
                        x += a
                        y += b
                dp[i] = [y, max(x, y)]
        ac.st(max(dp[root]))
        return

    @staticmethod
    def lg_p2015(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2015
        tag: tree_dp|tree_bag_dp
        """
        # tree_dp
        n, q = ac.read_list_ints()
        dct = [dict() for _ in range(n)]
        for _ in range(n - 1):
            x, y, z = ac.read_list_ints()
            dct[x - 1][y - 1] = z
            dct[y - 1][x - 1] = z
        dp = [[0] * (q + 1) for _ in range(n)]
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                if len(dct[i]) > 1:
                    a, b = [x for x in dct[i] if x != fa]
                    for j in range(1, q + 1):
                        cur = max(dp[a][j - 1] + dct[i][a], dp[b][j - 1] + dct[i][b])
                        for k in range(j - 1):
                            cur = max(cur, dp[a][k] + dp[b][j - k - 2] + dct[i][a] + dct[i][b])
                        dp[i][j] = cur
        ac.st(dp[0][q])
        return

    @staticmethod
    def lg_p2014(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2014
        tag: tree_dp
        """
        # tree_dp|bag_dp|
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        nums = [0]
        for i in range(n):
            k, s = ac.read_list_ints()
            nums.append(s)
            dct[k].append(i + 1)
        dp = [[0] * (m + 2) for _ in range(n + 1)]
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                dp[i][1] = nums[i]
                for j in dct[i]:
                    if j != fa:
                        cur = dp[i][:]
                        for x in range(1, m + 2):
                            for y in range(m + 2 - x):
                                cur[x + y] = max(cur[x + y], dp[i][x] + dp[j][y])
                        dp[i] = cur[:]
        ac.st(dp[0][m + 1])
        return

    @staticmethod
    def lg_p4316(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4316
        tag: reverse_graph|topological_sort|dag_dp
        """
        # reverse_graph|topological_sorting树形prob_dp
        n, m = ac.read_list_ints()
        dp = [0 for _ in range(n)]
        degree = [0] * n
        dct = [dict() for _ in range(n)]
        for _ in range(m):
            a, b, w = ac.read_list_ints()
            a -= 1
            b -= 1
            dct[b][a] = w
            degree[a] += 1
        cnt = degree[:]

        stack = deque([n - 1])
        while stack:
            i = stack.popleft()
            len(dct[i])
            a = dp[i]
            for j in dct[i]:
                dp[j] += a + dct[i][j]
                degree[j] -= 1
                if not degree[j]:
                    dp[j] /= cnt[j]
                    stack.append(j)
        ans = "%.2f" % (dp[0])
        ac.st(ans)
        return

    @staticmethod
    def lg_p1351(ac=FastIO()):
        # tree_dp
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        nums = ac.read_list_ints()
        ceil = ans = 0
        mod = 10007
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            lst = []
            if fa != -1:
                lst.append(nums[fa])
            for j in dct[i]:
                if j != fa:
                    stack.append([j, i])
                    lst.append(nums[j])
            if lst:

                s = sum(lst)
                a = b = 0
                for num in lst:
                    ans += num * (s - num)
                    ans %= mod
                    if num > a:
                        a, b = num, a
                    elif num > b:
                        b = num
                ceil = max(ceil, a * b)

        ac.lst([ceil, ans])
        return

    @staticmethod
    def lg_3408(ac=FastIO()):

        # tree_dp| implemention
        n, t, c = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        nums = [c]
        for i in range(n):
            b, a = ac.read_list_ints()
            dct[b].append(i + 1)
            nums.append(a)

        stack = [0]
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                for j in dct[i]:
                    stack.append(j)
            else:
                i = ~i
                if not dct[i]:
                    continue
                else:
                    # 收到子树下属的最少花费
                    if nums[i] > t:
                        continue

                    # 需要最少的 x 个下属花费
                    x = math.ceil(len(dct[i]) * nums[i] / t)
                    lst = []
                    for j in dct[i]:
                        lst.append(nums[j])
                    lst.sort()
                    nums[i] = sum(lst[:x])
        ac.st(nums[0])
        return

    @staticmethod
    def lg_p3478(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3478
        tag: tree_centroid
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        dis = ReRootDP().get_tree_distance(dct)
        ind = 0
        for i in range(1, n):
            if dis[i] > dis[ind]:
                ind = i
        ac.st(ind + 1)
        return

    @staticmethod
    def lg_p3931(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3931
        tag: classical|tree_dp
        """
        # tree_dp| implemention
        n, root = ac.read_list_ints()
        root -= 1
        dct = [dict() for _ in range(n)]
        for _ in range(n - 1):
            i, j, c = ac.read_list_ints_minus_one()
            c += 1
            dct[i][j] = dct[j][i] = c
        stack = [[root, -1]]
        sub = [math.inf] * n
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                if len(dct[i]) == 1 and i != root:
                    continue
                res = 0
                for j in dct[i]:
                    if j != fa:
                        res += min(dct[i][j], sub[j])
                sub[i] = res
        ac.st(sub[root] if sub[root] < math.inf else 0)
        return

    @staticmethod
    def lg_p4395(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4395
        tag: tree_dp|greedy
        """
        # tree_dp| greedy标权值使得整棵树总价值最小
        n = ac.read_int()
        ceil = int(math.log2(n)) + 1
        sub = [[math.inf] * (ceil + 1) for _ in range(n)]
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)

        # 迭代写法
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                cur = [0] * (ceil + 1)
                for j in dct[i]:
                    if j != fa:
                        # 记录子树最小的两个值
                        a = b = math.inf
                        for c in sub[j][1:]:
                            if c < a:
                                a, b = c, a
                            elif c < b:
                                b = c
                        # 记录 i 赋值为 x 时的子树价值和
                        for x in range(1, ceil + 1):
                            if sub[j][x] == a:
                                cur[x] += b
                            else:
                                cur[x] += a
                for x in range(1, ceil + 1):
                    sub[i][x] = x + cur[x]
        ac.st(min(sub[0][1:]))
        return

    @staticmethod
    def lg_p8625(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8625
        tag: tree_dp|classical
        """
        # tree_dp| classical
        n = ac.read_int()
        nums = ac.read_list_ints()
        sub = [0] * n
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                res = 0
                for j in dct[i]:
                    if j != fa:
                        res += sub[j]
                res += nums[i]
                sub[i] = res if res > 0 else 0
        ac.st(max(sub))
        return

    @staticmethod
    def lc_1617_2(n: int, edges: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/
        tag: brute_force|tree_diameter|tree_dp
        """
        # brute_forcetree_diameter端点与乘法原理tree_dp
        dct = [[] for _ in range(n)]
        for i, j in edges:
            i -= 1
            j -= 1
            dct[i].append(j)
            dct[j].append(i)

        dis = []
        for i in range(n):
            cur = [math.inf] * n
            cur[i] = 0
            stack = deque([i])
            while stack:
                i = stack.pop()
                for j in dct[i]:
                    if cur[j] == math.inf:
                        cur[j] = cur[i] + 1
                        stack.append(j)
            dis.append(cur[:])

        ans = [0] * n
        for i in range(n):
            for j in range(i + 1, n):
                d = dis[i][j]

                stack = [[i, -1]]
                sub = [0] * n
                while stack:
                    ii, fa = stack.pop()
                    if ii >= 0:
                        stack.append([~ii, fa])
                        for jj in dct[ii]:
                            if jj != fa:
                                if (dis[i][jj] < d or (dis[i][jj] == d and jj > j)) and \
                                        (dis[j][jj] < d or (dis[j][jj] == d and jj > i)):
                                    stack.append([jj, ii])
                    else:
                        ii = ~ii
                        sub[ii] = 1  # x是必点
                        for jj in dct[ii]:
                            if jj != fa:
                                if (dis[i][jj] < d or (dis[i][jj] == d and jj > j)) and \
                                        (dis[j][jj] < d or (dis[j][jj] == d and jj > i)):
                                    sub[ii] *= sub[jj]
                        if dis[i][ii] + dis[j][ii] > d:  # x 是可选点
                            sub[ii] += 1
                ans[d] += sub[i]

        return ans[1:]

    @staticmethod
    def ac_3760(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3763/
        tag: brain_teaser|tree_dp
        """
        # brain_teaser转化为tree_dp迭代方式求解
        n = ac.read_int()
        w = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v, c = ac.read_list_ints()
            u -= 1
            v -= 1
            dct[u].append([v, c])
            dct[v].append([u, c])
        ans = 0

        stack = [[0, -1]]
        sub = [0 for _ in range(n)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j, cc in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i

                d1, d2 = 0, 0
                for j, cc in dct[i]:
                    if j != fa:
                        d = sub[j] - cc
                        if d >= d1:
                            d1, d2 = d, d1
                        elif d >= d2:
                            d2 = d
                if d1 + d2 + w[i] > ans:
                    ans = d1 + d2 + w[i]
                sub[i] = d1 + w[i]
        ac.st(ans)
        return

    @staticmethod
    def ac_4381(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4384/
        tag: reroot_dp|dfs|dfs_order|diff_array
        """
        # 迭代法实现树形reroot_dp
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append([y, 0])
            dct[y].append([x, 1])

        # 第一遍DP子节点的影响，从上到下再从下到上累|
        sub = [0] * n
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j, w in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                cur = 0
                for j, w in dct[i]:
                    if j != fa:
                        cur += sub[j] + w
                sub[i] = cur

        # 第二遍DP祖先节点与兄弟节点的影响
        stack = [[0, -1, 0]]
        while stack:
            i, fa, pre = stack.pop()
            cur = sub[i]
            sub[i] += pre
            for j, w in dct[i]:
                if j != fa:
                    stack.append([j, i, pre + cur - sub[j] - w + 1 - w])

        x = min(sub)
        ac.st(x)
        res = [i + 1 for i in range(n) if sub[i] == x]
        ac.lst(res)
        return

    @staticmethod
    def lc_100041(n: int, edges: List[List[int]]) -> List[int]:
        # 一遍DFS迭代实现树形reroot_dp
        dct = [[] for _ in range(n)]
        for x, y in edges:
            dct[x].append([y, 1])
            dct[y].append([x, 0])

        sub_cnt = [0] * n
        sub_one = [0] * n
        pre_cnt = [0] * n
        pre_one = [0] * n
        stack = [[0, -1]]
        while stack:
            x, fa = stack.pop()
            if x >= 0:
                stack.append([~x, fa])
                for y, w in dct[x]:
                    if y != fa:
                        pre_cnt[y] = pre_cnt[x] + 1
                        pre_one[y] = pre_one[x] + w
                        stack.append([y, x])
            else:
                x = ~x
                sub_cnt[x] = 1
                for y, w in dct[x]:
                    if y != fa:
                        sub_cnt[x] += sub_cnt[y]
                        sub_one[x] += sub_one[y] + w
        ans = [pre_one[i] + (sub_cnt[i] - sub_one[i]) + (
                n - 1 - pre_cnt[i] - sub_cnt[i] - (sub_one[0] - sub_one[i] - pre_one[i])) for i in range(n)]
        return ans

    @staticmethod
    def lc_2673(n: int, cost: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/
        tag: tree_dp|greedy
        """
        # tree_dpgreedy
        ans = 0
        for i in range(n // 2, 0, -1):
            left = cost[i * 2 - 1]
            right = cost[i * 2]
            if left > right:
                cost[i - 1] += left
                ans += left - right
            else:
                cost[i - 1] += right
                ans += right - left
        return ans

    @staticmethod
    def cf_1926g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1926/problem/G
        tag: tree_dp|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            p = [0] + ac.read_list_ints_minus_one()
            s = ac.read_str()
            dpp = [0] * n
            dps = [0] * n
            for i in range(n - 1, -1, -1):
                if s[i] == "P":
                    dps[i] = n
                if s[i] == "S":
                    dpp[i] = n
                pp = p[i]
                if i:
                    dpp[pp] += min(dpp[i], dps[i] + 1)
                    dps[pp] += min(dps[i], dpp[i] + 1)
            ac.st(min(dpp[0], dps[0]))
        return

    @staticmethod
    def cf_1923e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1923/problem/E
        tag: heuristic_merge|tree_dp|counter|classical
        """
        ac.get_random_seed()
        for _ in range(ac.read_int()):
            n = ac.read_int()
            c = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)

            sub = [dict() for _ in range(n)]
            ind = list(range(n))
            stack = [(0, -1)]
            ans = 0
            while stack:
                x, fa = stack.pop()
                if x >= 0:
                    stack.append((~x, fa))
                    for y in dct[x]:
                        if y != fa:
                            stack.append((y, x))
                else:
                    x = ~x
                    xx = x
                    cc = c[x] ^ ac.random_seed
                    cur = ind[x]
                    for y in dct[x]:
                        if y != fa:
                            ans += sub[ind[y]].get(cc, 0)
                            if len(sub[ind[y]]) > len(sub[cur]):
                                for x in sub[cur]:
                                    if x != cc:
                                        ans += sub[cur][x] * sub[ind[y]].get(x, 0)
                                for x in sub[cur]:
                                    sub[ind[y]][x] = sub[ind[y]].get(x, 0) + sub[cur][x]
                                cur = ind[y]
                            else:
                                for x in sub[ind[y]]:
                                    if x != cc:
                                        ans += sub[ind[y]][x] * sub[cur].get(x, 0)
                                for x in sub[ind[y]]:
                                    sub[cur][x] = sub[cur].get(x, 0) + sub[ind[y]][x]
                    ind[xx] = cur
                    sub[cur][cc] = 1
            ac.st(ans)
        return

    @staticmethod
    def lg_p3047(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3047
        tag: reroot_dp|classical
        """
        n, k = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            dct[u].append(v)
            dct[v].append(u)
        c = [ac.read_int() for _ in range(n)]
        sub = [[0] * k for _ in range(n)]
        k += 1
        stack = [(0, -1)]
        while stack:
            x, fa = stack.pop()
            if x >= 0:
                stack.append((~x, fa))
                for y in dct[x]:
                    if y != fa:
                        stack.append((y, x))
            else:
                x = ~x
                cur = [0] * k
                for y in dct[x]:
                    if y != fa:
                        for j in range(k - 1):
                            cur[j + 1] += sub[y][j]
                cur[0] += c[x]
                sub[x] = cur[:]

        stack = [[0, -1, [0] * k]]
        while stack:
            x, fa, pre = stack.pop()
            for j in range(k):
                sub[x][j] += pre[j]
            for y in dct[x]:
                if y != fa:
                    for j in range(k - 1):
                        pre[j + 1] += sub[y][j]

            for y in dct[x]:
                if y != fa:
                    nex = pre[:]
                    for j in range(k - 1):
                        nex[j + 1] -= sub[y][j]
                    nex = [0] + nex[:-1]
                    nex[1] += c[x]
                    stack.append([y, x, nex])
        for ls in sub:
            ac.st(sum(ls))
        return

    @staticmethod
    def lg_u420033(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/U420033
        tag: reroot_dp|classical
        """

        def standard_procedure(n: int) -> int:
            dct = [[] for _ in range(n)]
            for i, j, w in edges:
                dct[i].append((j, w))
                dct[j].append((i, w))
            father = [-1] * n
            stack = [(0, -1)]
            sub = [[0, 0, 0] for _ in range(n)]
            dia = [0] * n
            while stack:
                x, fa = stack.pop()
                if x >= 0:
                    stack.append((~x, fa))
                    for y, w in dct[x]:
                        if y != fa:
                            stack.append((y, x))
                            father[y] = x
                else:
                    x = ~x
                    a = b = c = d = 0
                    for y, ww in dct[x]:
                        if y != fa:
                            for w in sub[y][:1]:
                                if w + ww >= a:
                                    a, b, c = w + ww, a, b
                                elif w + ww >= b:
                                    b, c = w + ww, b
                                elif w + ww >= c:
                                    c = w + ww
                            d = max(d, dia[y])
                    sub[x] = [a, b, c]
                    d = max(d, a + b)
                    dia[x] = d

            ans = math.inf
            stack = [(0, -1, 0, 0)]
            while stack:
                x, fa, pre, pre_dia = stack.pop()
                a, b, c = sub[x]
                aa = bb = -math.inf
                for y, _ in dct[x]:
                    if y != fa:
                        dd = dia[y]
                        if dd >= aa:
                            aa, bb = dd, aa
                        elif dd >= bb:
                            bb = dd
                for y, w in dct[x]:
                    if y != fa:
                        down = dia[y]
                        if sub[y][0] == a - w:
                            up = max(pre + b, b + c, pre_dia)
                            nex = max(pre, b) + w
                            nex_dia = max(pre_dia, pre + b, b + w, b + c)
                        elif sub[y][0] == b - w:
                            up = max(pre + a, a + c, pre_dia)
                            nex = max(pre, a) + w
                            nex_dia = max(pre_dia, pre + a, a + w, a + c)
                        else:
                            up = max(pre + a, a + b, pre_dia)
                            nex = max(pre, a) + w
                            nex_dia = max(pre_dia, pre + a, a + w, a + b)
                        if dia[y] == aa:
                            up = max(up, bb)
                            nex_dia = max(nex_dia, bb)
                        else:
                            up = max(up, aa)
                            nex_dia = max(nex_dia, aa)
                        ans = min(ans, abs(up - down))
                        stack.append((y, x, nex, nex_dia))
            return ans

        n = ac.read_int()
        edges = [ac.read_list_ints() for _ in range(n - 1)]
        ac.st(standard_procedure(n))
        return

    @staticmethod
    def abc_348e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc348/tasks/abc348_e
        tag: reroot_dp|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            a, b = ac.read_list_ints_minus_one()
            dct[a].append(b)
            dct[b].append(a)
        weight = ac.read_list_ints()
        ans = ReRootDP().get_tree_distance_weight(dct, weight)
        ac.st(min(ans))
        return

    @staticmethod
    def abc_259f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc259/tasks/abc259_f
        tag: tree_dp|brain_teaser|greedy
        """
        n = ac.read_int()
        d = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for i in range(n - 1):
            u, v, w = ac.read_list_ints_minus_one()
            w += 1
            dct[u].append((v, w))
            dct[v].append((u, w))
        sub = [(0, 0) for _ in range(n)]
        stack = [(0, -1)]
        while stack:
            x, fa = stack.pop()
            if x >= 0:
                stack.append((~x, fa))
                for y, _ in dct[x]:
                    if y != fa:
                        stack.append((y, x))
            else:
                x = ~x
                pos = 0
                son = []
                for y, w in dct[x]:
                    if y != fa:
                        a, b = sub[y]
                        diff = w + b - a
                        pos += a
                        if diff > 0 and d[y]:
                            son.append(diff)
                son.sort(reverse=True)
                if d[x]:
                    a = pos + sum(son[:d[x]])
                    sub[x] = (a, a - son[d[x] - 1] if len(son) >= d[x] else a)
                else:
                    sub[x] = (pos, 0)
        ac.st(max(sub[0]))
        return

    @staticmethod
    def abc_222f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc222/tasks/abc222_f
        tag: reroot_dp|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j, w = ac.read_list_ints()
            i -= 1
            j -= 1
            dct[i].append((j, w))
            dct[j].append((i, w))
        d = ac.read_list_ints()

        sub = [0] * n
        stack = [[0, -1]]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j, w in dct[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                cur = 0
                for j, w in dct[i]:
                    if j != fa:
                        cur = max(cur, max(sub[j], d[j]) + w)
                sub[i] = cur

        ans = [0] * n
        stack = [[0, -1, 0]]
        while stack:
            i, fa, pre = stack.pop()

            ans[i] = max(pre, sub[i])
            aa = bb = -math.inf
            for j, w in dct[i]:
                if j != fa:
                    cur = max(sub[j], d[j]) + w
                    if cur > aa:
                        aa, bb = cur, aa
                    elif cur > bb:
                        bb = cur
            for j, w in dct[i]:
                if j != fa:
                    cur = max(sub[j], d[j]) + w
                    if cur == aa:
                        stack.append((j, i, max(pre, bb, d[i]) + w))
                    else:
                        stack.append((j, i, max(pre, aa, d[i]) + w))
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_220f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc220/tasks/abc220_f
        tag: reroot_dp|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        ans = ReRootDP().get_tree_distance_weight(dct, [1] * n)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_218f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc218/tasks/abc218_f
        tag: tree_dp|game_dp|implemention|dfs_order|median
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        depth = [0] * n

        def find_median():
            k = len(lst)
            if k % 2:
                return lst[k // 2]
            return (lst[k // 2] + lst[k // 2 - 1]) // 2

        lst = SortedList()
        stack = [(0, -1)]
        sub = [0] * n
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                lst.add(nums[i])
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        depth[j] = depth[i] + 1
                        stack.append((j, i))
            else:
                i = ~i
                d = depth[i]
                nex = []
                for j in dct[i]:
                    if j != fa:
                        nex.append(sub[j])
                if not nex:
                    sub[i] = find_median()
                else:
                    if d % 2 == 0:
                        sub[i] = max(nex)
                    else:
                        sub[i] = min(nex)
                lst.discard(nums[i])
        ans = sub[0]
        ac.st(ans)
        return

    @staticmethod
    def cf_1984e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1984/problem/E
        tag: reroot_dp|mis|maximum_independent_set
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            dct = [[] for _ in range(n)]
            degree = [0] * n
            for _ in range(n - 1):
                x, y = ac.read_list_ints_minus_one()
                dct[y].append(x)
                dct[x].append(y)
                degree[x] += 1
                degree[y] += 1
            ans = [0] * n
            dp = [(0, 0) for _ in range(n)]  # not_include or include
            stack = [(0, -1)]
            while stack:
                i, fa = stack.pop()
                if i >= 0:
                    stack.append((~i, fa))
                    for j in dct[i]:
                        if j != fa:
                            stack.append((j, i))
                else:
                    i = ~i
                    x = 1
                    y = 0
                    for j in dct[i]:
                        if j != fa:
                            a, b = dp[j]
                            x += a
                            y += b
                    dp[i] = (y, max(x, y))
                    ans[i] = y + 1 if degree[i] == 1 else y

            stack = [(0, -1, 0, 0)]
            while stack:
                i, fa, pre_a, pre_b = stack.pop()
                ans[i] += pre_b
                lst = [j for j in dct[i] if j != fa]
                aa = sum(dp[j][0] for j in lst)
                bb = sum(dp[j][1] for j in lst)
                for j in lst:
                    nex_aa = aa - dp[j][0] + pre_a + 1
                    nex_bb = bb - dp[j][1] + pre_b
                    stack.append((j, i, nex_bb, max(nex_bb, nex_aa)))
            ac.st(max(ans))
        return

    @staticmethod
    def abc_359g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc359/tasks/abc359_g
        tag: heuristic_merge|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            dct[u].append(v)
            dct[v].append(u)
        nums = ac.read_list_ints_minus_one()
        tot = Counter(nums)
        stack = [(0, -1)]
        ans = 0
        sub = [dict() for _ in range(n)]
        index = list(range(n))
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                ind = index[i]
                sub[ind][nums[i]] = (0, 1)
                for j in dct[i]:
                    if j != fa:
                        xj = index[j]
                        for p in sub[xj]:
                            if p in sub[ind]:
                                dis, cnt = sub[xj][p]
                                dis0, cnt0 = sub[ind].get(p, (0, 0))
                                ans += dis * cnt0 + dis0 * cnt
                        if len(sub[xj]) > len(sub[ind]):
                            nex = ind
                            ind = xj
                        else:
                            nex = xj
                        for p, (dis, cnt) in sub[nex].items():
                            if p in sub[ind]:
                                dis0, cnt0 = sub[ind].get(p, (0, 0))
                                sub[ind][p] = (dis + dis0, cnt + cnt0)
                            else:
                                sub[ind][p] = (dis, cnt)
                        sub[nex] = None
                for p in list(sub[ind].keys()):
                    if tot[p] == sub[ind][p][1]:
                        del sub[ind][p]
                    dis, cnt = sub[ind][p]
                    sub[ind][p] = dis + cnt, cnt

                index[i] = ind
        ac.st(ans)
        return

    @staticmethod
    def cf_1363e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1363/E
        tag: greedy|implemention|observation
        """
        n = ac.read_int()
        a = []
        b = []
        c = []
        for _ in range(n):
            x, y, z = ac.read_list_ints()
            a.append(x)
            b.append(y)
            c.append(z)
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        stack = [(0, -1)]
        sub = [0 for _ in range(n)]
        ans = 0
        while stack:
            x, fa = stack.pop()
            if x >= 0:
                stack.append((~x, fa))
                for y in dct[x]:
                    if y != fa:
                        a[y] = min(a[y], a[x])
                        stack.append((y, x))
            else:
                x = ~x
                pos = neg = 0
                if b[x] and not c[x]:
                    pos += 1
                elif not b[x] and c[x]:
                    neg += 1
                for y in dct[x]:
                    if y != fa:
                        if sub[y] > 0:
                            pos += sub[y]
                        else:
                            neg -= sub[y]
                ans += min(pos, neg) * a[x] * 2
                sub[x] = pos - neg
        ac.st(ans if sub[0] == 0 else -1)
        return

    @staticmethod
    def cf_1406c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1406/C
        tag: link_cut_centroids|tree_centroids|greedy|implemention|construction|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)
            stack = [(0, -1)]
            sub = [1] * n
            parent = [-1] * n
            dp = [0] * n
            depth = [0] * n
            while stack:
                x, fa = stack.pop()
                if x >= 0:
                    stack.append((~x, fa))
                    for y in dct[x]:
                        if y != fa:
                            stack.append((y, x))
                            parent[y] = x
                            depth[y] = depth[x] + 1
                else:
                    x = ~x
                    nex = 0
                    for y in dct[x]:
                        if y != fa:
                            sub[x] += sub[y]
                            nex = max(nex, sub[y])
                    dp[x] = max(nex, n - sub[x])
            floor = min(dp)
            ind = [i for i in range(n) if dp[i] == floor]
            if len(ind) == 1:
                ac.lst([1, dct[0][0] + 1])
                ac.lst([1, dct[0][0] + 1])
            else:
                assert len(ind) == 2
                x, y = ind[0], ind[1]
                if depth[x] > depth[y]:
                    x, y = y, x

                a, fa = y, parent[y]
                while True:
                    for b in dct[a]:
                        if b != fa:
                            a, fa = b, a
                            break
                    else:
                        break
                ac.lst([a + 1, parent[a] + 1])
                ac.lst([a + 1, x + 1])
        return

    @staticmethod
    def cf_461b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/461/B
        tag: classical|tree_dp|observation
        """

        n = ac.read_int()
        p = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for i in range(n - 1):
            dct[i + 1].append(p[i])
            dct[p[i]].append(i + 1)
        dp0 = [0] * n
        dp1 = [0] * n
        color = ac.read_list_ints()
        stack = [(0, -1)]
        mod = 10 ** 9 + 7
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                if color[i]:
                    dp1[i] = 1
                else:
                    dp0[i] = 1
                for j in dct[i]:
                    if j != fa:
                        dp1[i] = (dp1[i] * (dp0[j] + dp1[j]) + dp0[i] * dp1[j]) % mod
                        dp0[i] = dp0[i] * (dp0[j] + dp1[j]) % mod
        ac.st(dp1[0])
        return

    @staticmethod
    def cf_1551f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1551/F
        tag: tree_dp|bag_dp|brute_force
        """
        mod = 10 ** 9 + 7
        for _ in range(ac.read_int()):
            ac.read_str()
            n, k = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)
            if k == 2:
                ac.st(n * (n - 1) // 2)
                continue
            ans = 0
            for i in range(n):
                dis = [-1] * n
                parent = [-1] * n
                stack = [i]
                dis[i] = 0
                while stack:
                    nex = []
                    for x in stack:
                        for y in dct[x]:
                            if dis[y] == -1:
                                dis[y] = dis[x] + 1
                                nex.append(y)
                                if parent[x] != -1:
                                    parent[y] = parent[x]
                                else:
                                    parent[y] = y
                    stack = nex
                group = [[] for _ in range(n)]
                for x in range(n):
                    group[dis[x]].append(x)
                for d in range(1, n):
                    if group[d]:
                        cnt = Counter([parent[x] for x in group[d]])
                        dp = [0] * (k + 1)
                        dp[0] = 1
                        for w in cnt.values():
                            for x in range(k, 0, -1):
                                dp[x] += dp[x - 1] * w
                                dp[x] %= mod
                        ans += dp[-1]
                        ans %= mod
            ac.st(ans % mod)
        return

    @staticmethod
    def lc_3241(edges: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/time-taken-to-mark-all-nodes/
        tag: reroot_dp|classical
        """
        n = len(edges) + 1
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)

        weights = [2 if i % 2 == 0 else 1 for i in range(n)]
        ans = ReRootDP().get_tree_distance_max_weighted(dct, weights)
        return ans

    @staticmethod
    def cf_1988d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1988/D
        tag: tree_dp|classical|observation|data_range
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)
            dp = [[0] * 21 for _ in range(n)]

            stack = [0]
            while stack:
                val = stack.pop()
                if val >= 0:
                    x, fa = val // n, val % n
                    stack.append(~val)
                    for y in dct[x]:
                        if y != fa:
                            stack.append(y * n + x)
                else:
                    val = ~val
                    x, fa = val // n, val % n
                    for i in range(21):
                        dp[x][i] = (i + 1) * nums[x]
                    for y in dct[x]:
                        if y != fa:
                            aa = bb = math.inf
                            for j in range(21):
                                cur = dp[y][j]
                                if cur < aa:
                                    aa, bb = cur, aa
                                elif cur < bb:
                                    bb = cur

                            for i in range(21):
                                dp[x][i] += aa if aa != dp[y][i] else bb
            ans = min(dp[0])
            ac.st(ans)
        return

    @staticmethod
    def cf_1101d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1101/D
        tag: tree_dp|prime_factor|classical|observation
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pf = PrimeFactor(2 * 10 ** 5 + 10)
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        dp = [dict() for _ in range(n)]
        ans = 0
        stack = [0]
        while stack:
            val = stack.pop()
            if val >= 0:
                x, fa = val // n, val % n
                stack.append(~val)
                for y in dct[x]:
                    if y != fa:
                        stack.append(y * n + x)
            else:
                val = ~val
                x, fa = val // n, val % n
                for p, _ in pf.prime_factor[nums[x]]:
                    aa = bb = 0
                    for y in dct[x]:
                        if y != fa:
                            if p in dp[y]:
                                if dp[y][p] >= aa:
                                    aa, bb = dp[y][p], aa
                                elif dp[y][p] > bb:
                                    bb = dp[y][p]
                    ans = max(ans, aa + bb + 1)
                    dp[x][p] = aa + 1
        ac.st(ans)
        return

    @staticmethod
    def cf_1997d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1997/D
        tag: tree_dp|greedy
        """

        class Graph(UnWeightedTree):
            def tree_dp(self, nums):
                ans = [0] * self.n
                stack = [0]
                res = nums[0]
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        cur = math.inf
                        while ind:
                            j = self.edge_to[ind]
                            cur = min(cur, ans[j])
                            ind = self.edge_next[ind]
                        if i == 0:
                            res = max(res, nums[0] + cur)
                        if cur == math.inf:
                            ans[i] = nums[i]
                        elif nums[i] >= cur:
                            ans[i] = cur
                        else:
                            ans[i] = nums[i] + (cur - nums[i]) // 2
                return res

        for _ in range(ac.read_int()):
            n = ac.read_int()
            arr = ac.read_list_ints()
            tree = Graph(n)
            p = ac.read_list_ints_minus_one()
            for k in range(n - 1):
                tree.add_directed_edge(p[k], k + 1)
            final = tree.tree_dp(arr)
            ac.st(final)
        return

    @staticmethod
    def cf_1083a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1083/A
        tag: tree_dp|greedy|implemention|weighted_tree|classical
        """

        class Graph(WeightedTree):
            def tree_dp(self, nums):
                ans = [0] * self.n
                parent = [-1] * self.n
                stack = [0]
                res = max(nums)
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        a = b = 0
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                cur = ans[j] - self.edge_weight[ind]
                                if cur > a:
                                    a, b = cur, a
                                elif cur > b:
                                    b = cur
                            ind = self.edge_next[ind]
                        res = max(res, a + b + nums[i])
                        ans[i] = a + nums[i]
                return res

        n = ac.read_int()
        graph = Graph(n)
        weights = ac.read_list_ints()
        for _ in range(n - 1):
            u, v, c = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(u, v, c + 1)
        final = graph.tree_dp(weights)
        ac.st(final)
        return

    @staticmethod
    def cf_982c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/982/C
        tag: tree_dp|greedy|classical
        """

        class Graph(UnWeightedTree):
            def tree_dp(self, nums):
                ans = [1] * self.n
                parent = [-1] * self.n
                stack = [0]
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                ans[i] += ans[j]
                            ind = self.edge_next[ind]
                res = sum(x % 2 == 0 for x in ans)
                return res - 1

        n = ac.read_int()
        graph = Graph(n)
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(u, v)
        if n % 2:
            ac.st(-1)
        else:
            ac.st(graph.tree_dp([-1]))
        return

    @staticmethod
    def cf_1856e1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1856/E1
        tag: tree_dp|greedy|down_to_up|classical
        """

        class Graph(UnWeightedTree):
            def tree_dp(self, nums):
                ans = [1] * self.n
                parent = [-1] * self.n
                stack = [0]
                res = 0
                dp = [0] * (n + 1)
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        lst = []
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                lst.append(ans[j])
                            ind = self.edge_next[ind]
                        s = sum(lst)
                        for x in range(s + 1):
                            dp[x] = 0
                        dp[0] = 1
                        for num in lst:
                            for x in range(s, num - 1, -1):
                                if dp[x - num]:
                                    dp[x] = 1
                        res += max(x * (s - x) for x in range(s + 1) if dp[x])
                        ans[i] += s
                return res

        n = ac.read_int()
        graph = Graph(n)
        p = ac.read_list_ints_minus_one()
        for u in range(1, n):
            graph.add_undirected_edge(p[u - 1], u)
        final = graph.tree_dp([-1])
        ac.st(final)
        return

    @staticmethod
    def cf_1153d_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1153/D
        tag: tree_dp|greedy|brain_teaser
        """

        class Graph(UnWeightedTree):
            def tree_dp(self, nums):
                ans = [1] * self.n
                parent = [-1] * self.n
                stack = [0]
                leaf = 0
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        lst = []
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                cur = ans[j]
                                lst.append(cur)
                            ind = self.edge_next[ind]
                        if lst:
                            if nums[i] == 0:
                                ans[i] = sum(lst)
                            else:
                                ans[i] = min(lst)
                        else:
                            leaf += 1
                return leaf - ans[0] + 1

        n = ac.read_int()
        graph = Graph(n)
        arr = ac.read_list_ints()
        p = ac.read_list_ints_minus_one()
        for u in range(1, n):
            graph.add_undirected_edge(p[u - 1], u)
        final = graph.tree_dp(arr)
        ac.st(final)
        return

    @staticmethod
    def cf_1153d_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1153/D
        tag: tree_dp|greedy|brain_teaser
        """

        n = ac.read_int()
        dp = [0] * n
        arr = ac.read_list_ints()
        p = ac.read_list_ints_minus_one()
        ans = 0
        for u in range(n - 1, 0, -1):
            if dp[u] == 0:
                dp[u] = 1
                ans += 1
            f = p[u - 1]
            if arr[f] == 0:
                dp[f] += dp[u]
            else:
                dp[f] = dp[u] if dp[f] == 0 else min(dp[f], dp[u])
        ac.st(ans - dp[0] + 1)
        return

    @staticmethod
    def cf_274b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/274/B
        tag: tree_dp|greedy|brain_teaser|classical
        """

        class Graph(UnWeightedTree):
            def tree_dp(self, nums):
                f = [0] * self.n
                g = [0] * self.n
                parent = [-1] * self.n
                stack = [0]
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        ff = gg = 0
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                ff = max(ff, f[j])
                                gg = max(gg, g[j])
                            ind = self.edge_next[ind]
                        k = nums[i] + ff - gg
                        f[i] = ff
                        g[i] = gg
                        if k > 0:
                            g[i] += k
                        else:
                            f[i] -= k
                return f[0] + g[0]

        n = ac.read_int()
        graph = Graph(n)
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(u, v)
        arr = ac.read_list_ints()
        final = graph.tree_dp(arr)
        ac.st(final)
        return

    @staticmethod
    def main(ac=FastIO()):
        """
        url: https://codeforces.com/contest/369/problem/C
        tag: tree_dp|greedy|classical
        """

        class Graph(WeightedTree):
            def tree_dp(self, nums):
                res = []
                ans = [0] * self.n
                parent = [-1] * self.n
                stack = [0]
                while stack:
                    i = stack.pop()
                    if i >= 0:
                        stack.append(~i)
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if j != parent[i]:
                                parent[j] = i
                                stack.append(j)
                            ind = self.edge_next[ind]
                    else:
                        i = ~i
                        ind = self.point_head[i]
                        sub = 0
                        while ind:
                            j = self.edge_to[ind]
                            w = self.edge_weight[ind]
                            if j != parent[i]:
                                if w and not ans[j]:
                                    sub += 1
                                    res.append(j + 1)
                                ans[i] += ans[j]
                            ind = self.edge_next[ind]
                        ans[i] += sub
                return res

        n = ac.read_int()
        graph = Graph(n)
        for _ in range(n - 1):
            u, v, ww = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(u, v, ww)
        final = graph.tree_dp([-1])
        ac.st(len(final))
        ac.lst(final)
        return
"""
Algorithm：binary_search_tree|binary_search_tree|array_to_bst|implemention
Description：build a binary_search_tree by the order of array


====================================LeetCode====================================
1569（https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/）array_to_bst|dp|comb|counter|specific_plan
1902（https://leetcode.cn/problems/depth-of-bst-given-insertion-order/）array_to_bst|tree_depth|implemention

=====================================LuoGu======================================
P2171（https://www.luogu.com.cn/problem/P2171）array_to_bst|reverse_order|union_find|implemention

"""
from typing import List

from src.graph.binary_search_tree.template import BinarySearchTree
from src.mathmatics.comb_perm.template import Combinatorics
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p2171(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2171
        tag: array_to_bst|reverse_order|union_find|implemention
        """
        ac.read_int()
        nums = ac.read_list_ints()
        dct = BinarySearchTree().build_with_unionfind(nums)  # or build_with_stack
        ans = []
        depth = 0
        stack = [[0, 1]]
        while stack:
            i, d = stack.pop()
            if i >= 0:
                stack.append([~i, d])
                dct[i].sort(key=lambda it: -nums[it])
                for j in dct[i]:
                    stack.append([j, d + 1])
            else:
                i = ~i
                depth = depth if depth > d else d
                ans.append(nums[i])
        ac.st(f"deep={depth}")
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lc_1569(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-reorder-array-to-get-same-bst/
        tag: array_to_bst|dp|comb|counter|specific_plan
        """
        mod = 10 ** 9 + 7
        cb = Combinatorics(1000, mod)
        dct = BinarySearchTree().build_with_unionfind(nums)  # build_with_stack is also ok
        stack = [0]
        n = len(nums)
        ans = [0] * n
        sub = [0] * n
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                for j in dct[i]:
                    stack.append(j)
            else:
                i = ~i
                cur_ans = 1
                cur_sub = sum(sub[j] for j in dct[i])
                sub[i] = cur_sub + 1
                for j in dct[i]:
                    cur_ans *= cb.comb(cur_sub, sub[j]) * ans[j]
                    cur_sub -= sub[j]
                    cur_ans %= mod
                ans[i] = cur_ans
        return (ans[0] - 1) % mod

    @staticmethod
    def lc_1902(order: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/depth-of-bst-given-insertion-order/
        tag: array_to_bst|tree_depth|implemention
        """
        dct = BinarySearchTree().build_with_stack(order)  # or build_with_unionfind
        stack = [[0, 1]]
        ans = 1
        while stack:
            i, d = stack.pop()
            for j in dct[i]:
                stack.append([j, d + 1])
                ans = ans if ans > d + 1 else d + 1
        return ans
"""
Algorithm：bipartite_graph|maximum_weight_match|minimum_weight_match|km|ek|unweighted
Description：

====================================LeetCode====================================
4（https://leetcode.cn/problems/broken-board-dominoes/）outline_dp|classical|hungarian
1820（https://leetcode.cn/problems/maximum-number-of-accepted-invitations/）hungarian|bipartite_graph|maximum_weight_match|km

=====================================LuoGu======================================
P3386（https://www.luogu.com.cn/problem/P3386）bipartite_graph|maximum_weight_match|km
P6577（https://www.luogu.com.cn/problem/P6577）bipartite_graph|maximum_weight_match|km
P1894（https://www.luogu.com.cn/problem/P1894）bipartite_graph|maximum_weight_match|km
B3605（https://www.luogu.com.cn/problem/B3605）hungarian|bipartite_graph|maximum_weight_match|km

===================================CodeForces===================================
1437C（https://codeforces.com/problemset/problem/1437/C）bipartite_graph|minimum_weight_match|km
1228D（https://codeforces.com/problemset/problem/1228/D）complete_tripartite|random_seed|random_hash|classical

=====================================AcWing=====================================
4298（https://www.acwing.com/problem/content/4301/）hungarian|bipartite_graph

================================LibraryChecker================================
1（https://judge.yosupo.jp/problem/bipartitematching）maximum_weight_match|bipartite_matching

"""
import random
from typing import List

from src.graph.bipartite_matching.template import BipartiteMatching
from src.graph.network_flow.template import DinicMaxflowMinCut
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/bipartitematching
        tag: maximum_weight_match|bipartite_matching
        """
        n, m, k = ac.read_list_ints()
        bm = BipartiteMatching(n, m)
        for _ in range(k):
            a, b = ac.read_list_ints()
            bm.add_edge(a, b)

        matching = bm.solve()
        ac.st(len(matching))
        for a, b in matching:
            ac.lst([a, b])
        return

    @staticmethod
    def lc_1820(grid):
        """
        url: https://leetcode.cn/problems/maximum-number-of-accepted-invitations/
        tag: hungarian|bipartite_graph|maximum_weight_match|bipartite_matching
        """
        m, n = len(grid), len(grid[0])
        bm = BipartiteMatching(m, n)
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    bm.add_edge(i, j)
        matching = bm.solve()
        return len(matching)

    @staticmethod
    def lg_p1894(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1894
        tag: bipartite_graph|maximum_weight_match|km
        """
        n, m = ac.read_list_ints()
        bm = BipartiteMatching(n, m)
        for i in range(n):
            for j in ac.read_list_ints_minus_one()[1:]:
                bm.add_edge(i, j)
        matching = bm.solve()
        ac.st(len(matching))
        return

    @staticmethod
    def lg_3386(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3386
        tag: bipartite_graph|maximum_weight_match|km
        """
        n, m, e = ac.read_list_ints()
        bm = BipartiteMatching(n, m)
        for i in range(e):
            i, j = ac.read_list_ints_minus_one()
            bm.add_edge(i, j)
        matching = bm.solve()
        ac.st(len(matching))
        return

    @staticmethod
    def ac_4298(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4301/
        tag: hungarian|bipartite_graph
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        m = ac.read_int()
        b = ac.read_list_ints()
        bm = BipartiteMatching(n, m)
        for i in range(n):
            for j in range(m):
                if abs(a[i] - b[j]) <= 1:
                    bm.add_edge(i, j)
        matching = bm.solve()
        ac.st(len(matching))
        return

    @staticmethod
    def lc_4(n: int, m: int, broken: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/broken-board-dominoes/
        tag: outline_dp|classical|hungarian
        """
        m, n = n, m
        grid = [[0] * n for _ in range(m)]
        for i, j in broken:
            grid[i][j] = 1
        bm = BipartiteMatching(m * n, m * n)
        for i in range(m):
            for j in range(n):
                if not grid[i][j]:
                    for x, y in [[i + 1, j], [i, j + 1]]:
                        if 0 <= x < m and 0 <= y < n and not grid[x][y]:
                            bm.add_edge(i * n + j, x * n + y)
                            bm.add_edge(x * n + y, i * n + j)
        matching = bm.solve()
        return len(matching) // 2

    @staticmethod
    def abc_274g_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc274/tasks/abc274_g
        tag: bipartite_matching|minimum_point_cover|maximum_match|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        row = [[-1] * n for _ in range(m)]
        r = flag = 0
        for i in range(m):
            if flag:
                r += 1
            flag = 0
            for j in range(n):
                if grid[i][j] == ".":
                    row[i][j] = r
                    flag = 1
                else:
                    if flag:
                        r += 1
                        flag = 0
        if flag:
            r += 1

        edge = set()
        c = flag = 0
        for j in range(n):
            if flag:
                c += 1
            flag = 0
            for i in range(m):
                if grid[i][j] == ".":
                    edge.add((row[i][j], c))
                    flag = 1
                else:
                    if flag:
                        c += 1
                        flag = 0
        if flag:
            c += 1
        bm = BipartiteMatching(r, c)
        for i, j in edge:
            bm.add_edge(i, j)
        matching = bm.solve()
        ac.st(len(matching))
        return

    @staticmethod
    def abc_274g_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc274/tasks/abc274_g
        tag: bipartite_matching|minimum_point_cover|maximum_match|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        row = [[-1] * n for _ in range(m)]
        r = flag = 0
        for i in range(m):
            if flag:
                r += 1
            flag = 0
            for j in range(n):
                if grid[i][j] == ".":
                    row[i][j] = r
                    flag = 1
                else:
                    if flag:
                        r += 1
                        flag = 0
        if flag:
            r += 1

        edge = set()
        c = flag = 0
        for j in range(n):
            if flag:
                c += 1
            flag = 0
            for i in range(m):
                if grid[i][j] == ".":
                    edge.add((row[i][j], c))
                    flag = 1
                else:
                    if flag:
                        c += 1
                        flag = 0
        if flag:
            c += 1

        flow = DinicMaxflowMinCut(r + c + 2)
        for i in range(1, r + 1):
            flow.add_edge(r + c + 1, i, 1)
        for i in range(r + 1, r + c + 1):
            flow.add_edge(i, r + c + 2, 1)
        for i, j in edge:
            flow.add_edge(i + 1, j + r + 1, 1)
        ans = flow.max_flow_min_cut(r + c + 1, r + c + 2)
        ac.st(ans)
        return

    @staticmethod
    def main(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1228/D
        tag: complete_tripartite|random_seed|random_hash|classical
        """
        n, m = ac.read_list_ints()
        nums = [random.getrandbits(32) for _ in range(n)]
        dct = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i] ^= nums[j]
            dct[j] ^= nums[i]
        lst = list(set(dct))
        if len(lst) != 3:
            ac.st(-1)
        elif 0 in lst:
            ac.st(-1)
        else:
            for i in range(n):
                dct[i] = lst.index(dct[i]) + 1
            ac.lst(dct)
        return

    @staticmethod
    def cf_1228d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1228/D
        tag: complete_tripartite|random_seed|random_hash|classical
        """
        n, m = ac.read_list_ints()
        nums = [random.getrandbits(32) for _ in range(n)]
        dct = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i] ^= nums[j]
            dct[j] ^= nums[i]
        lst = list(set(dct))
        if len(lst) != 3:
            ac.st(-1)
        elif 0 in lst:
            ac.st(-1)
        else:
            for i in range(n):
                dct[i] = lst.index(dct[i]) + 1
            ac.lst(dct)
        return
"""
Algorithm：dijkstra|strictly_second_shortest_path|longest_path|shortest_path_spanning_tree|two_params_dijkstra
Description：limited_shortest_path|layered_dijkstra|directed_smallest_circle|undirected_smallest_circle|shortest_path_mst

====================================LeetCode====================================
42（https://leetcode.cn/problems/trapping-rain-water/）prefix_suffix
407（https://leetcode.cn/problems/trapping-rain-water-ii/）maximum_weight_on_shortest_path
787（https://leetcode.cn/problems/cheapest-flights-within-k-stops/）limited_shortest_path
1293（https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/）limited_shortest_path
2203（https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/）several_dijkstra|shortest_path
2258（https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/）bfs|preprocess|shortest_path|maximum_weight_on_shortest_path
2290（https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/）shortest_path
499（https://leetcode.cn/problems/the-maze-iii/）two_params_dijkstra
6442（https://leetcode.cn/problems/modify-graph-edge-weights/）several_dijkstra|shortest_path|greedy
2714（https://leetcode.cn/problems/find-shortest-path-with-k-hops/）limited_shortest_path|layered_dijkstra
2699（https://leetcode.cn/problems/modify-graph-edge-weights/）dijkstra|shortest_path|greedy
1786（https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/）dijkstra|limited_shortest_path|counter|dag|undirected_to_dag
1928（https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/）dijkstra|limited_shortest_path|floyd
75（https://leetcode.cn/problems/rdmXM7/）bfs|minimum_max_weight|shortest_path|maximum_weight_on_shortest_path
1976（https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/）dijkstra|number_of_shortest_path|classical
2045（https://leetcode.cn/problems/second-minimum-time-to-reach-destination/）strictly_second_shortest_path|classical
2093（https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/）dijkstra|limited_shortest_path
882（https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/）dijkstra
2577（https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/）dijkstra|matrix
2065（https://leetcode.cn/problems/maximum-path-quality-of-a-graph/）back_trace|dijkstra|shortest_path|prune
3112（https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes/description/）dijkstra|template|classical

=====================================LuoGu======================================
P3371（https://www.luogu.com.cn/problem/P3371）shortest_path
P4779（https://www.luogu.com.cn/problem/P4779）shortest_path
P1629（https://www.luogu.com.cn/problem/P1629）shortest_path|several_dijkstra
P1462（https://www.luogu.com.cn/problem/P1462）limited_shortest_path
P1339（https://www.luogu.com.cn/problem/P1339）shortest_path
P1342（https://www.luogu.com.cn/problem/P1342）shortest_path|several_dijkstra|reverse_graph|reverse_dijkstra
P1576（https://www.luogu.com.cn/problem/P1576）heapq|pos_to_neg|shortest_path
P1821（https://www.luogu.com.cn/problem/P1821）shortest_path|several_dijkstra|reverse_graph|reverse_dijkstra
P1882（https://www.luogu.com.cn/problem/P1882）shortest_path
P1907（https://www.luogu.com.cn/problem/P1907）build_graph|shortest_path
P1744（https://www.luogu.com.cn/problem/P1744）shortest_path
P1529（https://www.luogu.com.cn/problem/P1529）shortest_path
P1649（https://www.luogu.com.cn/problem/P1649）define_distance|shortest_path
P2083（https://www.luogu.com.cn/problem/P2083）reverse_graph|shortest_path
P2299（https://www.luogu.com.cn/problem/P2299）shortest_path
P2683（https://www.luogu.com.cn/problem/P2683）shortest_path|union_find
P1396（https://www.luogu.com.cn/problem/P1396）shortest_path|maximum_weight_on_shortest_path
P1346（https://www.luogu.com.cn/problem/P1346）build_graph|shortest_path
list?user=739032&status=12&page=11（https://www.luogu.com.cn/record/list?user=739032&status=12&page=11）shortest_path
P2784（https://www.luogu.com.cn/problem/P2784）maximum_mul_path
P1318（https://www.luogu.com.cn/problem/P1318）prefix_suffix
P2888（https://www.luogu.com.cn/problem/P2888）shortest_path|minimum_max_weight_on_shortest_path
P2935（https://www.luogu.com.cn/problem/P2935）shortest_path
P2951（https://www.luogu.com.cn/problem/P2951）shortest_path
P2984（https://www.luogu.com.cn/problem/P2984）shortest_path
P3003（https://www.luogu.com.cn/problem/P3003）several_dijkstra|shortest_path
P3094（https://www.luogu.com.cn/problem/P3094）shortest_path|preprocess
P3905（https://www.luogu.com.cn/problem/P3905）reverse_thinking|build_graph|shortest_path
P5764（https://www.luogu.com.cn/problem/P5764）several_dijkstra|shortest_path
P5767（https://www.luogu.com.cn/problem/P5767）build_graph|shortest_path
P6770（https://www.luogu.com.cn/problem/P6770）shortest_path
P6833（https://www.luogu.com.cn/problem/P6833）several_dijkstra|shortest_path|brute_force
P7551（https://www.luogu.com.cn/problem/P7551）shortest_path|multi_edge|self_loop
P6175（https://www.luogu.com.cn/problem/P6175）dijkstra|brute_force|dfs
P4568（https://www.luogu.com.cn/problem/P4568）build_graph|layer_dijkstra|shortest_path
P2865（https://www.luogu.com.cn/problem/P2865）strictly_second_shortest_path
P2622（https://www.luogu.com.cn/problem/P2622）state_compress|dijkstra|shortest_path
P1073（https://www.luogu.com.cn/problem/P1073）reverse_graph|build_graph|dijkstra
P1300（https://www.luogu.com.cn/problem/P1300）dijkstra|shortest_path
P1354（https://www.luogu.com.cn/problem/P1354）build_graph|dijkstra|shortest_path
P1608（https://www.luogu.com.cn/problem/P1608）dijkstra|undirected|directed|number_of_shortest_path
P1828（https://www.luogu.com.cn/problem/P1828）several_dijkstra|shortest_path
P2047（https://www.luogu.com.cn/problem/P2047）node_shortest_path_count|dijkstra|shortest_path|floyd|classical
P2269（https://www.luogu.com.cn/problem/P2269）shortest_path
P2349（https://www.luogu.com.cn/problem/P2349）shortest_path
P2914（https://www.luogu.com.cn/problem/P2914）dijkstra|build_graph|dynamic_graph
P3020（https://www.luogu.com.cn/problem/P3020）dijkstra|shortest_path
P3057（https://www.luogu.com.cn/problem/P3057）dijkstra|shortest_path
P3753（https://www.luogu.com.cn/problem/P3753）shortest_path|two_params
P3956（https://www.luogu.com.cn/problem/P3956）several_params|dijkstra
P4880（https://www.luogu.com.cn/problem/P4880）brute_force|dijkstra|shortest_path
P4943（https://www.luogu.com.cn/problem/P4943）brute_force|several_dijkstra|shortest_path
P5201（https://www.luogu.com.cn/problem/P5201）shortest_path_spanning_tree|build_graph|tree_dp
P5663（https://www.luogu.com.cn/problem/P5663）shortest_odd_path|shortest_even_path
P5683（https://www.luogu.com.cn/problem/P5683）several_dijkstra|shortest_path|brute_force
P5837（https://www.luogu.com.cn/problem/P5837）dijkstra|several_params
P5930（https://www.luogu.com.cn/problem/P5930）dijkstra|minimum_max_weight_on_shortest_path
P6063（https://www.luogu.com.cn/problem/P6063）dijkstra|minimum_max_weight_on_shortest_path
P6512（https://www.luogu.com.cn/problem/P6512）shortest_path
P8385（https://www.luogu.com.cn/problem/P8385）brain_teaser|build_graph|shortest_path
P8724（https://www.luogu.com.cn/problem/P8724）shortest_path|layer_dijkstra
P8802（https://www.luogu.com.cn/problem/P8802）dijkstra|define_weight
P2176（https://www.luogu.com.cn/problem/P2176）brute_force|shortest_path
P1807（https://www.luogu.com.cn/problem/P1807）dag|longest_path|dag_dp|topological_sort

===================================CodeForces===================================
20C（https://codeforces.com/problemset/problem/20/C）shortest_path|specific_plan
1343E（https://codeforces.com/problemset/problem/1343/E）several_bfs|shortest_path|greedy|brute_force
715B（https://codeforces.com/contest/715/problem/B）several_dijkstra|shortest_path|greedy|dynamic_graph
1433G（https://codeforces.com/contest/1433/problem/G）several_source_dijkstra|shortest_path|brute_force
1650G（https://codeforces.com/contest/1650/problem/G）dijkstra|shortest_path|strictly_second_shortest_path|counter|zero_one_bfs
1915G（https://codeforces.com/contest/1915/problem/G）shortest_path|limited_shortest_path|dijkstra
1196F（https://codeforces.com/contest/1196/problem/F）shortest_path|data_range|kth_shortest|brute_force|data_range
1741G（https://codeforces.com/contest/1741/problem/G）shortest_path|brute_force|state_dp
1846G（https://codeforces.com/contest/1846/problem/G）shortest_path
449B（https://codeforces.com/contest/449/problem/B）shortest_path|not_shortest_path_spanning_tree|union_find
1307D（https://codeforces.com/problemset/problem/1307/D）math|graph|shortest_path|observation|brute_force
938D（https://codeforces.com/problemset/problem/938/D）dijkstra|fake_source|build_graph|classical
1817B（https://codeforces.com/problemset/problem/1817/B）undirected_shortest_circle|brute_force
1473E（https://codeforces.com/problemset/problem/1473/E）layer_dijkstra|observation|classical|brain_teaser
545E（https://codeforces.com/problemset/problem/545/E）shortest_path_spanning_tree|minimum_weight|dijkstra|classical|shortest_path_mst|greedy
786B（https://codeforces.com/contest/786/problem/B）segment_tree_opt_build_graph|dijkstra|classical|weighted_graph
1076D（https://codeforces.com/problemset/problem/1076/D）weighted_graph|shortest_path_mst

====================================AtCoder=====================================
ABC142F（https://atcoder.jp/contests/abc142/tasks/abc142_f）directed|directed_smallest_circle
ABC342E（https://atcoder.jp/contests/abc342/tasks/abc342_e）classical|dijkstra|longest_path
ABC325E（https://atcoder.jp/contests/abc325/tasks/abc325_e）classical|data_range
ABC305E（https://atcoder.jp/contests/abc305/tasks/abc305_e）dijkstra|classical|several_source|shortest_path
ABC271E（https://atcoder.jp/contests/abc271/tasks/abc271_e）shortest_path|brain_teaser|implemention
ABC348D（https://atcoder.jp/contests/abc348/tasks/abc348_d）bfs|dijkstra|limited_shortest_path|state|classical
ABC257F（https://atcoder.jp/contests/abc257/tasks/abc257_f）shortest_path|brute_force|bfs|classical
ABC252E（https://atcoder.jp/contests/abc252/tasks/abc252_e）shortest_path_spanning_tree|dijkstra|classical
ABC245G（https://atcoder.jp/contests/abc245/tasks/abc245_g）shortest_path|second_shortest_path|dijkstra|brain_teaser|classical
ABC237E（https://atcoder.jp/contests/abc237/tasks/abc237_e）dijkstra|negative_weight|graph_mapping|brain_teaser|classical
ABC211D（https://atcoder.jp/contests/abc211/tasks/abc211_d）dijkstra|get_cnt_of_shortest_path
ABC204E（https://atcoder.jp/contests/abc204/tasks/abc204_e）dijkstra|shortest_path|classical|observation
ABC375G（https://atcoder.jp/contests/abc375/tasks/abc375_g）dijkstra_for_cnt_of_shortest_path|key_edge_in_shortest_path
ABC375G（https://atcoder.jp/contests/abc375/tasks/abc375_g）dijkstra|classical

=====================================AcWing=====================================
176（https://www.acwing.com/problem/content/178/）dijkstra|implemention
3628（https://www.acwing.com/problem/content/3631/）shortest_path_spanning_tree
3772（https://www.acwing.com/problem/content/description/3775/）build_graph|reverse_graph|dijkstra|shortest_path|counter|greedy|implemention
3797（https://www.acwing.com/problem/content/description/3800/）shortest_path|brute_force|sort|greedy
4196（https://www.acwing.com/problem/content/4199/）shortest_path
385（https://www.acwing.com/problem/content/description/385/）dijkstra_for_cnt_of_strictly_second_shortest_path

================================LibraryChecker====================================
Shortest Path（https://judge.yosupo.jp/problem/shortest_path）shortest_path|specific_plan

"""
import math
import random
from collections import defaultdict, deque, Counter
from heapq import heappush, heappop, heapify
from itertools import accumulate, permutations
from operator import add
from typing import List

from src.data_structure.segment_tree.template import SegmentTreeOptBuildGraphZKW
from src.graph.dijkstra.template import UnDirectedShortestCycle, LimitedWeightedGraph, \
    WeightedGraphForShortestPathMST, WeightedGraphForDijkstra
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p6175_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6175
        tag: dijkstra|brute_force|dfs
        """
        n, m = ac.read_list_ints()
        dct = [defaultdict(lambda: math.inf) for _ in range(n)]
        edges = []
        for _ in range(m):
            i, j, w = ac.read_list_ints()
            dct[i - 1][j - 1] = min(dct[i - 1][j - 1], w)
            dct[j - 1][i - 1] = min(dct[j - 1][i - 1], w)
        for i in range(n):
            for j in dct[i]:
                if j > i:
                    edges.append([i, j, dct[i][j]])
        ans = UnDirectedShortestCycle.find_shortest_cycle_with_edge(n, dct, edges)
        ac.st(ans if ans != -1 else "No solution.")
        return

    @staticmethod
    def lg_p6175_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6175
        tag: dijkstra|brute_force|dfs
        """
        n, m = ac.read_list_ints()
        dct = [defaultdict(lambda: math.inf) for _ in range(n)]
        for _ in range(m):
            i, j, w = ac.read_list_ints()
            dct[i - 1][j - 1] = min(dct[i - 1][j - 1], w)
            dct[j - 1][i - 1] = min(dct[j - 1][i - 1], w)
        ans = UnDirectedShortestCycle().find_shortest_cycle_with_node(n, dct)
        ac.st(ans if ans != -1 else "No solution.")
        return

    @staticmethod
    def cf_1343e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1343/E
        tag: several_bfs|shortest_path|greedy|brute_force
        """
        for _ in range(ac.read_int()):
            n, m, a, b, c = ac.read_list_ints()
            a -= 1
            b -= 1
            c -= 1
            prices = sorted(ac.read_list_ints())
            prices = list(accumulate(prices, add, initial=0))

            inf = m + 1
            graph = WeightedGraphForDijkstra(n, inf)
            for _ in range(m):
                i, j = ac.read_list_ints_minus_one()
                graph.add_undirected_edge(i, j, 1)

            dis_a = graph.bfs_for_shortest_path(a)
            dis_b = graph.bfs_for_shortest_path(b)
            dis_c = graph.bfs_for_shortest_path(c)
            ans = math.inf
            for x in range(n):
                up = dis_b[x]
                down = dis_a[x] + dis_c[x]
                if up + down <= m:
                    cur = prices[up] + prices[up + down]
                    ans = min(ans, cur)
            ac.st(ans)
        return

    @staticmethod
    def cf_1650g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1650/problem/G
        tag: dijkstra|shortest_path|strictly_second_shortest_path|counter|zero_one_bfs
        """
        mod = 10 ** 9 + 7
        for _ in range(ac.read_int()):
            ac.read_str()
            n, m = ac.read_list_ints()
            s, t = ac.read_list_ints_minus_one()
            inf = 10 ** 9
            graph = WeightedGraphForDijkstra(n, inf)
            for _ in range(m):
                i, j = ac.read_list_ints_minus_one()
                graph.add_undirected_edge(i, j, 1)

            dis, cnt = graph.bfs_for_cnt_of_strictly_second_shortest_path(s, 0, mod)
            ans = cnt[t * 2]
            if dis[t * 2 + 1] == dis[t * 2] + 1:
                ans += cnt[t * 2 + 1]
                ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def ac_385(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/385/
        tag: dijkstra_for_cnt_of_strictly_second_shortest_path
        """

        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            inf = 10 ** 18
            graph = WeightedGraphForDijkstra(n, inf)
            for _ in range(m):
                i, j, w = ac.read_list_ints_minus_one()
                graph.add_directed_edge(i, j, w + 1)
            s, t = ac.read_list_ints_minus_one()
            dis, cnt = graph.dijkstra_for_cnt_of_strictly_second_shortest_path(s)
            ans = cnt[t * 2]
            if dis[t * 2 + 1] == dis[t * 2] + 1:
                ans += cnt[t * 2 + 1]
            ac.st(ans)
        return

    @staticmethod
    def lc_787(n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/cheapest-flights-within-k-stops/
        tag: limited_shortest_path
        """
        dct = [[] for _ in range(n)]
        for u, v, p in flights:
            dct[u].append((v, p))

        stack = [(0, 0, src)]
        dis = [math.inf] * n
        while stack:
            cost, cnt, i = heappop(stack)
            if dis[i] <= cnt or cnt >= k + 2:
                continue
            if i == dst:
                return cost
            dis[i] = cnt
            for j, w in dct[i]:
                if cnt + 1 < dis[j]:
                    heappush(stack, (cost + w, cnt + 1, j))
        return -1

    @staticmethod
    def lc_2045(n: int, edges: List[List[int]], time: int, change: int) -> any:
        """
        url: https://leetcode.cn/problems/second-minimum-time-to-reach-destination/
        tag: strictly_second_shortest_path|classical
        """
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i - 1].append(j - 1)
            dct[j - 1].append(i - 1)

        src = 0
        dis = [[math.inf] * 2 for _ in range(n)]
        dis[src][0] = 0
        stack = [(0, src)]
        while stack:
            d, i = heappop(stack)
            if dis[i][1] < d:
                continue
            for j in dct[i]:
                if (d // change) % 2 == 0:
                    nex_d = d + time
                else:
                    nex_d = (d // change + 1) * change + time
                if dis[j][0] > nex_d:
                    dis[j][1] = dis[j][0]
                    dis[j][0] = nex_d
                    heappush(stack, (nex_d, j))
                elif dis[j][0] < nex_d < dis[j][1]:
                    dis[j][1] = nex_d
                    heappush(stack, (nex_d, j))
        return dis[-1][1]

    @staticmethod
    def lc_2065(values: List[int], edges: List[List[int]], max_time: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-path-quality-of-a-graph/
        tag: back_trace|dijkstra|shortest_path|prune|data_range
        """
        n = len(values)
        inf = math.inf
        graph = WeightedGraphForDijkstra(n, inf)

        for i, j, c in edges:
            graph.add_undirected_edge(i, j, c)

        dis = graph.dijkstra_for_shortest_path(0)
        stack = [[0, 0, {0}]]
        ans = 0
        visit = {tuple(sorted({0}) + [0]): 0}
        while stack:
            t, x, nodes = heappop(stack)
            if dis[x] + t <= max_time:
                cur = sum(values[j] for j in nodes)
                if cur > ans:
                    ans = cur
            ind = graph.point_head[x]
            while ind:
                y = graph.edge_to[ind]
                w = graph.edge_weight[ind]
                if t + w + dis[y] <= max_time:
                    state = tuple(sorted(nodes.union({y})) + [y])
                    if visit.get(state, math.inf) > t + w:
                        visit[state] = t + w
                        heappush(stack, [t + w, y, nodes.union({y})])
                ind = graph.edge_next[ind]
        return ans

    @staticmethod
    def lc_2093(n: int, highways: List[List[int]], discounts: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/
        tag: dijkstra|limited_shortest_path
        """
        dct = [[] for _ in range(n)]
        for u, v, p in highways:
            dct[u].append([v, p])
            dct[v].append([u, p])

        stack = [(0, 0, 0)]
        dis = [math.inf] * n
        while stack:
            cost, cnt, i = heappop(stack)
            if dis[i] <= cnt:
                continue
            if i == n - 1:
                return cost
            dis[i] = cnt
            for j, w in dct[i]:
                if cnt < dis[j]:
                    heappush(stack, (cost + w, cnt, j))
                if cnt + 1 < dis[j] and cnt + 1 <= discounts:
                    heappush(stack, (cost + w // 2, cnt + 1, j))

        return -1

    @staticmethod
    def lc_882(edges: List[List[int]], max_moves: int, n: int) -> int:
        """
        url: https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/description/
        tag: dijkstra
        """
        inf = math.inf
        graph = WeightedGraphForDijkstra(n, inf)

        for i, j, c in edges:
            graph.add_undirected_edge(i, j, c + 1)

        dis = graph.dijkstra_for_shortest_path(0)

        ans = sum(dis[i] <= max_moves for i in range(n))
        for i, j, c in edges:
            if c:
                if dis[i] <= max_moves:
                    a, b = max_moves - dis[i], c
                    left = a if a < b else b
                else:
                    left = 0

                if dis[j] <= max_moves:
                    a, b = max_moves - dis[j], c
                    right = a if a < b else b
                else:
                    right = 0

                if left + right <= c:
                    ans += left + right
                else:
                    ans += c
        return ans

    @staticmethod
    def lc_1293(grid: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/
        tag: limited_shortest_path|classical|dijkstra_like
        """
        m, n = len(grid), len(grid[0])
        visit = defaultdict(lambda: float("math.inf"))

        stack = [[0, 0, 0, 0]]
        while stack:
            dis, cost, i, j = heappop(stack)
            if visit[(i, j)] <= cost or cost > k:
                continue
            if i == m - 1 and j == n - 1:
                return dis
            visit[(i, j)] = cost
            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= x < m and 0 <= y < n and cost + grid[x][y] < visit[(x, y)]:
                    heappush(stack, [dis + 1, cost + grid[x][y], x, y])
        return -1

    @staticmethod
    def lg_p1462(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1462
        tag: limited_shortest_path|classical
        """
        n, m, s = ac.read_list_ints()
        cost = [ac.read_int() for _ in range(n)]
        dct = [dict() for _ in range(n)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            a -= 1
            b -= 1
            if b not in dct[a] or dct[a][b] > c:
                dct[a][b] = c
            if a not in dct[b] or dct[b][a] > c:
                dct[b][a] = c

        visit = [0] * n
        stack = [(cost[0], 0, s)]
        while stack:
            dis, i, bd = heappop(stack)
            if visit[i] > bd:
                continue
            if i == n - 1:
                ac.st(dis)
                return
            visit[i] = bd
            for j in dct[i]:
                bj = bd - dct[i][j]
                if bj >= visit[j]:
                    visit[j] = bj
                    heappush(stack, (max(dis, cost[j]), j, bj))
        ac.st("AFK")
        return

    @staticmethod
    def lg_p4568(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4568
        tag: build_graph|layer_dijkstra|shortest_path|classical
        """
        n, m, k = ac.read_list_ints()
        s, t = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            dct[a].append((b, c))
            dct[b].append((a, c))

        n = len(dct)
        stack = [(0, 0, s)]
        dis = [math.inf] * n * (k + 1)
        dis[s * (k + 1)] = 0
        while stack:
            cost, cnt, i = heappop(stack)
            if dis[i * (k + 1) + cnt] < cost:
                continue
            if i == t:
                ac.st(cost)
                break
            for j, w in dct[i]:
                if dis[j * (k + 1) + cnt] > cost + w:
                    dis[j * (k + 1) + cnt] = cost + w
                    heappush(stack, (cost + w, cnt, j))
                if cnt + 1 <= k and dis[j * (k + 1) + cnt + 1] > cost:
                    dis[j * (k + 1) + cnt + 1] = cost
                    heappush(stack, (cost, cnt + 1, j))
        return

    @staticmethod
    def lg_p1629(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1629
        tag: shortest_path|several_dijkstra|reverse_thinking
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 18
        graph1 = WeightedGraphForDijkstra(n, inf)
        graph2 = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph1.add_directed_edge(i, j, w + 1)
            graph2.add_directed_edge(j, i, w + 1)
        dis1 = graph1.dijkstra_for_shortest_path(0)
        dis2 = graph2.dijkstra_for_shortest_path(0)
        ans = sum(dis1[i] + dis2[i] for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def lg_p2865(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2865
        tag: strictly_second_shortest_path
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 18
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)
        ans = graph.dijkstra_for_strictly_second_shortest_path(0)[(n - 1) * 2 + 1]
        ac.st(ans)
        return

    @staticmethod
    def lg_p1807(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1807
        tag: dag|longest_path|dag_dp|topological_sort
        """
        n, m = ac.read_list_ints()
        inf = math.inf
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_directed_edge(i, j, w + 1)
        dis = graph.dijkstra_for_longest_path(0)
        ac.st(dis[-1] if dis[-1] > -inf else -1)
        return

    @staticmethod
    def lc_75(maze: List[str]) -> int:
        """
        url: https://leetcode.cn/problems/rdmXM7/
        tag: bfs|minimum_max_weight|shortest_path|maximum_weight_on_shortest_path
        """
        # shortest_path逃离
        m, n = len(maze), len(maze[0])
        start = [-1, -1]
        end = [-1, -1]
        for i in range(m):
            for j in range(n):
                w = maze[i][j]
                if w == "S":
                    start = [i, j]
                elif w == "T":
                    end = [i, j]

        # 反向到达终点距离
        bfs = [[math.inf] * n for _ in range(m)]
        bfs[end[0]][end[1]] = 0
        stack = deque([end])
        while stack:
            i, j = stack.popleft()
            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= x < m and 0 <= y < n and maze[x][y] != "#" and bfs[x][y] == math.inf:
                    bfs[x][y] = bfs[i][j] + 1
                    stack.append([x, y])

        # 魔法卷轴更新正向距离
        dis = [[math.inf] * n for _ in range(n)]
        for i in range(m):
            for j in range(n):
                if bfs[i][j] < math.inf:
                    dis[i][j] = 0
                    if maze[i][j] == ".":
                        if maze[m - 1 - i][j] != "#":
                            dis[i][j] = max(dis[i][j], bfs[m - 1 - i][j])
                        if maze[i][n - 1 - j] != "#":
                            dis[i][j] = max(dis[i][j], bfs[i][n - 1 - j])

        # dijkstrashortest_path径边权最小的最大值
        visit = [[math.inf] * n for _ in range(n)]
        stack = [[dis[start[0]][start[1]], start[0], start[1]]]
        visit[start[0]][start[1]] = dis[start[0]][start[1]]
        while stack:
            d, i, j = heappop(stack)
            if visit[i][j] < d:
                continue
            visit[i][j] = d
            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= x < m and 0 <= y < n and maze[x][y] != "#":
                    dj = max(d, dis[x][y])
                    if dj < visit[x][y]:
                        visit[x][y] = dj
                        heappush(stack, [dj, x, y])
        x, y = end
        return visit[x][y] if visit[x][y] < math.inf else -1

    @staticmethod
    def lg_p2622(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2622
        tag: state_compress|dijkstra|shortest_path
        """
        # Dijkstra|状压shortest_path
        n = ac.read_int()
        m = ac.read_int()
        grid = [ac.read_list_ints() for _ in range(m)]
        visit = [math.inf] * (1 << n)
        visit[(1 << n) - 1] = 0
        stack = [[0, (1 << n) - 1]]
        while stack:
            d, state = heappop(stack)
            if visit[state] < d:
                continue
            for i in range(m):
                cur = state
                for j in range(n):
                    if grid[i][j] == 1 and cur & (1 << j):
                        cur ^= (1 << j)
                    elif grid[i][j] == -1 and not cur & (1 << j):
                        cur ^= (1 << j)
                if d + 1 < visit[cur]:
                    visit[cur] = d + 1
                    heappush(stack, [d + 1, cur])
        ans = visit[0]
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p1073(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1073
        tag: reverse_graph|build_graph|dijkstra
        """
        # 正反两遍build_graph|，两个shortest_path
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        rev = [[] for _ in range(n)]
        for _ in range(m):
            x, y, z = ac.read_list_ints_minus_one()
            dct[x].append(y)
            rev[y].append(x)
            if z == 1:
                dct[y].append(x)
                rev[x].append(y)

        # 前面最小值
        floor = [math.inf] * n
        stack = [[nums[0], 0]]
        floor[0] = nums[0]
        while stack:
            d, i = heappop(stack)
            if floor[i] < d:
                continue
            for j in dct[i]:
                dj = min(d, nums[j])
                if dj < floor[j]:
                    floor[j] = dj
                    heappush(stack, (dj, j))

        # 后面最大值
        ceil = [-math.inf] * n
        ceil[n - 1] = nums[n - 1]
        stack = [[-nums[n - 1], n - 1]]
        while stack:
            d, i = heappop(stack)
            if ceil[i] < d:
                continue
            for j in rev[i]:
                dj = max(-d, nums[j])
                if dj > ceil[j]:
                    ceil[j] = dj
                    heappush(stack, [-dj, j])
        ans = max(ceil[i] - floor[i] for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def lg_p1300(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1300
        tag: dijkstra|shortest_path
        """
        # Dijkstra求shortest_path
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        ind = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        dct = {"E": 0, "S": 1, "W": 2, "N": 3}
        start = [-1, -1]
        d = -1
        end = [-1, -1]
        for i in range(m):
            for j in range(n):
                w = grid[i][j]
                if w in dct:
                    start = [i, j]
                    d = dct[w]
                if w == "F":
                    end = [i, j]

        dis = [[[math.inf] * 4 for _ in range(n)] for _ in range(m)]
        dis[start[0]][start[1]][d] = 0
        stack = [[0, start[0], start[1], d]]
        while stack:
            pre, i, j, d = heappop(stack)
            if dis[i][j][d] < pre:
                continue
            flag = False
            for cost, r in [[1, (d - 1) % 4], [5, (d + 1) % 4], [0, d]]:
                x, y = i + ind[r][0], j + ind[r][1]
                if 0 <= x < m and 0 <= y < n and grid[x][y] != ".":
                    dj = pre + cost
                    if dj < dis[x][y][r]:
                        dis[x][y][r] = dj
                        heappush(stack, [dj, x, y, r])
                        flag = True
            if not flag:
                cost, r = 10, (d + 2) % 4
                x, y = i + ind[r][0], j + ind[r][1]
                if 0 <= x < m and 0 <= y < n and grid[x][y] != ".":
                    dj = pre + cost
                    if dj < dis[x][y][r]:
                        dis[x][y][r] = dj
                        heappush(stack, [dj, x, y, r])
        ac.st(min(dis[end[0]][end[1]]))
        return

    @staticmethod
    def lg_p1354(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1354
        tag: build_graph|dijkstra|shortest_path
        """
        def dis(x1, y1, x2, y2):
            return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

        n = ac.read_int()
        nodes = [[0, 5], [10, 5]]
        line = []
        for _ in range(n):
            x, a1, a2, b1, b2 = [float(x) for x in ac.read_list_strs()]
            nodes.append([x, a1])
            nodes.append([x, a2])
            nodes.append([x, b1])
            nodes.append([x, b2])
            line.append([x, a1, a2, b1, b2])

        def check():
            for xx, aa1, aa2, bb1, bb2 in line:
                if left <= xx <= right:
                    if not (aa1<=k*xx+bb<=aa2) and not (bb1<=k*xx+bb<=bb2):
                        return False
            return True

        start = 0
        end = 1
        m = len(nodes)
        inf = math.inf
        graph = WeightedGraphForDijkstra(m, inf)
        for i in range(m):
            for j in range(i + 1, m):
                a, b = nodes[i]
                c, d = nodes[j]
                if a == c:
                    continue
                k = (d - b) / (c - a)
                bb = d - k * c
                left, right = min(a, c), max(a, c)
                if check():
                    x = dis(a, b, c, d)
                    graph.add_undirected_edge(i, j, x)
        ans = graph.dijkstra_for_shortest_path_float(start)[end]
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p1608(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1608
        tag: dijkstra|undirected|directed|number_of_shortest_path
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 9
        dct = [dict() for _ in range(n)]
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            dct[i][j] = min(dct[i].get(j, inf), w+1)

        graph = WeightedGraphForDijkstra(n, inf)
        for i in range(n):
            for j, w in dct[i].items():
                graph.add_directed_edge(i, j, w)
            dct[i] = None
        del dct
        dis, cnt = graph.dijkstra_for_cnt_of_shortest_path(0)
        if dis[-1] == inf:
            ac.st("No answer")
        else:
            ac.lst([dis[-1], cnt[-1]])
        return

    @staticmethod
    def lg_p1828(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1828
        tag: several_dijkstra|shortest_path
        """
        n, p, c = ac.read_list_ints()
        cnt = Counter([ac.read_int() - 1 for _ in range(n)])
        inf = 10 ** 9
        graph = WeightedGraphForDijkstra(p, inf)
        for _ in range(c):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)

        total = [0] * p
        for i in cnt:
            dis = graph.dijkstra_for_shortest_path(i)
            for j in range(p):
                total[j] += dis[j] * cnt[i]
        ac.st(min(total))
        return

    @staticmethod
    def lg_p2047(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2047
        tag: node_shortest_path_count|dijkstra|shortest_path|floyd|classical
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 9
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)
        dis = []
        cnt = []
        for i in range(n):
            dd, cc = graph.dijkstra_for_cnt_of_shortest_path(i)
            dis.append(dd)
            cnt.append(cc)
        for i in range(n):
            ans = 0
            for j in range(n):
                for k in range(n):
                    if j != i and k != i:
                        if dis[j][i] + dis[i][k] == dis[j][k]:
                            ans += cnt[j][i] * cnt[i][k] / cnt[j][k]
            ac.st("%.3f" % ans)
        return

    @staticmethod
    def lg_p2176(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2176
        tag: brute_force|shortest_path
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 18
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)
        path, dis = graph.dijkstra_for_shortest_path_from_src_to_dst(0, n - 1)

        ans = 0
        for x in range(m):
            graph.edge_weight[x * 2 + 1] *= 2
            graph.edge_weight[x * 2 + 2] *= 2
            _, cur = graph.dijkstra_for_shortest_path_from_src_to_dst(0, n - 1)
            ans = max(ans, cur - dis)
            graph.edge_weight[x * 2 + 1] //= 2
            graph.edge_weight[x * 2 + 2] //= 2
        ac.st(ans)
        return

    @staticmethod
    def lg_p2269(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2269
        tag: shortest_path
        """
        # 比较两个维度的Dijkstra
        n, src, dst = ac.read_list_ints()
        src -= 1
        dst -= 1
        time = [ac.read_list_ints() for _ in range(n)]
        loss = [ac.read_list_floats() for _ in range(n)]

        # 丢失率与时延
        dis = [[math.inf, math.inf] for _ in range(n)]
        stack = [[0, 0, src]]
        dis[src] = [0, 0]
        # shortest_path
        while stack:
            ll, tt, i = heappop(stack)
            if dis[i] < [ll, tt]:
                continue
            if i == dst:
                break
            for j in range(n):
                if time[i][j] != -1 and loss[i][j] != -1:
                    nex_ll = 1 - (1 - ll) * (1 - loss[i][j])
                    nex_tt = tt + time[i][j]
                    if [nex_ll, nex_tt] < dis[j]:
                        dis[j] = [nex_ll, nex_tt]
                        heappush(stack, [nex_ll, nex_tt, j])
        res_ll = dis[dst][0]
        res_tt = dis[dst][1]
        ac.lst([res_tt, "%.4f" % res_ll])
        return

    @staticmethod
    def lg_p2349(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2349
        tag: shortest_path
        """
        # 比较两个项相|的shortest_path
        n, m = ac.read_list_ints()
        dct = [dict() for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            u -= 1
            v -= 1
            dct[u][v] = min(dct[u].get(v, math.inf), w)
            dct[v][u] = min(dct[v].get(u, math.inf), w)

        # shortest_path模板
        dis = [math.inf] * n
        stack = [[0, 0, 0, 0]]
        dis[0] = 0
        while stack:
            dd, d, ceil, i = heappop(stack)
            if dis[i] < dd:
                continue
            if i == n - 1:
                break
            for j in dct[i]:
                dj = d + dct[i][j] + max(ceil, dct[i][j])
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, [dj, d + dct[i][j], max(ceil, dct[i][j]), j])
        ac.st(dis[n - 1])
        return

    @staticmethod
    def lg_p2914(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2914
        tag: dijkstra|build_graph|dynamic_graph
        """

        # Dijkstra动态build_graph|距离

        def dis(x, y):
            if y in dct[x]:
                return 0
            x1, y1 = nums[x]
            x2, y2 = nums[y]
            res = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5
            return res if res <= m else math.inf

        n, w = ac.read_list_ints()
        m = ac.read_float()
        nums = [ac.read_list_ints() for _ in range(n)]
        dct = [set() for _ in range(n)]
        for _ in range(w):
            i, j = ac.read_list_ints_minus_one()
            dct[i].add(j)
            dct[j].add(i)

        n = len(dct)
        visit = [math.inf] * n
        stack = [[0, 0]]
        visit[0] = 0
        while stack:
            d, i = heappop(stack)
            if visit[i] < d:
                continue
            if i == n - 1:
                break
            for j in range(n):
                dj = dis(i, j) + d
                if dj < visit[j]:
                    visit[j] = dj
                    heappush(stack, (dj, j))
        ac.st(int(visit[-1] * 1000) if visit[-1] < math.inf else -1)
        return

    @staticmethod
    def lc_6442(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/modify-graph-edge-weights/
        tag: several_dijkstra|shortest_path|greedy
        """
        dct = [[] for _ in range(n)]
        m = len(edges)
        book = [0] * m
        for ind, (i, j, w) in enumerate(edges):
            if w == -1:
                w = 1
                book[ind] = 1
                edges[ind][-1] = w
            dct[i].append([ind, j])
            dct[j].append([ind, i])

        # 第一遍shortest_path最小情况下的距离
        dis0 = [math.inf] * n
        stack = [[0, source]]
        dis0[source] = 0
        while stack:
            d, i = heappop(stack)
            if dis0[i] < d:
                continue
            for ind, j in dct[i]:
                dj = edges[ind][2] + d
                if dj < dis0[j]:
                    dis0[j] = dj
                    heappush(stack, (dj, j))
        if dis0[destination] > target:
            return []

        # 第二遍shortest_path
        dis1 = [math.inf] * n
        stack = [[0, source]]
        dis1[source] = 0
        while stack:
            d, i = heappop(stack)
            if dis1[i] < d:
                continue
            for ind, j in dct[i]:
                if book[ind]:
                    # 假设 (i, j) 是shortest_path上的边
                    if (edges[ind][2] + dis1[i]) + (dis0[destination] - dis0[j]) < target:
                        # 此时还有一些增长空间即（当前到达 j 的距离）|上（剩余 j 到 destination）的距离仍旧小于 target
                        x = target - (edges[ind][2] + dis1[i]) - (dis0[destination] - dis0[j])
                        edges[ind][2] += x
                    book[ind] = 0
                dj = edges[ind][2] + d
                if dj < dis1[j]:
                    dis1[j] = dj
                    heappush(stack, (dj, j))

        if dis1[destination] == target:
            return edges
        return []

    @staticmethod
    def cf_715b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/715/problem/B
        tag: several_dijkstra|shortest_path|greedy|dynamic_graph
        """
        # 两遍shortest_path，greedy动态更新路径权值
        n, m, target, source, destination = ac.read_list_ints()
        edges = []
        dct = [[] for _ in range(n)]
        book = [0] * m
        for ind in range(m):
            i, j, w = ac.read_list_ints()
            if w == 0:
                w = 1
                book[ind] = 1
            edges.append([i, j, w])
            dct[i].append([ind, j])
            dct[j].append([ind, i])

        # 第一遍shortest_path最小情况下的距离
        dis0 = [math.inf] * n
        stack = [[0, source]]
        dis0[source] = 0
        while stack:
            d, i = heappop(stack)
            if dis0[i] < d:
                continue
            for ind, j in dct[i]:
                dj = edges[ind][2] + d
                if dj < dis0[j]:
                    dis0[j] = dj
                    heappush(stack, (dj, j))
        if dis0[destination] > target:
            ac.no()
            return

        # 第二遍shortest_path
        dis1 = [math.inf] * n
        stack = [[0, source]]
        dis1[source] = 0
        while stack:
            d, i = heappop(stack)
            if dis1[i] < d:
                continue
            for ind, j in dct[i]:
                if book[ind]:
                    # 假设 (i, j) 是shortest_path上的边
                    if (edges[ind][2] + dis1[i]) + (dis0[destination] - dis0[j]) < target:
                        # 此时还有一些增长空间即（当前到达 j 的距离）|上（剩余 j 到 destination）的距离仍旧小于 target
                        x = target - (edges[ind][2] + dis1[i]) - (dis0[destination] - dis0[j])
                        edges[ind][2] += x
                    book[ind] = 0
                dj = edges[ind][2] + d
                if dj < dis1[j]:
                    dis1[j] = dj
                    heappush(stack, (dj, j))

        if dis1[destination] == target:
            ac.yes()
            for e in edges:
                ac.lst(e)
        else:
            ac.no()
        return

    @staticmethod
    def lg_p3753(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3753
        tag: shortest_path|two_params
        """
        # shortest_path变形两个维度的比较
        n, m = ac.read_list_ints()
        dct = [dict() for _ in range(n)]
        cnt = 0
        for _ in range(m):
            x, y, s = ac.read_list_ints()
            cnt += s
            x -= 1
            y -= 1
            dct[x][y] = s
            dct[y][x] = s

        dis = [[math.inf, -math.inf] for _ in range(n)]
        stack = [[0, 0, 0]]
        dis[0] = [0, 0]

        while stack:
            dd, one, i = heappop(stack)
            if dis[i] < [dd, one]:
                continue
            for j in dct[i]:
                w = dct[i][j]
                dj = [dd + 1, one - w]
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, [dj[0], dj[1], j])
        ans = cnt + dis[-1][1] + dis[-1][0] + dis[-1][1]
        ac.st(ans)
        return

    @staticmethod
    def lg_p3956(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3956
        tag: several_params|dijkstra
        """
        # Dijkstra最小代价

        m, n = ac.read_list_ints()
        grid = [[-1] * m for _ in range(m)]
        for _ in range(n):
            x, y, c = ac.read_list_ints()
            grid[x - 1][y - 1] = c

        stack = [[0, 0, grid[0][0], 0, 0]]
        final = -1
        visit = defaultdict(lambda: math.inf)
        while stack:
            cost, magic, color, i, j = heappop(stack)
            if visit[(i, j, color)] <= cost:
                continue
            visit[(i, j, color)] = cost
            if i == j == m - 1:
                final = cost
                break
            for a, b in [[i - 1, j], [i, j + 1], [i, j - 1], [i + 1, j]]:
                if 0 <= a < m and 0 <= b < m:
                    if grid[i][j] != -1:
                        if grid[a][b] != -1:
                            heappush(stack, [cost + int(color != grid[a][b]), 0, grid[a][b], a, b])
                        else:
                            heappush(stack, [cost + 2 + int(color != 0), 1, 0, a, b])
                            heappush(stack, [cost + 2 + int(color != 1), 1, 1, a, b])

                    else:
                        if grid[a][b] != -1:
                            heappush(stack, [cost + int(color != grid[a][b]), 0, grid[a][b], a, b])
        ac.st(final)
        return

    @staticmethod
    def lg_p4880(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4880
        tag: brute_force|dijkstra|shortest_path
        """
        lst = []  # RE
        while True:
            cur = ac.read_list_ints()
            if not cur:
                break
            lst.extend(cur)
        lst.reverse()
        n, m, b, e = lst.pop(), lst.pop(), lst.pop(), lst.pop()
        b -= 1
        e -= 1
        inf = 10 ** 15
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            x, y, z = lst.pop(), lst.pop(), lst.pop()
            x -= 1
            y -= 1
            graph.add_undirected_edge(x, y, z)

        dis = graph.dijkstra_for_shortest_path(b)

        t = lst.pop()
        if not t:
            ac.st(dis[e])
            return

        nums = [[0, e + 1]] + [[lst.pop(), lst.pop()] for _ in range(t)]
        nums.sort()
        for i in range(t):
            pos = nums[i][1] - 1
            tt = nums[i + 1][0]
            if dis[pos] < tt:
                ac.st(max(dis[pos], nums[i][0]))
                return
        ac.st(max(dis[nums[-1][1]], nums[-1][0]))
        return

    @staticmethod
    def lg_p4943(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4943
        tag: brute_force|several_dijkstra|shortest_path
        """
        class Graph(WeightedGraphForDijkstra):
            def dijkstra_for_shortest_path_with_limit_and_target(self, src, initial, limit, target):
                dis = [self.inf] * self.n
                stack = [initial * self.n + src]
                dis[src] = initial
                while stack:
                    val = heappop(stack)
                    d, i = val // self.n, val % self.n
                    if i in target:
                        target.discard(i)
                    if dis[i] < d:
                        continue
                    ind = self.point_head[i]
                    while ind:
                        w = self.edge_weight[ind]
                        j = self.edge_to[ind]
                        if j not in limit:
                            dj = d + w
                            if dj < dis[j]:
                                dis[j] = dj
                                heappush(stack, dj * self.n + j)
                        ind = self.edge_next[ind]
                return dis

        n, m, k = ac.read_list_ints()
        if k:
            visit = set(ac.read_list_ints_minus_one())
        else:
            visit = set()
        inf = 10 ** 15
        graph = Graph(n, inf)
        for _ in range(m):
            a, b, c = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(a, b, c + 1)
        x, y = ac.read_list_ints_minus_one()

        dis1 = graph.dijkstra_for_shortest_path_with_limit_and_target(0, 0, visit, {0, x, y})
        dis11 = graph.dijkstra_for_shortest_path_with_limit_and_target(x, 0, visit, {0, x, y})
        dis2 = graph.dijkstra_for_shortest_path_with_limit_and_target(0, 0, set(), {0, x, y})
        dis22 = graph.dijkstra_for_shortest_path_with_limit_and_target(x, 0, set(), {0, x, y})

        ans = min(max(dis1[x], dis2[y]), max(dis1[y], dis2[x]),
                  dis1[x] + dis11[y], dis1[y] + dis11[y],
                  dis2[x] + dis22[y], dis2[y] + dis22[y])
        ac.st(ans)
        return

    @staticmethod
    def lg_p5201(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5201
        tag: shortest_path_spanning_tree|build_graph|tree_dp
        """
        #  shortest_path_spanning_tree build_graph|，再tree_dp| 最优解
        n, m, t = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            a, b, c = ac.read_list_ints_minus_one()
            dct[a].append([b, c + 1])
            dct[b].append([a, c + 1])
        for i in range(n):
            dct[i].sort()
        # 先跑一遍shortest_path
        dis = [math.inf] * n
        stack = [[0, 0]]
        dis[0] = 0
        while stack:
            d, i = heappop(stack)
            if dis[i] < d:
                continue
            for j, w in dct[i]:
                dj = w + d
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, (dj, j))

        # 选择lexicographical_order较小的边建立shortest_path_spanning_tree
        edge = [[] for _ in range(n)]
        visit = [0] * n
        for i in range(n):
            for j, w in dct[i]:
                if visit[j]:
                    continue
                if dis[i] + w == dis[j]:
                    edge[i].append(j)
                    edge[j].append(i)
                    visit[j] = 1

        # tree_dp| 
        stack = [[0, -1]]
        ans = 0
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append([~i, fa])
                for j in edge[i]:
                    if j != fa:
                        stack.append([j, i])
            else:
                i = ~i
                for j in edge[i]:
                    if j != fa:
                        nums[i] += nums[j]
                ans = max(ans, nums[i] * (dis[i] - t))
        ac.st(ans)
        return

    @staticmethod
    def lg_p5663(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5663
        tag: shortest_odd_path|shortest_even_path
        """
        n, m, q = ac.read_list_ints()
        inf = math.inf
        graph = WeightedGraphForDijkstra(n, inf)
        for i in range(m):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, 1)

        dis = graph.bfs_for_shortest_path_with_odd_and_even(0)
        for _ in range(q):
            x, y = ac.read_list_ints()
            x -= 1
            if dis[x * 2 + y % 2] > y:
                ac.no()
            else:
                ac.yes()
        return

    @staticmethod
    def lg_p5683(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5683
        tag: several_dijkstra|shortest_path|brute_force
        """
        n, m = ac.read_list_ints()
        inf = m + 1
        graph = WeightedGraphForDijkstra(n, inf)
        nums = []
        while len(nums) < 2 * m:
            nums.extend(ac.read_list_ints_minus_one())
        for i in range(0, 2 * m, 2):
            x, y = nums[i], nums[i + 1]
            graph.add_undirected_edge(x, y, 1)
        s1, t1, s2, t2 = ac.read_list_ints()
        s1 -= 1
        s2 -= 1
        dis0 = graph.dijkstra_for_shortest_path(0)
        dis1 = graph.dijkstra_for_shortest_path(s1)
        dis2 = graph.dijkstra_for_shortest_path(s2)
        ans = inf
        for i in range(n):
            cur = dis0[i] + dis1[i] + dis2[i]
            if dis1[i] + dis0[i] <= t1 and dis2[i] + dis0[i] <= t2:
                ans = min(ans, cur)
        ac.st(-1 if ans == inf else m - ans)
        return

    @staticmethod
    def lg_p5837(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5837
        tag: dijkstra|several_params
        """
        # Dijkstra变形问题，带多个状态
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j, c, f = ac.read_list_ints()
            dct[i - 1].append([j - 1, c, f])
            dct[j - 1].append([i - 1, c, f])

        dis = [math.inf] * n
        stack = [[0, 0, 0, math.inf]]
        dis[0] = 0
        while stack:
            d, i, cost, flow = heappop(stack)
            if dis[i] < d:
                continue
            for j, c, f in dct[i]:
                dj = -min(flow, f) / (cost + c)
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, [dj, j, cost + c, min(flow, f)])
        ac.st(int(-dis[-1] * 10 ** 6))
        return

    @staticmethod
    def lg_p5930(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5930
        tag: dijkstra|minimum_max_weight_on_shortest_path
        """
        # 接雨水 Dijkstra 
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        visit = [[math.inf] * n for _ in range(n)]
        stack = []
        for i in [0, m - 1]:
            for j in range(n):
                stack.append([grid[i][j], i, j])
                visit[i][j] = grid[i][j]
        for j in [0, n - 1]:
            for i in range(1, m - 1):
                stack.append([grid[i][j], i, j])
                visit[i][j] = grid[i][j]
        heapify(stack)
        while stack:
            d, i, j = heappop(stack)
            if visit[i][j] < d:
                continue
            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= x < m and 0 <= y < n:
                    # 每条路径边权最大值当中的最小值
                    dj = max(grid[x][y], d)
                    if dj < visit[x][y]:
                        visit[x][y] = dj
                        heappush(stack, [dj, x, y])
        ans = 0
        for i in range(m):
            for j in range(n):
                ans += visit[i][j] - grid[i][j]
        ac.st(ans)
        return

    @staticmethod
    def lg_p6063(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6063
        tag: dijkstra|minimum_max_weight_on_shortest_path
        """
        # Dijkstra应用接雨水
        n, m = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]

        # 虚拟化超级汇点初始化起点
        stack = []
        for i in [0, m - 1]:
            for j in range(n):
                stack.append([grid[i][j], i, j])
        for i in range(1, m - 1):
            for j in [0, n - 1]:
                stack.append([grid[i][j], i, j])
        heapify(stack)

        # shortest_path算法寻找每个格子到达超级汇点的路径途中最大值里面的最小值
        ans = 0
        while stack:
            dis, i, j = heappop(stack)
            if grid[i][j] == -1:
                continue
            ans += 0 if dis < grid[i][j] else dis - grid[i][j]
            grid[i][j] = -1
            for x, y in [[i - 1, j], [i + 1, j], [i, j + 1], [i, j - 1]]:
                if 0 <= x < m and 0 <= y < n and grid[x][y] != -1:
                    heappush(stack, [dis if dis > grid[x][y] else grid[x][y], x, y])
        ac.st(ans)
        return

    @staticmethod
    def lc_2714_1(n: int, edges: List[List[int]], s: int, d: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-shortest-path-with-k-hops/
        tag: limited_shortest_path|layered_dijkstra
        """
        # limited_shortest_path，也可以分层 Dijkstra 求解
        dct = [[] for _ in range(n)]
        for u, v, w in edges:
            dct[u].append([v, w])
            dct[v].append([u, w])

        visit = [[math.inf] * (k + 1) for _ in range(n)]
        stack = [[0, 0, s]]
        visit[s][0] = 0
        while stack:
            dis, c, i = heappop(stack)
            if i == d:
                return dis
            if visit[i][c] < dis:
                continue
            for j, w in dct[i]:
                if c + 1 <= k and dis < visit[j][c + 1]:
                    visit[j][c + 1] = dis
                    heappush(stack, [dis, c + 1, j])
                if dis + w < visit[j][c]:
                    visit[j][c] = dis + w
                    heappush(stack, [dis + w, c, j])
        return -1

    @staticmethod
    def lc_2714_2(n: int, edges: List[List[int]], s: int, d: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/find-shortest-path-with-k-hops/
        tag: limited_shortest_path|layered_dijkstra
        """
        # limited_shortest_path，也可以分层 Dijkstra 求解
        dct = [[] for _ in range(n)]
        for u, v, w in edges:
            dct[u].append([v, w])
            dct[v].append([u, w])

        n = len(dct)
        cnt = [math.inf] * n
        stack = [[0, 0, s]]
        while stack:
            dis, c, i = heappop(stack)
            if i == d:
                return dis
            if cnt[i] < c:
                continue
            cnt[i] = c
            for j, w in dct[i]:
                if c + 1 < cnt[j] and c + 1 <= k:
                    heappush(stack, [dis, c + 1, j])
                if c < cnt[j]:
                    heappush(stack, [dis + w, c, j])
        return -1

    @staticmethod
    def lc_2577(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/
        tag: dijkstra|matrix
        """
        # Dijkstra变形二维矩阵题目

        m, n = len(grid), len(grid[0])
        if grid[0][1] > 1 and grid[1][0] > 1:
            return -1

        dis = [[math.inf] * n for _ in range(m)]
        dis[0][0] = 0
        stack = [[0, 0, 0]]

        while stack:
            d, i, j = heappop(stack)
            if dis[i][j] < d:
                continue
            for x, y in [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]:
                if 0 <= x < m and 0 <= y < n:
                    if grid[x][y] <= d + 1:
                        dj = d + 1
                    else:
                        dj = d + 1 + 2 * ((grid[x][y] - d - 1 + 1) // 2)
                    if dj < dis[x][y]:
                        dis[x][y] = dj
                        heappush(stack, [dj, x, y])
        return dis[-1][-1]

    @staticmethod
    def lc_2699(n: int, edges: List[List[int]], source: int, destination: int, target: int) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/modify-graph-edge-weights/
        tag: dijkstra|shortest_path|greedy|brain_teaser
        """
        dct = [[] for _ in range(n)]
        m = len(edges)
        book = [0] * m
        for ind, (i, j, w) in enumerate(edges):
            if w == -1:
                w = 1
                book[ind] = 1
                edges[ind][-1] = w
            dct[i].append([ind, j])
            dct[j].append([ind, i])

        # 第一遍shortest_path最小情况下的距离
        dis0 = [math.inf] * n
        stack = [[0, source]]
        dis0[source] = 0
        while stack:
            d, i = heappop(stack)
            if dis0[i] < d:
                continue
            for ind, j in dct[i]:
                dj = edges[ind][2] + d
                if dj < dis0[j]:
                    dis0[j] = dj
                    heappush(stack, (dj, j))
        if dis0[destination] > target:
            return []

        # 第二遍shortest_path
        dis1 = [math.inf] * n
        stack = [[0, source]]
        dis1[source] = 0
        while stack:
            d, i = heappop(stack)
            if dis1[i] < d:
                continue
            for ind, j in dct[i]:
                if book[ind]:
                    # 假设 (i, j) 是shortest_path上的边
                    if (edges[ind][2] + dis1[i]) + (dis0[destination] - dis0[j]) < target:
                        # 此时还有一些增长空间即（当前到达 j 的距离）|上（剩余 j 到 destination）的距离仍旧小于 target
                        x = target - (edges[ind][2] + dis1[i]) - (dis0[destination] - dis0[j])
                        edges[ind][2] += x
                    book[ind] = 0
                dj = edges[ind][2] + d
                if dj < dis1[j]:
                    dis1[j] = dj
                    heappush(stack, (dj, j))

        if dis1[destination] == target:
            return edges
        return []

    @staticmethod
    def lg_p6512(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6512
        tag: shortest_path
        """
        n, m, k = ac.read_list_ints()
        inf = 10 ** 18
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)
        dis = [graph.dijkstra_for_shortest_path(i) for i in range(n)]

        dp = [-inf] * (k + 1)
        dp[0] = 0
        pos = [[0, 0]] + [ac.read_list_ints() for _ in range(k)]
        pos.sort()
        for i in range(k):
            t, v = pos[i + 1]
            v -= 1
            lst = [dp[j] + 1 for j in range(i + 1) if dis[v][pos[j][1] - 1] + pos[j][0] <= t] + [0]
            dp[i + 1] = max(lst)
        ac.st(max(dp))
        return

    @staticmethod
    def lg_p8385(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8385
        tag: brain_teaser|build_graph|shortest_path
        """
        # brain_teaserbuild_graph|shortest_path
        n = ac.read_int()
        price = [ac.read_int() for _ in range(n)]
        dct = [[] for _ in range(2 * n)]
        for _ in range(ac.read_int()):
            a, b, c = ac.read_list_ints_minus_one()
            c += 1
            dct[a].append([b, c])
            dct[a + n].append([b + n, c])
        for i in range(n):
            dct[i].append([i + n, price[i] / 2])

        dis = [math.inf] * 2 * n
        stack = [[0, 0]]
        dis[0] = 0
        while stack:
            total, i = heappop(stack)
            if dis[i] < total:
                continue
            for j, w in dct[i]:
                dj = total + w
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, (dj, j))
        ac.st(int(dis[n]))
        return

    @staticmethod
    def lc_1786(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/
        tag: dijkstra|limited_shortest_path|counter|dag|undirected_to_dag
        """
        # dijkstralimited_shortest_pathcounter（类似shortest_pathcounter）
        dct = defaultdict(dict)
        for i, j, w in edges:
            dct[i - 1][j - 1] = w
            dct[j - 1][i - 1] = w
        mod = 10 ** 9 + 7
        # reverse_order|shortest_path搜寻
        dis = [float('math.inf')] * n
        cnt = [0] * n
        cnt[n - 1] = 1
        dis[n - 1] = 0
        # 定义好初始值
        stack = [[0, n - 1]]
        while stack:
            cur_dis, cur = heappop(stack)
            if dis[cur] < cur_dis:
                continue
            dis[cur] = cur_dis
            for nex in dct[cur]:
                # 如果到达下一个点更近，则更新值
                if dis[nex] > dis[cur] + dct[cur][nex]:
                    dis[nex] = dis[cur] + dct[cur][nex]
                    heappush(stack, [dis[nex], nex])
                # 可以形成有效的路径
                if dis[cur] < dis[nex]:
                    cnt[nex] += cnt[cur]
                    cnt[nex] %= mod
        return cnt[0]

    @staticmethod
    def lc_1928_1(max_time: int, edges: List[List[int]], passing_fees: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/
        tag: dijkstra|limited_shortest_path|floyd
        """
        n = len(passing_fees)
        graph = LimitedWeightedGraph(n)
        for i, j, t in edges:
            graph.add_directed_edge(i, j, t, passing_fees[j])
            graph.add_directed_edge(j, i, t, passing_fees[i])

        ans = graph.limited_dijkstra_tuple(0, n - 1, max_time + 1, passing_fees[0])
        return ans

    @staticmethod
    def lc_1928_2(max_time: int, edges: List[List[int]], passing_fees: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/
        tag: dijkstra|limited_shortest_path|floyd
        """
        # Dijkstralimited_shortest_path，也可根据无后效性类似Floyd的动态规划求解
        n = len(passing_fees)
        dp = [[math.inf] * (max_time + 1) for _ in range(n)]
        dp[0][0] = passing_fees[0]
        for t in range(max_time + 1):
            for i, j, w in edges:
                if w <= t:
                    a, b = dp[j][t], dp[i][t - w] + passing_fees[j]
                    dp[j][t] = a if a < b else b

                    a, b = dp[i][t], dp[j][t - w] + passing_fees[i]
                    dp[i][t] = a if a < b else b
        ans = min(dp[-1])
        return ans if ans < math.inf else -1

    @staticmethod
    def lc_1976(n: int, roads: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/
        tag: dijkstra|number_of_shortest_path|classical
        """
        mod = 10 ** 9 + 7
        inf = 10 ** 15
        graph = WeightedGraphForDijkstra(n, inf)
        for i, j, w in roads:
            graph.add_undirected_edge(i, j, w)
        _, cnt = graph.dijkstra_for_cnt_of_shortest_path(0, 0, mod)
        return cnt[n - 1]

    @staticmethod
    def abc_142f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc142/tasks/abc142_f
        tag: directed|directed_smallest_circle
        """
        n, m = ac.read_list_ints()
        inf = m + 1
        graph = WeightedGraphForDijkstra(n, inf)
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        for i, j in edges:
            graph.add_directed_edge(i, j, 1)

        ans = inf
        res = []
        for x, (i, j) in enumerate(edges):
            graph.edge_weight[x + 1] = inf
            path, dis = graph.bfs_for_shortest_path_from_src_to_dst(j, i)
            if dis < ans:
                ans = dis
                res = path[:]
            graph.edge_weight[x + 1] = 1
        if ans == inf:
            ac.st(-1)
            return
        ac.st(len(res))
        for a in res:
            ac.st(a + 1)
        return

    @staticmethod
    def ac_3628(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3631/
        tag: shortest_path_spanning_tree
        """
        # shortest_path_spanning_tree模板题
        n, m, k = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for ind in range(m):
            x, y, w = ac.read_list_ints()
            x -= 1
            y -= 1
            dct[x].append([y, w, ind])
            dct[y].append([x, w, ind])

        for i in range(n):
            dct[i].sort()

        # 先跑一遍shortest_path
        dis = [math.inf] * n
        stack = [[0, 0]]
        dis[0] = 0
        while stack:
            d, i = heappop(stack)
            if dis[i] < d:
                continue
            for j, w, _ in dct[i]:
                dj = w + d
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, (dj, j))

        # 选择lexicographical_order较小的边建立shortest_path树
        edge = [[] for _ in range(n)]
        visit = [0] * n
        for i in range(n):
            for j, w, ind in dct[i]:
                if visit[j]:
                    continue
                if dis[i] + w == dis[j]:
                    edge[i].append([j, ind])
                    edge[j].append([i, ind])
                    visit[j] = 1

        # 最后一遍bfs确定选择的边
        ans = []
        stack = [[0, -1]]
        while stack:
            x, fa = stack.pop()
            for y, ind in edge[x]:
                if y != fa:
                    ans.append(ind + 1)
                    stack.append([y, x])
        ans = ans[:k]
        ac.st(len(ans))
        ac.lst(ans)
        return

    @staticmethod
    def ac_3772(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3775/
        tag: build_graph|reverse_graph|dijkstra|shortest_path|counter|greedy|implemention
        """
        n, m = ac.read_list_ints()
        inf = m + 1
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            graph.add_directed_edge(v, u, 1)

        k = ac.read_int()
        p = ac.read_list_ints_minus_one()
        dis, cnt = graph.bfs_for_cnt_of_shortest_path(p[-1], 0)

        floor = 0
        for i in range(k - 1):
            if k - i - 1 == dis[p[i]]:
                break
            if dis[p[i - 1]] == dis[p[i]] + 1:
                continue
            else:
                floor += 1

        ceil = 0
        for i in range(k - 1):
            if dis[p[i]] == dis[p[i + 1]] + 1 and cnt[p[i]] == cnt[p[i + 1]]:
                continue
            else:
                ceil += 1
        ac.lst([floor, ceil])
        return

    @staticmethod
    def ac_3797(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3800/
        tag: shortest_path|brute_force|sort|greedy
        """
        n, m, k = ac.read_list_ints()
        color = ac.read_list_ints_minus_one()
        inf = m + 1
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, 1)

        dis1 = graph.bfs_for_shortest_path(0)
        dis2 = graph.bfs_for_shortest_path(n - 1)
        color = [(dis1[i] - dis2[i]) * n + i for i in color]
        color.sort()
        ans = -inf
        post = -inf
        for i in range(k - 1, -1, -1):
            ans = max(ans, min(dis1[n - 1], post + dis1[color[i] % n] + 1))
            post = max(post, dis2[color[i] % n])
        ac.st(ans)
        return

    @staticmethod
    def ac_4196(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4199/
        tag: shortest_path
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 15
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)
        path, ans = graph.dijkstra_for_shortest_path_from_src_to_dst(0, n - 1)
        if ans == inf:
            ac.st(-1)
        else:
            ac.lst([x + 1 for x in path])
        return

    @staticmethod
    def cf_1915g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1915/problem/G
        tag: shortest_path|limited_shortest_path|dijkstra
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            nums = [ac.read_list_ints() for _ in range(m)]
            s = ac.read_list_ints()
            for u, v, w in nums:
                dct[u - 1].append([v - 1, w])
                dct[v - 1].append([u - 1, w])

            n = len(dct)
            stack = [(0, 0, s[0])]
            vis = [math.inf] * n

            while stack:
                d, i, k = heappop(stack)
                if i == n - 1:
                    ac.st(d)
                    break
                if vis[i] <= k:
                    continue
                vis[i] = k
                ss = min(k, s[i])
                for j, w in dct[i]:
                    dj = d + ss * w
                    if ss < vis[j]:
                        heappush(stack, (dj, j, ss))
        return

    @staticmethod
    def abc_342e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc342/tasks/abc342_e
        tag: classical|dijkstra|longest_path
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            ll, dd, k, c, a, b = ac.read_list_ints()
            a -= 1
            b -= 1
            dct[b].append((a, ll, dd, k, c))
        n = len(dct)
        ceil = 5 * 10 ** 18
        dis = [ceil] * n
        dis[n - 1] = -ceil
        stack = [(-ceil, n - 1)]
        while stack:
            d, i = heappop(stack)
            if dis[i] < d:
                continue
            for j, ll, dd, k, c in dct[i]:
                ki = (-d - c - ll) // dd
                if ki >= 0:
                    ki = min(ki, k - 1)
                    dj = -(ll + ki * dd)
                    if dj < dis[j]:
                        dis[j] = dj
                        heappush(stack, (dj, j))
        for d in dis[:-1]:
            if d == ceil:
                ac.st("Unreachable")
            else:
                ac.st(-d)
        return

    @staticmethod
    def abc_348d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc348/tasks/abc348_d
        tag: bfs|dijkstra|limited_shortest_path|state|classical
        """
        m, n = ac.read_list_ints()
        visit = [[-1] * n for _ in range(m)]
        grid = [ac.read_str() for _ in range(m)]
        start = [-1, -1]
        end = [-1, -1]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "S":
                    start = [i, j]
                elif grid[i][j] == "T":
                    end = [i, j]
        power = [[0] * n for _ in range(m)]
        for _ in range(ac.read_int()):
            r, c, w = ac.read_list_ints()
            power[r - 1][c - 1] = w
        stack = [(-power[start[0]][start[1]], start[0], start[1])]
        heapify(stack)
        visit[start[0]][start[1]] = power[start[0]][start[1]]
        while stack:
            x, i, j = heappop(stack)
            if x >= 0:
                break
            for a, b in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= a < m and 0 <= b < n and grid[a][b] != "#":
                    nex = max(-x - 1, power[a][b])
                    if nex > visit[a][b]:
                        visit[a][b] = nex
                        heappush(stack, (-nex, a, b))
                        if [a, b] == end:
                            ac.yes()
                            return
        ac.st("Yes" if visit[end[0]][end[1]] > -1 else "No")
        return

    @staticmethod
    def abc_257f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc257/tasks/abc257_f
        tag: shortest_path|brute_force|bfs|classical
        """
        n, m = ac.read_list_ints()
        inf = m + 1
        graph = WeightedGraphForDijkstra(n + 1, inf)
        for _ in range(m):
            i, j = ac.read_list_ints()
            graph.add_undirected_edge(i, j, 1)

        dis1 = graph.bfs_for_shortest_path(1)
        dis2 = graph.bfs_for_shortest_path(n)
        ans = []

        for i in range(1, n + 1):
            cur = min(dis1[n], min(dis1[0], dis1[i]) + min(dis2[0], dis2[i]))
            ans.append(cur if cur < inf else -1)
        ac.lst(ans)
        return

    @staticmethod
    def lc_3112(n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        """
        url: https://leetcode.com/problems/minimum-time-to-visit-disappearing-nodes/description/
        tag: dijkstra|template|classical
        """
        dct = [[] for _ in range(n)]
        for i, j, t in edges:
            dct[i].append((j, t))
            dct[j].append((i, t))
        initial = 0
        src = 0
        dis = [math.inf] * n
        stack = [(initial, src)]
        dis[src] = initial

        while stack:
            d, i = heappop(stack)
            if dis[i] < d:
                continue
            for j, w in dct[i]:
                dj = d + w
                if dj < dis[j] and disappear[j] > dj:
                    dis[j] = dj
                    heappush(stack, (dj, j))
        return [x if x < math.inf else -1 for x in dis]

    @staticmethod
    def abc_252e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc252/tasks/abc252_e
        tag: shortest_path_spanning_tree|dijkstra|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for ind in range(m):
            x, y, w = ac.read_list_ints_minus_one()
            dct[x].append((y, w + 1, ind))
            dct[y].append((x, w + 1, ind))

        dis = [math.inf] * n
        stack = [(0, 0)]
        dis[0] = 0
        father = [-1] * n
        while stack:
            d, i = heappop(stack)
            if dis[i] < d:
                continue
            for j, w, ind in dct[i]:
                dj = w + d
                if dj < dis[j]:
                    dis[j] = dj
                    father[j] = ind
                    heappush(stack, (dj, j))
        ac.lst([x + 1 for x in father if x != -1])
        return

    @staticmethod
    def abc_245g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc245/tasks/abc245_g
        tag: shortest_path|second_shortest_path|dijkstra|brain_teaser|classical
        """
        n, m, k, ll = ac.read_list_ints()
        a = ac.read_list_ints_minus_one()
        b = ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            dct[i].append((j, w + 1))
            dct[j].append((i, w + 1))
        dis1 = [math.inf] * n
        dis2 = [math.inf] * n
        fa1 = [math.inf] * n
        fa2 = [math.inf] * n

        stack = []
        for i in b:
            fa1[i] = a[i]
            dis1[i] = 0
            stack.append((0, i, a[i]))

        while stack:
            d, i, color = heappop(stack)
            if color == fa1[i] and dis1[i] < d:
                continue
            if color == fa2[i] and dis2[i] < d:
                continue
            if dis2[i] < d:
                continue
            for j, w in dct[i]:
                dj = d + w
                if dj < dis1[j]:
                    if dis1[j] < dis2[j] and fa1[j] != color:
                        dis2[j] = dis1[j]
                        fa2[j] = fa1[j]
                    dis1[j] = dj
                    fa1[j] = color
                    heappush(stack, (dj, j, color))
                elif dj < dis2[j] and color != fa1[j]:
                    dis2[j] = dj
                    fa2[j] = color
                    heappush(stack, (dj, j, color))
        ans = [dis2[i] if fa1[i] == a[i] else dis1[i] for i in range(n)]
        ans = [x if x < math.inf else -1 for x in ans]
        ac.lst(ans)
        return

    @staticmethod
    def abc_237e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc237/tasks/abc237_e
        tag: dijkstra|negative_weight|graph_mapping|brain_teaser|classical
        """
        n, m = ac.read_list_ints()
        h = ac.read_list_ints()
        inf = 10 ** 18
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            graph.add_directed_edge(u, v, max(h[v] - h[u], 0))
            graph.add_directed_edge(v, u, max(h[u] - h[v], 0))
        dis = graph.dijkstra_for_shortest_path(0)
        ans = max(h[0] - h[i] - dis[i] for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def cf_449bb(ac=FastIO()):
        """
        url: https://codeforces.com/contest/449/problem/B
        tag: shortest_path|not_shortest_path_spanning_tree|union_find
        """
        n, m, k = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for ind in range(m):
            x, y, w = ac.read_list_ints()
            x -= 1
            y -= 1
            dct[x].append((y, w))
            dct[y].append((x, w))

        dis = [math.inf] * n
        use = [0] * n
        dis[0] = 0
        for i in range(k):
            s, y = ac.read_list_ints()
            s -= 1
            if y < dis[s]:
                use[s] = 1
                dis[s] = y

        stack = [dis[i] * n + i for i in range(n) if dis[i] < math.inf] + [0]
        heapify(stack)
        while stack:
            x = heappop(stack)
            d, i = x // n, x % n
            if dis[i] < d:
                continue
            for j, w in dct[i]:
                dj = w + d
                if dj < dis[j]:
                    dis[j] = dj
                    use[j] = 0
                    heappush(stack, dj * n + j)
                elif dj == dis[j]:
                    use[j] = 0
        ac.st(k - sum(use))
        return

    @staticmethod
    def cf_1307d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1307/D
        tag: math|graph|shortest_path|observation|brute_force
        """
        n, m, k = ac.read_list_ints()
        color = ac.read_list_ints_minus_one()
        inf = 10 ** 6
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, 1)

        dis1 = graph.bfs_for_shortest_path(0)
        dis2 = graph.bfs_for_shortest_path(n - 1)
        color = [(dis1[i] - dis2[i]) * n + i for i in color]
        color.sort()
        ans = -inf
        post = -inf
        for i in range(k - 1, -1, -1):
            ans = max(ans, min(dis1[n - 1], post + dis1[color[i] % n] + 1))
            post = max(post, dis2[color[i] % n])
        ac.st(ans)
        return

    @staticmethod
    def cf_938d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/938/D
        tag: dijkstra|fake_source|build_graph|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        for _ in range(m):
            i, j, w = ac.read_list_ints()
            dct[i].append((j, w))
            dct[j].append((i, w))
        a = ac.read_list_ints()
        for i in range(n):
            dct[0].append((i + 1, a[i]))

        n += 1
        dis = [math.inf] * n
        stack = [(0, 0)]

        while stack:
            d, i = heappop(stack)
            if dis[i] < d:
                continue
            for j, w in dct[i]:
                dj = d + w if not i else d + w * 2
                if dj < dis[j]:
                    dis[j] = dj
                    heappush(stack, (dj, j))
        ac.lst(dis[1:])
        return

    @staticmethod
    def cf_1817b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1817/B
        tag: undirected_shortest_circle|brute_force
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            edges = [ac.read_list_ints_minus_one() for _ in range(m)]
            dct = [set() for _ in range(n)]
            degree = [0] * n
            for i, j in edges:
                dct[i].add(j)
                dct[j].add(i)
                degree[i] += 1
                degree[j] += 1

            parent = [-1] * n
            dis = [math.inf] * n
            for x, y in edges:
                dct[x].discard(y)
                dct[y].discard(x)
                for i in range(n):
                    parent[i] = -1
                    dis[i] = math.inf

                stack = [x]
                dis[x] = 0
                while stack:
                    nex = []
                    for i in stack:
                        for j in dct[i]:
                            if dis[j] == math.inf:
                                dis[j] = dis[i] + 1
                                parent[j] = i
                                nex.append(j)
                    stack = nex[:]
                if dis[y] < math.inf:
                    lst = [y]
                    while lst[-1] != x:
                        lst.append(parent[lst[-1]])
                    if any(degree[z] >= 4 for z in lst):
                        ac.st("YES")
                        i = [z for z in lst if degree[z] >= 4][0]
                        k = len(lst)
                        res = k + 2
                        ac.st(res)
                        for j in range(k):
                            ac.lst([lst[j] + 1, lst[(j + 1) % k] + 1])
                        cnt = 0
                        cur = set(lst)
                        for j in dct[i]:
                            if j not in cur:
                                ac.lst([i + 1, j + 1])
                                cnt += 1
                                if cnt == 2:
                                    break
                        break
                dct[x].add(y)
                dct[y].add(x)
            else:
                ac.st("NO")
        return

    @staticmethod
    def cf_1473e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1473/E
        tag: layer_dijkstra|observation|classical|brain_teaser
        """

        n, m = ac.read_list_ints()  # TLE
        dct = [[] for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            dct[u - 1].append((v - 1, w))
            dct[v - 1].append((u - 1, w))

        n = len(dct)
        dis = [math.inf] * n * 4
        ans = [math.inf] * n
        stack = [(0, 0)]
        dis[0] = ans[0] = 0

        while stack:
            d, s = heappop(stack)
            if dis[s] < d:
                continue
            i = s >> 2
            s1 = s & 1
            s2 = s & 2
            if d < ans[i] and s1 and s2:
                ans[i] = d
            for j, w in dct[i]:
                dj = d + w
                if dj < dis[(j << 2) | s1 | s2]:
                    dis[(j << 2) | s1 | s2] = dj
                    heappush(stack, (dj, (j << 2) | s1 | s2))

                if not s1:
                    dj = d
                    if dj < dis[(j << 2) | 1 | s2]:
                        dis[(j << 2) | 1 | s2] = dj
                        heappush(stack, (dj, (j << 2) | 1 | s2))
                    if not s2:
                        dj = d + w
                        if dj < dis[(j << 2) | 1 | 2]:
                            dis[(j << 2) | 1 | 2] = dj
                            heappush(stack, (dj, (j << 2) | 1 | 2))

                if not s2:
                    dj = d + w * 2
                    if dj < dis[(j << 2) | s1 | 2]:
                        dis[(j << 2) | s1 | 2] = dj
                        heappush(stack, (dj, (j << 2) | s1 | 2))

        ac.lst(ans[1:])
        return

    @staticmethod
    def lg_p5764(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5764
        tag: several_dijkstra|shortest_path
        """
        n, m = ac.read_list_ints()
        lst = [0] + ac.read_list_ints_minus_one()
        inf = 10 ** 18
        graph = WeightedGraphForDijkstra(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j, w + 1)
        dis = [graph.dijkstra_for_shortest_path(x, 0) for x in lst]
        ans = inf
        for item in permutations(range(1, 6), 5):
            cur = [0] + list(item)
            cost = sum(dis[cur[i]][lst[cur[i + 1]]] for i in range(5))
            ans = min(ans, cost)
        ac.st(ans)
        return

    @staticmethod
    def abc_204e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc204/tasks/abc204_e
        tag: dijkstra|shortest_path|classical|observation
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            a, b, c, d = ac.read_list_ints()
            a -= 1
            b -= 1
            dct[a].append((b, c, d))
            dct[b].append((a, c, d))

        n = len(dct)
        dis = [math.inf] * n
        stack = [(0, 0)]
        dis[0] = 0

        while stack:
            pre, i = heappop(stack)
            if dis[i] < pre:
                continue
            for j, c, d in dct[i]:
                t = max(pre, int(d ** 0.5))
                dd = t + c + d // (t + 1)
                if dd < dis[j]:
                    dis[j] = dd
                    heappush(stack, (dd, j))
        ac.st(dis[-1] if dis[-1] < math.inf else -1)
        return

    @staticmethod
    def cf_545e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/545/E
        tag: shortest_path_spanning_tree|minimum_weight|dijkstra|classical|greedy|shortest_path_mst
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        weight = []
        for ind in range(m):
            x, y, w = ac.read_list_ints_minus_one()
            dct[x].append((y, ind))
            dct[y].append((x, ind))
            weight.append(w + 1)

        root = ac.read_int() - 1
        dis = [math.inf] * n
        stack = [root]
        dis[root] = 0
        father = [-1] * n
        weights = [math.inf] * n
        while stack:
            val = heappop(stack)
            d, i = val // n, val % n
            if dis[i] < d:
                continue
            for j, ind in dct[i]:
                w = weight[ind]
                dj = w + d
                if dj < dis[j] or (dj == dis[j] and w < weights[j]):
                    dis[j] = dj
                    father[j] = ind
                    weights[j] = w
                    heappush(stack, dj * n + j)
        res = [x + 1 for x in father if x != -1]
        ac.st(sum(weight[x - 1] for x in res))
        ac.lst(res)
        return

    @staticmethod
    def cf_786b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/786/problem/B
        tag: segment_tree_opt_build_graph|dijkstra|classical|weighted_graph
        """

        n, q, s = ac.read_list_ints()
        s -= 1
        graph = WeightedGraph(4 * n)
        tree = SegmentTreeOptBuildGraphZKW(n)
        for i in range(1, n):
            graph.add_directed_edge(i, i << 1, 0)
            graph.add_directed_edge(i, (i << 1) | 1, 0)
            graph.add_directed_edge((i << 1) + 2 * n, i + 2 * n, 0)
            graph.add_directed_edge(((i << 1) | 1) + 2 * n, i + 2 * n, 0)

        for i in range(n):
            graph.add_directed_edge(i + 3 * n, i + n, 0)
            graph.add_directed_edge(i + n, i + 3 * n, 0)

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                v, u, w = [x - 1 for x in lst[1:]]
                graph.add_directed_edge(v + n, u + n, w + 1)
            elif lst[0] == 2:
                v, ll, rr, w = [x - 1 for x in lst[1:]]
                lst = tree.range_opt(ll, rr)
                for j in lst:
                    graph.add_directed_edge(v + 3 * n, j, w + 1)
            else:
                v, ll, rr, w = [x - 1 for x in lst[1:]]
                lst = tree.range_opt(ll, rr)
                for j in lst:
                    graph.add_directed_edge(j + 2 * n, v + n, w + 1)

        graph.dijkstra(s + 3 * n)
        for i in range(n, 2 * n):
            if graph.dis[i] == math.inf:
                graph.dis[i] = -1
        ac.lst(graph.dis[n:2 * n])
        return

    @staticmethod
    def cf_1076d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1076/D
        tag: weighted_graph|shortest_path_mst
        """
        n, m, k = ac.read_list_ints()
        graph = WeightedGraphForShortestPathMST(n)
        for i in range(m):
            x, y, w = ac.read_list_ints_minus_one()
            w += 1
            graph.add_undirected_edge(x, y, w)
        res = graph.shortest_path_mst(0, k)
        ac.st(len(res))
        ac.lst(res)
        return

    @staticmethod
    def abc_375g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc375/tasks/abc375_g
        tag: dijkstra_for_cnt_of_shortest_path|key_edge_in_shortest_path
        """
        n, m = ac.read_list_ints()
        graph = WeightedGraphForDijkstra(n, 2 * 10 ** 14)
        for ind in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            graph.add_undirected_edge(i, j, w)
        assert graph.edge_id == 2 * m + 1

        mod = random.getrandbits(32)
        dis1, cnt1 = graph.dijkstra_for_cnt_of_shortest_path(0, 0, mod)
        dis2, cnt2 = graph.dijkstra_for_cnt_of_shortest_path(n - 1, 0, mod)

        for ind in range(m):
            i, j, w = graph.edge_from[ind * 2 + 1], graph.edge_to[ind * 2 + 1], graph.edge_weight[ind * 2 + 1]
            if dis1[i] + w + dis2[j] == dis1[-1] and cnt1[i] * cnt2[j] % mod == cnt1[-1]:
                ac.yes()
                continue
            i, j = j, i
            if dis1[i] + w + dis2[j] == dis1[-1] and cnt1[i] * cnt2[j] % mod == cnt1[-1]:
                ac.yes()
                continue
            ac.no()
        return
"""

Algorithm：euler_path|hierholzer
Description：directed_graph|undirected_graph|euler_path
directed_euler_path：start point has out_degree - in_degree = 1, end point has in_degree - out_degree = 1, others in_degree = out_degree
directed_euler_circular_path：all points have in_degree = out_degree, all points can be start or end point
undirected_euler_path：start and end point have odd degree, others have even degree
undirected_euler_circular_path：all points have even degree, all points can be start or end point
hamilton_path：like euler_path, path pass every node exactly once, back_trace?
hamilton_circular_path：like euler_circular_path, path pass every node exactly once, back_trace?
Note1：where there exist euler_circular_path, there exist euler_path
Note2：where there exist euler_path if and only if the graph is connected

====================================LeetCode====================================
332（https://leetcode.cn/problems/reconstruct-itinerary/）euler_circular_path
753（https://leetcode.cn/problems/cracking-the-safe/）euler_path
2097（https://leetcode.cn/problems/valid-arrangement-of-pairs/submissions/）euler_path
1743（https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/）undirected_euler_path|discretization

=====================================LuoGu======================================
P7771（https://www.luogu.com.cn/problem/P7771）euler_path
P6066（https://www.luogu.com.cn/problem/P6066）euler_path
P1127（https://www.luogu.com.cn/problem/P1127）lexicographical_order_minimum|directed_euler_path|specific_plan
P2731（https://www.luogu.com.cn/problem/P2731）lexicographical_order_minimum|undirected_euler_path|specific_plan
P1341（https://www.luogu.com.cn/problem/P1341）lexicographical_order_minimum|undirected_euler_path|specific_plan
P1333 （https://www.luogu.com.cn/problem/P1333）lexicographical_order_minimum|undirected_euler_path|specific_plan

=====================================CodeForces======================================
1981D（https://codeforces.com/contest/1981/problem/D）undirected_euler_path|brain_teaser|prime_sieve

=====================================AcWing=====================================
4211（https://www.acwing.com/problem/content/4214/）directed_euler_path|specific_plan

OI WiKi（https://oi-wiki.org/graph/euler/）
https://www.jianshu.com/p/8394b8e5b878
https://www.luogu.com.cn/problem/solution/P7771
"""
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.graph.euler_path.template import DirectedEulerPath, UnDirectedEulerPath
from src.graph.union_find.template import UnionFind
from src.mathmatics.number_theory.template import PrimeSieve
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p7771(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7771
        tag: directed_euler_path
        """
        n, m = ac.read_list_ints()
        pairs = [ac.read_list_ints_minus_one() for _ in range(m)]
        euler = DirectedEulerPath(n, pairs)
        if euler.exist:
            ac.lst([x + 1 for x in euler.nodes])
        else:
            ac.no()
        return

    @staticmethod
    def lg_p2731(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2731
        tag: lexicographical_order_minimum|undirected_euler_path|specific_plan
        """
        # 无向图euler_path或者euler_circular_path
        m = ac.read_int()
        pairs = [ac.read_list_ints() for _ in range(m)]
        node = set()
        for a, b in pairs:
            node.add(a)
            node.add(b)
        node = sorted(list(node))
        n = len(node)
        ind = {node[i]: i for i in range(n)}
        pairs = [[ind[x], ind[y]] for x, y in pairs]
        euler = UnDirectedEulerPath(n, pairs)
        for a in euler.nodes:
            ac.st(node[a])
        return

    @staticmethod
    def lg_p1341(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1341
        tag: lexicographical_order_minimum|undirected_euler_path|specific_plan
        """
        # 无向图euler_path或者euler_circular_path
        m = ac.read_int()
        nodes = set()
        pairs = []
        for _ in range(m):
            s = ac.read_str()
            nodes.add(s[0])
            nodes.add(s[1])
            pairs.append([s[0], s[1]])

        # 首先discretization编码判断是否连通
        nodes = sorted(list(nodes))
        ind = {num: i for i, num in enumerate(nodes)}
        n = len(nodes)
        uf = UnionFind(n)
        for x, y in pairs:
            uf.union(ind[x], ind[y])
        if uf.part != 1:
            ac.st("No Solution")
            return

        # 无向图lexicographical_order最小的欧拉序
        pairs = [[ind[x], ind[y]] for x, y in pairs]
        euler = UnDirectedEulerPath(n, pairs)
        if not euler.exist:
            ac.st("No Solution")
            return
        ans = "".join([nodes[a] for a in euler.nodes])
        ac.st(ans)
        return

    @staticmethod
    def lg_p1127(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1127
        tag: lexicographical_order_minimum|directed_euler_path|specific_plan
        """
        # 有向图euler_path或者euler_circular_path
        m = ac.read_int()

        # 最关键的build_graph|
        nodes = set()
        pairs = []
        for _ in range(m):
            s = ac.read_str()
            nodes.add(s[0])
            nodes.add(s[-1])
            nodes.add(s)
            pairs.append([s[0], s])
            pairs.append([s, s[-1]])

        # 按照序号编码并检查连通性
        nodes = sorted(list(nodes))
        ind = {num: i for i, num in enumerate(nodes)}
        n = len(nodes)
        uf = UnionFind(n)
        for x, y in pairs:
            uf.union(ind[x], ind[y])
        if uf.part != 1:
            ac.st("***")
            return

        # 有向图euler_path或者euler_circular_path的获取
        pairs = [[ind[x], ind[y]] for x, y in pairs]
        euler = DirectedEulerPath(n, pairs)
        if not euler.exist:
            ac.st("***")
            return

        # 去除虚拟开头与结尾字母
        ans = []
        for x in euler.nodes:
            ans.append(nodes[x])
        ans = ans[1:-1:2]
        ac.st(".".join(ans))
        return

    @staticmethod
    def lg_p6606(ac=FastIO()):
        # 有向图euler_path或者euler_circular_path
        n, m = ac.read_list_ints()
        # 最关键的build_graph|
        pairs = []
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            # 每条边两个方向各走一遍
            pairs.append([u, v])
            pairs.append([v, u])

        # 有向图euler_path或者euler_circular_path的获取
        euler = DirectedEulerPath(n, pairs)
        i = euler.nodes.index(0)
        for x in euler.nodes[i:] + euler.nodes[:i]:
            ac.st(x + 1)
        return

    @staticmethod
    def lc_1743(adjacent: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/
        tag: undirected_euler_path|discretization
        """
        # 无向图euler_path模板题, discretization解决
        nodes = set()
        for a, b in adjacent:
            nodes.add(a)
            nodes.add(b)
        nodes = sorted(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        pairs = [[ind[x], ind[y]] for x, y in adjacent]
        n = len(nodes)
        ruler = UnDirectedEulerPath(n, pairs)
        return [nodes[x] for x in ruler.nodes]

    @staticmethod
    def lc_2097(pairs: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/valid-arrangement-of-pairs/submissions/
        tag: euler_path
        """
        # euler_path模板题，discretization后转化为图的euler_path求解
        nodes = set()
        for a, b in pairs:
            nodes.add(a)
            nodes.add(b)
        nodes = list(nodes)
        n = len(nodes)
        ind = {num: i for i, num in enumerate(nodes)}
        lst = [[ind[a], ind[b]] for a, b in pairs]
        ep = DirectedEulerPath(n, lst)
        ans = ep.paths
        return [[nodes[x], nodes[y]] for x, y in ans]

    @staticmethod
    def ac_4211(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4214/
        tag: directed_euler_path|specific_plan
        """
        # 有向图euler_path模板题
        n = ac.read_int()
        pairs = []
        nums = ac.read_list_ints()
        for i in range(n):
            for j in range(n):
                if j != i:
                    if nums[j] == nums[i] * 2 or nums[j] * 3 == nums[i]:
                        pairs.append([i, j])
        dt = DirectedEulerPath(n, pairs)
        ac.lst([nums[x] for x in dt.nodes])
        return

    @staticmethod
    def cf_1981d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1981/problem/D
        tag: undirected_euler_path|brain_teaser|prime_sieve
        """

        def check(x):
            if x % 2:
                return x * (x + 1) // 2 >= n - 1
            return x * x // 2 + 1 >= n - 1

        # TLE
        primes = PrimeSieve().eratosthenes_sieve(10 ** 5)

        for _ in range(ac.read_int()):
            n = ac.read_int()
            m = BinarySearch().find_int_left(1, n + 10, check)
            edges = set()
            for i in range(m):
                for j in range(i + 1, m):
                    edges.add((i, j))
            if m % 2 == 0:
                tot = 0
                for i in range(1, m - 2, 2):
                    edges.discard((i, i + 1))
                    tot += 1
                assert tot == m // 2 - 1
            path = UnDirectedEulerPath(n, list(edges))
            assert path.exist
            ans = [primes[x] for x in path.nodes[:n]]
            pre = set()
            res = []
            rest = n - len(ans)
            for num in ans:
                res.append(num)
                if num not in pre and rest:
                    rest -= 1
                    pre.add(num)
                    res.append(num)
            ac.lst(res)
        return"""

Algorithm：floyd|several_source_shortest_path|undirected_graph|directed_graph|pos_weight|neg_weight|negative_circle|shortest_circle
Description：shortest_path|longest_path|necessary_point_on_shortest_path|necessary_point_on_longest_path|necessary_edge
specific_plan： floyd need dp[i][j] where pre[i][j] = k, and bellman-ford dijkstra need pre[v] = u

====================================LeetCode====================================
2642（https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/）floyd|dynamic_graph|shortest_path
1462（https://leetcode.cn/problems/course-schedule-iv/）transitive_closure|floyd

=====================================LuoGu======================================
P1119（https://www.luogu.com.cn/problem/P1119）offline_query|floyd|dynamic_graph
P1476（https://www.luogu.com.cn/problem/P1476）floyd|longest_path|specific_plan
P3906（https://www.luogu.com.cn/problem/P3906）floyd|shortest_path|specific_plan

P2009（https://www.luogu.com.cn/problem/P2009）floyd|shortest_path
P2419（https://www.luogu.com.cn/problem/P2419）floyd|topological_sort
P2910（https://www.luogu.com.cn/problem/P2910）shortest_path|floyd
P6464（https://www.luogu.com.cn/problem/P6464）brute_force|floyd|dynamic_graph
P6175（https://www.luogu.com.cn/problem/P6175）floyd|brute_force|O(n^3)|bfs|dijkstra
B3611（https://www.luogu.com.cn/problem/B3611）transitive_closure|floyd
P1613（https://www.luogu.com.cn/problem/P1613）floyd|several_floyd|shortest_path
P8312（https://www.luogu.com.cn/problem/P8312）limited_floyd|shortest_path|several_floyd
P8794（https://www.luogu.com.cn/problem/P8794）binary_search|floyd


===================================CodeForces===================================
472D（https://codeforces.com/problemset/problem/472/D）floyd|construction|shortest_path
1205B（https://codeforces.com/problemset/problem/1205/B）data_range|floyd|undirected_shortest_circle
25C（https://codeforces.com/problemset/problem/25/C）floyd
543B（https://codeforces.com/problemset/problem/543/B）bfs|brute_force|observation|floyd|implemention


====================================AtCoder=====================================
ABC051D（https://atcoder.jp/contests/abc051/tasks/abc051_d）floyd|shortest_path|necessary_edge|classical
ABC074D（https://atcoder.jp/contests/abc074/tasks/arc083_b）shortest_path_spanning_tree|floyd|dynamic_graph
ABC143E（https://atcoder.jp/contests/abc143/tasks/abc143_e）floyd|build_graph|shortest_path|several_floyd
ABC286E（https://atcoder.jp/contests/abc286/tasks/abc286_e）floyd|classical
ABC243E（https://atcoder.jp/contests/abc243/tasks/abc243_e）get_cnt_of_shortest_path|undirected|dijkstra|floyd|classical
ABC208D（https://atcoder.jp/contests/abc208/tasks/abc208_d）floyd|shortest_path|classical
ABC369E（https://atcoder.jp/contests/abc369/tasks/abc369_e）floyd|permutation|brute_force
ABC375F（https://atcoder.jp/contests/abc375/tasks/abc375_f）floyd|add_undirected_edge
        
=====================================AcWing=====================================
4872（https://www.acwing.com/problem/content/submission/4875/）floyd|reverse_thinking|shortest_path|reverse_graph

"""
import math
import random
from collections import defaultdict
from heapq import heappop, heappush
from itertools import permutations
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.graph.floyd.template import WeightedGraphForFloyd
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1613(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1613
        tag: floyd|several_floyd|shortest_path
        """
        n, m = ac.read_list_ints()

        pre = [0] * n * n
        cur = [0] * n * n
        dis = [math.inf] * n * n
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            pre[u * n + v] = dis[u * n + v] = 1

        for x in range(1, 32):
            for k in range(n):
                for i in range(n):
                    if not pre[i * n + k]:
                        continue
                    for j in range(n):
                        if pre[i * n + k] and pre[k * n + j]:
                            cur[i * n + j] = dis[i * n + j] = 1

            for i in range(n * n):
                pre[i] = cur[i]
                cur[i] = 0

        for k in range(n):
            for i in range(n):
                if dis[i * n + k] == math.inf:
                    continue
                for j in range(n):
                    dis[i * n + j] = min(dis[i * n + j], dis[i * n + k] + dis[k * n + j])
        ac.st(dis[n - 1])
        return

    @staticmethod
    def ac_4872(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4875/
        tag: floyd|reverse_thinking|shortest_path|reverse_graph
        """
        n = ac.read_int()
        dp = [ac.read_list_ints() for _ in range(n)]
        a = ac.read_list_ints_minus_one()
        node = []
        ans = []
        for ind in range(n - 1, -1, -1):
            x = a[ind]
            node.append(x)
            cur = 0
            for i in node:
                for j in node:
                    dp[i][x] = min(dp[i][x], dp[i][j] + dp[j][x])
                    dp[x][i] = min(dp[x][i], dp[x][j] + dp[j][i])

            for i in node:
                for j in node:
                    dp[i][j] = min(dp[i][j], dp[i][x] + dp[x][j])
                    cur += dp[i][j]
            ans.append(cur)

        ac.lst(ans[::-1])
        return

    @staticmethod
    def lg_p1119(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1119
        tag: offline_query|floyd|dynamic_graph|undirected
        """
        n, m = ac.read_list_ints()
        repair = ac.read_list_ints()
        inf = 10 ** 10
        graph = WeightedGraphForFloyd(n, inf)
        for i in range(m):
            i, j, w = ac.read_list_ints()
            graph.add_undirected_edge_initial(i, j, w)

        k = 0
        for _ in range(ac.read_int()):
            x, y, t = ac.read_list_ints()
            while k < n and repair[k] <= t:
                graph.update_point_undirected(k)
                k += 1
            if graph.dis[x * n + y] < inf and x < k and y < k:
                ac.st(graph.dis[x * n + y])
            else:
                ac.st(-1)
        return

    @staticmethod
    def lg_p1476(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1476
        tag: floyd|longest_path|specific_plan|classical
        """
        n = ac.read_int() + 1
        m = ac.read_int()
        inf = 10 ** 6
        graph = WeightedGraphForFloyd(n, inf)
        for _ in range(m):
            i, j, k = ac.read_list_ints_minus_one()
            if i == j:
                continue
            graph.add_directed_edge_initial(i, j, -k - 1)
        graph.initialize_directed()

        ans = -graph.dis[n - 1]
        path = graph.get_nodes_between_src_and_dst(0, n - 1)
        ac.st(ans)
        ac.lst([x + 1 for x in path])
        return

    @staticmethod
    def lg_p3906(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3906
        tag: floyd|shortest_path|specific_plan|classical
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 4
        graph = WeightedGraphForFloyd(n, inf)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge_initial(i, j, 1)
        graph.initialize_undirected()

        for _ in range(ac.read_int()):
            i, j = ac.read_list_ints_minus_one()
            path = graph.get_nodes_between_src_and_dst(i, j)
            ac.lst([x + 1 for x in path])
        return

    @staticmethod
    def lg_b3611(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/B3611
        tag: transitive_closure|floyd
        """
        n = ac.read_int()
        inf = 10 ** 5
        graph = WeightedGraphForFloyd(n, inf)
        dp = []
        for _ in range(n):
            dp.extend(ac.read_list_ints())
        for i in range(n):
            for j in range(n):
                if dp[i * n + j]:
                    graph.add_directed_edge_initial(i, j, 1)
        for i in range(n):
            graph.dis[i * n + i] = inf

        graph.initialize_directed()
        for i in range(n):
            ac.lst([int(graph.dis[i * n + j] < inf) for j in range(n)])
        return

    @staticmethod
    def abc_051d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc051/tasks/abc051_d
        tag: floyd|shortest_path|necessary_edge|classical|reverse_thinking
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 7
        graph = WeightedGraphForFloyd(n, inf)
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        for i, j, w in edges:
            graph.add_undirected_edge_initial(i, j, w + 1)
        graph.initialize_undirected()
        ans = sum(graph.dis[i * n + j] < w + 1 for i, j, w in edges)
        ac.st(ans)
        return

    @staticmethod
    def abc_074d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc074/tasks/arc083_b
        tag: shortest_path_spanning_tree|floyd|dynamic_graph
        """
        n = ac.read_int()
        grid = []
        for _ in range(n):
            grid.extend(ac.read_list_ints())

        vals = []
        for i in range(n):
            if grid[i * n + i]:
                ac.st(-1)
                return
            for j in range(i + 1, n):
                if grid[i * n + j] != grid[j * n + i]:
                    ac.st(-1)
                    return
                vals.append(grid[i * n + j] * n * n + i * n + j)

        vals.sort()
        inf = 10 ** 15
        graph = WeightedGraphForFloyd(n, inf)
        ans = 0
        for val in vals:
            w, num = val // n // n, val % (n * n)
            i, j = num // n, num % n
            if graph.dis[i * n + j] < w:
                ac.st(-1)
                return
            if graph.dis[i * n + j] == w:
                continue
            ans += w
            graph.add_undirected_edge(i, j, w)
        ac.st(ans)
        return

    @staticmethod
    def abc_143e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc143/tasks/abc143_e
        tag: floyd|build_graph|shortest_path|several_floyd
        """
        n, m, ll = ac.read_list_ints()

        inf = 10 ** 15
        graph = WeightedGraphForFloyd(n, inf)
        for _ in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            graph.add_undirected_edge_initial(i, j, w)

        graph.initialize_undirected()
        for i in range(n):
            for j in range(i + 1, n):
                graph.dis[i * n + j] = 0 if graph.dis[j * n + i] <= ll else inf

        for k in range(n):
            for i in range(graph.n):
                if graph.dis[i * graph.n + k] == graph.inf:
                    continue
                for j in range(i + 1, graph.n):
                    cur = graph.dis[i * graph.n + k] + graph.dis[k * graph.n + j] + 1
                    graph.dis[i * graph.n + j] = graph.dis[j * graph.n + i] = min(graph.dis[i * graph.n + j], cur)

        for _ in range(ac.read_int()):
            i, j = ac.read_list_ints_minus_one()
            ans = graph.dis[i * n + j]
            ac.st(ans if ans < inf else -1)
        return

    @staticmethod
    def cf_472d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/472/D
        tag: floyd|construction|shortest_path
        """

        n = ac.read_int()
        grid = [ac.read_list_ints() for _ in range(n)]
        for i in range(n):
            if grid[i][i]:
                ac.no()
                return
            for j in range(i + 1, n):
                if grid[i][j] != grid[j][i] or not grid[i][j]:
                    ac.no()
                    return
        if n == 1:
            ac.yes()
            return
        for i in range(n):
            j = 1 if not i else 0
            for r in range(n):
                if grid[i][r] < grid[i][j] and i != r:
                    j = r
            for k in range(n):
                if abs(grid[i][k] - grid[j][k]) != grid[i][j]:
                    ac.no()
                    return
        ac.yes()
        return

    @staticmethod
    def lg_p8312(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8312
        tag: limited_floyd|shortest_path|several_floyd
        """
        n, m = ac.read_list_ints()
        dis = [[math.inf] * n for _ in range(n)]
        for i in range(n):
            dis[i][i] = 0

        for _ in range(m):
            a, b, c = ac.read_list_ints_minus_one()
            c += 1
            dis[a][b] = min(dis[a][b], c)

        dct = [d[:] for d in dis]
        k, q = ac.read_list_ints()
        nums = [ac.read_list_ints_minus_one() for _ in range(q)]
        k = min(k, n)
        for _ in range(k - 1):
            cur = [d[:] for d in dis]
            for p in range(n):
                for i in range(n):
                    for j in range(n):
                        cur[i][j] = min(cur[i][j], dis[i][p] + dct[p][j])
            dis = [d[:] for d in cur]

        for c, d in nums:
            res = dis[c][d]
            ac.st(res if res < math.inf else -1)
        return

    @staticmethod
    def lg_p8794(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8794
        tag: binary_search|floyd
        """

        def get_dijkstra_result_mat(mat: List[List[int]], src: int) -> List[float]:
            len(mat)
            dis = [math.inf] * n
            stack = [[0, src]]
            dis[src] = 0
            visit = set(list(range(n)))
            while stack:
                d, ii = heappop(stack)
                if dis[ii] < d:
                    continue
                visit.discard(ii)
                for j in visit:
                    dj = mat[ii][j] + d
                    if dj < dis[j]:
                        dis[j] = dj
                        heappush(stack, [dj, j])
            return dis

        n, q = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(n)]
        lower = [ac.read_list_ints() for _ in range(n)]
        ans = 0
        for i in range(n):
            ans += sum(get_dijkstra_result_mat(lower, i))
        if ans > q:
            ac.st(-1)
            return

        ans = 0
        for i in range(n):
            ans += sum(get_dijkstra_result_mat(grid, i))
        if ans <= q:
            ac.st(0)
            return

        def check(x):
            cnt = [x // n] * n
            for y in range(x % n):
                cnt[y] += 1
            cur = [[0] * n for _ in range(n)]
            for a in range(n):
                for b in range(n):
                    cur[a][b] = max(lower[a][b], grid[a][b] - cnt[a] - cnt[b])
            dis = 0
            for y in range(n):
                dis += sum(get_dijkstra_result_mat(cur, y))
            return dis <= q

        def check2(x):
            cnt = [x // n] * n
            for y in range(x % n):
                cnt[y] += 1
            cur = [[0] * n for _ in range(n)]
            for a in range(n):
                for b in range(n):
                    cur[a][b] = max(lower[a][b], grid[a][b] - cnt[a] - cnt[b])
            for k in range(n):
                for a in range(n):
                    for b in range(a + 1, n):
                        cur[a][b] = cur[b][a] = min(cur[a][b], cur[a][k] + cur[k][b])
            return sum(sum(c) for c in cur) <= q

        low = 1
        high = n * 10 ** 5
        BinarySearch().find_int_left(low, high, check)
        ans = BinarySearch().find_int_left(low, high, check2)
        ac.st(ans)
        return

    @staticmethod
    def lc_2642():
        """
        url: https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/
        tag: floyd|dynamic_graph|shortest_path
        """

        class Graph:

            def __init__(self, n: int, edges: List[List[int]]):
                self.graph = WeightedGraphForFloyd(n, 10 ** 15)
                for i, j, w in edges:
                    self.graph.add_directed_edge_initial(i, j, w)
                self.graph.initialize_directed()

            def add_edge(self, edge: List[int]) -> None:
                i, j, w = edge
                if w < self.graph.dis[i * self.graph.n + j]:
                    self.graph.add_directed_edge(i, j, w)

            def shortest_path(self, node1: int, node2: int) -> int:
                ans = self.graph.dis[node1 * self.graph.n + node2]
                return ans if ans < self.graph.inf else -1

        return Graph

    @staticmethod
    def abc_286e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc286/tasks/abc286_e
        tag: floyd|classical
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        s = [ac.read_str() for _ in range(n)]

        inf = 10 ** 18
        dis = [inf] * n * n
        gain = [0] * n * n
        for i in range(n):
            dis[i * n + i] = 0
            gain[i * n + i] = a[i]

        for i in range(n):
            for j in range(n):
                if s[i][j] == "Y":
                    dis[i * n + j] = 1
                    gain[i * n + j] = a[i] + a[j]

        for k in range(n):
            for i in range(n):
                if dis[i * n + k] == inf:
                    continue
                for j in range(n):
                    cur = dis[i * n + k] + dis[k * n + j]
                    g = gain[i * n + k] + gain[k * n + j] - a[k]
                    if cur < dis[i * n + j] or (cur == dis[i * n + j] and g > gain[i * n + j]):
                        gain[i * n + j] = g
                        dis[i * n + j] = cur

        for _ in range(ac.read_int()):
            u, v = ac.read_list_ints_minus_one()
            if dis[u * n + v] == inf:
                ac.st("Impossible")
            else:
                ac.lst([dis[u * n + v], gain[u * n + v]])
        return

    @staticmethod
    def abc_243e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc243/tasks/abc243_e
        tag: get_cnt_of_shortest_path|undirected|dijkstra|floyd|classical
        """
        n, m = ac.read_list_ints()
        graph = WeightedGraphForFloyd(n)
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        for i, j, w in edges:
            graph.add_undirected_edge_initial(i, j, w + 1)
        mod = random.getrandbits(32)
        graph.get_cnt_of_shortest_path_undirected(mod)
        ans = sum(graph.cnt[i * n + j] > 1 or graph.dis[i * n + j] < w + 1 for i, j, w in edges)
        ac.st(ans)
        return

    @staticmethod
    def abc_208d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc208/tasks/abc208_d
        tag: floyd|shortest_path|classical
        """
        n, m = ac.read_list_ints()
        dp = [[math.inf] * n for _ in range(n)]
        for i in range(n):
            dp[i][i] = 0
        for _ in range(m):
            i, j, c = ac.read_list_ints_minus_one()
            c += 1
            dp[i][j] = c
        ans = 0
        tot = sum(sum(x if x < math.inf else 0 for x in dp[i]) for i in range(n))
        for i in range(n):
            for a in range(n):
                if dp[a][i] < math.inf:
                    for b in range(n):
                        if dp[a][i] + dp[i][b] < dp[a][b]:
                            if dp[a][b] < math.inf:
                                tot -= dp[a][b]
                            dp[a][b] = dp[a][i] + dp[i][b]
                            tot += dp[a][b]
            ans += tot
        ac.st(ans)
        return

    @staticmethod
    def cf_1205b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1205/B
        tag: data_range|floyd|undirected_shortest_circle
        """
        ac.read_int()
        nums = ac.read_list_ints()
        nums = [num for num in nums if num]
        n = len(nums)
        if n <= 2:
            ac.st(-1)
            return
        dct = [[] for _ in range(64)]
        for i, num in enumerate(nums):
            for x in range(64):
                if (num >> x) & 1:
                    dct[x].append(i)
        if any(len(dct[w]) >= 3 for w in range(64)):
            ac.st(3)
            return

        assert n <= 200
        edge = [math.inf] * n * n
        dis = [math.inf] * n * n
        for x in range(64):
            if len(dct[x]) == 2:
                i, j = dct[x][0], dct[x][1]
                dis[i * n + j] = dis[j * n + i] = 1
                edge[i * n + j] = edge[j * n + i] = 1
        ans = math.inf
        for k in range(n):
            for i in range(n):
                if dis[i * n + k] == math.inf:
                    continue
                for j in range(i + 1, n):
                    ans = min(ans, dis[i * n + j] + edge[i * n + k] + edge[k * n + j])  # classical
            for i in range(n):
                if dis[i * n + k] == math.inf:
                    continue
                for j in range(i + 1, n):
                    dis[j * n + i] = dis[i * n + j] = min(dis[i * n + j], dis[i * n + k] + dis[k * n + j])
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_369e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc369/tasks/abc369_e
        tag: floyd|permutation|brute_force
        """
        n, m = ac.read_list_ints()
        inf = 10 ** 18
        graph = WeightedGraphForFloyd(n, inf)
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        for i, j, w in edges:
            graph.add_undirected_edge_initial(i, j, w + 1)
        graph.initialize_undirected()

        for _ in range(ac.read_int()):
            k = ac.read_int()
            lst = ac.read_list_ints_minus_one()
            ans = inf
            cost = sum(edges[x][-1] + 1 for x in lst)

            for item in permutations(lst, k):

                pre = defaultdict(lambda: inf)
                pre[0] = cost
                for x in item:
                    cur = defaultdict(lambda: inf)
                    for p in pre:
                        cur[edges[x][0]] = min(cur[edges[x][0]], pre[p] + graph.dis[p * graph.n + edges[x][1]])
                        cur[edges[x][1]] = min(cur[edges[x][1]], pre[p] + graph.dis[p * graph.n + edges[x][0]])
                    pre = cur
                ans = min(ans, min(pre[p] + graph.dis[p * graph.n + graph.n - 1] for p in pre))
            ac.st(ans)
        return

    @staticmethod
    def abc_375f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc375/tasks/abc375_f
        tag: floyd|add_undirected_edge
        """
        n, m, q = ac.read_list_ints()
        math.inf = 2 * 10 ** 15
        graph = WeightedGraphForFloyd(n, math.inf)
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        visit = [1] * m
        queries = [ac.read_list_ints_minus_one() for _ in range(q)]
        for lst in queries:
            if lst[0] == 0:
                visit[lst[1]] = 0

        for x in range(m):
            if visit[x]:
                i, j, w = edges[x]
                w += 1
                graph.add_undirected_edge_initial(i, j, w)
        graph.initialize_undirected()

        res = []
        for x in range(q - 1, -1, -1):
            lst = queries[x]
            if lst[0] == 0:
                ind = lst[1]
                i, j, w = edges[ind]
                w += 1
                graph.add_undirected_edge(i, j, w)
            else:
                i, j = lst[1], lst[2]
                res.append(graph.dis[i * n + j])
        res.reverse()
        for x in res:
            ac.st(x if x < math.inf else -1)
        return
"""

Algorithm：mst|kruskal|prim|strictly_second_mst|multiplication_method|lca|brute_force|shortest_path_spanning_tree|greedy
Description：prim is node wise and kruskal is edge wise, prim is suitable for dense graph and kruskal is suitable for sparse graph


====================================LeetCode====================================
1489（https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/）mst|necessary_edge|fake_necessary_edge
1584（https://leetcode.cn/problems/min-cost-to-connect-all-points/）manhattan_distance|dense_graph|prim|mst
1724（https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/）mst|classical|multiplication_method|lca

=====================================LuoGu======================================
P3366（https://www.luogu.com.cn/problem/P3366）mst
P2820（https://www.luogu.com.cn/problem/P2820）reverse_thinking|mst
P1991（https://www.luogu.com.cn/problem/P1991）mst|connected_graph
P1661（https://www.luogu.com.cn/problem/P1661）mst
P1547（https://www.luogu.com.cn/problem/P1547）mst
P2121（https://www.luogu.com.cn/problem/P2121）limited_mst
P2126（https://www.luogu.com.cn/problem/P2126）mst
P2872（https://www.luogu.com.cn/problem/P2872）prim|mst
P2330（https://www.luogu.com.cn/problem/P2330）mst
P2504（https://www.luogu.com.cn/problem/P2504）mst
P2700（https://www.luogu.com.cn/problem/P2700）reverse_thinking|mst|union_find|size
list?user=739032&status=12&page=13（https://www.luogu.com.cn/record/list?user=739032&status=12&page=13）mst
P1194（https://www.luogu.com.cn/problem/P1194）mst
P2916（https://www.luogu.com.cn/problem/P2916）custom_sort|mst|classical
P4955（https://www.luogu.com.cn/problem/P4955）mst
P6705（https://www.luogu.com.cn/problem/P6705）brute_force|mst|union_find|uf_initial
P7775（https://www.luogu.com.cn/problem/P7775）bfs|mst_like
P2658（https://www.luogu.com.cn/problem/P2658）classical|mst
P4180（https://www.luogu.com.cn/problem/P4180）mst|lca|multiplication_method|strictly_second_mst|classical
P1265（https://www.luogu.com.cn/problem/P1265）prim|mst
P1340（https://www.luogu.com.cn/problem/P1340）reverse_order|union_find|mst
P2212（https://www.luogu.com.cn/problem/P2212）prim|mst|dense_graph
P2847（https://www.luogu.com.cn/problem/P2847）prim|mst|dense_graph
P3535（https://www.luogu.com.cn/problem/P3535）mst|judge_circle_by_union_find|connected
P4047（https://www.luogu.com.cn/problem/P4047）mst
P6171（https://www.luogu.com.cn/problem/P6171）sparse|kruskal|mst
P1550（https://www.luogu.com.cn/problem/P1550）mst|build_graph|fake_source|classical
P1661（https://www.luogu.com.cn/problem/P1661）manhattan_distance|mst|classical

===================================CodeForces===================================
609E（https://codeforces.com/problemset/problem/609/E）lca|greedy|mst|strictly_second_mst|necessary_edge
1108F（https://codeforces.com/contest/1108/problem/F）mst|classical
1095F（https://codeforces.com/contest/1095/problem/F）mst|brain_teaser|greedy
1624G（https://codeforces.com/contest/1624/problem/G）or_mst|classical
1857G（https://codeforces.com/contest/1857/problem/G）mst|brain_teaser|classical
1981E（https://codeforces.com/contest/1981/problem/E）scan_line|union_find|classical|implemention|mst
1242B（https://codeforces.com/contest/1242/problem/B）mst|observation|prim|brain_teaser|implemention|bfs
1245D（https://codeforces.com/problemset/problem/1245/D）prim|specific_plan|virtual_source|classical
1513D（https://codeforces.com/problemset/problem/1513/D）bfs|gcd_like|mst
888G（https://codeforces.com/contest/888/problem/G）heuristic_merge|get_minimum_xor|mst|classical
587C（https://codeforces.com/problemset/problem/587/C）tree_multiplication_method|multiplication_method|classical

====================================AtCoder=====================================
ARC076B（https://atcoder.jp/contests/abc065/tasks/arc076_b）mst
ABC282E（https://atcoder.jp/contests/abc282/tasks/abc282_e）union_find|mst|brain_teaser|classical
ABC235E（https://atcoder.jp/contests/abc235/tasks/abc235_e）online_query|data_range|offline_query|mst|maximum_weight|classical
ABC352E（https://atcoder.jp/contests/abc352/tasks/abc352_e）union_find|mst|reverse_order

=====================================AcWing=====================================
3731（https://www.acwing.com/problem/content/3731/）prim|mst|dense_graph|specific_plan

================================LibraryChecker================================
1（https://judge.yosupo.jp/problem/manhattanmst）manhattan_distance|mst|classical
Directed MST（https://judge.yosupo.jp/problem/directedmst）
3（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/F）mst|brute_force
4（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/H）mst|greedy
5（https://vjudge.net/problem/BZOJ-2177）manhattan_distance|mst|classical
6（https://www.51nod.com/Challenge/Problem.html#problemId=1213）manhattan_distance|mst|classical

"""
import math
from collections import defaultdict
from typing import List

from src.data_structure.sorted_list.template import SortedList
from src.data_structure.trie_like.template import BinaryTrieXor
from src.graph.minimum_spanning_tree.template import KruskalMinimumSpanningTree, \
    PrimMinimumSpanningTree, ManhattanMST, TreeAncestorMinIds, \
    TreeMultiplicationMaxWeights, TreeMultiplicationMaxSecondWeights
from src.graph.tarjan.template import Tarjan
from src.graph.union_find.template import UnionFind, PersistentUnionFind
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1991(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1991
        tag: mst|connected_grap|classical|kruskal
        """
        k, n = ac.read_list_ints()
        pos = [ac.read_list_ints() for _ in range(n)]
        edge = []
        for i in range(n):
            for j in range(i + 1, n):
                a = pos[i][0] - pos[j][0]
                b = pos[i][1] - pos[j][1]
                edge.append((i, j, a * a + b * b))

        uf = UnionFind(n)
        edge.sort(key=lambda it: it[2])
        cost = 0
        for x, y, z in edge:
            if uf.part == k:
                break
            if uf.union(x, y):
                cost = z
        ans = math.sqrt(cost)
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p2820(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2820
        tag: reverse_thinking|mst
        """
        n, m = ac.read_list_ints()
        edge = [ac.read_list_ints() for _ in range(m)]
        uf = UnionFind(n)
        edge.sort(key=lambda it: it[2])
        cost = 0
        for x, y, z in edge:
            if not uf.union(x - 1, y - 1):
                cost += z
        ac.st(cost)
        return

    @staticmethod
    def lg_p3366_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3366
        tag: mst
        """
        n, m = ac.read_list_ints()
        edges = []
        for _ in range(m):
            x, y, z = ac.read_list_ints()
            x -= 1
            y -= 1
            edges.append([x, y, z])
        mst = KruskalMinimumSpanningTree(edges, n, "kruskal")
        if mst.cost == -1:
            ac.st("orz")
        else:
            ac.st(mst.cost)
        return

    @staticmethod
    def lg_p3366_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3366
        tag: mst
        """
        n, m = ac.read_list_ints()
        edges = []
        for _ in range(m):
            x, y, z = ac.read_list_ints()
            x -= 1
            y -= 1
            edges.append([x, y, z])
        mst = KruskalMinimumSpanningTree(edges, n, "prim")
        if mst.cnt < n:
            ac.st("orz")
        else:
            ac.st(mst.cost)
        return

    @staticmethod
    def cf_1108f_1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1108/problem/F
        tag: mst|second_mst|multiplication_method|union_find
        """
        n, m = ac.read_list_ints()
        weights = []
        fro = []
        to = []
        use = [0] * m
        for x in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            weights.append(w * m + x)
            fro.append(i)
            to.append(j)
        weights.sort()
        uf = UnionFind(n)
        graph = TreeMultiplicationMaxWeights(n)
        cost = 0
        for val in weights:
            w, x = val // m, val % m
            i, j = fro[x], to[x]
            if uf.union(i, j):
                cost += w
                use[x] = 1
                graph.add_undirected_edge(i, j, w)
            if uf.part == 1:
                break
        graph.build_multiplication()
        ans = 0
        for val in weights:
            w, x = val // m, val % m
            if not use[x]:
                i, j = fro[x], to[x]
                dis = graph.get_max_weights_between_nodes(i, j)
                if dis == w:
                    ans += 1
        ac.st(ans)
        return

    @staticmethod
    def cf_1108f_2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1108/problem/F
        tag: mst|second|multiplication_method|union_find|classical|hard
        """
        n, m = ac.read_list_ints()
        dct = defaultdict(list)
        for _ in range(m):
            i, j, w = ac.read_list_ints()
            dct[w].append((i - 1, j - 1))
        uf = UnionFind(n)
        ans = 0
        for w in sorted(dct):
            for i, j in dct[w]:
                if not uf.is_connected(i, j):
                    ans += 1
            for i, j in dct[w]:
                if uf.union(i, j):
                    ans -= 1
        ac.st(ans)
        return

    @staticmethod
    def lc_1489(n: int, edges: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/
        tag: mst|necessary_edge|fake_necessary_edge|brain_teaser|classical|tarjan|cutting_edge|hard
        """

        m = len(edges)
        dct = defaultdict(list)
        for i in range(m):
            dct[edges[i][2]].append(i)

        uf = UnionFind(n)
        key = []
        fake = []
        for w in sorted(dct):
            cur_dct = defaultdict(list)
            nodes = set()
            for i in dct[w]:
                x, y, _ = edges[i]
                rx, ry = uf.find(x), uf.find(y)
                if rx != ry:
                    if rx > ry:
                        rx, ry = ry, rx
                    nodes.add(rx)
                    nodes.add(ry)
                    cur_dct[(rx, ry)].append(i)
            nodes = sorted(nodes)
            ind = {num: i for i, num in enumerate(nodes)}
            cur_edge = [[] for _ in range(len(nodes))]
            for rx, ry in cur_dct:
                cur_edge[ind[rx]].append(ind[ry])
                cur_edge[ind[ry]].append(ind[rx])
            _, cutting_edge = Tarjan().get_cut(len(nodes), cur_edge)

            for rx, ry in cur_dct:
                if len(cur_dct[(rx, ry)]) > 1:
                    fake.extend(cur_dct[(rx, ry)])
                elif (ind[rx], ind[ry]) in cutting_edge:
                    key.append(cur_dct[(rx, ry)][0])
                else:
                    fake.append(cur_dct[(rx, ry)][0])
                uf.union(rx, ry)

        return [key, fake]

    @staticmethod
    def lg_p2872(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2872
        tag: prim|mst|classical
        """

        def dis(x1, y1, x2, y2):
            res = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
            return res ** 0.5

        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        dct = [dict() for _ in range(n)]
        for i in range(m):
            u, v = ac.read_list_ints_minus_one()
            dct[u][v] = dct[v][u] = 0

        ans = nex = 0
        rest = set(list(range(1, n)))
        visit = [math.inf] * n
        visit[nex] = 0
        while rest:
            i = nex
            rest.discard(i)
            d = visit[i]
            ans += d
            x, y = nums[i]
            nex = -1
            for j in rest:
                dj = dis(nums[j][0], nums[j][1], x, y)
                visit[j] = min(visit[j], dct[i].get(j, math.inf))
                if dj < visit[j]:
                    visit[j] = dj
                if nex == -1 or visit[j] < visit[nex]:
                    nex = j
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p1194(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1194
        tag: mst|classical|build_graph
        """

        a, b = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(b)]
        edge = [(0, i, a) for i in range(1, b + 1)]
        for i in range(b):
            for j in range(i + 1, b):
                if 0 < grid[i][j] < a:
                    edge.append((i + 1, j + 1, grid[i][j]))
        mst = KruskalMinimumSpanningTree(edge, b + 1)
        ac.st(mst.cost)
        return

    @staticmethod
    def lg_p4180(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4180
        tag: mst|lca|multiplication_method|strictly_second_mst|classical
        """
        n, m = ac.read_list_ints()  # TLE
        weights = []
        fro = []
        to = []
        for x in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            weights.append(w * m + x)
            fro.append(i)
            to.append(j)
        weights.sort()
        uf = UnionFind(n)
        graph = TreeMultiplicationMaxSecondWeights(n)
        cost = 0
        for val in weights:
            w, x = val // m, val % m
            i, j = fro[x], to[x]
            if uf.union(i, j):
                cost += w
                graph.add_undirected_edge(i, j, w)
            if uf.part == 1:
                break
        graph.build_multiplication()
        ans = 10 ** 14
        for val in weights:
            w, x = val // m, val % m
            i, j = fro[x], to[x]
            dis = graph.get_max_weights_between_nodes(i, j)
            for weight in dis:
                if -1 < weight < w:
                    cur = cost - weight + w
                    ans = min(cur, ans)
        ac.st(ans)
        return

    @staticmethod
    def cf_609e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/609/E
        tag: lca|greedy|mst|strictly_second_mst|necessary_edge
        """
        """
        url: https://codeforces.com/problemset/problem/609/E
        tag: lca|greedy|mst|tree_multiplication|maximum_weight|second_mst|strictly_second_minimum_spanning_tree
        """
        n, m = ac.read_list_ints()
        weights = []
        fro = []
        to = []
        for x in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            weights.append(w * m + x)
            fro.append(i)
            to.append(j)
        weights.sort()
        uf = UnionFind(n)
        graph = TreeMultiplicationMaxWeights(n)
        cost = 0
        ans = [-1] * m
        use = []
        for val in weights:
            w, x = val // m, val % m
            i, j = fro[x], to[x]
            if uf.union(i, j):
                cost += w
                graph.add_undirected_edge(i, j, w)
                use.append(x)
            if uf.part == 1:
                break
        graph.build_multiplication()
        for x in use:
            ans[x] = cost
        for val in weights:
            w, x = val // m, val % m
            if ans[x] == -1:
                i, j = fro[x], to[x]
                dis = graph.get_max_weights_between_nodes(i, j)
                ans[x] = cost - dis + w
        ac.flatten(ans)
        return

    @staticmethod
    def lg_p1265(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1265
        tag: prim|mst
        """

        def dis(x1, y1, x2, y2):
            return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)

        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = nex = 0
        rest = set(list(range(1, n)))
        visit = [math.inf] * n
        visit[nex] = 0
        while rest:
            i = nex
            rest.discard(i)
            d = visit[i]
            ans += d ** 0.5
            nex = -1
            x, y = nums[i]
            for j in rest:
                dj = dis(nums[j][0], nums[j][1], x, y)
                if dj < visit[j]:
                    visit[j] = dj
                if nex == -1 or visit[j] < visit[nex]:
                    nex = j
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p1340_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1340
        tag: reverse_order|union_find|mst|reverse_thinking
        """

        n, w = ac.read_list_ints()

        edges = [ac.read_list_ints() for _ in range(w)]
        ind = list(range(w))
        ind.sort(key=lambda it: edges[it][-1])

        uf = UnionFind(n)
        ans = []
        select = set()
        cost = 0
        for i in range(w - 1, -1, -1):
            if uf.part > 1:
                cost = 0
                select = set()
                for j in ind:
                    if j <= i:
                        x, y, ww = edges[j]
                        if uf.union(x - 1, y - 1):
                            cost += ww
                            select.add(j)
            if uf.part > 1:
                ans.append(-1)
                break
            ans.append(cost)
            if i in select:
                uf.initialize()
                select = set()
                cost = 0
        while len(ans) < w:
            ans.append(-1)

        for i in range(w - 1, -1, -1):
            ls = ans[i]
            ac.st(ls)
        return

    @staticmethod
    def lg_p1340_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1340
        tag: reverse_order|union_find|mst|reverse_thinking
        """
        n, m = ac.read_list_ints()
        uf = UnionFind(n)
        lst = SortedList()
        for _ in range(m):
            i, j, w = ac.read_list_ints()
            uf.union(i - 1, j - 1)
            lst.add((w, i - 1, j - 1))
            if uf.part > 1:
                ac.st(-1)
            else:
                uf.initialize()
                cost = 0
                for w, i, j in lst:
                    if uf.union(i, j):
                        cost += w
                    if uf.part == 1:
                        break
                ac.st(cost)
        return

    @staticmethod
    def lg_p1550(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1550
        tag: mst|build_graph|fake_source|classical
        """

        n = ac.read_int()
        edges = []
        for i in range(n):
            w = ac.read_int()
            edges.append((0, i + 1, w))

        for i in range(n):
            grid = ac.read_list_ints()
            for j in range(i + 1, n):
                edges.append((i + 1, j + 1, grid[j]))
        edges.sort(key=lambda it: it[2])
        cost = 0
        uf = UnionFind(n + 1)
        for i, j, c in edges:
            if uf.union(i, j):
                cost += c
            if uf.part == 1:
                break
        ac.st(cost)
        return

    @staticmethod
    def lg_p2212(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2212
        tag: prim|mst|dense_graph
        """

        def dis(x1, y1, x2, y2):
            res = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
            return res if res >= c else math.inf

        n, c = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        tree = PrimMinimumSpanningTree(dis)
        ac.st(tree.build(nums))
        return

    @staticmethod
    def lg_p2658(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2658
        tag: classical|mst
        """

        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        edge = []
        for i in range(m):
            for j in range(n):
                if i + 1 < m:
                    edge.append((i * n + j, i * n + j + n, abs(grid[i][j] - grid[i + 1][j])))
                if j + 1 < n:
                    edge.append((i * n + j, i * n + j + 1, abs(grid[i][j] - grid[i][j + 1])))
        del grid

        uf = UnionFind(m * n)
        road = [0] * (m * n)
        s = 0
        for i in range(m):
            lst = ac.read_list_ints()
            for j in range(n):
                if lst[j]:
                    s += 1
                    road[i * n + j] = 1
        if s == 1:
            ac.st(0)
            return
        edge.sort(key=lambda it: it[2])
        for x, y, d in edge:
            a, b = road[uf.find(x)], road[uf.find(y)]
            if uf.union(x, y):
                road[uf.find(x)] = a + b
            if road[uf.find(x)] == s:
                ac.st(d)
                return
        return

    @staticmethod
    def lg_p2847(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2847
        tag: prim|mst|dense_graph
        """

        def dis(x1, y1, x2, y2):
            res = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
            return res

        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ans = nex = 0
        rest = set(list(range(1, n)))
        visit = [math.inf] * n
        visit[nex] = 0
        while rest:
            i = nex
            rest.discard(i)
            d = visit[i]
            ans = max(ans, d)
            nex = -1
            x, y = nums[i]
            for j in rest:
                dj = dis(nums[j][0], nums[j][1], x, y)
                if dj < visit[j]:
                    visit[j] = dj
                if nex == -1 or visit[j] < visit[nex]:
                    nex = j
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p3535(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3535
        tag: mst|judge_circle_by_union_find|connected|reverse_thinking
        """

        n, m, k = ac.read_list_ints()
        edge = []
        uf = UnionFind(n)
        ans = 0
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            if i >= k and j >= k:
                uf.union(i, j)
            else:
                edge.append((i, j))
        for i, j in edge:
            if not uf.union(i, j):
                ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p4047(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4047
        tag: mst
        """

        def dis():
            return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)

        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        edge = []
        for i in range(n):
            x1, y1 = nums[i]
            for j in range(i + 1, n):
                x2, y2 = nums[j]
                edge.append((i, j, dis()))
        edge.sort(key=lambda it: it[2])

        uf = UnionFind(n)
        ans = 0
        for i, j, d in edge:
            if uf.part == k:
                if not uf.is_connected(i, j):
                    ans = d
                    break
            else:
                uf.union(i, j)
        ans = ans ** 0.5
        ac.st("%.2f" % ans)
        return

    @staticmethod
    def lg_p6171(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6171
        tag: sparse|kruskal|mst
        """
        a, b, n, m = ac.read_list_ints()
        nums1 = [0, a] + [ac.read_int() for _ in range(n)]
        nums2 = [0, b] + [ac.read_int() for _ in range(m)]
        nums1.sort()
        nums2.sort()
        dct = defaultdict(list)
        k = (m + 2) * (n + 2)
        for i in range(1, m + 2):
            for j in range(1, n + 2):
                x = (i - 1) * (n + 1) + (j - 1)
                if i + 1 < m + 2:
                    y = i * (n + 1) + (j - 1)
                    dct[nums1[j] - nums1[j - 1]].append(x * k + y)
                if j + 1 < n + 2:
                    y = (i - 1) * (n + 1) + j
                    dct[nums2[i] - nums2[i - 1]].append(x * k + y)
        del nums1
        del nums2
        ans = 0
        uf = UnionFind((n + 1) * (m + 1))
        for c in sorted(dct):
            for num in dct[c]:
                if uf.union(num // k, num % k):
                    ans += c
        ac.st(ans)
        return

    @staticmethod
    def lc_1584_1(points: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/min-cost-to-connect-all-points/
        tag: dense_graph|prim|mst
        """

        def dis(x1, y1, x2, y2):
            res = abs(x1 - x2) + abs(y1 - y2)
            return res

        tree = PrimMinimumSpanningTree(dis)
        return tree.build(points)

    @staticmethod
    def lc_1584_2(points: List[List[int]]) -> int:
        """
        url: manhattan_distance|dense_graph|prim|mst
        tag: dense_graph|prim|mst
        """
        return ManhattanMST().build(points)[0]

    @staticmethod
    def abc_076b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc065/tasks/arc076_b
        tag: mst|classical|brain_teaser
        """

        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        ind = list(range(n))
        ind.sort(key=lambda it: nums[it][0])
        edges = []
        for i in range(1, n):
            x, y = ind[i - 1], ind[i]
            d = nums[y][0] - nums[x][0]
            edges.append((x, y, d))

        uf = UnionFind(n)
        ind.sort(key=lambda it: nums[it][1])
        for i in range(1, n):
            x, y = ind[i - 1], ind[i]
            d = nums[y][1] - nums[x][1]
            edges.append((x, y, d))

        edges.sort(key=lambda it: it[2])
        ans = 0
        for i, j, d in edges:
            if uf.union(i, j):
                ans += d
        ac.st(ans)
        return

    @staticmethod
    def ac_3731(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3731/
        tag: prim|mst|dense_graph|specific_plan|classical|fake_source
        """

        def dis(aa, bb):
            if aa == 0:
                return cost[bb]
            if bb == 0:
                return cost[aa]
            return (k[aa] + k[bb]) * (abs(nums[aa][0] - nums[bb][0]) + abs(nums[aa][1] - nums[bb][1]))

        n = ac.read_int()
        nums = [[math.inf, math.inf]] + [ac.read_list_ints() for _ in range(n)]
        cost = [math.inf] + ac.read_list_ints()
        k = [math.inf] + ac.read_list_ints()

        ans = nex = 0
        rest = set(list(range(n + 1)))
        visit = [math.inf] * (n + 1)
        visit[nex] = 0
        pre = [-1] * (n + 1)
        edge = []
        while rest:
            i = nex
            rest.discard(i)
            d = visit[i]
            ans += d
            nex = -1
            for j in rest:
                dj = dis(i, j)
                if dj < visit[j]:
                    visit[j] = dj
                    pre[j] = i
                if nex == -1 or visit[j] < visit[nex]:
                    nex = j
            if nex != -1:
                edge.append((pre[nex], nex))
        ac.st(ans if ans < math.inf else -1)

        lst = []
        for a, b in edge:
            if a == 0:
                lst.append(b)
            elif b == 0:
                lst.append(a)
        ac.st(len(lst))
        ac.lst(lst)
        ac.st(len(edge) - len(lst))
        for a, b in edge:
            if a and b:
                ac.lst([a, b])
        return

    @staticmethod
    def lc_1724_1():
        """
        url: https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/
        tag: mst|classical|multiplication_method|lca
        """

        class DistanceLimitedPathsExist:
            def __init__(self, n: int, edge_list: List[List[int]]):
                uf = UnionFind(n + 1)
                edge_list.extend([[n, i, math.inf] for i in range(n)])
                dct = [dict() for _ in range(n + 1)]
                for i, j, d in sorted(edge_list, key=lambda it: it[-1]):
                    if uf.union(i, j):
                        dct[i][j] = dct[j][i] = d
                # self.tree = SecondMinimumSpanningTreeLight(dct)
                self.tree = TreeMultiplicationMaxWeights(n)

            def query(self, p: int, q: int, limit: int) -> bool:
                maximum = self.tree.get_max_weights_between_nodes(p, q)
                return maximum < limit

        return DistanceLimitedPathsExist

    @staticmethod
    def lc_1724_2():
        """
        url: https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/
        tag: mst|classical|multiplication_method|lca
        """

        class DistanceLimitedPathsExist:

            def __init__(self, n: int, edge_list: List[List[int]]):
                self.puf = PersistentUnionFind(n)
                edge_list.sort(key=lambda it: it[2])
                for x, y, tm in edge_list:
                    self.puf.union(x, y, tm)
                return

            def query(self, p: int, q: int, limit: int) -> bool:
                return self.puf.is_connected(p, q, limit)

        return DistanceLimitedPathsExist

    @staticmethod
    def library_check_3(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/F
        tag: mst|brute_force
        """
        n, m = ac.read_list_ints()
        edges = [tuple(ac.read_list_ints()) for _ in range(m)]
        edges.sort(key=lambda it: it[2])
        uf = UnionFind(n)
        for x in range(m - 1, -1, -1):
            i, j, w = edges[x]
            uf.union(i - 1, j - 1)
            if uf.part == 1:
                break
        else:
            ac.no()
            return
        ans = math.inf
        uf = UnionFind(n)
        for i in range(x + 1):
            uf.initialize()
            s = edges[i][2]
            for j in range(i, m):
                x, y, w = edges[j]
                uf.union(x - 1, y - 1)
                if uf.part == 1 or w - s > ans:
                    if uf.part == 1 and w - s <= ans:
                        ans = w - s
                    break
        ac.yes()
        ac.st(ans)
        return

    @staticmethod
    def library_check_4(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/H
        tag: mst|greedy
        """
        n, m, s = ac.read_list_ints()
        edges = [tuple(ac.read_list_ints()) for _ in range(m)]
        ind = list(range(m))
        ind.sort(key=lambda it: -edges[it][2])
        uf = UnionFind(n)
        rest = []
        cost = 0
        for i in ind:
            x, y, w = edges[i]
            if not uf.union(x - 1, y - 1):
                rest.append(i)
                cost += w
        rest.reverse()
        while cost > s:
            cost -= edges[rest.pop()][2]
        ac.st(len(rest))
        ac.lst([x + 1 for x in rest])
        return

    @staticmethod
    def abc_282e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc282/tasks/abc282_e
        tag: union_find|mst|brain_teaser|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = []
        for i in range(n):
            for j in range(i + 1, n):
                x, y = nums[j], nums[i]
                score = (pow(x, y, m) + pow(y, x, m)) % m
                lst.append((score, i, j))
        lst.sort(reverse=True)
        ans = 0
        uf = UnionFind(n)
        for score, i, j in lst:
            if uf.union(i, j):
                ans += score
        ac.st(ans)
        return

    @staticmethod
    def library_checker_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/manhattanmst
        tag: manhattan_distance|mst|classical
        """
        n = ac.read_int()  # TLE
        ans = ManhattanMST().build([ac.read_list_ints() for _ in range(n)])
        ac.st(ans[0])
        for ls in ans[1]:
            ac.lst(ls)
        return

    @staticmethod
    def library_checker_5(ac=FastIO()):
        """
        url: https://vjudge.net/problem/BZOJ-2177
        tag: manhattan_distance|mst|classical
        """
        n = ac.read_int()
        ans = ManhattanMST().build([ac.read_list_ints() for _ in range(n)])
        ac.st(ans[0])
        return

    @staticmethod
    def library_checker_6(ac=FastIO()):
        """
        url: https://www.51nod.com/Challenge/Problem.html#problemId=1213
        tag: manhattan_distance|mst|classical
        """
        n = ac.read_int()
        ans = ManhattanMST().build([ac.read_list_ints() for _ in range(n)])
        ac.st(ans[0])
        return

    @staticmethod
    def lg_p1661(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1661
        tag: manhattan_distance|mst|classical
        """
        n = ac.read_int()
        ans = ManhattanMST().build([ac.read_list_ints() for _ in range(n)])
        ac.st((ans[-1][-1] + 1) // 2)
        return

    @staticmethod
    def abc_235e_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc235/tasks/abc235_e
        tag: online_query|data_range|offline_query|mst|maximum_weight|classical
        """
        n, m, q = ac.read_list_ints()
        weights = []
        fro = []
        to = []
        for x in range(m):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            weights.append(w * m + x)
            fro.append(i)
            to.append(j)
        weights.sort()
        uf = UnionFind(n)
        graph = TreeMultiplicationMaxWeights(n)
        cost = 0
        for val in weights:
            w, x = val // m, val % m
            i, j = fro[x], to[x]
            if uf.union(i, j):
                cost += w
                graph.add_undirected_edge(i, j, w)
            if uf.part == 1:
                break
        graph.build_multiplication()

        for _ in range(q):
            i, j, w = ac.read_list_ints_minus_one()
            w += 1
            dis = graph.get_max_weights_between_nodes(i, j)
            if dis > w:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def abc_235e_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc235/tasks/abc235_e
        tag: online_query|data_range|offline_query|mst|maximum_weight|classical
        """
        n, m, q = ac.read_list_ints()
        edges = []
        for i in range(m):
            lst = ac.read_list_ints() + [i]
            edges.append(lst)
        for i in range(q):
            lst = ac.read_list_ints() + [i + m]
            edges.append(lst)
        edges.sort(key=lambda it: it[-2])
        uf = UnionFind(n + 1)
        visit = [0] * (m + q)
        for a, b, _, i in edges:
            if not uf.is_connected(a, b):
                visit[i] = 1
            if i < m:
                uf.union(a, b)
        for i in range(m, m + q):
            if visit[i]:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def cf_1981e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1981/problem/E
        tag: scan_line|union_find|classical|implemention|mst
        """
        for _ in range(ac.read_int()):  # TLE
            n = ac.read_int()
            nums = [ac.read_list_ints() for _ in range(n)]
            nodes = set()
            for x, y, _ in nums:
                nodes.add(x)
                nodes.add(y)
            ac.get_random_seed()
            start = defaultdict(list)
            end = defaultdict(list)
            for i, (x, y, _) in enumerate(nums):
                start[x ^ ac.random_seed].append(i)
                end[y ^ ac.random_seed].append(i)
            lst = SortedList()
            edges = []
            for x in sorted(nodes):
                for i in start[x ^ ac.random_seed]:
                    lst.add((nums[i][2], i))

                for i in start[x ^ ac.random_seed]:
                    lst.discard((nums[i][2], i))
                    j = lst.bisect_left((nums[i][2], -1))
                    if j - 1 >= 0:
                        edges.append((i, lst[j - 1][1], abs(nums[i][2] - nums[lst[j - 1][1]][2])))
                    if j < len(lst):
                        edges.append((i, lst[j][1], abs(nums[i][2] - nums[lst[j][1]][2])))
                    lst.add((nums[i][2], i))

                for i in end[x ^ ac.random_seed]:
                    lst.discard((nums[i][2], i))
            uf = UnionFind(n)
            edges.sort(key=lambda it: it[2])
            ans = 0
            for i, j, w in edges:
                if uf.union(i, j):
                    ans += w
            ac.st(ans if uf.part == 1 else -1)
        return

    @staticmethod
    def cf_1242b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1242/problem/B
        tag: mst|observation|prim|brain_teaser|implemention|bfs
        """
        n, m = ac.read_list_ints()
        dct = [set() for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            if i > j:
                i, j = j, i
            dct[i].add(j)
            dct[j].add(i)

        ans = 0
        zero = []
        rest = set(range(n))
        while rest:
            if zero:
                root = zero.pop()
            else:
                root = rest.pop()
                ans += 1
            cur = {x for x in rest if root not in dct[x]}
            zero += cur
            rest -= cur
        ac.st(ans - 1)
        return

    @staticmethod
    def cf_1245d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1245/D
        tag: prim|specific_plan|virtual_source|classical
        """
        n = ac.read_int()
        nums = [[0, 0]] + [ac.read_list_ints() for _ in range(n)]
        c = [0] + ac.read_list_ints()
        k = [0] + ac.read_list_ints()

        def dis(ii, jj):
            if ii == 0:
                return c[jj]
            if jj == 0:
                return c[ii]
            return (k[ii] + k[jj]) * (abs(nums[ii][0] - nums[jj][0]) + abs(nums[ii][1] - nums[jj][1]))

        n = len(nums)
        ans = nex = 0
        rest = set(list(range(1, n)))
        visit = [math.inf] * n
        visit[nex] = 0
        parent = [-1] * n
        while rest:
            i = nex
            rest.discard(i)
            d = visit[i]
            ans += d
            nex = -1
            for j in rest:
                dj = dis(i, j)
                if dj < visit[j]:
                    visit[j] = dj
                    parent[j] = i
                if nex == -1 or visit[j] < visit[nex]:
                    nex = j
        ac.st(ans)
        power = [i for i in range(n) if parent[i] == 0]
        ac.st(len(power))
        ac.lst(power)
        edges = [(i, parent[i]) for i in range(n) if parent[i] not in [0, -1]]
        ac.st(len(edges))
        for ls in edges:
            ac.lst(ls)
        return

    @staticmethod
    def cf_888g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/888/problem/G
        tag: heuristic_merge|get_minimum_xor|mst|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        nums.sort()
        uf = UnionFind(n)
        pre = dict()
        ac.get_random_seed()
        trie = BinaryTrieXor(1 << 30, n)
        for i in range(n):
            cur = nums[i] ^ ac.random_seed
            if cur in pre:
                uf.union(i, pre[cur])
            pre[cur] = i
            trie.add(nums[i], 1)
        ans = 0
        while uf.part > 1:
            group = uf.get_root_part()
            for g in group:
                for x in group[g]:
                    trie.remove(nums[x], 1)
                res = [math.inf, 0, 1]
                for x in group[g]:
                    y = trie.get_minimum_xor(nums[x])
                    if y < res[0]:
                        res = [y, x, pre[y ^ nums[x] ^ ac.random_seed]]
                if uf.union(res[1], res[2]):
                    ans += res[0]
                for x in group[g]:
                    trie.add(nums[x], 1)
        ac.st(ans)
        return

    @staticmethod
    def cf_587c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/587/C
        tag: tree_multiplication_method|multiplication_method|classical
        """
        n, m, q = ac.read_list_ints()  # math.inf making tle !!
        tree = TreeAncestorMinIds(n)
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            tree.add_undirected_edge(u, v)

        ids = [n + 1] * 10 * n
        ind = [0] * n
        c = ac.read_list_ints_minus_one()
        for i in range(m):
            if ind[c[i]] < 10:
                ids[c[i] * 10 + ind[c[i]]] = i + 1
                ind[c[i]] += 1
        tree.build_multiplication(ids)

        for _ in range(q):
            u, v, a = ac.read_list_ints_minus_one()
            a += 1
            ans = tree.get_min_ids_between_nodes(u, v)[:a]
            ans = [x for x in ans if x < n + 1]
            ac.lst([len(ans)] + ans)
        return
"""

Algorithm：dinic_max_flow_min_cut|dinic_max_flow_min_cost|dinic_max_flow_max_cost|bipartite_matching
Description：dinic_max_flow_min_cut|dinic_max_flow_min_cost|dinic_max_flow_max_cost|bipartite_matching

====================================LeetCode====================================
1947（https://leetcode.cn/problems/maximum-compatibility-score-sum/）bipartite_graph|maximum_weight_match|state_compress
1066（https://leetcode.cn/problems/campus-bikes-ii/）bipartite_graph|minimum_weight_match|km
100401（https://leetcode.cn/problems/find-the-power-of-k-size-subarrays-ii/）max_flow_min_cost|classical
3276（https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/）dinic_max_flow_min_cost|state_dp|classical

=====================================LuoGu======================================
P3376（https://www.luogu.com.cn/problem/P3376）dinic_max_flow
P1343（https://www.luogu.com.cn/problem/P1343）dinic_max_flow
P2740（https://www.luogu.com.cn/problem/P2740）dinic_max_flow
P1361（https://www.luogu.com.cn/problem/P1361）dinic_max_flow|min_cut
P2057（https://www.luogu.com.cn/problem/P2057）dinic_max_flow|min_cut
P1344（https://www.luogu.com.cn/problem/P1344）dinic_max_flow|min_cut
P1345（https://www.luogu.com.cn/problem/P1345）dinic_max_flow|min_cut
P2762（https://www.luogu.com.cn/problem/P2762）dinic_max_flow|min_cut|specific_plan
P3381（https://www.luogu.com.cn/problem/P3381）dinic_max_flow|min_cost
P4452（https://www.luogu.com.cn/problem/P4452）dinic_max_flow|min_cost
P2153（https://www.luogu.com.cn/problem/P2153）dinic_max_flow|min_cost
P2053（https://www.luogu.com.cn/problem/P2053）dinic_max_flow|min_cost
P2050（https://www.luogu.com.cn/problem/P2050）dinic_max_flow|min_cost
P4722（https://www.luogu.com.cn/problem/P4722）dinic_max_flow

===================================CodeForces===================================

===================================AtCoder===================================
ABC247G（https://atcoder.jp/contests/abc247/tasks/abc247_g）max_flow|max_cost|dynamic_graph|brain_teaser|network_flow|classical
ABC241G（https://atcoder.jp/contests/abc241/tasks/abc241_g）network_flow|brain_teaser|brute_force|greedy|implemention|classical
ABC239E（https://atcoder.jp/contests/abc239/tasks/abc239_g）specific_plan|network_flow|max_flow|min_cut|greedy|implemention
ABC205F（https://atcoder.jp/contests/abc205/tasks/abc205_f）max_flow_min_cut|matrix|build_graph

"""
import math
from collections import defaultdict
from typing import List

from src.graph.network_flow.template import DinicMaxflowMinCut, DinicMaxflowMinCost
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p3376(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3376
        tag: dinic_max_flow
        """
        n, m, s, t = ac.read_list_ints()
        flow = DinicMaxflowMinCut(n)
        graph = [defaultdict(int) for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            graph[u - 1][v - 1] += w
        for u in range(n):
            for v in graph[u]:
                flow.add_edge(u + 1, v + 1, graph[u][v])
        ans = flow.max_flow_min_cut(s, t)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1343(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1343
        tag: dinic_max_flow
        """
        n, m, x = ac.read_list_ints()
        s, t = 1, n
        flow = DinicMaxflowMinCut(n)
        graph = [defaultdict(int) for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            graph[u - 1][v - 1] += w
        for u in range(n):
            for v in graph[u]:
                flow.add_edge(u + 1, v + 1, graph[u][v])
        ans = flow.max_flow_min_cut(s, t)
        if ans < 1:
            ac.st("Orz Ni Jinan Saint Cow!")
        else:
            ac.lst([ans, math.ceil(x / ans)])
        return

    @staticmethod
    def lg_p2740(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2740
        tag: dinic_max_flow
        """
        m, n = ac.read_list_ints()
        s, t = 1, n
        flow = DinicMaxflowMinCut(n)
        graph = [defaultdict(int) for _ in range(n)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            graph[u - 1][v - 1] += w
        for u in range(n):
            for v in graph[u]:
                flow.add_edge(u + 1, v + 1, graph[u][v])
        ans = flow.max_flow_min_cut(s, t)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1361(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1361
        tag: dinic_max_flow|min_cut
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        s, t = 1, n + 2
        m = ac.read_int()
        flow = DinicMaxflowMinCut(n + 2 + m * 2)
        for i in range(n):
            flow.add_edge(s, i + 2, a[i])
            flow.add_edge(i + 2, t, b[i])
        ans = sum(a) + sum(b)
        for i in range(m):
            nums = ac.read_list_ints()
            c1, c2 = nums[1], nums[2]
            ans += c1 + c2
            flow.add_edge(s, n + 1 + i * 2 + 1 + 1, c1)
            flow.add_edge(n + 1 + i * 2 + 2 + 1, t, c2)
            for j in nums[3:]:
                flow.add_edge(n + 1 + i * 2 + 1 + 1, j + 1, math.inf)
                flow.add_edge(j + 1, n + 1 + i * 2 + 2 + 1, math.inf)
        ac.st(ans - flow.max_flow_min_cut(s, t))
        return

    @staticmethod
    def lg_p2057(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2057
        tag: dinic_max_flow|min_cut
        """
        n, m = ac.read_list_ints()
        s, t = 1, n + 2
        a = ac.read_list_ints()
        flow = DinicMaxflowMinCut(n + 2)
        for i in range(n):
            if a[i]:
                flow.add_edge(s, i + 2, 1)
            else:
                flow.add_edge(i + 2, t, 1)

        for _ in range(m):
            x, y = ac.read_list_ints()
            flow.add_edge(x + 1, y + 1, 1)
            flow.add_edge(y + 1, x + 1, 1)
        ac.st(flow.max_flow_min_cut(s, t))
        return

    @staticmethod
    def lg_p1344(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1344
        tag: dinic_max_flow|min_cut
        """
        n, m = ac.read_list_ints()
        flow = DinicMaxflowMinCut(n)
        mod = 2023
        for _ in range(m):
            s, e, c = ac.read_list_ints()
            flow.add_edge(s, e, c * mod + 1)
        ans = flow.max_flow_min_cut(1, n)
        ac.lst([ans // mod, ans % mod])
        return

    @staticmethod
    def lg_p1345(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1345
        tag: dinic_max_flow|min_cut
        """
        n, m, s, t = ac.read_list_ints()
        flow = DinicMaxflowMinCut(n * 2)
        for i in range(1, n + 1):
            flow.add_edge(i * 2 - 1, i * 2, 1)
        for _ in range(m):
            x, y = ac.read_list_ints()
            flow.add_edge(x * 2, y * 2 - 1, math.inf)
            flow.add_edge(y * 2, x * 2 - 1, math.inf)
        ans = flow.max_flow_min_cut(2 * s, 2 * t - 1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2762(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2762
        tag: dinic_max_flow|min_cut|specific_plan
        """
        m, n = ac.read_list_ints()
        flow = DinicMaxflowMinCut(m + n + 2)
        ans = 0
        for i in range(1, m + 1):
            nums = ac.read_list_ints()
            ans += nums[0]
            flow.add_edge(1, i + 1, nums[0])
            for j in nums[1:]:
                flow.add_edge(i + 1, m + 1 + j, math.inf)
        cost = ac.read_list_ints()
        for j in range(1, n + 1):
            flow.add_edge(m + j + 1, m + n + 2, cost[j - 1])
        ans -= flow.max_flow_min_cut(1, m + n + 2)
        ac.lst([i - 1 for i in range(2, m + 2) if flow.depth[i] != -1])
        ac.lst([j - m - 1 for j in range(m + 2, m + n + 2) if flow.depth[j] != -1])
        ac.st(ans)
        return

    @staticmethod
    def lg_p3381(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3381
        tag: dinic_max_flow|min_cost
        """
        n, m, s, t = ac.read_list_ints()
        flow = DinicMaxflowMinCost(n)
        for i in range(1, m + 1):
            u, v, w, c = ac.read_list_ints()
            flow.add_edge(u, v, w, c)
        ac.lst(flow.max_flow_min_cost(s, t))
        return

    @staticmethod
    def lg_p4452(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4452
        tag: dinic_max_flow|min_cost
        """
        n, m, k, end = ac.read_list_ints()
        tt = [ac.read_list_ints() for _ in range(n)]
        f = [ac.read_list_ints() for _ in range(n)]
        queries = [ac.read_list_ints() for _ in range(m)]
        source, target, original = m * 2 + 1, m * 2 + 2, m * 2 + 3
        flow = DinicMaxflowMinCost(m * 2 + 3)
        flow.add_edge(original, source, k, 0)
        for i in range(1, m + 1):
            a, b, s, t, c = queries[i - 1]
            flow.add_edge(2 * i - 1, 2 * i, 1, -c)
            if tt[0][a] <= s:
                flow.add_edge(source, 2 * i - 1, math.inf, f[0][a])
            if t + tt[b][0] <= end:
                flow.add_edge(2 * i, target, math.inf, f[b][0])
        for i in range(1, m + 1):
            a1, b1, s1, t1, c1 = queries[i - 1]
            for j in range(1, m + 1):
                a2, b2, s2, t2, c2 = queries[j - 1]
                if t1 + tt[b1][a2] <= s2:
                    flow.add_edge(2 * i, 2 * j - 1, math.inf, f[b1][a2])
        _, min_cost = flow.max_flow_min_cost(original, target)
        ac.st(-min_cost)
        return

    @staticmethod
    def lg_p2153(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2153
        tag: dinic_max_flow|min_cost
        """
        n, m = ac.read_list_ints()
        flow = DinicMaxflowMinCost(n * 2)
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            if a == 1 and b == n:
                flow.add_edge(a * 2, b * 2 - 1, 1, c)
            else:
                flow.add_edge(a * 2, b * 2 - 1, math.inf, c)
        for i in range(2, n):
            flow.add_edge(i * 2 - 1, i * 2, 1, 0)
        ac.lst(flow.max_flow_min_cost(2, 2 * n - 1))
        return

    @staticmethod
    def lg_p2053(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2053
        tag: dinic_max_flow|min_cost
        """
        m, n = ac.read_list_ints()
        flow = DinicMaxflowMinCost(m * n + n + 2)
        for i in range(1, n + 1):
            flow.add_edge(m * n + n + 1, m * n + i, 1, 0)
            cost = ac.read_list_ints()
            for j in range(1, m + 1):
                for k in range(1, n + 1):
                    flow.add_edge(m * n + i, (j - 1) * n + k, 1, k * cost[j - 1])
        for j in range(1, m + 1):
            for k in range(1, n + 1):
                flow.add_edge((j - 1) * n + k, m * n + n + 2, 1, 0)

        max_flow, min_cost = flow.max_flow_min_cost(m * n + n + 1, m * n + n + 2)
        assert max_flow == n
        ac.st("%.2f" % (min_cost / n))
        return

    @staticmethod
    def lg_p2050(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2050
        tag: dinic_max_flow|min_cost
        """
        n, m = ac.read_list_ints()
        p = ac.read_list_ints()
        np = sum(p)
        flow = DinicMaxflowMinCost(m * np + n + 2)

        for i in range(1, n + 1):
            flow.add_edge(m * np + n + 1, m * np + i, p[i - 1], 0)
            cost = ac.read_list_ints()
            for j in range(1, m + 1):
                for k in range(1, np + 1):
                    flow.add_edge(m * np + i, (j - 1) * np + k, 1, k * cost[j - 1])
        for j in range(1, m + 1):
            for k in range(1, np + 1):
                flow.add_edge((j - 1) * np + k, m * np + n + 2, 1, 0)

        max_flow, min_cost = flow.max_flow_min_cost(m * np + n + 1, m * np + n + 2)
        assert max_flow == np
        ac.st(min_cost)
        return

    @staticmethod
    def lc_1947(students: List[List[int]], mentors: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-compatibility-score-sum/
        tag: bipartite_graph|maximum_weight_match|state_compress|max_flow_max_cost
        """
        m = len(students)
        flow = DinicMaxflowMinCost(2 * m + 2 * m + 2)
        for i in range(1, m + 1):
            flow.add_edge(2 * i - 1, 2 * i, 1, 0)
            flow.add_edge(2 * m + 2 * m + 1, 2 * i - 1, 1, 0)
            flow.add_edge(2 * m + 2 * i - 1, 2 * m + 2 * i, 1, 0)
            flow.add_edge(2 * m + 2 * i, 2 * m + 2 * m + 2, 1, 0)
        for i in range(m):
            for j in range(m):
                score = sum(x == y for x, y in zip(students[i], mentors[j]))
                flow.add_edge(2 * (i + 1), 2 * m + 2 * (j + 1) - 1, 1, -score)
        ans = flow.max_flow_min_cost(2 * m + 2 * m + 1, 2 * m + 2 * m + 2)
        return -ans[1]

    @staticmethod
    def lc_1066(workers: List[List[int]], bikes: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/campus-bikes-ii/
        tag: bipartite_graph|minimum_weight_match|km
        """
        m, n = len(workers), len(bikes)
        flow = DinicMaxflowMinCost(2 * m + 2 * n + 2)
        for i in range(1, m + 1):
            flow.add_edge(2 * i - 1, 2 * i, 1, 0)
            flow.add_edge(2 * m + 2 * n + 1, 2 * i - 1, 1, 0)
        for i in range(1, n + 1):
            flow.add_edge(2 * m + 2 * i - 1, 2 * m + 2 * i, 1, 0)
            flow.add_edge(2 * m + 2 * i, 2 * m + 2 * n + 2, 1, 0)
        for i in range(m):
            for j in range(n):
                score = abs(workers[i][0] - bikes[j][0]) + abs(workers[i][1] - bikes[j][1])
                flow.add_edge(2 * (i + 1), 2 * m + 2 * (j + 1) - 1, 1, score)
        ans = flow.max_flow_min_cost(2 * m + 2 * n + 1, 2 * m + 2 * n + 2)
        return ans[1]

    @staticmethod
    def abc_247g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc247/tasks/abc247_g
        tag: max_flow|max_cost|dynamic_graph|brain_teaser|network_flow|classical
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        dct = defaultdict(int)
        for a, b, c in nums:
            dct[(a, b)] = max(dct[(a, b)], c)
        aa = {a for a, _, _ in nums}
        bb = {b for _, b, _ in nums}
        ans = []
        flow = DinicMaxflowMinCost(304)
        for a, b in dct:
            c = dct[(a, b)]
            flow.add_edge(a, b + 150, 1, -c)
        for a in aa:
            flow.add_edge(302, a, 1, 0)
        for b in bb:
            flow.add_edge(b + 150, 303, 1, 0)
        for k in range(1, n + 1):
            flow.add_edge(301, 302, 1, 0)
            flow.add_edge(303, 304, 1, 0)
            max_flow, min_cost = flow.max_flow_min_cost(301, 304)
            if max_flow < k:
                break
            assert max_flow == k
            ans.append(-min_cost)
        ac.st(len(ans))
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_241g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc241/tasks/abc241_g
        tag: network_flow|brain_teaser|brute_force|greedy|implemention|classical
        """
        n, m = ac.read_list_ints()
        lose = [0] * (n + 1)
        visit = [[0] * (n + 1) for _ in range(n + 1)]
        for _ in range(m):
            ww, ll = ac.read_list_ints()
            lose[ll] += 1
            visit[ww][ll] = 1
            visit[ll][ww] = 0

        ans = []
        e = n * (n - 1) // 2
        for i in range(1, n + 1):
            ceil = n - 1 - lose[i]
            if ceil == 0:
                continue
            s = e + n + 1
            t = e + n + 2
            ind = 0
            flow = DinicMaxflowMinCut(e + n + 2)
            for a in range(1, n + 1):
                for b in range(a + 1, n + 1):
                    ind += 1
                    flow.add_edge(s, ind, 1)
                    if visit[a][b]:
                        flow.add_edge(ind, a + e, 1)
                        continue
                    if visit[b][a]:
                        flow.add_edge(ind, b + e, 1)
                        continue
                    flow.add_edge(ind, a + e, 1)
                    flow.add_edge(ind, b + e, 1)
                if a != i:
                    flow.add_edge(a + e, t, min(ceil - 1, n - 1 - lose[a]))
                else:
                    flow.add_edge(a + e, t, ceil)
            assert ind == e
            if flow.max_flow_min_cut(s, t) == e:
                ans.append(i)
        ac.lst(ans)
        return

    @staticmethod
    def abc_239e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc239/tasks/abc239_g
        tag: specific_plan|network_flow|max_flow|min_cut|greedy|implemention
        """
        n, m = ac.read_list_ints()
        s = 1
        t = n
        edges = [ac.read_list_ints() for _ in range(m)]
        c = ac.read_list_ints()
        c[0] = c[-1] = math.inf

        flow = DinicMaxflowMinCut(n * 2)
        for i in range(1, n + 1):
            flow.add_edge(i * 2 - 1, i * 2, c[i - 1])
        for x, y in edges:
            flow.add_edge(x * 2, y * 2 - 1, math.inf)
            flow.add_edge(y * 2, x * 2 - 1, math.inf)
        min_cut = flow.max_flow_min_cut(2 * s, 2 * t - 1)
        ac.st(min_cut)
        ans = [i for i in range(2, n) if flow.depth[i * 2 - 1] != -1 and flow.depth[i * 2] == -1]
        ac.st(len(ans))
        ac.lst(ans)
        return

    @staticmethod
    def lc_100401(board: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/description/
        tag: max_flow_min_cost|classical
        """
        m, n = len(board), len(board[0])
        flow = DinicMaxflowMinCost(m + n + 4)
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                flow.add_edge(i, m + j, 1, -board[i - 1][j - 1])
        for i in range(1, m + 1):
            flow.add_edge(m + n + 1, i, 1, 0)
        for j in range(1, n + 1):
            flow.add_edge(m + j, m + n + 2, 1, 0)

        flow.add_edge(m + n + 3, m + n + 1, 3, 0)
        flow.add_edge(m + n + 2, m + n + 4, 3, 0)
        ans = flow.max_flow_min_cost(m + n + 3, m + n + 4)
        return -ans[1]

    @staticmethod
    def abc_205f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc205/tasks/abc205_f
        tag: max_flow_min_cut|matrix|build_graph
        """
        m, n, k = ac.read_list_ints()
        flow = DinicMaxflowMinCut(m + n + k + k + 2)
        for j in range(1, k + 1):
            a, b, c, d = ac.read_list_ints()
            for i in range(a, c + 1):
                flow.add_edge(i, m + n + j, 1)
            for i in range(b, d + 1):
                flow.add_edge(m + n + j + k, m + i, 1)
            flow.add_edge(m + n + j, m + n + j + k, 1)
        for i in range(1, m + 1):
            flow.add_edge(m + n + k + k + 1, i, 1)
        for i in range(1, n + 1):
            flow.add_edge(m + i, m + n + k + k + 2, 1)
        ans = flow.max_flow_min_cut(m + n + k + k + 1, m + n + k + k + 2)
        ac.st(ans)
        return

    @staticmethod
    def lc_3276(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/submissions/
        tag: dinic_max_flow_min_cost|state_dp|classical
        """
        m, n = len(grid), len(grid[0])
        flow = DinicMaxflowMinCost(m + 202)
        start = m + 201
        end = m + 202
        for i in range(m):
            flow.add_edge(start, i + 1, 1, 0)
        vals = set()
        edges = set()
        for i in range(m):
            for j in range(n):
                edges.add((i + 1, m + grid[i][j], 1, 0))
                vals.add(grid[i][j])
                edges.add((m + 100 + grid[i][j], end, 1, 0))
        for a, b, c, d in edges:
            flow.add_edge(a, b, c, d)
        for va in vals:
            flow.add_edge(m + va, m + va + 100, 1, -va)
        ans = flow.max_flow_min_cost(start, end)
        return -ans[1]
"""
Algorithm：prufer_series
Description：Prufer code is a method of representing labeled rootless trees with a unique sequence of integers, which can generate a bijective relationship between labeled rootless trees and Prufer sequences.

=====================================LuoGu======================================
P6086（https://www.luogu.com.cn/problem/P6086）prufer|classical
P2817（https://www.luogu.com.cn/problem/P2817）cayley|specific_plan

"""
"""
Algorithm：spfa|negative_weight|shortest_path|differential_constraint|number_of_shortest_path

Description：shortest_path_faster_algorithm|single_source|deque

====================================LeetCode====================================
2589（https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/）differential_constraint|greedy|classical

=====================================LuoGu======================================
P3385（https://www.luogu.com.cn/problem/P3385）shortest_path|negative_circle
P1938（https://www.luogu.com.cn/problem/P1938）negative_circle|positive_circle|shortest_path|longest_path
P2136（https://www.luogu.com.cn/problem/P2136）negative_circle|shortest_path
P2648（https://www.luogu.com.cn/problem/P2648）positive_circle|longest_path|classical
P1993（https://www.luogu.com.cn/problem/P1993）differential_constraint|negative_circle
P5960（https://www.luogu.com.cn/problem/P5960）differential_constraint
P1260（https://www.luogu.com.cn/problem/P1260）differential_constraint
P1931（https://www.luogu.com.cn/problem/P1931）positive_circle|mul
P1986（https://www.luogu.com.cn/problem/P1986）differential_constraint
P2850（https://www.luogu.com.cn/problem/P2850）negative_circle|several_source|classical
P4878（https://www.luogu.com.cn/problem/P4878）diff_array|dijkstra|shortest_path
P5751（https://www.luogu.com.cn/problem/P5751）prefix_sum|differential_constraint
P5905（https://www.luogu.com.cn/problem/P5905）johnson_shortest_path|several_source|shortest_path
P2784（https://www.luogu.com.cn/problem/P2784）spfa|classical|dense_graph

====================================AtCoder=====================================
ABC061D（https://atcoder.jp/contests/abc061/tasks/abc061_d）reverse_graph|positive_circle|longest_path
ABC137E（https://atcoder.jp/contests/abc137/tasks/abc137_e）spfa|positive_circle
ABC216G（https://atcoder.jp/contests/abc216/tasks/abc216_g）differential_constraint|minimum|longest_path|prefix_sum|classical|can_be_dijkstra|reverse_thinking|dijkstra|shortest_path|maximum

====================================LeetCode====================================
differential_constraint（https://oi-wiki.org/graph/diff-constraints/）
"""
from collections import deque
from typing import List

from src.graph.dijkstra.template import Dijkstra
from src.graph.spfa.template import SPFA
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p2648(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2648
        tag: positive_circle|longest_path|classical
        """
        d, p, c, f = ac.read_list_ints()
        dct = [[] for _ in range(c)]
        for _ in range(p):
            a, b = ac.read_list_ints()
            dct[a - 1].append((b - 1, d))
        for _ in range(f):
            j, k, t = ac.read_list_ints()
            dct[j - 1].append((k - 1, d - t))
        res = 0
        for s in range(c):
            ans, dis, _ = SPFA().positive_circle_edge(dct, s, d)
            if ans:
                ac.st("orz")
                return
            res = max(res, max(dis))
        ac.st(res)
        return

    @staticmethod
    def lg_p2136(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2136
        tag: negative_circle|shortest_path
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            dct[a - 1].append((b - 1, -c))
        ans1, dis1, _ = SPFA().negative_circle_edge(dct, 0)
        if ans1:
            ac.st("Forever love")
            return
        ans2, dis2, _ = SPFA().negative_circle_edge(dct, n - 1)
        if ans2:
            ac.st("Forever love")
            return
        ac.st(min(dis1[n - 1], dis2[0]))
        return

    @staticmethod
    def lg_p3385(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3385
        tag: shortest_path|negative_circle
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(m):
                u, v, w = ac.read_list_ints()
                dct[u - 1].append((v - 1, w))
                if w >= 0:
                    dct[v - 1].append((u - 1, w))
            ans, _, _ = SPFA().negative_circle_edge(dct)
            ac.st("YES" if ans else "NO")
        return

    @staticmethod
    def lg_p1938(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1938
        tag: negative_circle|positive_circle|shortest_path|longest_path
        """
        d, p, c, f, s = ac.read_list_ints()
        s -= 1
        dct = [[] for _ in range(c)]
        for _ in range(p):
            a, b = ac.read_list_ints()
            dct[a - 1].append((b - 1, d))
        for _ in range(f):
            j, k, t = ac.read_list_ints()
            dct[j - 1].append((k - 1, d - t))
        ans, dis, _ = SPFA().positive_circle_edge(dct, s, d)
        ac.st(-1 if ans else max(dis))
        return

    @staticmethod
    def lg_p1993(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1993
        tag: differential_constraint|negative_circle
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        for i in range(1, n + 1):
            dct[0].append((i, 0))
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                a, b, c = lst[1:]
                dct[a].append((b, -c))
            elif lst[0] == 2:
                a, b, c = lst[1:]
                dct[b].append((a, c))
            else:
                a, b = lst[1:]
                dct[a].append((b, 0))
                dct[b].append((a, 0))
        ans, _, _ = SPFA().negative_circle_edge(dct)
        ac.st("Yes" if not ans else "No")
        return

    @staticmethod
    def lg_p5960(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5960
        tag: differential_constraint
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n + 1)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            edge[b].append((a, c))
        for i in range(1, n + 1):
            edge[0].append((i, 0))
        ans, dis, _ = SPFA().negative_circle_edge(edge, 0, 0)
        if ans:
            ac.no()
        else:
            ac.lst(dis[1:])
        return

    @staticmethod
    def lg_p1260(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1260
        tag: differential_constraint
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n + 1)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            edge[b].append((a, c))
        for i in range(1, n + 1):
            edge[0].append((i, 0))
        ans, dis, _ = SPFA().negative_circle_edge(edge, 0, 0)
        if ans:
            ac.st("NO SOLUTION")
        else:
            low = min(dis[1:])
            for x in dis[1:]:
                ac.st(x - low)
        return

    @staticmethod
    def lg_p1931(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1931
        tag: positive_circle|mul
        """
        case = 0
        while True:
            n = ac.read_int()
            if not n:
                break
            case += 1
            name = [ac.read_str() for _ in range(n)]
            dct = [[] for _ in range(n)]
            ind = {na: i for i, na in enumerate(name)}
            for _ in range(ac.read_int()):
                a, c, b = ac.read_list_strs()
                dct[ind[a]].append((ind[b], float(c)))
            ans = "No"
            for i in range(n):
                flag, _, _ = SPFA().positive_circle_mul(dct, i, 1)
                if flag:
                    ans = "Yes"
                    break
            ac.st(f"Case {case}: {ans}")
            ac.read_str()
        return

    @staticmethod
    def lg_p1986(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1986
        tag: differential_constraint|minimum|longest_path|prefix_sum|classical|can_not_be_dijkstra
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n + 1)]
        for _ in range(m):
            # x2 - x1 >= w is edge[x1].append((x2, w))
            a, b, c = ac.read_list_ints()
            if a > b:
                a, b = b, a
            edge[a - 1].append((b, c))

        for i in range(1, n + 1):
            # xi - 0 >= 0
            edge[0].append((i, 0))
            if i > 1:
                # (i) - (i-1) >= 0
                edge[i - 1].append((i, 0))
                # (i-1) - (i) >= -1
                edge[i].append((i - 1, -1))
        ans, dis, _ = SPFA().positive_circle_edge(edge, 0)
        ac.st(dis[n])
        return

    @staticmethod
    def abc_61d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc061/tasks/abc061_d
        tag: reverse_graph|positive_circle|longest_path|classical|reachable
        """
        n, m = ac.read_list_ints()
        edges = [ac.read_list_ints() for _ in range(m)]
        rev = [[] for _ in range(n)]
        for a, b, c in edges:
            a -= 1
            b -= 1
            rev[b].append(a)

        reach = [0] * n  # important
        stack = [n - 1]
        reach[-1] = 1
        while stack:
            i = stack.pop()
            for j in rev[i]:
                if not reach[j]:
                    reach[j] = 1
                    stack.append(j)
        dct = [[] for _ in range(n)]
        for a, b, c in edges:
            a -= 1
            b -= 1
            if reach[a] and reach[b]:
                dct[a].append((b, c))

        ans, dis, _ = SPFA().positive_circle_edge(dct, 0, 0)
        ac.st("math.inf" if ans else dis[n - 1])
        return

    @staticmethod
    def abc_137e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc137/tasks/abc137_e
        tag: spfa|positive_circle
        """
        # math.inf = 1 << 64
        n, m, p = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        rev = [[] for _ in range(n)]
        edges = [ac.read_list_ints() for _ in range(m)]
        for a, b, c in edges:
            dct[a - 1].append((b - 1, c - p))
            rev[b - 1].append((a - 1, c - p))

        visit = [0] * n
        stack = [n - 1]
        visit[n - 1] = 1
        while stack:
            i = stack.pop()
            for j, _ in rev[i]:
                if not visit[j]:
                    visit[j] = 1
                    stack.append(j)
        for i in range(n):
            dct[i] = [(a, b) for a, b in dct[i] if visit[a]]

        res, dis, cnt = SPFA().positive_circle_edge(dct, 0, 0)
        if res or dis[-1] == -math.inf:
            ac.st(-1)
            return
        ac.st(max(dis[-1], 0))
        return

    @staticmethod
    def lc_2589(tasks: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/
        tag: differential_constraint|greedy|classical|minimum|longest_path
        """
        n = max(max(a, b) for a, b, _ in tasks)
        edge = [[] for _ in range(n + 1)]
        for a, b, c in tasks:
            if a > b:
                a, b = b, a
            edge[a - 1].append((b, c))

        for i in range(1, n + 1):
            edge[0].append((i, 0))
            if i > 1:
                edge[i - 1].append((i, 0))
                edge[i].append((i - 1, -1))
        ans, dis, _ = SPFA().positive_circle_edge(edge, 0, 0)
        return dis[n]

    @staticmethod
    def lg_p2850(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2850
        tag: negative_circle|several_source|classical
        """
        for _ in range(ac.read_int()):
            n, m, w = ac.read_list_ints()
            dct = [[] for _ in range(n + 1)]
            for _ in range(m):
                x, y, p = ac.read_list_ints()
                dct[x].append((y, p))
                dct[y].append((x, p))
            for _ in range(w):
                x, y, p = ac.read_list_ints()
                dct[x].append((y, -p))
            for i in range(1, n + 1):
                dct[0].append((i, 0))

            ans, _, _ = SPFA().negative_circle_edge(dct, 0, 0)
            ac.st("YES" if ans else "NO")
        return

    @staticmethod
    def lg_p4878(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4878
        tag: diff_array|dijkstra|shortest_path
        """
        n, ml, md = ac.read_list_ints()
        edge = [[] for _ in range(n + 1)]
        for _ in range(ml):
            # x1 - x2 <= w is edge[x2].append((x1, w))
            a, b, d = ac.read_list_ints()
            edge[a].append((b, d))

        for _ in range(md):
            a, b, d = ac.read_list_ints()
            edge[b].append((a, -d))

        for i in range(1, n + 1):
            # xi <= 0 is edge[0].append((i, 0))
            edge[0].append((i, 0))  # super source for solution check
            if i > 1:
                edge[i].append((i - 1, 0))

        ans, dis, _ = SPFA().negative_circle_edge(edge, 0, 0)
        if ans:
            ac.st(-1)
        else:
            ans, dis, _ = SPFA().negative_circle_edge(edge, 1, 0)
            if ans:
                ac.st(-1)
            elif dis[n] == math.inf:
                ac.st(-2)
            else:
                ac.st(dis[n])
        return

    @staticmethod
    def lg_p5905(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5905
        tag: johnson_shortest_path|several_source|shortest_path|classical
        """
        n, m = ac.read_list_ints()
        dct = [dict() for _ in range(n + 1)]
        for _ in range(m):
            u, v, w = ac.read_list_ints()
            if u != v:
                dct[u][v] = min(dct[u].get(v, math.inf), w)
        dct = [[(x, d[x]) for x in d] for d in dct]
        for i in range(1, n + 1):
            dct[0].append([i, 0])
        flag, h, _ = SPFA().negative_circle_edge(dct)
        if flag:
            ac.st(-1)
            return

        for i in range(n + 1):
            dct[i] = [(j, w + h[i] - h[j]) for j, w in dct[i]]

        ceil = 10 ** 9
        dj = Dijkstra()
        for i in range(1, n + 1):
            ans = 0
            dis = dj.get_shortest_path(dct, i)
            for j in range(1, n + 1):
                ans += j * (dis[j] + h[j] - h[i]) if dis[j] < math.inf else j * ceil
            ac.st(ans)
        return

    @staticmethod
    def lg_p5751(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5751
        tag: prefix_sum|differential_constraint|negative_circle_edge|maximum|shortest_path
        """
        n, a0, b0, l0, a1, b1, l1 = ac.read_list_ints()
        # maximum is shortest_path
        edge = [[] for _ in range(n + 1)]  # node is the prefix sum
        for i in range(n):
            # a - b <= c is edge[b].append((a, c))
            if i - l0 + 1 >= 0:
                edge[i - l0 + 1].append((i + 1, l0 - a0))
                edge[i + 1].append((i - l0 + 1, b0 - l0))
            if i - l1 + 1 >= 0:
                edge[i - l1 + 1].append((i + 1, b1))
                edge[i + 1].append((i - l1 + 1, -a1))

        for i in range(1, n + 1):
            # xi - x0 >= 0 is edge edge[i].append((0, 0))
            edge[i].append((0, 0))
            if i > 1:
                edge[i].append((i - 1, 0))
                edge[i - 1].append((i, 1))

        ans, dis, _ = SPFA().negative_circle_edge(edge, 0, 0)
        if ans:
            ac.st(-1)
            return

        ac.st(dis[n])
        return

    @staticmethod
    def abc_216g_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc216/tasks/abc216_g
        tag: differential_constraint|minimum|longest_path|prefix_sum|classical|can_be_dijkstra|reverse_thinking|dijkstra|shortest_path|maximum
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n + 1)]
        for _ in range(m):
            # x2 - x1 >= w is edge[x1].append((x2, w))
            a, b, c = ac.read_list_ints()
            if a > b:
                a, b = b, a
            edge[a - 1].append((b, c))

        for i in range(1, n + 1):
            # xi - 0 >= 0
            edge[0].append((i, 0))
            if i > 1:
                # (i) - (i-1) >= 0
                edge[i - 1].append((i, 0))
                # (i-1) - (i) >= -1
                edge[i].append((i - 1, -1))
        ans, dis, _ = SPFA().positive_circle_edge(edge, 0)
        ans = [dis[i + 1] - dis[i] for i in range(n)]
        ac.lst(ans)
        return

    @staticmethod
    def abc_216g_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc216/tasks/abc216_g
        tag: differential_constraint|minimum|longest_path|prefix_sum|classical|can_be_dijkstra|reverse_thinking|dijkstra|shortest_path|maximum
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n + 1)]
        for _ in range(m):
            a, b, c = ac.read_list_ints()
            if a > b:
                a, b = b, a
            edge[a - 1].append((b, b-a+1-c))

        for i in range(1, n + 1):
            edge[i - 1].append((i, 1))
            edge[i].append((i - 1, 0))

        dis = Dijkstra().get_shortest_path(edge, 0)
        ans = [1 - (dis[i + 1] - dis[i]) for i in range(n)]
        ac.lst(ans)
        return

    @staticmethod
    def lg_p2784(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2784
        tag: spfa|classical|dense_graph
        """
        n, m, s, t = ac.read_list_ints()
        dct = [[] for _ in range(n + 1)]
        for _ in range(m):
            x, y, c = ac.read_list_strs()
            x = int(x)
            y = int(y)
            dct[x].append((y, float(c)))
        n = len(dct)
        dis = [-math.inf for _ in range(n)]
        visit = [False] * n
        cnt = [0] * n
        queue = deque([s])
        dis[s] = 1
        visit[s] = True

        while queue:
            u = queue.popleft()
            visit[u] = False
            for v, w in dct[u]:
                if dis[v] < dis[u] * w:
                    dis[v] = dis[u] * w
                    cnt[v] = cnt[u] + 1
                    if cnt[v] >= n:
                        return True, dis, cnt
                    if not visit[v]:
                        queue.append(v)
                        visit[v] = True

        ans = dis[t]
        if ans == -math.inf:
            ac.st("orz")
        else:
            ans = ac.round_5(ans * 10000) / 10000
            ac.st("%.4f" % ans)
        return"""
Algorithm：tarjan|cut_point|cut_edge|point_doubly_connected_component|edge_doubly_connected_component|pdcc|edcc
Description：scc|edcc|pdcc|cur_point|cut_edge|directed_acyclic_graph

====================================LeetCode====================================
1192（https://leetcode.cn/problems/critical-connections-in-a-network/）tarjan|cut_edge
2360（https://leetcode.cn/problems/longest-cycle-in-a-graph/solution/）largest_circle|scc|topological_sort
2204（https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/description/）scc|dag|build_graph|reverse_graph
1568（https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solution/）cut_point|tarjan

=====================================LuoGu======================================
P3387（https://www.luogu.com.cn/problem/P3387）scc
P3388（https://www.luogu.com.cn/problem/P3388）multi_edge|self_loop|cut_point
P8435（https://www.luogu.com.cn/problem/P8435）multi_edge|self_loop|several_circle
P8436（https://www.luogu.com.cn/problem/P8436）multi_edge|self_loop|build_graph|fake_source
P2860（https://www.luogu.com.cn/problem/P2860）edge_doubly_connected_component|scc|tree_centroid
P2863（https://www.luogu.com.cn/problem/P2863）tarjan|scc

P1656（https://www.luogu.com.cn/problem/P1656）cut_edge
P1793（https://www.luogu.com.cn/problem/P1793）cut_point|brute_force|union_find
P2656（https://www.luogu.com.cn/problem/P2656）scc|dag|longest_path
P1726（https://www.luogu.com.cn/problem/P1726）scc
P2002（https://www.luogu.com.cn/problem/P2002）scc|shrink_point
P2341（https://www.luogu.com.cn/problem/P2341）scc|shrink_point
P2835（https://www.luogu.com.cn/problem/P2835）scc|shrink_point
P2863（https://www.luogu.com.cn/problem/P2863）scc
B3609（https://www.luogu.com.cn/problem/B3609）scc
B3610（https://www.luogu.com.cn/problem/B3610）point_doubly_connected_component
P7033（https://www.luogu.com.cn/problem/P7033）scc|dag|tree_dp
P7965（https://www.luogu.com.cn/problem/P7965）scc|dag|tree_dp

===================================CodeForces===================================
1811F（https://codeforces.com/contest/1811/problem/F）scc|pdcc
427C（https://codeforces.com/problemset/problem/427/C）scc|shrink_point
193A（https://codeforces.com/contest/193/problem/A）brain_teaser|cut_point
999E（https://codeforces.com/contest/999/problem/E）scc|shrink_point|union_find
1213F（https://codeforces.com/contest/1213/problem/F）scc|shrink_point|topological_sort|greedy
1547G（https://codeforces.com/contest/1547/problem/G）scc|shrink_point|build_graph|counter|number_of_path
1702E（https://codeforces.com/contest/1702/problem/E）point_doubly_connected_component|pdcc|undirected|odd_circle
1768D（https://codeforces.com/contest/1768/problem/D）permutation_circle|tarjan
1986E（https://codeforces.com/contest/1986/problem/E）cutting_edge|tarjan|brute_force
118E（https://codeforces.com/problemset/problem/118/E）tarjan|cutting_edge|order|classical
1000E（https://codeforces.com/problemset/problem/1000/E）tarjan|edcc|cutting_edge|tree_diameter

===================================CodeForces===================================
ABC334G（https://atcoder.jp/contests/abc334/tasks/abc334_g）union_find|mod_reverse|tarjan|edcc|expectation|math|classical
ABC334E（https://atcoder.jp/contests/abc334/tasks/abc334_e）union_find|mod_reverse|expectation|math|classical
ABC245F（https://atcoder.jp/contests/abc245/tasks/abc245_f）scc|reverse_graph|implemention|bfs|classical
ABC357E（https://atcoder.jp/contests/abc357/tasks/abc357_e）scc|build_graph|reverse_graph

=====================================AcWing=====================================
3582（https://www.acwing.com/problem/content/3582/）scc
3816（https://www.acwing.com/problem/content/description/3816/）scc|topological_sort|dag_dp

===================================LibraryChecker===================================
1 Cycle Detection (Directed)（https://judge.yosupo.jp/problem/cycle_detection）directed_graph|circle
2 Strongly Connected Components（https://judge.yosupo.jp/problem/scc）scc
3 Two-Edge-Connected Components（https://judge.yosupo.jp/problem/two_edge_connected_components）edcc

"""
import math
from collections import Counter
from typing import List

from src.graph.tarjan.template import Tarjan, DirectedGraphForTarjanScc
from src.graph.topological_sort.template import GraphForTopologicalSort
from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p3387(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3387
        tag: scc|dag|classical|longest_path
        """
        n, m = ac.read_list_ints()
        weights = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(x, y)
        graph.build_scc()
        scc_weights = [0] * graph.scc_id
        for i in range(n):
            scc_weights[graph.node_scc_id[i]] += weights[i]

        graph_topo = GraphForTopologicalSort(graph.scc_id)
        for val in graph.get_scc_edge_degree()[0]:
            i, j = val // graph.scc_id, val % graph.scc_id
            graph_topo.add_directed_edge(i, j)
        ans = graph_topo.topological_sort_for_dag_dp(scc_weights)
        ac.st(max(ans))
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/cycle_detection
        tag: directed_graph|circle
        """
        n, m = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        dct = dict()
        for ind in range(m):
            i, j = ac.read_list_ints()
            graph.add_directed_original_edge(i, j)
            dct[i * n + j] = ind
        graph.build_scc()

        root = [0] * graph.scc_id
        cnt = [0] * graph.scc_id
        for i in range(n):
            root[graph.node_scc_id[i]] = i
            cnt[graph.node_scc_id[i]] += 1
        visit = [0] * n
        for g in range(graph.scc_id):
            if cnt[g] > 1:
                i = root[g]
                lst = [i]
                visit[lst[-1]] = 1
                end = -1
                while end == -1:
                    ind = graph.point_head[lst[-1]]
                    while ind:
                        j = graph.edge_to[ind]
                        if graph.node_scc_id[j] == g:
                            if visit[j]:
                                end = j
                                break
                            lst.append(j)
                            visit[j] = 1
                            break
                        ind = graph.edge_next[ind]
                ind = lst.index(end)
                lst = lst[ind:] + [end]
                ans = []
                k = len(lst)
                for j in range(1, k):
                    x, y = lst[j - 1], lst[j]
                    ans.append(dct[x * n + y])
                ac.st(len(ans))
                for a in ans:
                    ac.st(a)
                break
        else:
            ac.st(-1)
        return

    @staticmethod
    def library_check_2(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/scc
        tag: scc
        """
        n, m = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            x, y = ac.read_list_ints()
            graph.add_directed_original_edge(x, y)
        graph.build_scc()

        graph.initialize_graph()
        for i in range(n):
            graph.add_directed_edge(graph.node_scc_id[i], i)
        ac.st(graph.scc_id)
        for i in range(graph.scc_id - 1, -1, -1):
            lst = []
            ind = graph.point_head[i]
            while ind:
                lst.append(graph.edge_to[ind])
                ind = graph.edge_next[ind]
            k = len(lst)
            ac.lst([k] + lst)
        return

    @staticmethod
    def library_check3(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/two_edge_connected_components
        tag: edcc
        """
        n, m = ac.read_list_ints()
        edge = [set() for _ in range(n)]
        for _ in range(m):
            a, b = ac.read_list_ints()
            if a > b:
                a, b = b, a
            if a == b:
                x = len(edge)
                edge.append(set())
                edge[a].add(x)
                edge[x].add(a)
            elif b in edge[a]:
                x = len(edge)
                edge.append(set())
                edge[a].add(x)
                edge[x].add(a)
                edge[b].add(x)
                edge[x].add(b)
            else:
                edge[a].add(b)
                edge[b].add(a)
        group = Tarjan().get_edcc(len(edge), edge)
        res = []
        for r in group:
            lst = [str(x) for x in r if x < n]
            if lst:
                res.append([str(len(lst))] + lst)
        ac.st(len(res))
        for a in res:
            ac.st(" ".join(a))
        return

    @staticmethod
    def lg_p3388(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3388
        tag: multi_edge|self_loop|cut_point
        """
        n, m = ac.read_list_ints()
        dct = [set() for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].add(j)
            dct[j].add(i)
        cut_node, _ = Tarjan().get_cut(n, [list(d) for d in dct])
        cut_node = sorted(list(cut_node))
        ac.st(len(cut_node))
        ac.lst([x + 1 for x in cut_node])
        return

    @staticmethod
    def lg_p8435(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8435
        tag: multi_edge|self_loop|several_circle|pdcc
        """
        n, m = ac.read_list_ints()
        edge = [set() for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            if x != y:
                edge[x].add(y)
                edge[y].add(x)
                degree[x] += 1
                degree[y] += 1

        pdcc_id, pdcc_node_id, node_pdcc_id = Tarjan().get_pdcc(n, [list(e) for e in edge])
        ac.st(len(pdcc_node_id) + sum(degree[i] == 0 for i in range(n)))
        for r in range(pdcc_id):
            ac.lst([len(pdcc_node_id[r])] + [x + 1 for x in pdcc_node_id[r]])
        for i in range(n):
            if not degree[i]:
                ac.lst([1, i + 1])
        return

    @staticmethod
    def lg_p8436(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8436
        tag: multi_edge|self_loop|build_graph|fake_source|edcc
        """
        n, m = ac.read_list_ints()
        edge = [set() for _ in range(n)]
        dup = [set() for _ in range(n)]
        for _ in range(m):
            a, b = ac.read_list_ints_minus_one()
            if a > b:
                a, b = b, a
            if a == b:
                continue
            if b in edge[a]:
                if b not in dup[a]:
                    dup[a].add(b)
                    x = len(edge)
                    edge.append(set())
                    edge[a].add(x)
                    edge[x].add(a)
                    edge[b].add(x)
                    edge[x].add(b)
            else:
                edge[a].add(b)
                edge[b].add(a)
        group = Tarjan().get_edcc(len(edge), edge)
        res = []
        for r in group:
            lst = [str(x + 1) for x in r if x < n]
            if lst:
                res.append([str(len(lst))] + lst)
        ac.st(len(res))
        for a in res:
            ac.st(" ".join(a))
        return

    @staticmethod
    def cf_999e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/999/problem/E
        tag: scc|shrink_point
        """
        n, m, s = ac.read_list_ints()
        s -= 1
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(i, j)
        graph.build_scc()
        scc_degree = graph.get_scc_edge_degree()[1]
        ans = sum(x == 0 for x in scc_degree)
        ans -= int(scc_degree[graph.node_scc_id[s]] == 0)
        ac.st(ans)
        return

    @staticmethod
    def cf_1702e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1702/problem/E
        tag: point_doubly_connected_component|pdcc|undirected|odd_circle
        """
        for _ in range(ac.read_int()):
            def check():
                n = ac.read_int()
                nums = [ac.read_list_ints() for _ in range(n)]
                cnt = Counter()
                for a, b in nums:
                    if a == b:
                        ac.no()
                        return
                    cnt[a] += 1
                    cnt[b] += 1
                if max(cnt.values()) > 2:
                    ac.no()
                    return

                dct = [[] for _ in range(n)]
                for a, b in nums:
                    a -= 1
                    b -= 1
                    dct[a].append(b)
                    dct[b].append(a)
                group_id, group_node, node_group_id = Tarjan().get_pdcc(n, dct)
                for g in group_node:
                    if len(group_node[g]) % 2:
                        ac.no()
                        return
                ac.yes()
                return

            check()

        return

    @staticmethod
    def lc_1192(n: int, connections: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/critical-connections-in-a-network/
        tag: tarjan|cut_edge
        """
        edge = [set() for _ in range(n)]
        for i, j in connections:
            edge[i].add(j)
            edge[j].add(i)
        cutting_point, cutting_edge = Tarjan().get_cut(n, [list(e) for e in edge])
        return [list(e) for e in cutting_edge]

    @staticmethod
    def lg_p1656(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1656
        tag: cut_edge
        """
        n, m = ac.read_list_ints()
        dct = [set() for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].add(j)
            dct[j].add(i)
        cut_node, cut_edge = Tarjan().get_cut(n, [list(d) for d in dct])
        cut_edge = sorted([list(e) for e in cut_edge])
        for x in cut_edge:
            ac.lst([w + 1 for w in x])
        return

    @staticmethod
    def lg_p2860(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2860
        tag: edge_doubly_connected_component|scc|tree_centroid
        """
        n, m = ac.read_list_ints()
        edge = [set() for _ in range(n)]
        dup = [set() for _ in range(n)]
        for _ in range(m):
            a, b = ac.read_list_ints_minus_one()
            if a > b:
                a, b = b, a
            if a == b:  # self loop is not necessary
                continue
            if b in edge[a]:
                if b not in dup[a]:  # at most one another duplicate edge
                    dup[a].add(b)
                    dup[b].add(a)
                    x = len(edge)
                    edge.append(set())
                    edge[a].add(x)
                    edge[x].add(a)
                    edge[b].add(x)
                    edge[x].add(b)
            else:
                edge[a].add(b)
                edge[b].add(a)
        group = Tarjan().get_edcc(len(edge), [ls.copy() for ls in edge])
        scc_node_id = []
        for r in group:
            lst = [x for x in r if x < n]
            if lst:
                scc_node_id.append(lst)
        scc_id = len(scc_node_id)
        node_scc_id = [-1] * n
        for i in range(scc_id):
            for j in scc_node_id[i]:
                node_scc_id[j] = i

        new_dct = [set() for _ in range(scc_id)]
        for i in range(n):
            for j in edge[i]:
                if j < n:
                    a, b = node_scc_id[i], node_scc_id[j]
                    if a != b:
                        new_dct[a].add(b)
                        new_dct[b].add(a)
        leaf = sum(len(ls) == 1 for ls in new_dct)
        ac.st((leaf + 1) // 2)
        return

    @staticmethod
    def lg_p2863(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2863
        tag: scc
        """
        n, m = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(i, j)
        graph.build_scc()
        cnt = [0] * graph.scc_id
        for i in range(n):
            cnt[graph.node_scc_id[i]] += 1
        ans = sum(x > 1 for x in cnt)
        ac.st(ans)
        return

    @staticmethod
    def cf_427c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/427/C
        tag: scc|shrink_point
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(ac.read_int()):
            i, j = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(i, j)
        graph.build_scc()
        graph.build_new_graph_from_scc_id_to_original_node()
        ans = 1
        cost = 0
        mod = 10 ** 9 + 7
        for g in range(graph.scc_id):
            cnt = Counter([nums[i] for i in graph.get_original_out_node(g)])
            x = min(cnt)
            cost += x
            ans *= cnt[x]
            ans %= mod
        ac.lst([cost, ans])
        return

    @staticmethod
    def lg_p2656(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2656
        tag: scc|dag|longest_path|longest_path|dijkstra|spfa|reverse_graph
        """

        def check(cc, dd):
            xx = 0
            while cc:
                xx += cc
                cc = cc * dd // 10
            return xx

        n, m = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        edges = []
        for _ in range(m):
            a, b, c, d = ac.read_list_strs()
            a = int(a) - 1
            b = int(b) - 1
            c = int(c)
            d = int(float(d) * 10)
            edges.append((a, b, c, d))
            graph.add_directed_original_edge(a, b)
        graph.build_scc()
        scc_weight = [0] * graph.scc_id
        for a, b, c, d in edges:
            if graph.node_scc_id[a] == graph.node_scc_id[b]:
                scc_weight[graph.node_scc_id[a]] += check(c, d)
        graph.initialize_graph()

        # reverse_graph
        s = ac.read_int() - 1
        graph_topo = GraphForTopologicalSort(graph.scc_id)
        for a, b, c, d in edges:
            if graph.node_scc_id[a] != graph.node_scc_id[b]:
                graph_topo.add_directed_edge(graph.node_scc_id[b], graph.node_scc_id[a], c)
        res = graph_topo.topological_sort_for_dag_dp_with_edge_weight(scc_weight)[graph.node_scc_id[s]]
        ac.st(res)
        return

    @staticmethod
    def lg_p1726(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1726
        tag: scc
        """
        n, m = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            a, b, t = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(a, b)
            if t == 1:
                graph.add_directed_original_edge(b, a)
        graph.build_scc()
        scc_node_id = graph.get_scc_node_id()
        ans = []
        for g in scc_node_id:
            lst = sorted(g)
            if len(lst) > len(ans) or (len(lst) == len(ans) and ans > lst):
                ans = lst[:]
        ac.st(len(ans))
        ac.lst([x + 1 for x in ans])
        return

    @staticmethod
    def lg_p2002(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2002
        tag: scc|shrink_point
        """
        n, m = ac.read_list_ints()
        inf = m + 1
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            a, b = ac.read_list_ints_minus_one()
            if a >= 0:  # invalid data
                graph.add_directed_original_edge(a, b)
        graph.build_scc()
        _, scc_degree = graph.get_scc_edge_degree()
        ans = sum(x == 0 for x in scc_degree)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2341(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2341
        tag: scc|shrink_point
        """
        n, m = ac.read_list_ints()
        graph = DirectedGraphForTarjanScc(n)
        for _ in range(m):
            a, b = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(a, b)
        graph.build_scc()
        _, scc_degree, scc_cnt = graph.get_scc_edge_degree_reverse()
        ans = sum(x == 0 for x in scc_degree)
        ac.st(0 if ans > 1 else scc_cnt[scc_degree.index(0)])
        return

    @staticmethod
    def lg_p2835(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2835
        tag: scc|shrink_point
        """
        n = ac.read_int()
        graph = DirectedGraphForTarjanScc(n)
        for i in range(n):
            for j in ac.read_list_ints_minus_one()[:-1]:
                graph.add_directed_original_edge(i, j)
        graph.build_scc()
        _, scc_degree = graph.get_scc_edge_degree()
        ac.st(sum(d == 0 for d in scc_degree))
        return

    @staticmethod
    def lg_p7033(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7033
        tag: scc|dag|tree_dp|reverse_graph
        """
        class Graph(DirectedGraphForTarjanScc):
            def get_scc_dag_dp(self):
                scc_edge = set()
                scc_cnt = [0] * self.scc_id
                for i in range(self.n):
                    ind = self.point_head[i]
                    while ind:
                        j = self.edge_to[ind]
                        a, b = self.node_scc_id[i], self.node_scc_id[j]
                        if a != b:
                            scc_edge.add(b * self.scc_id + a)
                        ind = self.edge_next[ind]
                    scc_cnt[self.node_scc_id[i]] += 1
                self.initialize_graph()
                for val in scc_edge:
                    self.add_directed_edge(val // self.scc_id, val % self.scc_id)
                scc_degree = [0] * self.scc_id
                for val in scc_edge:
                    scc_degree[val % self.scc_id] += 1
                ans_group = [0] * graph.scc_id
                stack = [i for i in range(graph.scc_id) if not scc_degree[i]]
                while stack:
                    i = stack.pop()
                    ans_group[i] += scc_cnt[i] - 1
                    ind = self.point_head[i]
                    while ind:
                        j = self.edge_to[ind]
                        ans_group[j] += ans_group[i] + 1
                        stack.append(j)
                        ind = self.edge_next[ind]
                ans = [ans_group[graph.node_scc_id[i]] for i in range(self.n)]
                return ans

        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        graph = Graph(n)
        lst = [nums[i][0] * n + i for i in range(n)]
        lst.sort(reverse=True)
        for i in range(1, n):
            graph.add_directed_original_edge(lst[i - 1] % n, lst[i] % n)
        lst = [nums[i][1] * n + i for i in range(n)]
        lst.sort(reverse=True)
        for i in range(1, n):
            graph.add_directed_original_edge(lst[i - 1] % n, lst[i] % n)

        graph.build_scc()
        final = graph.get_scc_dag_dp()
        for x in final:
            ac.st(x)
        return

    @staticmethod
    def lg_p7965(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7965
        tag: scc|dag|tree_dp
        """
        class Graph(DirectedGraphForTarjanScc):
            def get_scc_dag_dp(self):
                scc_edge = set()
                scc_cnt = [0] * self.scc_id
                for i in range(self.n):
                    ind = self.point_head[i]
                    while ind:
                        j = self.edge_to[ind]
                        a, b = self.node_scc_id[i], self.node_scc_id[j]
                        if a != b:
                            scc_edge.add(b * self.scc_id + a)
                        ind = self.edge_next[ind]
                    scc_cnt[self.node_scc_id[i]] += 1
                self.initialize_graph()
                for val in scc_edge:
                    self.add_directed_edge(val // self.scc_id, val % self.scc_id)
                scc_degree = [0] * self.scc_id
                for val in scc_edge:
                    scc_degree[val % self.scc_id] += 1

                stack = [i for i in range(graph.scc_id) if not scc_degree[i]]
                while stack:
                    i = stack.pop()
                    ind = self.point_head[i]
                    while ind:
                        j = self.edge_to[ind]
                        stack.append(j)
                        depth[j] = depth[i] + 1
                        ancestor[j] = ancestor[i]
                return

        n, m, q = ac.read_list_ints()
        graph = Graph(n)
        for _ in range(m):
            lst = ac.read_list_ints_minus_one()
            for x in range(n):
                graph.add_directed_original_edge(x, lst[x])
        graph.build_scc()
        ancestor = list(range(n))
        depth = [0] * n
        graph.get_scc_dag_dp()
        for _ in range(q):
            u, v = ac.read_list_ints_minus_one()
            x, y = graph.node_scc_id[u], graph.node_scc_id[v]
            ac.st("DA" if ancestor[x] == ancestor[y] and depth[x] <= depth[y] else "NE")
        return

    @staticmethod
    def lc_1568(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/solution/
        tag: cut_point|tarjan
        """
        m, n = len(grid), len(grid[0])

        edge = [[] for _ in range(m * n)]
        nodes = set()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    if i + 1 < m and grid[i + 1][j] == 1:
                        edge[i * n + j].append(i * n + n + j)
                        edge[i * n + n + j].append(i * n + j)
                    if j + 1 < n and grid[i][j + 1] == 1:
                        edge[i * n + j].append(i * n + 1 + j)
                        edge[i * n + 1 + j].append(i * n + j)
                    nodes.add(i * n + j)
        if len(nodes) <= 1:
            return len(nodes)
        nodes = sorted(list(nodes))
        ind = {num: i for i, num in enumerate(nodes)}
        k = len(nodes)
        dct = [[] for _ in range(k)]
        for i in range(m * n):
            for j in edge[i]:
                dct[ind[i]].append(ind[j])
                dct[ind[j]].append(ind[i])

        uf = UnionFind(k)
        for i in range(k):
            for j in dct[i]:
                uf.union(i, j)
        if uf.part > 1:
            return 0

        cutting_point, _ = Tarjan().get_cut(k, dct)
        return 2 if not cutting_point else 1

    @staticmethod
    def ac_3582(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3582/
        tag: scc
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            p = ac.read_list_ints_minus_one()
            graph = DirectedGraphForTarjanScc(n)
            for i in range(n):
                graph.add_directed_original_edge(i, p[i])

            graph.build_scc()
            scc_cnt = graph.get_scc_cnt()
            ans = [scc_cnt[graph.node_scc_id[i]] for i in range(n)]
            ac.lst(ans)
        return

    @staticmethod
    def ac_3816(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3816/
        tag: scc|topological_sort|dag_dp
        """
        class Graph(DirectedGraphForTarjanScc):
            def get_scc_dag_dp(self):
                scc_edge = set()
                scc_weight = [0] * self.scc_id * 26
                for i in range(self.n):
                    ind = self.point_head[i]
                    while ind:
                        j = self.edge_to[ind]
                        a, b = self.node_scc_id[i], self.node_scc_id[j]
                        if a != b:
                            scc_edge.add(a * self.scc_id + b)
                        ind = self.edge_next[ind]
                    scc_weight[self.node_scc_id[i] * 26 + lst[i]] += 1
                self.initialize_graph()
                for val in scc_edge:
                    self.add_directed_edge(val // self.scc_id, val % self.scc_id)
                scc_degree = [0] * self.scc_id
                for val in scc_edge:
                    scc_degree[val % self.scc_id] += 1
                res = max(scc_weight)
                stack = [i for i in range(self.scc_id) if not scc_degree[i]]
                scc_pre = [0] * self.scc_id * 26
                while stack:
                    nex = []
                    for i in stack:
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            scc_degree[j] -= 1
                            for w in range(26):
                                scc_pre[j * 26 + w] = max(scc_pre[i * 26 + w] + scc_weight[i * 26 + w],
                                                          scc_pre[j * 26 + w])
                                res = max(res, scc_pre[j * 26 + w] + scc_weight[j * 26 + w])
                            if not scc_degree[j]:
                                nex.append(j)
                            ind = self.edge_next[ind]
                    stack = nex
                return res

        n, m = ac.read_list_ints()
        graph = Graph(n)
        lst = [ord(w) - ord("a") for w in ac.read_str()]
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            if u == v:
                ac.st(-1)
                return
            graph.add_directed_original_edge(u, v)
        graph.build_scc()
        if graph.scc_id != n:
            ac.st(-1)
            return
        ans = graph.get_scc_dag_dp()
        ac.st(ans)
        return

    @staticmethod
    def lc_2360(edges):
        """
        url: https://leetcode.cn/problems/longest-cycle-in-a-graph/
        tag: largest_circle|scc|topological_sort|scc
        """
        n = len(edges)
        graph = DirectedGraphForTarjanScc(n)
        for i in range(n):
            if edges[i] != -1:
                graph.add_directed_edge(i, edges[i])
        graph.build_scc()
        ans = max(graph.get_scc_cnt())
        return ans if ans > 1 else -1

    @staticmethod
    def abc_334g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc334/tasks/abc334_g
        tag: union_find|mod_reverse|tarjan|edcc|expectation|math|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        uf = UnionFind(m * n)
        mod = 998244353
        green = 0
        dct = [[] for _ in range(m * n)]
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "#":
                    if i + 1 < m and grid[i + 1][j] == "#":
                        uf.union(i * n + j, i * n + n + j)
                        dct[i * n + j].append(i * n + n + j)
                        dct[i * n + n + j].append(i * n + j)
                    if j + 1 < n and grid[i][j + 1] == "#":
                        uf.union(i * n + j, i * n + j + 1)
                        dct[i * n + j].append(i * n + 1 + j)
                        dct[i * n + 1 + j].append(i * n + j)
                    green += 1
        group = uf.get_root_part()
        ans = 0
        p = pow(green, -1, mod)
        roots = [root for root in group if grid[root // n][root % n] == "#"]
        count = len(roots)
        _, _, node_group_id = Tarjan().get_pdcc(m * n, dct)
        for root in roots:
            lst = group[root]
            tot = len(lst)
            if tot == 1:
                ans += (count - 1)
            else:
                for ls in lst:
                    ans += count + len(node_group_id[ls]) - 1
                    ans %= mod
        ans *= p
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_245f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc245/tasks/abc245_f
        tag: scc|reverse_graph|implemention|bfs|classical
        """
        class Graph(DirectedGraphForTarjanScc):
            def get_scc_dag_dp(self):
                scc_edge = set()
                scc_cnt = [0] * self.scc_id
                for i in range(self.n):
                    ind = self.point_head[i]
                    while ind:
                        j = self.edge_to[ind]
                        a, b = self.node_scc_id[i], self.node_scc_id[j]
                        if a != b:
                            scc_edge.add(b * self.scc_id + a)
                        ind = self.edge_next[ind]
                    scc_cnt[self.node_scc_id[i]] += 1
                self.initialize_graph()
                for val in scc_edge:
                    self.add_directed_edge(val // self.scc_id, val % self.scc_id)
                scc_degree = [0] * self.scc_id
                for val in scc_edge:
                    scc_degree[val % self.scc_id] += 1
                stack = [i for i in range(self.scc_id) if scc_cnt[i] > 1]
                visit = [0] * self.scc_id
                for i in stack:
                    visit[i] = scc_cnt[i]
                while stack:
                    nex = []
                    for i in stack:
                        ind = self.point_head[i]
                        while ind:
                            j = self.edge_to[ind]
                            if not visit[j]:
                                nex.append(j)
                                visit[j] = scc_cnt[j]
                            ind = self.edge_next[ind]
                    stack = nex
                return sum(visit)

        n, m = ac.read_list_ints()
        graph = Graph(n)
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            graph.add_directed_original_edge(u, v)
        graph.build_scc()
        ans = graph.get_scc_dag_dp()
        ac.st(ans)
        return

    @staticmethod
    def abc_357e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc357/tasks/abc357_e
        tag: scc|build_graph|reverse_graph
        """
        n = ac.read_int()
        nums = ac.read_list_ints_minus_one()
        graph = DirectedGraphForTarjanScc(n)
        for i in range(n):
            graph.add_directed_original_edge(i, nums[i])
        graph.build_scc()
        ans = graph.get_scc_dag_dp()
        ac.st(ans)
        return

    @staticmethod
    def cf_1986e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1986/problem/E
        tag: cutting_edge|tarjan|brute_force
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(m):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)
            _, edge = Tarjan().get_cut(n, dct)
            if not edge:
                ac.st(n * (n - 1) // 2)
            else:
                uf = UnionFind(n)
                new_dct = [[] for _ in range(n)]
                for i, j in edge:
                    uf.union(i, j)
                    new_dct[i].append(j)
                    new_dct[j].append(i)
                for i in range(n):
                    for j in dct[i]:
                        if uf.union(i, j):
                            new_dct[i].append(j)
                            new_dct[j].append(i)
                sub = [0] * n
                stack = [(0, -1)]
                father = [-1] * n
                while stack:
                    i, fa = stack.pop()
                    if i >= 0:
                        stack.append((~i, fa))
                        for j in new_dct[i]:
                            if j != fa:
                                stack.append((j, i))
                                father[j] = i
                    else:
                        i = ~i
                        sub[i] = 1
                        for j in new_dct[i]:
                            if j != fa:
                                sub[i] += sub[j]
                ans = n * (n - 1) // 2
                for i, j in edge:
                    if father[i] == j:
                        cur = sub[i]
                    else:
                        cur = sub[j]
                    ans = min(ans, cur * (cur - 1) // 2 + (n - cur) * (n - cur - 1) // 2)
                ac.st(ans)
        return

    @staticmethod
    def cf_118e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/118/E
        tag: tarjan|cutting_edge|order|classical
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        nums = []
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            edge[x].append(y)
            edge[y].append(x)
            nums.append((x, y))

        res = Tarjan().get_cut(n, edge)
        cutting_point, cutting_edge, parent, order = res
        if not cutting_edge:
            for x, y in nums:
                if x == parent[y]:
                    ac.lst([x + 1, y + 1])
                elif y == parent[x]:
                    ac.lst([y + 1, x + 1])
                elif order[x] > order[y]:
                    ac.lst([x + 1, y + 1])
                else:
                    ac.lst([y + 1, x + 1])
        else:
            ac.st(0)
        return

    @staticmethod
    def cf_1000e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1000/E
        tag: tarjan|edcc|cutting_edge|tree_diameter
        """
        n, m = ac.read_list_ints()
        dct = [set() for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].add(j)
            dct[j].add(i)
        _, cutting_edges = Tarjan().get_cut(n, [list(e) for e in dct])
        # edcc
        nex_dct = [list(e) for e in dct]
        for i, j in cutting_edges:
            dct[i].discard(j)
            dct[j].discard(i)
        visit = [0] * n
        node_edcc_id = [-1] * n
        edcc_id = 0
        for i in range(n):
            if visit[i]:
                continue
            stack = [i]
            visit[i] = 1
            node_edcc_id[i] = edcc_id
            while stack:
                x = stack.pop()
                for j in dct[x]:
                    if not visit[j]:
                        visit[j] = 1
                        stack.append(j)
                        node_edcc_id[j] = edcc_id
            edcc_id += 1
        del dct, visit
        new_dct = [[] for _ in range(edcc_id)]
        for i in range(n):
            for j in nex_dct[i]:
                a, b = node_edcc_id[i], node_edcc_id[j]
                if a != b:
                    new_dct[a].append(b)
        del nex_dct
        n = len(new_dct)
        root = 0
        dis = [math.inf] * n
        stack = [(root, -1)]
        dis[root] = 0
        while stack:
            i, fa = stack.pop()
            for j in new_dct[i]:  # weighted edge
                if j != fa:
                    dis[j] = dis[i] + 1
                    stack.append((j, i))
        root = dis.index(max(dis))
        dis = [math.inf] * n
        stack = [(root, -1)]
        dis[root] = 0
        while stack:
            i, fa = stack.pop()
            for j in new_dct[i]:  # weighted edge
                if j != fa:
                    dis[j] = dis[i] + 1
                    stack.append((j, i))

        ac.st(max(dis))
        return
"""

Algorithm：topological_sort|circle_based_tree|bfs_order|topological_order|topological_lexicographic_order
Description：undirected_topological_sort|directed_topological_sort|directed_circle_based_tree|undirected_circle_based_tree

====================================LeetCode====================================
360（https://leetcode.cn/problems/longest-cycle-in-a-graph/）topological_sort|directed_circle_based_tree|longest_circle
2392（https://leetcode.cn/problems/build-a-matrix-with-conditions/）build_graph|union_find|topological_sort
2371（https://leetcode.cn/problems/minimize-maximum-value-in-a-grid/）build_graph|topological_sort|greedy
2127（https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/）topological_sort|dag|directed_circle_based_tree|classification_discussion
127（https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/）topological_sort|directed_circle_based_tree|
269（https://leetcode.cn/problems/alien-dictionary/）lexicographical_order|build_graph|topological_sort
2603（https://leetcode.cn/problems/collect-coins-in-a-tree/）undirected_topological_sort|undirected_circle_based_tree
2204（https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/）undirected_topological_sort
1857（https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/）topological_sort|dag_dp
1932（https://leetcode.cn/problems/merge-bsts-to-create-single-bst/）union_find|topological_sort|union_find|binary_search_tree
1591（https://leetcode.cn/problems/strange-printer-ii/）build_graph|topological_sort|circle_judge
2192（https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/）directed_topological_sort|dag_dp

=====================================LuoGu======================================
P1960（https://www.luogu.com.cn/problem/P1960）topological_sort|topological_order
P1992（https://www.luogu.com.cn/problem/P1992）directed_topological_sort|directed_circle_judge
P2712（https://www.luogu.com.cn/problem/P2712）topological_sort|circle_judge|find_circle
P6145（https://www.luogu.com.cn/problem/P6145）directed_topological_sort|dag_dp
P1137（https://www.luogu.com.cn/problem/P1137）topological_sort|dag_dp
P1347（https://www.luogu.com.cn/problem/P1347）topological_sort|lexicographical_order|construction
P1685（https://www.luogu.com.cn/problem/P1685）dag_dp|directed_topological_sort|counter
P3243（https://www.luogu.com.cn/problem/P3243）reverse_graph|topological_sort|heapq|implemention|topological_lexicographic_order
P5536（https://www.luogu.com.cn/problem/P5536）undirected_topological_sort
P6037（https://www.luogu.com.cn/problem/P6037）undirected_circle_based_tree|union_find|topological_sort|implemention
P6255（https://www.luogu.com.cn/problem/P6255）union_find|topological_sort|circle_judge
P6417（https://www.luogu.com.cn/problem/P6417）directed_circle_based_tree|greedy|topological_sort
P6560（https://www.luogu.com.cn/problem/P6560）reverse_graph|topological_sort|game_dp
P8655（https://www.luogu.com.cn/problem/P8655）topological_sort|directed_circle_based_tree
P8943（https://www.luogu.com.cn/problem/P8943）undirected_circle_based_tree|game_dp
P1983（https://www.luogu.com.cn/problem/P1983）topological_sort
P2921（https://www.luogu.com.cn/problem/P2921）circle_based_tree|topological_sort|classical

===================================CodeForces===================================
1454E（https://codeforces.com/contest/1454/problem/E）circle_based_tree|counter|brute_force|inclusion_exclusion
1907G（https://codeforces.com/contest/1907/problem/G）directed_circle_based_tree|greedy|implemention|topological_sort
1914F（https://codeforces.com/contest/1914/problem/F）topological_sort|greedy
1829F（https://codeforces.com/contest/1829/problem/F）reverse_thinking|degree|undirected_graph
1873H（https://codeforces.com/contest/1873/problem/H）circle_based_tree|topological_sort
1029E（https://codeforces.com/contest/1029/problem/E）greedy|implemention|rooted_tree|depth|degree
1872F（https://codeforces.com/contest/1872/problem/F）topological_sort|greedy
1388D（https://codeforces.com/problemset/problem/1388/D）topological_sort|dag_dp|heuristic_merge|classical
919D（https://codeforces.com/problemset/problem/919/D）topological_sort|dag_dp|classical
1335F（https://codeforces.com/problemset/problem/1335/F）circle_based_tree|implemention|observation|greedy
1027D（https://codeforces.com/problemset/problem/1027/D）topological_sort|classical|circle_based_tree
1867D（https://codeforces.com/problemset/problem/1867/D）topological_sort|classical|circle_based_tree

====================================AtCoder=====================================
ABC266F（https://atcoder.jp/contests/abc266/tasks/abc266_f）undirected_circle_based_tree
ABC303E（https://atcoder.jp/contests/abc303/tasks/abc303_e）undirected_graph|topological_sort
ABC296E（https://atcoder.jp/contests/abc296/tasks/abc296_e）topological_sort|directed_graph
ABC256E（https://atcoder.jp/contests/abc256/tasks/abc256_e）topological_sort|greedy|circle_based_tree|classical
ABC223D（https://atcoder.jp/contests/abc223/tasks/abc223_d）topological_sort


=====================================AcWing=====================================
3696（https://www.acwing.com/problem/content/description/3699/）topological_order|dag|construction
3831（https://www.acwing.com/problem/content/description/3831/）topological_sort|dag_dp|circle_judge
4629（https://www.acwing.com/problem/content/description/4629/）directed_circle_based_tree|circle_judge

=====================================LibraryChecker=====================================
1（https://www.hackerrank.com/challenges/favourite-sequence/problem?isFullScreen=true）topological_lexicographic_order


"""

import math
from collections import defaultdict, deque
from heapq import heapify, heappop, heappush
from typing import List, Optional

from src.basis.tree_node.template import TreeNode
from src.graph.network_flow.template import UndirectedGraph
from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_266f_1(ac=FastIO()):
        """
        urL: https://atcoder.jp/contests/abc266/tasks/abc266_f
        tag: undirected_circle_based_tree|classical|connected
        """
        n = ac.read_int()
        edge = [[] for _ in range(n)]
        uf = UnionFind(n)

        degree = [0] * n
        for _ in range(n):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append(v)
            edge[v].append(u)
            degree[u] += 1
            degree[v] += 1

        que = deque()
        for i in range(n):
            if degree[i] == 1:
                que.append(i)
        while que:
            now = que.popleft()
            nex = edge[now][0]
            degree[now] -= 1
            degree[nex] -= 1
            edge[nex].remove(now)
            uf.union(now, nex)
            if degree[nex] == 1:
                que.append(nex)

        q = ac.read_int()
        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            if uf.is_connected(x, y):
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def abc_266f_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc266/tasks/abc266_f
        tag: topological|sort|circle_based_tree|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(n):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += 1
            degree[j] += 1
        stack = [i for i in range(n) if degree[i] == 1]
        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    degree[j] -= 1
                    if degree[j] == 1:
                        nex.append(j)
            stack = nex[:]
        circle = [i for i in range(n) if degree[i] >= 2]
        father = [-1] * n
        for i in circle:
            father[i] = i
        stack = circle[:]
        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    if father[j] == -1:
                        father[j] = father[i]
                        nex.append(j)
            stack = nex[:]
        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints_minus_one()
            if father[x] != father[y]:
                ac.no()
            else:
                ac.yes()
        return

    @staticmethod
    def ac_3696(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3699/
        tag: topological_order|dag|construction|classical|hard|brain_teaser
        """
        for _ in range(ac.read_int()):

            def check():
                n, m = ac.read_list_ints()
                dct = [[] for _ in range(n)]
                degree = [0] * n
                edges = []
                ans = []
                for _ in range(m):
                    t, x, y = ac.read_list_ints()
                    x -= 1
                    y -= 1
                    if t == 1:
                        ans.append([x, y])
                        dct[x].append(y)
                        degree[y] += 1
                    else:
                        edges.append([x, y])

                order = [0] * n
                stack = [i for i in range(n) if degree[i] == 0]
                ind = 0
                while stack:
                    nex = []
                    for i in stack:
                        order[i] = ind
                        ind += 1
                        for j in dct[i]:
                            degree[j] -= 1
                            if degree[j] == 0:
                                nex.append(j)
                    stack = nex[:]
                if any(degree[x] > 0 for x in range(n)):
                    ac.no()
                    return

                ac.yes()
                for x, y in edges:
                    if order[x] < order[y]:
                        ac.lst([x + 1, y + 1])
                    else:
                        ac.lst([y + 1, x + 1])
                for x, y in ans:
                    ac.lst([x + 1, y + 1])
                return

            check()
        return

    @staticmethod
    def lc_2392(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/build-a-matrix-with-conditions/
        tag: build_graph|union_find|topological_sort
        """

        def check(cond):
            dct = defaultdict(list)
            degree = defaultdict(int)
            for i, j in cond:
                dct[i].append(j)
                degree[j] += 1
            stack = [i for i in range(1, k + 1) if not degree[i]]
            ans = []
            while stack:
                ans.extend(stack)
                nex = []
                for i in stack:
                    for j in dct[i]:
                        degree[j] -= 1
                        if not degree[j]:
                            nex.append(j)
                stack = nex
            return ans

        row = check(row_conditions)
        col = check(col_conditions)
        if len(row) != k or len(col) != k:
            return []

        row_ind = {row[i]: i for i in range(k)}
        col_ind = {col[i]: i for i in range(k)}
        res = [[0] * k for _ in range(k)]
        for i in range(1, k + 1):
            res[row_ind[i]][col_ind[i]] = i
        return res

    @staticmethod
    def lg_p1137(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1137
        tag: topological_sort|dag_dp|longest_path
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints()
            degree[j - 1] += 1
            dct[i - 1].append(j - 1)
        cnt = [1] * n
        stack = [i for i in range(n) if not degree[i]]
        while stack:
            i = stack.pop()
            for j in dct[i]:
                cnt[j] = max(cnt[j], cnt[i] + 1)
                degree[j] -= 1
                if not degree[j]:
                    stack.append(j)
        for a in cnt:
            ac.st(a)
        return

    @staticmethod
    def lg_p1347(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1347
        tag: topological_sort|lexicographical_order|construction
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n

        def check():
            stack = [k for k in range(n) if not degree[k]]
            res = []
            unique = True
            while stack:
                res.extend(stack)
                if len(stack) > 1:
                    unique = False
                nex = []
                for i in stack:
                    for j in dct[i]:
                        degree[j] -= 1
                        if not degree[j]:
                            nex.append(j)
                stack = nex

            if unique and len(nodes) == n:
                ss = "".join([chr(ord("A") + w) for w in res])
                return True, f"Sorted sequence determined after {x} relations: {ss}."

            if len(res) < n:
                return True, f"Inconsistency found after {x} relations."

            return False, "Sorted sequence cannot be determined."

        nodes = set()
        for x in range(1, m + 1):
            s = ac.read_str()
            dct[ord(s[0]) - ord("A")].append(ord(s[2]) - ord("A"))
            degree[ord(s[2]) - ord("A")] += 1
            nodes.add(s[0])
            nodes.add(s[2])
            original = degree[:]
            flag, ans = check()
            if flag:
                ac.st(ans)
                break
            degree = original[:]
        else:
            ac.st("Sorted sequence cannot be determined.")
        return

    @staticmethod
    def lg_p1685(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1685
        tag: dag_dp|directed_topological_sort|counter|classical
        """
        n, m, s, e, t = ac.read_list_ints()
        s -= 1
        e -= 1
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            i, j, w = ac.read_list_ints()
            i -= 1
            j -= 1
            dct[i].append([j, w])
            degree[j] += 1
        mod = 10000

        time = [0] * n
        cnt = [0] * n
        stack = [s]
        cnt[s] = 1
        while stack:
            i = stack.pop()
            for j, w in dct[i]:
                degree[j] -= 1
                if not degree[j]:
                    stack.append(j)
                cnt[j] += cnt[i]
                time[j] += cnt[i] * w + time[i]
                time[j] %= mod
        ans = time[e] + (cnt[e] - 1) * t
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p3243(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3243
        tag: reverse_graph|topological_sort|heapq|implemention|topological_lexicographic_order|brain_teaser|classical|hard
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            degree = [0] * n
            for _ in range(m):
                i, j = ac.read_list_ints_minus_one()
                dct[j].append(i)
                degree[i] += 1
            ans = []
            stack = [-i for i in range(n) if not degree[i]]
            heapify(stack)
            while stack:
                i = -heappop(stack)
                ans.append(i)
                for j in dct[i]:
                    degree[j] -= 1
                    if not degree[j]:
                        heappush(stack, -j)
            if len(ans) == n:
                ans.reverse()
                ac.lst([x + 1 for x in ans])
            else:
                ac.st("Impossible!")
        return

    @staticmethod
    def lg_p5536(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5536
        tag: undirected_topological_sort|classical|brain_teaser
        """
        n, k = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += 1
            degree[j] += 1

        rem = n - k
        ans = 0
        stack = deque([[i, 1] for i in range(n) if degree[i] == 1])
        while rem:
            i, d = stack.popleft()
            ans = d
            rem -= 1
            for j in dct[i]:
                if degree[j] > 1:
                    degree[j] -= 1
                    if degree[j] == 1:
                        stack.append([j, d + 1])
        ac.st(ans)
        return

    @staticmethod
    def lg_p6037(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6037
        tag: undirected_circle_based_tree|union_find|topological_sort|implemention
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        tot = 0
        for _ in range(n):
            u, v, w, p = ac.read_list_ints()
            u -= 1
            v -= 1
            dct[u].append((v, w, p))
            dct[v].append((u, w, p))
            degree[u] += 1
            degree[v] += 1
            tot += w
        stack = [i for i in range(n) if degree[i] == 1]
        while stack:
            nex = []
            for i in stack:
                for j, _, _ in dct[i]:
                    degree[j] -= 1
                    if degree[j] == 1:
                        nex.append(j)
            stack = nex
        ans = [0] * n
        for i in range(n):
            if degree[i] > 1:
                p1 = math.inf
                w1 = 0
                for j, w, p in dct[i]:
                    if degree[j] > 1 and p < p1:
                        p1 = p
                        w1 = w
                ans[i] = tot - w1
            stack = [(i, -1)]
            while stack:
                x, fa = stack.pop()
                for y, _, _ in dct[x]:
                    if degree[y] <= 1 and y != fa:
                        stack.append((y, x))
                        ans[y] = ans[i]
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p6037_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6037
        tag: undirected_circle_based_tree|union_find|topological_sort|implemention
        """

        n = ac.read_int()

        graph = UndirectedGraph(n)

        degree = [0] * (n + 1)
        tot = 0
        for i in range(n):
            u, v, w, p = ac.read_list_ints()
            graph.add_edge(u, v, w, p)
            degree[u] += 1
            degree[v] += 1
            tot += w
        stack = [i for i in range(1, n + 1) if degree[i] == 1]
        while stack:
            nex = []
            for u in stack:
                i = graph.point_head[u]
                while i:
                    j = graph.edge_to[i]
                    degree[j] -= 1
                    if degree[j] == 1:
                        nex.append(j)
                    i = graph.edge_next[i]
            stack = nex

        ans = [0] * (n + 1)
        for u in range(1, n + 1):
            if degree[u] > 1:
                p1 = math.inf
                w1 = 0
                i = graph.point_head[u]
                while i:
                    p, w = graph.edge_p[i], graph.edge_w[i]
                    j = graph.edge_to[i]
                    i = graph.edge_next[i]
                    if degree[j] > 1 and p < p1:
                        p1 = p
                        w1 = w
                ans[u] = tot - w1
            stack = [(u, -1)]
            while stack:
                x, fa = stack.pop()
                i = graph.point_head[x]
                while i:
                    j = graph.edge_to[i]
                    if degree[j] <= 1:
                        stack.append((j, x))
                        ans[j] = ans[u]
                    i = graph.edge_next[i]
        for a in ans[1:]:
            ac.st(a)
        return


    @staticmethod
    def lg_p6255(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6255
        tag: topological_sort|circle_judge|classical|simple_graph|brain_teaser|bfs
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            degree[j] += 1
            degree[i] += 1
            dct[i].append(j)
            dct[j].append(i)
        original = degree[:]

        stack = deque([i for i in range(n) if degree[i] == 1])
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                degree[j] -= 1
                if degree[j] == 1:
                    stack.append(j)

        stack = deque([i for i in range(n) if degree[i] >= 2])
        ans = []
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                if 0 <= degree[j] < 2:
                    if degree[i] >= 2:
                        ans.append([i + 1, j + 1])
                    degree[j] = -1
                    stack.append(j)

        for i in range(n):
            if 0 <= degree[i] < 2 and original[i] == 1:
                ans.append([i + 1, dct[i][0] + 1])
        ans.sort()
        ac.st(len(ans))
        for ls in ans:
            ac.lst(ls)
        return

    @staticmethod
    def lg_p6417(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6417
        tag: directed_circle_based_tree|greedy|topological_sort|brain_teaser|classical
        """
        n = ac.read_int() # MLE
        dct = [ac.read_int() - 1 for _ in range(n)]
        degree = [0] * n
        for i in range(n):
            degree[dct[i]] += 1

        stack = [x for x in range(n) if not degree[x]]
        visit = [-1] * n
        ans = len(stack)
        for i in stack:
            visit[i] = 1
        while stack:
            nex = []
            for i in stack:
                degree[dct[i]] -= 1
                if (not degree[dct[i]] or visit[i] == 1) and visit[dct[i]] == -1:
                    if visit[i] == 1:
                        visit[dct[i]] = 0
                    else:
                        ans += 1
                        visit[dct[i]] = 1
                    nex.append(dct[i])
            stack = nex[:]

        for i in range(n):
            x = 0
            while visit[i] == -1:
                visit[i] = 1
                x += 1
                i = dct[i]
            ans += x // 2
        ac.st(ans)
        return

    @staticmethod
    def lg_p6560(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6560
        tag: reverse_graph|topological_sort|game_dp|brain_teaser|game_dp|classical
        """
        n, m, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        degree = [0 for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[j].append(i)
            degree[i] += 1
        original = degree[:]
        out = [i for i in range(n) if not degree[i]]
        state = [0] * n
        for i in out:
            state[i] = -1
        dp = state[:]
        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            for i in range(n):
                degree[i] = original[i]
                dp[i] = state[i]
            stack = deque(out + [y]) if degree[y] else deque(out)
            if degree[y]:
                dp[y] = -1
            while stack:
                u = stack.popleft()
                for v in dct[u]:
                    if dp[v] != 0:
                        continue
                    if dp[u] == 1:
                        degree[v] -= 1
                        if not degree[v]:
                            dp[v] = -1
                            stack.append(v)
                    else:
                        dp[v] = 1
                        stack.append(v)
            ac.st(dp[x])
        return

    @staticmethod
    def lg_p8655(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8655
        tag: topological_sort|directed_circle_based_tree
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(n):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += 1
            degree[j] += 1
        stack = [x for x in range(n) if degree[x] == 1]
        while stack:
            y = stack.pop()
            for z in dct[y]:
                degree[z] -= 1
                if degree[z] == 1:
                    stack.append(z)
        ans = [x + 1 for x in range(n) if degree[x] == 2]
        ac.lst(ans)
        return

    @staticmethod
    def lg_p8943(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8943
        tag: undirected_circle_based_tree|game_dp
        """
        n, q = ac.read_list_ints()
        degree = [0] * n
        dct = [[] for _ in range(n)]
        for _ in range(n):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(y)
            dct[y].append(x)
            degree[x] += 1
            degree[y] += 1

        stack = deque([i for i in range(n) if degree[i] == 1])
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                degree[j] -= 1
                if degree[j] == 1:
                    stack.append(j)

        dis = [math.inf] * n
        stack = [i for i in range(n) if degree[i] >= 2]
        path = [stack[0]]
        degree[stack[0]] = 0
        while True:
            for j in dct[path[-1]]:
                if degree[j] >= 2 and j != path[-1]:
                    path.append(j)
                    degree[j] = 0
                    break
            else:
                break
        ind = {num: i for i, num in enumerate(path)}

        ancestor = [-1] * n
        for i in stack:
            dis[i] = 0
            ancestor[i] = i
        while stack:
            i = stack.pop()
            for j in dct[i]:
                if dis[j] == math.inf:
                    stack.append(j)
                    dis[j] = dis[i] + 1
                    ancestor[j] = ancestor[i]

        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            if x == y:
                ac.st("Deception")
                continue
            dis_x = dis[x]
            xy = abs(ind[ancestor[x]] - ind[ancestor[y]])
            dis_y = dis[y] + min(xy, len(ind) - xy)
            if dis_x < dis_y:
                ac.st("Survive")
            else:
                ac.st("Deception")
        return

    @staticmethod
    def lc_2127(favorite: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/
        tag: topological_sort|dag|directed_circle_based_tree|classification_discussion|classical|hard
        """
        n = len(favorite)
        degree = [0] * n
        for i in range(n):
            degree[favorite[i]] += 1
        depth = [0] * n
        stack = [i for i in range(n) if degree[i] == 0]
        while stack:
            nex = []
            for i in stack:
                j = favorite[i]
                degree[j] -= 1
                a, b = depth[i] + 1, depth[j]
                depth[j] = a if a > b else b
                if not degree[j]:
                    nex.append(j)
            stack = nex[:]
        ans = 0
        bicycle = 0
        for i in range(n):
            if not degree[i]:
                continue
            lst = [i]
            degree[i] = 0
            x = favorite[i]
            while x != i:
                lst.append(x)
                degree[x] = 0
                x = favorite[x]
            if len(lst) == 2:
                bicycle += depth[lst[0]] + depth[lst[1]] + 2
            elif len(lst) > ans:
                ans = len(lst)

        ans = ans if ans > bicycle else bicycle
        return ans

    @staticmethod
    def lc_2192(n: int, edges: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/
        tag: directed_topological_sort|dag_dp
        """
        ans = [set() for _ in range(n)]
        degree = [0] * n
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            degree[j] += 1
        stack = [i for i in range(n) if not degree[i]]
        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    for x in ans[i]:
                        ans[j].add(x)
                    ans[j].add(i)
                    degree[j] -= 1
                    if not degree[j]:
                        nex.append(j)
            stack = nex
        return [sorted(list(a)) for a in ans]

    @staticmethod
    def lc_2204(n: int, edges: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/
        tag: undirected_topological_sort
        """
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += 1
            degree[j] += 1
        stack = deque([i for i in range(n) if degree[i] == 1])
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                degree[j] -= 1
                if degree[j] == 1:
                    stack.append(j)

        circle = deque([i for i in range(n) if degree[i] > 1])
        ans = [-1] * n
        for i in circle:
            ans[i] = 0
        while circle:
            i = circle.popleft()
            for j in dct[i]:
                if ans[j] == -1:
                    ans[j] = ans[i] + 1
                    circle.append(j)
        return ans

    @staticmethod
    def lc_1857(colors: str, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/
        tag: topological_sort|dag_dp|alphabet|data_range|classical
        """
        n = len(colors)
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for i, j in edges:
            if i == j:
                return -1
            dct[i].append(j)
            degree[j] += 1

        cnt = [[0] * 26 for _ in range(n)]
        stack = deque([i for i in range(n) if not degree[i]])
        for i in stack:
            cnt[i][ord(colors[i]) - ord("a")] += 1
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                degree[j] -= 1
                for c in range(26):
                    a, b = cnt[j][c], cnt[i][c]
                    cnt[j][c] = a if a > b else b
                if not degree[j]:
                    cnt[j][ord(colors[j]) - ord("a")] += 1
                    stack.append(j)
        if not all(x == 0 for x in degree):
            return -1
        return max(max(c) for c in cnt)

    @staticmethod
    def lc_1932(trees: List[TreeNode]) -> Optional[TreeNode]:
        """
        url: https://leetcode.cn/problems/merge-bsts-to-create-single-bst/
        tag: union_find|topological_sort|union_find|binary_search_tree|classical
        """
        n = len(trees)
        ind = {tree.val: i for i, tree in enumerate(trees)}

        degree = [0] * n
        for i in range(n):
            if trees[i].left:
                if trees[i].left.val in ind:
                    degree[ind[trees[i].left.val]] += 1
            if trees[i].right:
                if trees[i].right.val in ind:
                    degree[ind[trees[i].right.val]] += 1

        stack = [(i, -math.inf, math.inf) for i in range(n) if not degree[i]]
        if len(stack) != 1 or any(x > 1 for x in degree):
            return None
        ans = trees[stack[0][0]]
        while stack:
            i, low, high = stack.pop()
            if not low < trees[i].val < high:
                return None
            if trees[i].left:
                if trees[i].left.val in ind:
                    degree[ind[trees[i].left.val]] -= 1
                    trees[i].left = trees[ind[trees[i].left.val]]
                    stack.append((ind[trees[i].left.val], low, trees[i].val))
                else:
                    if not low < trees[i].left.val < trees[i].val:
                        return None
            if trees[i].right:
                if trees[i].right.val in ind:
                    degree[ind[trees[i].right.val]] -= 1
                    trees[i].right = trees[ind[trees[i].right.val]]
                    stack.append((ind[trees[i].right.val], trees[i].val, high))
                else:
                    if not trees[i].val < trees[i].right.val < high:
                        return
        return ans if all(x == 0 for x in degree) else None

    @staticmethod
    def ac_3831(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3831/
        tag: topological_sort|dag_dp|circle_judge
        """
        m, n = ac.read_list_ints()
        ind = {w: i for i, w in enumerate("QWER")}
        grid = [ac.read_str() for _ in range(m)]

        dct = [[] for _ in range(m * n)]
        degree = [0] * (m * n)
        for i in range(m):
            for j in range(n):
                x = ind[grid[i][j]]
                for a, b in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                    if 0 <= a < m and 0 <= b < n:
                        y = ind[grid[a][b]]
                        if y == (x + 1) % 4:
                            dct[i * n + j].append(a * n + b)
                            degree[a * n + b] += 1

        pre = [0] * (m * n)
        stack = [i for i in range(m * n) if not degree[i]]
        for i in stack:
            if grid[i // n][i % n] == "Q":
                pre[i] = 1
        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    degree[j] -= 1
                    if pre[i] > pre[j]:
                        pre[j] = pre[i]
                    if not degree[j]:
                        if not pre[j]:
                            if grid[j // n][j % n] == "Q":
                                pre[j] = 1
                        else:
                            pre[j] += 1
                        nex.append(j)
            stack = nex[:]
        if any(d > 0 for d in degree):
            ac.st("math.infinity")
            return
        ans = max(x // 4 for x in pre)
        ac.st(ans if ans else "none")
        return

    @staticmethod
    def ac_4629(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4629/
        tag: directed_circle_based_tree|circle_judge|classical|brain_teaser
        """
        n = ac.read_int()
        a = ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for i in range(n):
            dct[i].append(a[i])
            degree[a[i]] += 1
        if any(d == 0 for d in degree):
            ac.st(-1)
            return

        ans = 1
        for i in range(n):
            if degree[i] == 0:
                continue
            stack = [i]
            degree[i] = 0
            cur = 1
            while stack:
                x = stack.pop()
                for j in dct[x]:
                    if degree[j] > 0:
                        degree[j] = 0
                        cur += 1
                        stack.append(j)
            if cur % 2:
                ans = math.lcm(cur, ans)
            else:
                ans = math.lcm(cur // 2, ans)
        ac.st(ans)
        return

    @staticmethod
    def lc_1591(grid: List[List[int]]) -> bool:
        """
        url: https://leetcode.cn/problems/strange-printer-ii/
        tag: build_graph|topological_sort|circle_judge
        """
        color = defaultdict(list)
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                color[grid[i][j]].append([i, j])

        pos = defaultdict(list)
        for c in color:
            lst = color[c]
            x1 = min(x for x, _ in lst)
            x2 = max(x for x, _ in lst)

            y1 = min(x for _, x in lst)
            y2 = max(x for _, x in lst)
            pos[c] = [x1, x2, y1, y2]

        degree = defaultdict(int)
        dct = defaultdict(list)
        for x in pos:
            a1, a2, b1, b2 = pos[x]
            for y in pos:
                if x != y:
                    for a, b in color[y]:
                        if a1 <= a <= a2 and b1 <= b <= b2:
                            dct[x].append(y)
                            degree[y] += 1
        stack = [x for x in pos if not degree[x]]
        while stack:
            nex = []
            for i in stack:
                for j in dct[i]:
                    degree[j] -= 1
                    if not degree[j]:
                        nex.append(j)
            stack = nex[:]
        return all(degree[x] == 0 for x in pos)

    @staticmethod
    def abc_256e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc256/tasks/abc256_e
        tag: topological_sort|greedy|circle_based_tree|classical
        """
        n = ac.read_int()
        x = ac.read_list_ints_minus_one()
        c = ac.read_list_ints()
        degree = [0] * n
        for i in range(n):
            degree[x[i]] += 1
        stack = [i for i in range(n) if not degree[i]]
        while stack:
            i = stack.pop()
            degree[x[i]] -= 1
            if not degree[x[i]]:
                stack.append(x[i])
        ans = 0
        for i in range(n):
            if degree[i]:
                p = i
                cur = c[p]
                degree[p] = 0
                while x[p] != i:
                    p = x[p]
                    cur = min(cur, c[p])
                    degree[p] = 0
                ans += cur
        ac.st(ans)
        return

    @staticmethod
    def cf_1388d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1388/D
        tag: topological_sort|dag_dp|heuristic_merge|classical
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        degree = [0] * n
        for i in range(n):
            if b[i] != -1:
                degree[b[i] - 1] += 1
        res = []
        ans = 0
        stack = [i for i in range(n) if degree[i] == 0]
        ind = [-1] * n
        path = [[] for _ in range(n)]
        for i in stack:
            ind[i] = i
            path[i].append(i)
        while stack:
            nex = []
            for i in stack:
                ans += a[i]
            for i in stack:
                j = b[i]
                if j == -1:
                    res.extend(path[ind[i]][::-1])
                    continue
                j -= 1
                if a[i] < 0:
                    res.extend(path[ind[i]][::-1])
                    path[ind[i]] = []
                    ind[i] = -1
                degree[j] -= 1
                a[j] += max(a[i], 0)
                if ind[j] == -1 and ind[i] != -1:
                    ind[j] = ind[i]
                elif ind[i] != -1 and ind[j] != -1:
                    x, y = ind[i], ind[j]
                    if len(path[x]) < len(path[y]):
                        path[y].extend(path[x])
                        ind[j] = y
                    else:
                        path[x].extend(path[y])
                        ind[j] = x
                elif ind[j] == -1:
                    ind[j] = j
                if degree[j] == 0:
                    nex.append(j)
                    path[ind[j]].append(j)
            stack = nex[:]
        ac.st(ans)
        ac.lst([x + 1 for x in res[::-1]])
        return

    @staticmethod
    def cf_1335f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1335/F
        tag: circle_based_tree|implemention|observation|greedy
        """
        move = dict()
        move["U"] = (-1, 0)
        move["D"] = (1, 0)
        move["L"] = (0, -1)
        move["R"] = (0, 1)
        tm = 10 ** 9
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            color = [ac.read_str() for _ in range(m)]
            grid = [ac.read_str() for _ in range(m)]
            ans = [0, 0]
            dct = [-1] * m * n
            rev = [[] for _ in range(m * n)]
            degree = [0] * m * n
            for i in range(m):
                for j in range(n):
                    w = move[grid[i][j]]
                    dct[i * n + j] = (i + w[0]) * n + j + w[1]
                    rev[(i + w[0]) * n + j + w[1]].append(i * n + j)
                    degree[(i + w[0]) * n + j + w[1]] += 1
            stack = [i for i in range(m * n) if degree[i] == 0]
            while stack:
                nex = []
                for i in stack:
                    j = dct[i]
                    degree[j] -= 1
                    if not degree[j]:
                        nex.append(j)
                stack = nex
            dis = [-1] * m * n
            parent = [-1] * m * n
            index = [-1] * m * n
            for i in range(m * n):
                if degree[i]:
                    lst = [i]
                    while len(lst) == 1 or lst[-1] != i:
                        lst.append(dct[lst[-1]])
                    lst.pop()
                    k = len(lst)
                    for ii, x in enumerate(lst):
                        index[x] = ii
                        degree[x] = 0
                    ans[0] += len(lst)
                    stack = lst[:]
                    for x in stack:
                        dis[x] = 0
                        parent[x] = x
                    cur = set()
                    while stack:
                        for x in stack:
                            pi = index[parent[x]]
                            if color[x // n][x % n] == "0":
                                cur.add((tm - dis[x] + dis[parent[x]] + pi) % k)
                        nex = []
                        for x in stack:
                            for y in rev[x]:
                                if dis[y] == -1:
                                    dis[y] = dis[x] + 1
                                    parent[y] = parent[x]
                                    nex.append(y)
                        stack = nex
                    ans[1] += len(cur)
            ac.lst(ans)
        return"""
Algorithm：bfs|deque_bfs|01-bfs|discretization_bfs|bound_bfs|coloring_method|odd_circle
Description：multi_source_bfs|bilateral_bfs|spfa|a-star|heuristic_search

====================================LeetCode====================================
1617（https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/）brute_force|tree_diameter
100318（https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees）graph_diameter|diameter_merge|classical

=====================================LuoGu======================================
P1099（https://www.luogu.com.cn/problem/P1099）tree_diameter|bfs|two_pointers|monotonic_queue|classical|greedy
P2491（https://www.luogu.com.cn/problem/P2491）tree_diameter|bfs|two_pointers|monotonic_queue|classical|greedy
P3304（https://www.luogu.com.cn/problem/P3304）tree_diameter

===================================CodeForces===================================
1805D（https://codeforces.com/problemset/problem/1805/D）tree_diameter
455C（https://codeforces.com/problemset/problem/455/C）bfs|graph_diameter|union_find|implemention|diameter_merge
734E（https://codeforces.com/problemset/problem/734/E）tree_diameter|brain_teaser|greedy|shrink_node

====================================AtCoder=====================================
ABC267F（https://atcoder.jp/contests/abc267/tasks/abc267_f）tree_diameter|reroot_dp|brain_teaser|dfs|back_trace|classical
ABC221F（https://atcoder.jp/contests/abc221/tasks/abc221_f）tree_diameter|linear_dp
ABC361E（https://atcoder.jp/contests/abc361/tasks/abc361_e）tree_diameter|classical

=====================================AcWing=====================================

=====================================LibraryChcker=====================================
1（https://judge.yosupo.jp/problem/tree_diameter）tree_diameter

"""
from collections import Counter
from typing import List

from src.graph.tree_diameter.template import TreeDiameter, GraphDiameter
from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1805d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1805/D
        tag: tree_diameter|classical|brain_teaser
        """
        n = ac.read_int()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append([v, 1])
            edge[v].append([u, 1])
        tree = TreeDiameter(edge)
        u, v = tree.get_diameter_math.info()[:2]
        dis1, _ = tree.get_bfs_dis(u)
        dis2, _ = tree.get_bfs_dis(v)
        diff = [0] * (n + 1)
        for i in range(n):
            diff[max(dis1[i], dis2[i]) + 1] += 1
        diff[0] = 1
        for i in range(1, n + 1):
            diff[i] += diff[i - 1]
        ac.lst([min(x, n) for x in diff[1:]])
        return

    @staticmethod
    def lg_p3304(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3304
        tag: tree_diameter|classical|hard|brain_teaser|hard|necessary_diameter_edge
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j, k = ac.read_list_ints()
            i -= 1
            j -= 1
            dct[i].append((j, k))
            dct[j].append((i, k))

        x = 0
        dis = [math.inf] * n
        stack = [x]
        dis[x] = 0
        parent = [-1] * n
        while stack:
            i = stack.pop()
            for j, w in dct[i]:
                if j != parent[i]:
                    parent[j] = i
                    dis[j] = dis[i] + w
                    stack.append(j)
        x = dis.index(max(dis))

        dis = [math.inf] * n
        stack = [x]
        dis[x] = 0
        parent = [-1] * n
        weight = [0] * n
        while stack:
            i = stack.pop()
            for j, w in dct[i]:
                if j != parent[i]:
                    parent[j] = i
                    weight[j] = w
                    dis[j] = dis[i] + w
                    stack.append(j)
        y = dis.index(max(dis))
        path = [y]
        path_weight = []
        while path[-1] != x:
            path_weight.append(weight[path[-1]])
            path.append(parent[path[-1]])
        for i in path:
            dis[i] = -1
        del parent, weight
        tot = sum(path_weight)
        m = len(path)
        right = 0
        pre = 0
        for i in range(1, m):
            pre += path_weight[i - 1]
            stack = [(path[i], 0, -1)]
            cur = 0
            while stack:
                x, d, fa = stack.pop()
                cur = max(cur, d)
                for y, w in dct[x]:
                    if y != fa and dis[y] != -1:
                        stack.append((y, d + w, x))
            right = i
            if cur == tot - pre:
                break

        left = m - 1
        pre = 0
        for i in range(m - 2, -1, -1):
            pre += path_weight[i]
            stack = [(path[i], 0, -1)]
            cur = 0
            while stack:
                x, d, fa = stack.pop()
                cur = max(cur, d)
                for y, w in dct[x]:
                    if y != fa and dis[y] != -1:
                        stack.append((y, d + w, x))
            left = i
            if cur == tot - pre:
                break

        ans = max(0, right - left)
        ac.st(tot)
        ac.st(ans)
        return

    @staticmethod
    def lc_1617(n: int, edges: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities/
        tag: brute_force|tree_diameter
        """
        ans = [0] * n
        for state in range(1, 1 << n):
            node = [i for i in range(n) if state & (1 << i)]
            ind = {num: i for i, num in enumerate(node)}
            m = len(node)
            dct = [[] for _ in range(m)]
            uf = UnionFind(m)
            for u, v in edges:
                u -= 1
                v -= 1
                if u in ind and v in ind:
                    dct[ind[u]].append([ind[v], 1])
                    dct[ind[v]].append([ind[u], 1])
                    uf.union(ind[u], ind[v])
            if uf.part != 1:
                continue
            tree = TreeDiameter(dct)
            ans[tree.get_diameter_math.info()[-1]] += 1
        return ans[1:]

    @staticmethod
    def library_checker_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/tree_diameter
        tag: tree_diameter
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y, c = ac.read_list_ints()
            dct[x].append((y, c))
            dct[y].append((x, c))
        tree = TreeDiameter(dct)
        _, _, path, d = tree.get_diameter_math.info()
        ac.lst([d, len(path)])
        ac.lst(path)
        return

    @staticmethod
    def abc_267f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc267/tasks/abc267_f
        tag: tree_diameter|reroot_dp|brain_teaser|dfs|back_trace|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append((j, 1))
            dct[j].append((i, 1))
        _, _, stack, _ = TreeDiameter(dct).get_diameter_math.info()
        ind = {num: i for i, num in enumerate(stack)}
        queries = [[] for _ in range(n)]
        q = ac.read_int()
        for i in range(q):
            u, k = ac.read_list_ints()
            queries[u - 1].append((k, i))
        visit = [0] * n
        for i in stack:
            visit[i] = 1
        ans = [-2] * q
        depth = [0] * n
        for i in stack:
            fa = ind[i]
            cur = [(i, 0)]
            while cur:
                x, d = cur.pop()
                depth[d] = x
                for k, y in queries[x]:
                    if k > d:
                        dd = k - d
                        if fa + dd < len(stack):
                            ans[y] = stack[fa + dd]
                        elif fa >= dd:
                            ans[y] = stack[fa - dd]
                    else:
                        ans[y] = depth[d - k]
                for y, _ in dct[x]:
                    if not visit[y]:
                        cur.append((y, d + 1))
                        visit[y] = 1
        for a in ans:
            ac.st(a + 1)
        return

    @staticmethod
    def abc_221f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc221/tasks/abc221_f
        tag: diameter|linear_dp
        """
        mod = 998244353
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append((j, 1))
            dct[j].append((i, 1))
        if n == 2:
            ac.st(1)
            return

        x, y, path, d = TreeDiameter(dct).get_diameter_math.info()
        if len(path) % 2 == 0:
            m = len(path)
            i, j = path[m // 2 - 1], path[m // 2]
            n += 1
            dct.append([])
            dct[i].remove((j, 1))
            dct[j].remove((i, 1))
            dct[n - 1].append((i, 1))
            dct[i].append((n - 1, 1))
            dct[n - 1].append((j, 1))
            dct[j].append((n - 1, 1))
            x, y, path, d = TreeDiameter(dct).get_diameter_math.info()
        m = len(path)
        mid = path[m // 2]
        dis = [-1] * n
        stack = [mid]
        dis[mid] = 0
        parent = [-1] * n

        while stack:
            nex = []
            for i in stack:
                for j, _ in dct[i]:
                    if dis[j] == -1:
                        if parent[i] == -1:
                            parent[j] = j
                        else:
                            parent[j] = parent[i]
                        dis[j] = dis[i] + 1
                        nex.append(j)
            stack = nex[:]
        ceil = max(dis)

        cnt = list(Counter([parent[x] for x in range(n) if dis[x] == ceil]).values())
        dp = [1, 0, 0]
        for c in cnt:
            ndp = [0, 0, 0]
            ndp[0] = dp[0]
            ndp[1] = dp[0] * c + dp[1]
            ndp[2] = (dp[1] + dp[2]) * c + dp[2]
            dp = [x % mod for x in ndp]
        ac.st(dp[-1])
        return

    @staticmethod
    def cf_455c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/455/C
        tag: bfs|graph_diameter|union_find|implemention|diameter_merge
        """
        n, m, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        uf = UnionFind(n)
        for i, j in edges:
            uf.union(i, j)
            dct[i].append(j)
            dct[j].append(i)
        diameter = [0] * n
        group = uf.get_root_part()
        for g in group:
            if len(group[g]) > 1:
                lst = group[g][:]
                m = len(lst)
                ind = {num: i for i, num in enumerate(lst)}
                edge = [[] for _ in range(m)]
                for i in lst:
                    for j in dct[i]:
                        edge[ind[i]].append(ind[j])
                        edge[ind[j]].append(ind[i])
                diameter[g] = GraphDiameter().get_diameter(edge)

        def check(aa, bb):
            if aa > bb:
                aa, bb = bb, aa
            return max((aa + 1) // 2 + 1, bb // 2) + (bb + 1) // 2

        for _ in range(q):
            lst = ac.read_list_ints_minus_one()
            if lst[0] == 0:
                ac.st(diameter[uf.find(lst[1])])
            else:
                x, y = lst[1:]
                a, b = diameter[uf.find(x)], diameter[uf.find(y)]
                if uf.union(x, y):
                    diameter[uf.find(x)] = check(a, b)
        return

    @staticmethod
    def lc_100318(edges1: List[List[int]], edges2: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees
        tag: graph_diameter|diameter_merge|classical
        """
        n = len(edges1) + 1
        dct1 = [[] for _ in range(n)]
        for i, j in edges1:
            dct1[i].append(j)
            dct1[j].append(i)
        path1 = GraphDiameter().get_diameter(dct1, 0)

        m = len(edges2) + 1
        dct1 = [[] for _ in range(m)]
        for i, j in edges2:
            dct1[i].append(j)
            dct1[j].append(i)
        path2 = GraphDiameter().get_diameter(dct1, 0)

        def check(aa, bb):
            if aa > bb:
                aa, bb = bb, aa
            return max((aa + 1) // 2 + 1, bb // 2) + (bb + 1) // 2

        return check(path1, path2)

    @staticmethod
    def cf_734e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/734/E
        tag: tree_diameter|brain_teaser|greedy|shrink_node
        """
        n = ac.read_int()
        color = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            if color[i] == color[j]:
                dct[i].append((j, 0))
                dct[j].append((i, 0))
            else:
                dct[i].append((j, 1))
                dct[j].append((i, 1))
        _, _, _, dis = TreeDiameter(dct).get_diameter_math.info()
        ac.st((dis + 1) // 2)
        return"""

Algorithm：lca|multiplication_method|tree_chain_split|tree_centroid|offline_lca|tree_diff_array
Description：tree_diff_array_edge|tree_diff_array_point

====================================LeetCode====================================
2646（https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/）offline_lca|tree_diff_array|counter|tree_dp

=====================================LuoGu======================================
P3128（https://www.luogu.com.cn/problem/P3128）offline_lca|tree_diff_array
P3258（https://www.luogu.com.cn/problem/P3258）offline_lca|tree_diff_array|tree_dp
P6869（https://www.luogu.com.cn/problem/P6869）offline_lca|tree_diff_array_edge|tree_diff_array_point

===================================CodeForces===================================
191C（https://codeforces.com/problemset/problem/191/C）tree_diff_array|tree_lca|implemention

====================================AtCoder=====================================
ABC309E（https://atcoder.jp/contests/abc309/tasks/abc309_e）tree_diff_array|dfs_order

=====================================AcWing=====================================


"""
from typing import List

from src.graph.tree_diff_array.template import TreeDiffArray
from src.graph.tree_lca.template import OfflineLCA, TreeAncestor
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_2646(n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/
        tag: offline_lca|tree_diff_array|counter|tree_dp|classical
        """
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)

        res = OfflineLCA().bfs_iteration(dct, trips)

        m = len(trips)
        queries = [trips[i] + [res[i]] for i in range(m)]
        cnt = TreeDiffArray().bfs_iteration(dct, queries)

        stack = [0]
        sub = [[] for _ in range(n)]
        parent = [-1] * n
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                for j in dct[i]:
                    if j != parent[i]:
                        parent[j] = i
                        stack.append(j)
            else:
                i = ~i
                res = [cnt[i] * price[i], cnt[i] * price[i] // 2]
                for j in dct[i]:
                    if j != parent[i]:
                        a, b = sub[j]
                        res[0] += a if a < b else b
                        res[1] += a
                sub[i] = res

        return min(sub[0])

    @staticmethod
    def lg_p3128(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3128
        tag: offline_lca|tree_diff_array
        """
        n, k = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        queries = [ac.read_list_ints_minus_one() for _ in range(k)]
        res = OfflineLCA().bfs_iteration(dct, queries)
        queries = [queries[i] + [res[i]] for i in range(k)]
        cnt = TreeDiffArray().bfs_iteration(dct, queries)
        ac.st(max(cnt))
        return

    @staticmethod
    def lg_p6869(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6869
        tag: offline_lca|tree_diff_array_edge|tree_diff_array_point
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        cost = [dict() for _ in range(n)]
        for _ in range(n - 1):
            a, b, c1, c2 = ac.read_list_ints()
            a -= 1
            b -= 1
            cost[a][b] = cost[b][a] = [c1, c2]
            dct[a].append(b)
            dct[b].append(a)

        query = [[i, i + 1] for i in range(n - 1)]
        res = OfflineLCA().bfs_iteration(dct, query)
        for i in range(n - 1):
            query[i].append(res[i])
        diff = TreeDiffArray().bfs_iteration_edge(dct, query, 0)

        ans = 0
        stack = [0]
        parent = [-1] * n
        while stack:
            i = stack.pop()
            for j in dct[i]:
                if j != parent[i]:
                    stack.append(j)
                    parent[j] = i
                    cnt = diff[j]
                    c1, c2 = cost[i][j]
                    ans += min(cnt * c1, c2)
        ac.st(ans)
        return

    @staticmethod
    def lg_p3258(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3258
        tag: offline_lca|tree_diff_array|tree_dp
        """
        n = ac.read_int()
        nums = ac.read_list_ints_minus_one()
        root = nums[0]
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)

        stack = [root]
        parent = [-1] * n
        parent[root] = root
        while stack:
            i = stack.pop()
            for j in dct[i]:
                if j != parent[i]:
                    stack.append(j)
                    parent[j] = i
        tree = UnionFindGetLCA(parent, root)

        diff = [0] * n
        for i in range(1, n):
            u, v = nums[i - 1], nums[i]
            ancestor = tree.get_lca(u, v)
            if u != ancestor:
                u = parent[u]
                diff[u] += 1
                diff[v] += 1
                diff[ancestor] -= 1
                if parent[ancestor] != ancestor:
                    diff[parent[ancestor]] -= 1
            else:
                diff[v] += 1
                diff[u] -= 1

        stack = [root]
        while stack:
            i = stack.pop()
            if i >= 0:
                stack.append(~i)
                for j in dct[i]:
                    if j != parent[i]:
                        stack.append(j)
            else:
                i = ~i
                for j in dct[i]:
                    if j != parent[i]:
                        diff[i] += diff[j]
        diff[nums[0]] += 1
        diff[nums[-1]] -= 1
        for a in diff:
            ac.st(a)
        return

    @staticmethod
    def abc_309e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc309/tasks/abc309_e
        tag: tree_diff_array|dfs_order
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        p = [0] + ac.read_list_ints_minus_one()
        for i in range(1, n):
            dct[p[i]].append(i)
        buy = [0] * n
        for _ in range(m):
            x, y = ac.read_list_ints()
            x -= 1
            buy[x] = max(buy[x], y + 1)
        diff = [0] * (n + 2)
        pre = [0] * (n + 2)
        stack = [(0, 1)]
        cur = [0] * n
        while stack:
            x, d = stack.pop()
            if x >= 0:
                stack.append((~x, d))
                diff[d] += 1
                if d + buy[x] < n + 2:
                    diff[d + buy[x]] -= 1
                pre[d] = diff[d] + pre[d - 1]
                cur[x] = pre[d]
                for y in dct[x]:
                    stack.append((y, d + 1))
            else:
                x = ~x
                pre[d] = 0
                diff[d] -= 1
                if d + buy[x] < n + 2:
                    diff[d + buy[x]] += 1
        ans = sum(x > 0 for x in cur)
        ac.st(ans)
        return

    @staticmethod
    def cf_191c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/191/C
        tag: tree_diff_array|tree_lca|implemention
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        edges = []
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            edges.append((i, j))
            dct[i].append(j)
            dct[j].append(i)
        k = ac.read_int()
        queries = []
        tree = TreeAncestor(dct, 0)
        for _ in range(k):
            u, v = ac.read_list_ints_minus_one()
            queries.append((u, v, tree.get_lca(u, v)))
        diff, parent = TreeDiffArray.bfs_iteration_edge(dct, queries, 0)
        ans = [diff[u] if parent[u] == v else diff[v] for u, v in edges]
        ac.lst(ans)
        return"""

Algorithm：lca|multiplication_method|tree_chain_split|offline_lca|online_lca
Description：

====================================LeetCode====================================
1483（https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/）sparse_table|tree_array|lca|tree_lca|classical
2846（https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree）tree_lca|greedy


=====================================LuoGu======================================
P3379（https://www.luogu.com.cn/problem/P3379）tree_lca|classical
P7128（https://www.luogu.com.cn/problem/P7128）lca|implemention|sort
P7167（https://www.luogu.com.cn/problem/P7167）monotonic_stack|tree_lca|build_tree
P2912（https://www.luogu.com.cn/problem/P2912）offline_lca|offline_query
P3019（https://www.luogu.com.cn/problem/P3019）offline_query|lca
P3384（https://www.luogu.com.cn/problem/P3384）tree_chain_split|tree_array|implemention
P3976（https://www.luogu.com.cn/problem/P3976）range_add|range_max_gain|range_min_gain

======================================LibraryChecker==================================
1（https://judge.yosupo.jp/problem/lca）tree_lca

===================================CodeForces===================================
1328E（https://codeforces.com/problemset/problem/1328/E）tree_lca|dfs_order
321C（https://codeforces.com/problemset/problem/321/C）tree_centroid_recursion|classical
519E（https://codeforces.com/problemset/problem/519/E）lca|kth_ancestor|counter
1296F（https://codeforces.com/contest/1296/problem/F）offline_lca|greedy|construction|multiplication_method
1702G2（https://codeforces.com/contest/1702/problem/G2）tree_lca
1843F2（https://codeforces.com/contest/1843/problem/F2）tree_lca|multiplication_method|classical|max_con_sub_sum
1304E（https://codeforces.com/problemset/problem/1304/E）observation|tree_lca|graph|implemention

====================================AtCoder=====================================
ABC294G（https://atcoder.jp/contests/abc294/tasks/abc294_g）segment_tree|point_set|range_sum|heavy_chain|tree_lca
ABC209D（https://atcoder.jp/contests/abc209/tasks/abc209_d）tree_ancestor
ABC202E（https://atcoder.jp/contests/abc202/tasks/abc202_e）heuristic_merge|offline_query|classical

=====================================AcWing=====================================
4202（https://www.acwing.com/problem/content/4205/）bit_operation|build_graph|tree_lca|tree_dis

=====================================CodeChef=====================================
1（https://www.codechef.com/problems/BITTREEMIN）data_range|minimum_xor|tree_lca


"""
from typing import List
import math
from src.data_structure.segment_tree.template import PointSetRangeSum, RangeSetPointGet, RangeAddRangeMaxGainMinGain
from src.data_structure.tree_array.template import RangeAddRangeSum
from src.graph.tree_lca.template import OfflineLCA, TreeAncestor, TreeCentroid, HeavyChain, TreeAncestorPool, \
    UnionFindGetLCA, TreeAncestorMaxSub
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p7167(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7167
        tag: monotonic_stack|tree_lca|build_tree|multiplication_method|classical|hard
        """
        n, q = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        parent = [n] * n
        edge = [[] for _ in range(n + 1)]
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]][0] < nums[i][0]:
                parent[stack.pop()] = i
            stack.append(i)
        for i in range(n):
            edge[n - parent[i]].append(n - i)

        weight = [x for _, x in nums] + [math.inf]
        tree = TreeAncestorPool(edge, weight[::-1])

        for _ in range(q):
            r, v = ac.read_list_ints()
            ans = tree.get_final_ancestor(n - r + 1, v)
            ac.st(0 if ans == 0 else n - ans + 1)
        return

    @staticmethod
    def cf_519e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/519/E
        tag: lca|kth_ancestor|counter|dis|classical
        """
        n = ac.read_int()
        edges = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edges[x].append(y)
            edges[y].append(x)

        lca = TreeAncestor(edges)
        sub = [0] * n
        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                for j in edges[i]:
                    if j != fa:
                        stack.append((j, i))
            else:
                i = ~i
                cur = 1
                for j in edges[i]:
                    if j != fa:
                        cur += sub[j]
                sub[i] = cur

        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints_minus_one()
            if x == y:
                ac.st(n)
                continue

            dis = lca.get_dist(x, y)
            if dis % 2 == 1:
                ac.st(0)
            else:
                z = lca.get_lca(x, y)
                dis1 = lca.get_dist(x, z)
                dis2 = lca.get_dist(y, z)
                if dis1 == dis2:
                    up = n - sub[z]
                    down = sub[z] - sub[lca.get_kth_ancestor(x, dis1 - 1)] - sub[lca.get_kth_ancestor(y, dis2 - 1)]
                    ac.st(up + down)
                elif dis1 > dis2:
                    w = lca.get_kth_ancestor(x, (dis1 + dis2) // 2)
                    ac.st(sub[w] - sub[lca.get_kth_ancestor(x, (dis1 + dis2) // 2 - 1)])
                else:
                    w = lca.get_kth_ancestor(y, (dis1 + dis2) // 2)
                    ac.st(sub[w] - sub[lca.get_kth_ancestor(y, (dis1 + dis2) // 2 - 1)])
        return

    @staticmethod
    def cf_1328e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1328/E
        tag: tree_lca|dfs_order|classical
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append(v)
            edge[v].append(u)

        tree = TreeAncestor(edge)
        for _ in range(m):
            nums = ac.read_list_ints_minus_one()[1:]
            deep = nums[0]
            for num in nums:
                if tree.depth[num] > tree.depth[deep]:
                    deep = num
            ans = True
            for num in nums:
                fa = tree.get_lca(num, deep)
                if fa == num or tree.parent[num] == fa:
                    continue
                else:
                    ans = False
                    break
            ac.st("YES" if ans else "NO")
        return

    @staticmethod
    def lc_1483(parent, node, k):
        """
        url: https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/
        tag: sparse_table|tree_array|lca|tree_lca|classical
        """
        n = len(parent)
        edges = [[] for _ in range(n)]
        for i in range(n):
            if parent[i] != -1:
                edges[i].append(parent[i])
                edges[parent[i]].append(i)
        tree = TreeAncestor(edges)
        return tree.get_kth_ancestor(node, k)

    @staticmethod
    def lg_p3379_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3379
        tag: tree_lca|classical
        """
        n, m, s = ac.read_list_ints()
        s -= 1
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edge[x].append(y)
            edge[y].append(x)

        tree = TreeAncestor(edge, s)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            ac.st(tree.get_lca(x, y) + 1)
        return

    @staticmethod
    def lg_p3379_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3379
        tag: tree_lca|classical
        """
        n, m, r = ac.read_list_ints()
        r -= 1
        graph = HeavyChain(n)
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j)
        graph.initial(r)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            ans = graph.query_lca(x, y) + 1
            ac.st(ans)
        return

    @staticmethod
    def lg_p3379_3(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3379
        tag: tree_lca|classical
        """
        n, m, s = ac.read_list_ints()
        s -= 1
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edge[x].append(y)
            edge[y].append(x)
        parent = [-1] * n
        stack = [s]
        parent[s] = s
        while stack:
            i = stack.pop()
            for j in edge[i]:
                if j != parent[i]:
                    stack.append(j)
                    parent[j] = i

        uf = UnionFindGetLCA(parent, s)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            ac.st(uf.get_lca(x, y) + 1)
        return

    @staticmethod
    def lg_p3379_4(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3379
        tag: tree_lca|classical
        """
        n, m, s = ac.read_list_ints()
        s -= 1
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            edge[x].append(y)
            edge[y].append(x)

        queries = [ac.read_list_ints_minus_one() for _ in range(m)]
        ans = OfflineLCA().bfs_iteration(edge, queries, s)
        ac.st("\n".join(str(x + 1) for x in ans))
        return

    @staticmethod
    def cf_321c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/321/C
        tag: tree_centroid_recursion|classical
        """
        n = ac.read_int()
        to = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            to[u].append(v)
            to[v].append(u)

        cc, pp, ss = TreeCentroid().centroid_finder(to)
        ans = [64] * n
        for c, p in zip(cc, pp):
            ans[c] = ans[p] + 1
        ac.lst([chr(x) for x in ans])
        return

    @staticmethod
    def lg_p3384(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3384
        tag: tree_chain_split|tree_array|implemention
        """
        n, m, r, p = ac.read_list_ints()
        r -= 1
        tree = RangeAddRangeSum(n)
        nums = ac.read_list_ints()
        graph = HeavyChain(n)
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j)
        graph.initial(r)
        tree.build([nums[i] for i in graph.rev_dfn])

        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y, z = lst[1:]
                path, _ = graph.query_chain(x - 1, y - 1)
                for a, b in path:
                    if a > b:
                        a, b = b, a
                    tree.range_add(a + 1, b + 1, z)
            elif lst[0] == 2:
                x, y = lst[1:]
                ans = 0
                path, _ = graph.query_chain(x - 1, y - 1)
                for a, b in path:
                    if a > b:
                        a, b = b, a
                    ans += tree.range_sum(a + 1, b + 1)
                    ans %= p
                ac.st(ans)
            elif lst[0] == 3:
                x, z = lst[1:]
                x -= 1
                a, b = graph.dfn[x], graph.cnt_son[x]
                tree.range_add(a + 1, a + b, z)
            else:
                x = lst[1] - 1
                a, b = graph.dfn[x], graph.cnt_son[x]
                ans = tree.range_sum(a + 1, a + b) % p
                ac.st(ans)
        return

    @staticmethod
    def lg_p2912(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2912
        tag: offline_lca|offline_query|classical
        """
        n, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j, w = ac.read_list_ints()
            i -= 1
            j -= 1
            dct[i].append((j, w))
            dct[j].append((i, w))

        dis = [math.inf] * n
        dis[0] = 0
        parent = [-1] * n
        parent[0] = 0
        stack = [0]
        while stack:
            i = stack.pop()
            for j, w in dct[i]:
                if dis[j] == math.inf:
                    dis[j] = dis[i] + w
                    stack.append(j)
                    parent[j] = i
        tree = UnionFindGetLCA(parent)
        for x in range(q):
            i, j = ac.read_list_ints_minus_one()
            ans = dis[i] + dis[j] - 2 * dis[tree.get_lca(i, j)]
            ac.st(ans)
        return

    @staticmethod
    def lg_p3019(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3019
        tag: offline_query|lca
        """
        n, m = ac.read_list_ints()
        parent = [0] + [ac.read_int() - 1 for _ in range(n - 1)]
        tree = UnionFindGetLCA(parent)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            ac.st(tree.get_lca(x, y) + 1)
        return

    @staticmethod
    def library_checker_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/lca
        tag: tree_lca
        """
        n, m = ac.read_list_ints()
        parent = [0] + ac.read_list_ints()
        uf = UnionFindGetLCA(parent, 0)
        ans = []
        for _ in range(m):
            x, y = ac.read_list_ints()
            ans.append(str(uf.get_lca(x, y)))
        ac.st("\n".join(ans))
        return

    @staticmethod
    def lc_2846(n: int, edges: List[List[int]], queries: List[List[int]]) -> List[int]:

        """
        url: https://leetcode.cn/problems/minimum-edge-weight-equilibrium-queries-in-a-tree
        tag: tree_lca|greedy
        """
        dct = [[] for _ in range(n)]
        for i, j, _ in edges:
            dct[i].append(j)
            dct[j].append(i)
        tree = TreeAncestor(dct)

        dct = [[] for _ in range(n)]
        for i, j, w in edges:
            dct[i].append([j, w - 1])
            dct[j].append([i, w - 1])
        cnt = [[0] * 26 for _ in range(n)]
        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            for j, w in dct[i]:
                if j != fa:
                    cnt[j] = cnt[i][:]
                    cnt[j][w] += 1
                    stack.append((j, i))
        ans = []
        for i, j in queries:
            k = tree.get_lca(i, j)
            cur = [cnt[i][w] + cnt[j][w] - 2 * cnt[k][w] for w in range(26)]
            ceil = max(cur)
            tot = sum(cur)
            ans.append(tot - ceil)
        return ans

    @staticmethod
    def abc_294g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc294/tasks/abc294_g
        tag: segment_tree|point_set|range_sum|heavy_chain|tree_lca
        """
        n = ac.read_int()
        tree = PointSetRangeSum(n)
        edges = [ac.read_list_ints() for _ in range(n - 1)]
        graph = HeavyChain(n)
        for x in range(n - 1):
            i, j, _ = edges[x]
            graph.add_undirected_edge(i - 1, j - 1)
        graph.initial(0)
        val = [0] * n
        for i, j, w in edges:
            i -= 1
            j -= 1
            if graph.dfn[i] < graph.dfn[j]:
                val[j] = w
            else:
                val[i] = w

        nums = [val[i] for i in graph.rev_dfn]
        tree.build(nums)

        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, w = lst[1:]
                x -= 1
                i, j, _ = edges[x]
                i -= 1
                j -= 1
                if graph.dfn[i] < graph.dfn[j]:
                    tree.point_set(graph.dfn[j], w)
                    nums[graph.dfn[j]] = w
                else:
                    tree.point_set(graph.dfn[i], w)
                    nums[graph.dfn[i]] = w

            else:
                x, y = lst[1:]
                y -= 1
                x -= 1
                ans = 0
                lst, lca = graph.query_chain(x, y)
                for a, b in lst:
                    if a <= b:
                        ans += tree.range_sum(a, b)
                    else:
                        ans += tree.range_sum(b, a)
                ans -= nums[lca]
                ac.st(ans)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/BITTREEMIN
        tag: data_range|minimum_xor|tree_lca
        """
        cnt = [0] * 1001
        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)

            nums = [x // 2 for x in ac.read_list_ints()]

            tree = TreeAncestor(dct, 0)
            for _ in range(q):
                op, u, v = ac.read_list_ints_minus_one()
                if op == 0:
                    nums[u] = (v + 1) // 2
                else:
                    dis = tree.get_dist(u, v)
                    if dis > 1001:
                        ac.st(0)
                    else:
                        lca = tree.get_lca(u, v)
                        lst = [u]
                        while lst[-1] != lca:
                            lst.append(tree.parent[lst[-1]])
                        while v != lca:
                            lst.append(v)
                            v = tree.parent[v]
                        for i in range(1001):
                            cnt[i] = 0
                        for x in lst:
                            cnt[nums[x]] += 1
                        ans = pre = math.inf
                        for i in range(1001):
                            if cnt[i] >= 2:
                                ans = 0
                                break
                            if cnt[i]:
                                if pre < math.inf:
                                    ans = min(ans, pre ^ i)
                                pre = i
                        ac.st(ans)
        return

    @staticmethod
    def abc_209d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc209/tasks/abc209_d
        tag: tree_ancestor
        """
        n, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        tree = TreeAncestor(dct, 0)
        for _ in range(q):
            i, j = ac.read_list_ints_minus_one()
            dis = tree.get_dist(i, j)
            if dis % 2:
                ac.st("Road")
            else:
                ac.st("Town")
        return

    @staticmethod
    def cf_343d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/343/problem/D
        tag: heavy_chain|range_set|point_get|classical|implemention
        """
        n = ac.read_int()
        graph = HeavyChain(n)
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j)
        graph.initial(0)
        tree = RangeSetPointGet(n, -1)
        tree.build([0] * n)
        for _ in range(ac.read_int()):
            op, v = ac.read_list_ints_minus_one()
            if op == 0:
                start = graph.dfn[v]
                end = start + graph.cnt_son[v] - 1
                tree.range_set(start, end, 1)
            elif op == 1:
                x, y = v, 0
                path, _ = graph.query_chain(x, y)
                for a, b in path:
                    if a > b:
                        a, b = b, a
                    tree.range_set(a, b, 0)
            else:
                ans = tree.point_get(graph.dfn[v])  # important!!!
                ac.st(ans)
        return

    @staticmethod
    def cf_1843f2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1843/problem/F2
        tag: tree_lca|multiplication_method|classical|max_con_sub_sum
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            query = []
            dct = [[]]
            sub = [1]
            for _ in range(n):
                lst = ac.read_list_strs()
                if lst[0] == "+":
                    v, x = [int(w) for w in lst[1:]]
                    v -= 1
                    sub.append(x)
                    dct[v].append(len(sub) - 1)
                    dct.append([])
                else:
                    u, v, k = [int(w) - 1 for w in lst[1:]]
                    query.append((u, v, k + 1))

            ceil = TreeAncestorMaxSub(dct, sub[:])
            floor = TreeAncestorMaxSub(dct, [-x for x in sub])
            for u, v, k in query:
                high = ceil.get_max_con_sum(u, v)
                low = -floor.get_max_con_sum(u, v)
                ac.st("YES" if low <= k <= high or k == 0 else "NO")
        return

    @staticmethod
    def cf_1304e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1304/E
        tag: observation|tree_lca|graph|implemention
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            u, v = ac.read_list_ints_minus_one()
            dct[u].append(v)
            dct[v].append(u)
        tree = TreeAncestor(dct)
        for _ in range(ac.read_int()):
            x, y, a, b, k = ac.read_list_ints_minus_one()
            k += 1
            dis = tree.get_dist(a, x) + 1 + tree.get_dist(y, b)
            if dis <= k and (k - dis) % 2 == 0:
                ac.yes()
                continue
            dis = tree.get_dist(a, y) + 1 + tree.get_dist(x, b)
            if dis <= k and (k - dis) % 2 == 0:
                ac.yes()
                continue
            dis = tree.get_dist(a, b)
            if dis <= k and (k - dis) % 2 == 0:
                ac.yes()
                continue
            ac.no()
        return

    @staticmethod
    def lg_p3976(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3976
        tag: range_add|range_max_gain|range_min_gain
        """
        inf = 10 ** 18
        n = ac.read_int()
        nums = ac.read_list_ints()
        graph = HeavyChain(n)
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(i, j)
        graph.initial(0)
        nums = [nums[i] for i in graph.rev_dfn]
        tree = RangeAddRangeMaxGainMinGain(n, inf)
        tree.build(nums)

        for _ in range(ac.read_int()):
            a, b, v = ac.read_list_ints()
            a -= 1
            b -= 1
            ans = [inf, -inf, -inf, inf]  # floor, ceil, max_gain, min_gain
            path, _ = graph.query_chain(a, b)
            for x, y in path:
                if x <= y:
                    floor, ceil, max_gain, min_gain = tree.range_max_gain_min_gain(x, y)
                else:
                    floor, ceil, aa, bb = tree.range_max_gain_min_gain(y, x)
                    max_gain = -bb
                    min_gain = -aa
                ans[2] = max(ans[2], max_gain, ceil - ans[0])
                ans[3] = min(ans[3], min_gain, floor - ans[1])
                ans[0] = min(ans[0], floor)
                ans[1] = max(ans[1], ceil)
            for x, y in path:
                if x <= y:
                    tree.range_add(x, y, v)
                else:
                    tree.range_add(y, x, v)
            ac.st(max(ans[2], 0))
        return

    @staticmethod
    def abc_202e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc202/tasks/abc202_e
        tag: heuristic_merge|offline_query|classical
        """
        n = ac.read_int()
        p = [-1] + ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        for i in range(1, n):
            dct[p[i]].append(i)

        q = ac.read_int()
        ans = [-1] * q
        sub = [dict() for _ in range(n)]
        node = list(range(n))
        queries = [[] for _ in range(n)]
        for i in range(q):
            u, d = ac.read_list_ints()
            u -= 1
            queries[u].append((d, i))
        depth = [0] * n
        stack = [0]
        while stack:
            x = stack.pop()
            if x >= 0:
                stack.append(~x)
                for y in dct[x]:
                    depth[y] = depth[x] + 1
                    stack.append(y)
            else:
                x = ~x
                cur = node[x]
                sub[cur][depth[x]] = 1
                for y in dct[x]:
                    nex = node[y]
                    if len(sub[cur]) < len(sub[nex]):
                        cur, nex = nex, cur
                    for kk, vv in sub[nex].items():
                        sub[cur][kk] = sub[cur].get(kk, 0) + vv
                node[x] = cur
                for dd, ii in queries[x]:
                    ans[ii] = sub[cur].get(dd, 0)
        for a in ans:
            ac.st(a)
        return
"""

Algorithm：scc|2-sat|largest_circle|smallest_circle
Description：scc|dag|shrink_point|topological_sort|strongly_connected_component
Example：path pass the most points which can be duplicated
2-SAT：giving n sets, each with two elements, in which (a, b) indicating that a and b are contradictory (where a and b belong to different sets), then select an element from each set and determine if a total of n pairwise non-contradictory elements can be selected

====================================LeetCode====================================

=====================================LuoGu======================================
P4782（https://www.luogu.com.cn/problem/P4782）2-sat|scc|classical
P5782（https://www.luogu.com.cn/problem/P5782）2-sat|scc|classical
P4171（https://www.luogu.com.cn/problem/P4171）2-sat|scc|classical

===================================CodeForces===================================
1438C（https://codeforces.com/problemset/problem/1438/C）2-sat|scc|classical
776D（https://codeforces.com/problemset/problem/776/D）union_find|classical|2-sat


"""

from src.graph.tarjan.template import Tarjan
from src.utils.fast_io import FastIO


class TwoSAT:
    def __init__(self):
        return

    @staticmethod
    def lg_p4782(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4782
        tag: 2-sat|scc|classical
        """
        n, m = ac.read_list_ints()
        edge = [set() for _ in range(2 * n)]
        for _ in range(m):
            i, a, j, b = ac.read_list_ints()
            i -= 1
            j -= 1
            if i * 2 + 1 - a != j * 2 + b:
                edge[i * 2 + 1 - a].add(j * 2 + b)
            if j * 2 + 1 - b != i * 2 + a:
                edge[j * 2 + 1 - b].add(i * 2 + a)

        _, scc_node_id, _ = Tarjan().get_scc(2 * n, [list(s) for s in edge])
        for s in scc_node_id:
            pre = set()
            for node in s:
                if node // 2 in pre:
                    ac.st("IMPOSSIBLE")
                    return
                pre.add(node // 2)

        ac.st("POSSIBLE")
        ans = [0] * n
        pre = set()
        for s in scc_node_id:
            for node in s:
                i = node // 2
                if i not in pre:
                    ans[i] = node % 2
                pre.add(i)
        ac.lst(ans)
        return

    @staticmethod
    def lg_p5782(ac=FastIO()):
        """
        url:https://www.luogu.com.cn/problem/P5782
        tag: 2-sat|scc|classical
        """
        n, m = ac.read_list_ints()
        edge = [set() for _ in range(4 * n)]
        for _ in range(m):
            a, b = ac.read_list_ints_minus_one()
            edge[a * 2 + 1].add(b * 2)
            edge[b * 2 + 1].add(a * 2)

        for i in range(n):
            a, b = 2 * i, 2 * i + 1
            edge[a * 2 + 1].add(b * 2)
            edge[a * 2].add(b * 2 + 1)
            edge[b * 2 + 1].add(a * 2)
            edge[b * 2].add(a * 2 + 1)

        _, scc_node_id, _ = Tarjan().get_scc(4 * n, [list(s) for s in edge])
        for s in scc_node_id:
            pre = set()
            for node in s:
                if node // 2 in pre:
                    ac.st("NIE")
                    return
                pre.add(node // 2)

        ans = [0] * 2 * n
        pre = set()
        for s in scc_node_id:
            for node in s:
                i = node // 2
                if i not in pre:
                    ans[i] = node % 2
                pre.add(i)
        for i in range(2 * n):
            if ans[i]:
                ac.st(i + 1)
        return

    @staticmethod
    def lg_p4171(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4171
        tag: 2-sat|scc|classical
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            edge = [set() for _ in range(2 * n)]
            for _ in range(m):
                lst = ac.read_list_strs()
                i = int(lst[0][1:]) - 1
                j = int(lst[1][1:]) - 1
                a = 1 if lst[0][0] == "h" else 0
                b = 1 if lst[1][0] == "h" else 0
                if i * 2 + (1 - a) != j * 2 + b:
                    edge[i * 2 + (1 - a)].add(j * 2 + b)
                if j * 2 + (1 - b) != i * 2 + a:
                    edge[j * 2 + (1 - b)].add(i * 2 + a)

            _, scc_node_id, _ = Tarjan().get_scc(2 * n, [list(s) for s in edge])

            ans = True
            for s in scc_node_id:
                pre = set()
                for node in s:
                    if node // 2 in pre:
                        ans = False
                    pre.add(node // 2)
            ac.st("GOOD" if ans else "BAD")
        return

    @staticmethod
    def cf_1438c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1438/C
        tag: 2-sat|scc|classical
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_list_ints() for _ in range(m)]
            edge = [set() for _ in range(2 * m * n)]
            for i in range(m):
                for j in range(n):
                    if i + 1 < m:
                        x, y = i * n + j, i * n + n + j
                        for a, b in [[0, 0], [0, 1], [1, 0], [1, 1]]:
                            if grid[i][j] + a == grid[i + 1][j] + b:
                                edge[x * 2 + a].add(y * 2 + 1 - b)
                                edge[y * 2 + b].add(x * 2 + 1 - a)
                    if j + 1 < n:
                        x, y = i * n + j, i * n + 1 + j
                        for a, b in [[0, 0], [0, 1], [1, 0], [1, 1]]:
                            if grid[i][j] + a == grid[i][j + 1] + b:
                                edge[x * 2 + a].add(y * 2 + 1 - b)
                                edge[y * 2 + b].add(x * 2 + 1 - a)
            for i in range(2 * m * n):
                if i in edge[i]:
                    edge[i].discard(i)
            _, scc_node_id, _ = Tarjan().get_scc(2 * m * n, [list(s) for s in edge])

            ans = [0] * m * n
            pre = set()
            for sc in scc_node_id:
                for node in sc:
                    i = node // 2
                    if i not in pre:
                        ans[i] = node % 2
                    pre.add(i)

            for x in range(m * n):
                grid[x // n][x % n] += ans[x]
            for g in grid:
                ac.lst(g)
        return

    @staticmethod
    def cf_776d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/776/D
        tag: union_find|classical|2-sat
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        key = [[] for _ in range(n)]
        dct = [set() for _ in range(2 * m)]
        for i in range(m):
            lst = ac.read_list_ints_minus_one()
            for x in lst[1:]:
                key[x].append(i)
        for x in range(n):
            a, b = key[x][0], key[x][1]
            if nums[x]:
                dct[a + m].add(b + m)
                dct[a].add(b)
                dct[b].add(a)
                dct[b + m].add(a + m)
            else:
                dct[a].add(b + m)
                dct[a + m].add(b)
                dct[b].add(a + m)
                dct[b + m].add(a)

        _, scc_node_id, _ = Tarjan().get_scc(2 * m, [list(e) for e in dct])
        for s in scc_node_id:
            pre = set()
            for node in s:
                if node - m in pre or node + m in pre:
                    ac.no()
                    return
                pre.add(node)
        ac.yes()
        return"""

Algorithm：union_find|persistent_union_find|permutation_circle
Description：graph|reverse_thinking|permutation_circle|offline_query|merge_wise|root_wise

====================================LeetCode====================================
765（https://leetcode.cn/problems/couples-holding-hands/）union_find
1697（https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/）sort|offline_query|implemention
2503（https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/）sort|offline_query|implemention
2421（https://leetcode.cn/problems/number-of-good-paths/）sort|union_find|counter
2382（https://leetcode.cn/problems/maximum-segment-sum-after-removals/）reverse_order|union_find|implemention|reverse_thinking
2334（https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/）sort|brute_force|union_find
2158（https://leetcode.cn/problems/amount-of-new-area-painted-each-day/）union_left
2157（https://leetcode.cn/problems/groups-of-strings/）alphabet|brute_force
2076（https://leetcode.cn/problems/process-restricted-friend-requests/）union_find|reverse_thinking
2459（https://leetcode.cn/problems/sort-array-by-moving-items-to-empty-space/）permutation_circle
2709（https://leetcode.cn/problems/greatest-common-divisor-traversal/）union_find|prime_factorization
2612（https://leetcode.cn/problems/minimum-reverse-operations/）union_find|find_range_merge_to_disjoint
1559（https://leetcode.cn/problems/detect-cycles-in-2d-grid/）union_find|circle_judge|classical
1970（https://leetcode.cn/problems/last-day-where-you-can-still-cross/）reverse_thinking|union_find
1998（https://leetcode.cn/problems/gcd-sort-of-an-array/）union_find|prime_factorization
2158（https://leetcode.cn/problems/amount-of-new-area-painted-each-day/）union_find_range|union_left|union_find_right_root
2471（https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/）discretization|permutation_circle
945（https://leetcode.cn/problems/minimum-increment-to-make-array-unique/description/）union_find_right_root|greedy
947（https://leetcode.cn/contest/weekly-contest-112/problems/most-stones-removed-with-same-row-or-column/）brain_teaser|union_find
547（https://leetcode.cn/problems/number-of-provinces/description/）union_find
684（https://leetcode.cn/problems/redundant-connection/description/）union_find
1562（https://leetcode.cn/problems/find-latest-group-of-size-m/description/）union_find|sorted_list
407（https://leetcode-cn.com/problems/trapping-rain-water-ii/）union_find|classical
1632（https://leetcode.cn/problems/rank-transform-of-a-matrix/）union_find|matrix_rank|row_column_union_find
100376（https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-ii/）build_graph|union_find|union_right

=====================================LuoGu======================================
P3367（https://www.luogu.com.cn/problem/P3367）connected_part|counter|union_find
P5836（https://www.luogu.com.cn/problem/P5836）union_find|several_union_find
P3144（https://www.luogu.com.cn/problem/P3144）reverse_order|union_find|connected_part|counter
P5836（https://www.luogu.com.cn/problem/P5836）union_find|several_union_find
P5877（https://www.luogu.com.cn/problem/P5877）union_find|implemention|counter
P6111（https://www.luogu.com.cn/problem/P6111）union_find|offline_query
P6121（https://www.luogu.com.cn/problem/P6121）reverse_order|union_find|size
P6153（https://www.luogu.com.cn/problem/P6153）union_find|greedy|classical
P1955（https://www.luogu.com.cn/problem/P1955）union_find
P1196（https://www.luogu.com.cn/problem/P1196）union_find_weighted
P1197（https://www.luogu.com.cn/problem/P1197）reverse_order|union_find|reverse_order|brute_force|part
P1522（https://www.luogu.com.cn/problem/P1522）connected_part|brute_force|high_precision|tree_diameter
P1621（https://www.luogu.com.cn/problem/P1621）euler_series|O(nlogn)|prime_factorization
P1892（https://www.luogu.com.cn/problem/P1892）union_find|bipartite_graph
P2189（https://www.luogu.com.cn/problem/P2189）union_find
P2307（https://www.luogu.com.cn/problem/P2307）union_find
P3420（https://www.luogu.com.cn/problem/P3420）union_find
P5429（https://www.luogu.com.cn/problem/P5429）union_find
P6004（https://www.luogu.com.cn/problem/P6004）union_find|permutation_circle|kruskal|mst|greedy|pointer
P6193（https://www.luogu.com.cn/problem/P6193）permutation_circle
P6706（https://www.luogu.com.cn/problem/P6706）directed_graph|union_find|reverse_order|find_range_merge_to_disjoint
P7991（https://www.luogu.com.cn/problem/P7991）union_find|shrink_point
P8230（https://www.luogu.com.cn/problem/P8230）layer|union_find|implemention
P8637（https://www.luogu.com.cn/problem/P8637）union_find|permutation_circle
P8686（https://www.luogu.com.cn/problem/P8686）union_find
P8785（https://www.luogu.com.cn/problem/P8785）union_find|counter
P8787（https://www.luogu.com.cn/problem/P8787）greedy|heapq|implemention|union_find
P8881（https://www.luogu.com.cn/problem/P8881）brain_teaser|union_find|circle_judge|part
P5930（https://www.luogu.com.cn/problem/P5930）union_find|classical
P2024（https://www.luogu.com.cn/problem/P2024）union_find_type|build_graph
P3402（https://www.luogu.com.cn/problem/P3402）
P2391（https://www.luogu.com.cn/problem/P2391）union_find_right|reverse_thinking
P1840（https://www.luogu.com.cn/problem/P1840）union_find_right

===================================CodeForces===================================
25D（https://codeforces.com/problemset/problem/25/D）union_find
1810E（https://codeforces.com/contest/1810/problem/E）union_find|heuristic_search|bfs|heapq
920E（https://codeforces.com/contest/920/problem/E）union_find
540C（https://codeforces.com/problemset/problem/540/C）union_find
1800E2（https://codeforces.com/problemset/problem/1800/E2）union_find
1691E（https://codeforces.com/contest/1691/problem/E）union_find_range
827A（https://codeforces.com/problemset/problem/827/A）union_find_right_root|implemention|greedy
1167C（https://codeforces.com/problemset/problem/1167/C）union_find
1411C（https://codeforces.com/contest/1411/problem/C）brain_teaser|classical|hard
1726D（https://codeforces.com/contest/1726/problem/D）union_find|brain_teaser|classical
915F（https://codeforces.com/contest/915/problem/F）union_find|contribution_method|counter
371D（https://codeforces.com/problemset/problem/371/D）union_find_right
292D（https://codeforces.com/problemset/problem/292/D）union_find_right|prefix_suffix
566D（https://codeforces.com/problemset/problem/566/D）union_find_range
1012B（https://codeforces.com/problemset/problem/1012/B）union_find|brain_teaser|classical
650C（https://codeforces.com/problemset/problem/650/C）union_find|matrix_rank|row_column_union_find
1253D（https://codeforces.com/problemset/problem/1253/D）union_find_right
1851G（https://codeforces.com/contest/1851/problem/G）union_find|offline_query|brain_teaser
1609D（https://codeforces.com/problemset/problem/1609/D）union_find|part|sorted_list
1850H（https://codeforces.com/contest/1850/problem/H）union_find_weighted_dis|classical|hard
766D（https://codeforces.com/problemset/problem/766/D）union_find_type|build_graph|bipartite_graph
1594D（https://codeforces.com/contest/1594/problem/D）union_find_type|build_graph|bipartite_graph|2-sat
1290C（https://codeforces.com/problemset/problem/1290/C）
1713E（https://codeforces.com/contest/1713/problem/E）
1788F（https://codeforces.com/problemset/problem/1788/F）
1807C（https://codeforces.com/contest/1807/problem/C）union_find_type
1213G（https://codeforces.com/contest/1213/problem/G）union_find|offline_query|classical
1619G（https://codeforces.com/contest/1619/problem/G）union_find|implemention
1618G（https://codeforces.com/contest/1618/problem/G）union_find_left|union_find_right|classical|offline_query
1941G（https://codeforces.com/contest/1941/problem/G）union_find|build_graph|bfs|brain_teaser|classical
1971G（https://codeforces.com/contest/1971/problem/G）union_find|bit_operation
1383A（https://codeforces.com/problemset/problem/1383/A）build_graph|greedy|implemention|union_find|brain_teaser|observation
1494D（https://codeforces.com/problemset/problem/1494/D）union_right|union_find|implemention|construction
1209D（https://codeforces.com/problemset/problem/1494/D）union_find|brain_teaser
776D（https://codeforces.com/problemset/problem/776/D）union_find|classical|2-sat
1278D（https://codeforces.com/problemset/problem/1278/D）union_find|range|binary_search|observation|partial_order|observation|bucket_sort
1994D（https://codeforces.com/problemset/problem/1994/D）reverse_order|pigeonhole_principle|union_find
2020D（https://codeforces.com/contest/2020/problem/D）union_find|union_right|classical
277A（https://codeforces.com/problemset/problem/277/A）union_find_general
1156D（https://codeforces.com/problemset/problem/1156/D）union_find|brute_force

====================================AtCoder=====================================
ARC065B（https://atcoder.jp/contests/abc049/tasks/arc065_b）union_find|several_union_find
ABC126E（https://atcoder.jp/contests/abc126/tasks/abc126_e）union_find|several_union_find
ABC131F（https://atcoder.jp/contests/abc131/tasks/abc131_f）brain_teaser|union_find|counter
ARC097B（https://atcoder.jp/contests/arc097/tasks/arc097_b）union_find|permutation_circle
ABC304E（https://atcoder.jp/contests/abc304/tasks/abc304_e）union_find|reverse_thinking
ABC237E（https://atcoder.jp/contests/abc238/tasks/abc238_e）union_find_range|prefix_sum|brain_teaser
ABC279F（https://atcoder.jp/contests/abc279/tasks/abc279_f）union_find_range|brain_teaser|build_graph|classical
ABC214D（https://atcoder.jp/contests/abc214/tasks/abc214_d）union_find|contribution_method|counter
ARC107C（https://www.luogu.com.cn/problem/AT_arc107_c）union_find|comb_perm
ABC328F（https://atcoder.jp/contests/abc328/tasks/abc328_f）union_find_weighted_dis|classical|hard
ABC314F（https://atcoder.jp/contests/abc314/tasks/abc314_f）union_find|bfs|build_graph|expectation|prob
ABC295G（https://atcoder.jp/contests/abc295/tasks/abc295_g）union_find|implemention|tree|union_min|classical
ABC293D（https://atcoder.jp/contests/abc293/tasks/abc293_d）union_find
ABC280F（https://atcoder.jp/contests/abc270/tasks/abc270_f）union_find|build_graph|brute_force|classical
ABC264E（https://atcoder.jp/contests/abc264/tasks/abc264_e）union_right|reverse_order|classical
ABC259D（https://atcoder.jp/contests/abc259/tasks/abc259_d）geometry|union_find|circle_location|classical
ABC350G（https://atcoder.jp/contests/abc350/tasks/abc350_g）implemention|union_find|data_range|heuristic_merge|brain_teaser|classical
ABC350D（https://atcoder.jp/contests/abc350/tasks/abc350_d）union_find|classical
ABC238E（https://atcoder.jp/contests/abc238/tasks/abc238_e）prefix_sum|union_find|classical
ABC229E（https://atcoder.jp/contests/abc229/tasks/abc229_e）reverse_order|union_find|classical
ABC228D（https://atcoder.jp/contests/abc228/tasks/abc228_d）union_find_range|classical|implemention
ABC351D（https://atcoder.jp/contests/abc351/tasks/abc351_d）union_find|bfs|classical
ABC226E（https://atcoder.jp/contests/abc226/tasks/abc226_e）circle_based_tree|union_find|classical
ABC218E（https://atcoder.jp/contests/abc218/tasks/abc218_e）union_find|mst
ABC214E（https://atcoder.jp/contests/abc214/tasks/abc214_e）union_find_right|dict|discretization|implemention|linked_list
ABC355F（https://atcoder.jp/contests/abc355/tasks/abc355_f）union_find|brain_teaser|implemention
ABC372E（https://atcoder.jp/contests/abc372/tasks/abc372_e）heuristic_merge|union_find

=====================================AcWing=====================================
4309（https://www.acwing.com/problem/content/description/4309/）union_right
4869（https://www.acwing.com/problem/content/description/4869/）union_find|implemention|size
5148（https://www.acwing.com/problem/content/5148/）union_find|circle_judge

================================LibraryChecker================================
1（https://judge.yosupo.jp/problem/cycle_detection_undirected）union_find|circle_judge
2（https://ac.nowcoder.com/acm/contest/7780/C）union_find|circle_judge
3（https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/B）union_find_max|union_find_min
4（https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/C）union_find|heuristic_merge|classical|hard
5（https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/D）union_find|reverse_thinking|classical
6（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/A）union_find_range
7（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/B）union_find_range
8（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/C）union_find_range
9（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/D）union_find_weighted_dis|classical|hard
10（https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/J）union_find_type|build_graph


1（https://www.codechef.com/problems/TFALL）union_find_left|union_find_right|brute_force
2786（https://yukicoder.me/problems/no/2786）heuristic_merge|union_find|classical

"""

import decimal
import math
from collections import defaultdict, Counter, deque
from heapq import heappop, heapify, heappush
from typing import List, Optional

from src.basis.tree_node.template import TreeNode
from src.data_structure.segment_tree.template import RangeDivideRangeSum
from src.data_structure.sorted_list.template import SortedList
from src.graph.dijkstra.template import Dijkstra
from src.graph.union_find.template import UnionFind, UnionFindWeighted, UnionFindSP, UnionFindInd, UnionFindGeneral
from src.mathmatics.comb_perm.template import Combinatorics
from src.mathmatics.number_theory.template import PrimeSieve
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1810e_1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1810/problem/E
        tag: cannot_be_union_find|heuristic_search|bfs|heapq|classical|hard
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = ac.read_list_ints()
            edge = [[] for _ in range(n)]
            for _ in range(m):
                u, v = ac.read_list_ints_minus_one()
                edge[u].append(v)
                edge[v].append(u)

            visit = [-1] * n
            ans = "NO"
            for i in range(n):
                if visit[i] == -1 and not nums[i]:
                    count = 0
                    visit[i] = i
                    stack = [(0, i)]
                    while stack:
                        d, x = heappop(stack)
                        if count < nums[x]:
                            break
                        count += 1
                        for j in edge[x]:
                            if visit[j] != i:
                                visit[j] = i
                                heappush(stack, (nums[j], j))
                    if count == n:
                        ans = "YES"
                        break
            ac.st(ans)

        return

    @staticmethod
    def cf_1810e_2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1810/problem/E
        tag: cannot_be_union_find|heuristic_search|bfs|heapq|classical|hard|mst
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = ac.read_list_ints()
            nums = [num * n + i for i, num in enumerate(nums)]  # classical skills

            edge = [[] for _ in range(n)]
            for _ in range(m):
                u, v = ac.read_list_ints_minus_one()
                if nums[u] < nums[v]:
                    u, v = v, u
                edge[u].append(v)

            reach = [0] * n
            uf = UnionFind(n)
            nums.sort()
            for val in nums:
                num, i = val // n, val % n
                if not num:
                    reach[i] = 1
                for j in edge[i]:
                    if reach[uf.find(j)] and num <= uf.size(j):
                        reach[i] = 1
                    uf.union_left(i, j)
            ac.st("YES" if uf.part == 1 and reach[uf.find(0)] else "NO")
        return

    @staticmethod
    def ac_5148(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/5148/
        tag: union_find|circle_judge
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        uf = UnionFind(m * n)
        for i in range(m):
            for j in range(n):
                for x, y in [[i, j + 1], [i + 1, j]]:
                    if 0 <= x < m and 0 <= y < n and grid[x][y] == grid[i][j]:
                        if not uf.union(i * n + j, x * n + y):
                            ac.yes()
                            return
        ac.no()
        return

    @staticmethod
    def cf_872a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/827/A
        tag: union_find_right_root|implemention|greedy
        """
        n = ac.read_int()
        nums = [ac.read_list_strs() for _ in range(n)]
        length = max(int(ls[-1]) + len(ls[0]) - 1 for ls in nums)
        uf = UnionFind(length + 1)
        ans = ["a"] * length
        for ls in nums:
            st = ls[0]
            m = len(st)
            for x in ls[2:]:
                x = int(x) - 1
                start = x
                while x <= start + m - 1:
                    x = uf.find(x)
                    if x <= start + m - 1:
                        ans[x] = st[x - start]
                        uf.union_right(x, x + 1)
                    else:
                        break
        ac.st("".join(ans))
        return

    @staticmethod
    def cf_920e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/920/problem/E
        tag: union_find
        """
        n, m = ac.read_list_ints()
        edge = set()
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            edge.add((u, v))

        ans = []
        not_visit = set(range(n))
        while not_visit:
            i = next(iter(not_visit))
            not_visit.discard(i)
            stack = [i]
            cnt = 1
            while stack:
                u = stack.pop()
                visit = []
                for v in not_visit:
                    if (u, v) in edge or (v, u) in edge:
                        continue
                    cnt += 1
                    stack.append(v)
                    visit.append(v)
                for v in visit:
                    not_visit.discard(v)
            ans.append(cnt)
        ans.sort()
        ac.st(len(ans))
        ac.lst(ans)
        return

    @staticmethod
    def lc_1697(n: int, edge_list: List[List[int]], queries: List[List[int]]) -> List[bool]:
        """
        url: https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/
        tag: sort|offline_query|implemention|classical
        """
        m = len(queries)
        ind = list(range(m))
        ind.sort(key=lambda x: queries[x][2])

        edge_list.sort(key=lambda x: x[2])
        uf = UnionFind(n)
        i = 0
        k = len(edge_list)
        ans = []
        for j in ind:
            p, q, limit = queries[j]
            while i < k and edge_list[i][2] < limit:
                uf.union(edge_list[i][0], edge_list[i][1])
                i += 1
            ans.append([j, uf.is_connected(p, q)])

        ans.sort(key=lambda x: x[0])
        return [an[1] for an in ans]

    @staticmethod
    def lc_2503(grid: List[List[int]], queries: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries/
        tag: sort|offline_query|implemention
        """
        dct = []
        m, n = len(grid), len(grid[0])
        for i in range(m):
            for j in range(n):
                if i + 1 < m:
                    x, y = grid[i][j], grid[i + 1][j]
                    dct.append([i * n + j, i * n + n + j, x if x > y else y])
                if j + 1 < n:
                    x, y = grid[i][j], grid[i][j + 1]
                    dct.append([i * n + j, i * n + 1 + j, x if x > y else y])
        dct.sort(key=lambda d: d[2])
        uf = UnionFind(m * n)
        k = len(queries)
        ind = list(range(k))
        ind.sort(key=lambda d: queries[d])

        ans = [0] * k
        j = 0
        length = len(dct)
        for i in ind:
            cur = queries[i]
            while j < length and dct[j][2] < cur:
                uf.union(dct[j][0], dct[j][1])
                j += 1
            if cur > grid[0][0]:
                ans[i] = uf.size(0)
        return ans

    @staticmethod
    def lc_2421(vals: List[int], edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-good-paths/
        tag: sort|union_find|counter|classical|discretization
        """
        n = len(vals)
        index = defaultdict(list)
        for i in range(n):
            index[vals[i]].append(i)
        edges.sort(key=lambda x: max(vals[x[0]], vals[x[1]]))
        uf = UnionFind(n)
        i = 0
        m = len(edges)
        ans = 0
        for val in sorted(index):
            while i < m and vals[edges[i][0]] <= val and vals[edges[i][1]] <= val:
                uf.union(edges[i][0], edges[i][1])
                i += 1
            cnt = Counter(uf.find(x) for x in index[val])
            for w in cnt.values():
                ans += w * (w - 1) // 2 + w
        return ans

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/cycle_detection_undirected
        tag: union_find|circle_judge
        """
        n, m = ac.read_list_ints()
        edges = [ac.read_list_ints() for i in range(m)]
        uf = UnionFind(n)
        dct = [[] for _ in range(n)]
        for i in range(m):
            u, v = edges[i]
            if not uf.union(u, v):
                stack = [(u, -1)]
                parent = [(-1, -1) for _ in range(n)]
                while stack:
                    x, fa = stack.pop()
                    for y, ind in dct[x]:
                        if y != fa:
                            parent[y] = (x, ind)
                            stack.append((y, x))
                nodes = [v]
                edges = []
                while nodes[-1] != u:
                    edges.append(parent[nodes[-1]][1])
                    nodes.append(parent[nodes[-1]][0])
                edges.append(i)
                ac.st(len(nodes))
                ac.lst(nodes)
                ac.lst(edges)
                break
            dct[u].append((v, i))
            dct[v].append((u, i))
        else:
            ac.st(-1)
        return

    @staticmethod
    def lg_p1196(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1196
        tag: union_find_weighted|classical|hard
        """
        uf = UnionFindWeighted(3 * 10 ** 4)
        for _ in range(ac.read_int()):
            op, i, j = ac.read_list_strs()
            i = int(i) - 1
            j = int(j) - 1
            if op == "M":
                uf.union_right(i, j)
            else:
                if uf.is_connected(i, j):
                    ac.st(abs(uf.dis[i] - uf.dis[j]) - 1)
                else:
                    ac.st(-1)
        return

    @staticmethod
    def lg_p1197(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1197
        tag: reverse_order|union_find|reverse_order|brute_force|part
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints()
            dct[i].append(j)
            dct[j].append(i)
        k = ac.read_int()
        rem = [ac.read_int() for _ in range(k)]
        out = set(rem)
        uf = UnionFind(n)
        for i in range(n):
            if i not in out:
                for j in dct[i]:
                    if j not in out:
                        uf.union(i, j)
        ans = []
        for i in range(k - 1, -1, -1):
            ans.append(uf.part - i - 1)
            out.discard(rem[i])
            for j in dct[rem[i]]:
                if j not in out:
                    uf.union(rem[i], j)
        ans.append(uf.part)
        ans.reverse()
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p1522(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1522
        tag: connected_part|brute_force|high_precision|tree_diameter|classical|hard
        """

        def dis(x1, y1, x2, y2):
            return math.sqrt(decimal.Decimal(((x1 - x2) ** 2 + (y1 - y2) ** 2)))

        n = ac.read_int()
        nums = [[w for w in ac.read_list_ints()] for _ in range(n)]
        grid = [ac.read_str() for _ in range(n)]
        dct = [dict() for _ in range(n)]
        uf = UnionFind(n)
        for i in range(n):
            for j in range(i + 1, n):
                if grid[i][j] == "1":
                    uf.union(i, j)
                    d = dis(nums[i][0], nums[i][1], nums[j][0], nums[j][1])
                    dct[i][j] = dct[j][i] = d

        dist = []
        for i in range(n):
            dist.append(Dijkstra().get_shortest_path(dct, i))

        part = uf.get_root_part()
        fast = [math.inf] * n
        group = dict()
        for p in part:
            for i in part[p]:
                fast[i] = max(dist[i][j] for j in part[p])
            group[p] = max(fast[i] for i in part[p])

        ans = math.inf
        for i in range(n):
            for j in range(n):
                if not uf.is_connected(i, j):
                    cur = dis(nums[i][0], nums[i][1], nums[j][0], nums[j][1]) + fast[i] + fast[j]
                    cur = max(cur, group[uf.find(i)])
                    cur = max(cur, group[uf.find(j)])
                    ans = min(ans, cur)
        ac.st("%.6f" % ans)
        return

    @staticmethod
    def lg_p1621(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1621
        tag: euler_series|O(nlogn)|prime_factorization|classical
        """
        a, b, p = ac.read_list_ints()
        nums = list(range(a, b + 1))
        ind = {num: num - a for num in nums}
        primes = [x for x in PrimeSieve().eratosthenes_sieve(b) if x >= p]

        uf = UnionFind(b - a + 1)
        for x in primes:
            lst = []
            y = x
            while y <= b:
                if y in ind:
                    lst.append(ind[y])
                y += x
            m = len(lst)
            for j in range(m - 1):
                uf.union(lst[j], lst[j + 1])
        ac.st(uf.part)
        return

    @staticmethod
    def lg_p1892(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1892
        tag: union_find|bipartite_graph
        """
        n = ac.read_int()
        m = ac.read_int()
        uf = UnionFind(n)
        dct = dict()
        for _ in range(m):
            lst = ac.read_list_strs()
            a, b = int(lst[1]), int(lst[2])
            a -= 1
            b -= 1
            if lst[0] == "E":
                if a in dct:
                    uf.union(dct[a], b)
                if b in dct:
                    uf.union(dct[b], a)
                dct[a] = b
                dct[b] = a
            else:
                uf.union(a, b)
        ac.st(uf.part)
        return

    @staticmethod
    def lg_p1955(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1955
        tag: union_find|discretization
        """
        t = ac.read_int()
        for _ in range(t):
            n = ac.read_int()
            ind = dict()
            uf = UnionFind(n * 2)
            res = []
            for _ in range(n):
                lst = ac.read_list_ints()
                while not lst:
                    lst = ac.read_list_ints()
                i, j, e = lst
                if i not in ind:
                    ind[i] = len(ind)
                if j not in ind:
                    ind[j] = len(ind)
                if e == 1:
                    uf.union(ind[i], ind[j])
                else:
                    res.append((ind[i], ind[j]))
            if any(uf.is_connected(i, j) for i, j in res):
                ac.no()
            else:
                ac.yes()
        return

    @staticmethod
    def lg_p2189(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2189
        tag: union_find|classical|preprocess|hard
        """
        n, m, k, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)

        for _ in range(q):
            order = ac.read_list_ints_minus_one()
            uf = UnionFind(n)
            visit = [0] * n
            for i in order:
                visit[i] = 1

            ans = True
            pre = order[0]
            for i in range(n):
                if not visit[i]:
                    for j in dct[i]:
                        if not visit[j]:
                            uf.union(i, j)

            for i in order:
                visit[i] = 0
                for j in dct[i]:
                    if not visit[j]:
                        uf.union(i, j)
                if not uf.is_connected(i, pre):
                    ans = False
                    break
                pre = i
            ac.st("Yes" if ans else "No")
        return

    @staticmethod
    def lg_p2307(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2307
        tag: union_find
        """
        while True:
            ans = []
            while True:
                lst = ac.read_list_ints()
                if not lst:
                    break
                ans.extend(lst)
            if ans == [-1, -1]:
                break
            ans = ans[:-2]
            nodes = list(set(ans))
            ind = {num: i for i, num in enumerate(nodes)}
            m = len(ind)
            uf = UnionFind(m)
            res = True
            for i in range(0, len(ans), 2):
                a, b = ind[ans[i]], ind[ans[i + 1]]
                if not uf.union(a, b):
                    res = False
                    break
            ac.st(1 if res and uf.part == 1 else 0)
        return

    @staticmethod
    def lg_p3420(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3420
        tag: union_find
        """
        n = ac.read_int()
        uf = UnionFind(n)
        for i in range(n):
            j = ac.read_int()
            uf.union(i, j - 1)
        ac.st(uf.part)
        return

    @staticmethod
    def lg_p6004(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6004
        tag: union_find|permutation_circle|kruskal|mst|greedy|pointer
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints_minus_one()
        edges = [ac.read_list_ints() for _ in range(m)]
        edges.sort(key=lambda it: -it[2])
        uf = UnionFind(n)
        ind = 0
        ans = -1
        for i, j, w in edges:
            while ind < n and uf.is_connected(ind, nums[ind]):
                ind += 1
            if ind == n:
                ac.st(ans)
                return
            uf.union(i - 1, j - 1)
            ans = w
        ac.st(ans)
        return

    @staticmethod
    def lg_p6193(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6193
        tag: permutation_circle|discretization|brain_teaser|classical|hard
        """
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        lst = sorted(nums)
        ind = {num: i for i, num in enumerate(lst)}
        uf = UnionFind(n)
        x = lst[0]
        for i in range(n):
            uf.union(i, ind[nums[i]])
        part = uf.get_root_part()
        ans = 0
        for p in part:
            y = min(lst[i] for i in part[p])
            s = sum(lst[i] for i in part[p])
            m = len(part[p])
            if m == 1:
                continue
            cost1 = s + (m - 2) * y
            cost2 = s - y + x + (m - 2) * x + (x + y) * 2
            ans += min(cost1, cost2)
        ac.st(ans)
        return

    @staticmethod
    def lc_2709(nums: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/greatest-common-divisor-traversal/
        tag: union_find|prime_factorization
        """
        pf = PrimeFactor(10 ** 5)
        n = len(nums)
        uf = UnionFind(n)
        pre = dict()
        for i in range(n):
            for num, _ in pf.prime_factor[nums[i]]:
                if num in pre:
                    uf.union(i, pre[num])
                else:
                    pre[num] = i
        return uf.part == 1

    @staticmethod
    def lg_p6706(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6706
        tag: directed_graph|union_find|reverse_order|find_range_merge_to_disjoint|classical|hard
        """
        n = ac.read_int()  # MLE
        edge = ac.read_list_ints()
        q = ac.read_int()
        query = []
        for _ in range(q):
            op, x = ac.read_list_ints()
            if op == 2:
                edge[x - 1] = -edge[x - 1]
            query.append(op * (n + 1) + x)
        uf = UnionFind(n + 1)
        for i in range(1, n + 1):
            if edge[i - 1] > 0:
                j = uf.find(edge[i - 1])
                if j == i:
                    uf.union_left(0, i)
                    uf.union_left(0, j)
                else:
                    uf.union_right(i, j)

        ans = []
        for i in range(q - 1, -1, -1):
            op, x = query[i] // (n + 1), query[i] % (n + 1)
            if op == 1:
                y = uf.find(x)
                if y == 0:
                    res = "CIKLUS"
                else:
                    res = y
                ans.append(res)
            else:
                j = uf.find(-edge[x - 1])
                if j == x:
                    uf.union_left(0, x)
                    uf.union_left(0, j)
                else:
                    uf.union_right(x, j)
        for i in range(len(ans) - 1, -1, -1):
            ac.st(ans[i])
        return

    @staticmethod
    def lg_p7991(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7991
        tag: union_find|shrink_point
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            uf = UnionFind(n)
            for _ in range(m):
                i, j = ac.read_list_ints_minus_one()
                uf.union(i, j)
            if uf.is_connected(0, n - 1):
                ac.st(0)
                continue

            dis_0 = [n] * n
            dis_1 = [n] * n

            pre_0 = pre_1 = -1
            for i in range(n):
                if uf.is_connected(0, i):
                    pre_0 = i
                if uf.is_connected(n - 1, i):
                    pre_1 = i
                if pre_0 != -1:
                    dis_0[uf.find(i)] = min(dis_0[uf.find(i)], i - pre_0)
                if pre_1 != -1:
                    dis_1[uf.find(i)] = min(dis_1[uf.find(i)], i - pre_1)

            pre_0 = pre_1 = -1
            for i in range(n - 1, -1, -1):
                if uf.is_connected(0, i):
                    pre_0 = i
                if uf.is_connected(n - 1, i):
                    pre_1 = i
                if pre_0 != -1:
                    dis_0[uf.find(i)] = min(dis_0[uf.find(i)], pre_0 - i)
                if pre_1 != -1:
                    dis_1[uf.find(i)] = min(dis_1[uf.find(i)], pre_1 - i)
            ans = min(dis_0[i] * dis_0[i] + dis_1[i] * dis_1[i] for i in range(n))
            ac.st(ans)
        return

    @staticmethod
    def lc_2612(n: int, p: int, banned: List[int], k: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/minimum-reverse-operations/
        tag: union_find|find_range_merge_to_disjoint|classical|hard|odd_even|bfs|brain_teaser
        """
        ans = [-1] * n
        uf = UnionFind(n + 2)
        for i in banned:
            uf.union_right(i, i + 2)
        stack = deque([p])
        ans[p] = 0
        while stack:
            i = stack.popleft()
            low = max(0, k - 1 - i, i - k + 1)
            high = min(2 * n - k - 1 - i, n - 1, i + k - 1)
            j = uf.find(low)
            while j <= high:
                if ans[j] == -1:
                    ans[j] = ans[i] + 1
                    stack.append(j)
                    uf.union_right(j, j + 2)
                j = uf.find(j + 2)
        return ans

    @staticmethod
    def lg_p8230(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8230
        tag: layer|union_find|implemention|mst|brain_teaser
        """
        k, m, n = ac.read_list_ints()
        ans = 1
        start = [0, 0]
        uf = UnionFind(m * n)
        for _ in range(k):

            lst = []
            end = [-1, -1]
            for i in range(m * n):
                uf.root_or_size[i] = -1
            pre = [-9] * n
            for i in range(m):
                cur = ac.read_list_ints()
                for j in range(n):
                    w = cur[j]
                    if w != -9:
                        lst.append(w * m * n + i * n + j)
                        x = i - 1
                        if 0 <= x < m and pre[j] != -9:
                            uf.union(i * n + j, x * n + j)

                        y = j - 1
                        if 0 <= y < n and cur[y] != -9:
                            uf.union(i * n + j, i * n + y)

                    if w == -1:
                        end = [i, j]
                pre = cur[:]
            lst.sort()

            for num in lst:
                val, i, j = num // m // n, (num % (m * n)) // n, (num % (m * n)) % n
                if val > ans:
                    break
                if uf.is_connected(start[0] * n + start[1], i * n + j):
                    if ans >= val:
                        if val > 0:
                            ans += val
            start = end[:]
        ac.st(ans)
        return

    @staticmethod
    def lg_p8686(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8686
        tag: union_find|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        dct = dict()
        ans = []
        for num in nums:
            pre = num
            while pre in dct:
                pre = dct[pre]

            x = num
            while x in dct:
                dct[x], x = pre + 1, dct[x]

            dct[pre] = pre + 1
            ans.append(pre)
        ac.lst(ans)
        return

    @staticmethod
    def lg_p8787_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8787
        tag: greedy|heapq|implemention|union_find|classical|hard

        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        stack = [(-nums[i], -i) for i in range(n)]
        heapify(stack)
        uf = UnionFind(n)
        for i in range(n):
            if i and nums[i] == nums[i - 1]:
                uf.union_left(i - 1, i)
        ans = 0
        while stack:
            val, i = heappop(stack)
            val, i = -val, -i
            if val == 1:
                break
            if i != uf.find(i):
                continue
            if i and nums[uf.find(i - 1)] == val:
                uf.union_left(i - 1, i)
                continue
            ans += 1
            val = int(((val // 2) + 1) ** 0.5)
            nums[i] = val
            heappush(stack, (-val, -i))
        ac.st(ans)
        return

    @staticmethod
    def lg_p8787_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8787
        tag: greedy|heapq|implemention|union_find|classical|hard

        """
        ac.read_int()
        nums = ac.read_list_ints()
        pre = set()
        ans = 0
        for num in nums:
            cur = set()
            while num > 1:
                if num not in pre:
                    ans += 1
                cur.add(num)
                num = int(((num // 2) + 1) ** 0.5)
            pre = cur
        ac.st(ans)
        return

    @staticmethod
    def lg_p8881(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8881
        tag: brain_teaser|union_find|circle_judge|part|classical
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            uf = UnionFind(n)
            edge = []
            for _ in range(m):
                i, j = ac.read_list_ints_minus_one()
                uf.union(i, j)
                edge.append((i, j))
            cnt = 0
            for i, j in edge:
                if uf.is_connected(0, i):
                    cnt += 1
            ac.st("1.000" if uf.size(0) == cnt + 1 else "0.000")
        return

    @staticmethod
    def lc_945_1(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-increment-to-make-array-unique/description/
        tag: union_find_right_root|greedy
        """
        nums.sort()
        ans = 0
        uf = UnionFind(max(nums) + len(nums) + 2)
        for num in nums:
            x = uf.find(num)
            ans += x - num
            uf.union_right(x, x + 1)
        return ans

    @staticmethod
    def lc_945_2(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-increment-to-make-array-unique/description/
        tag: union_find_right_root|greedy
        """
        nums.sort()
        ans = 0
        pre = -1
        for num in nums:
            if num > pre:
                pre = num
            else:
                ans += pre + 1 - num
                pre += 1
        return ans

    @staticmethod
    def lc_1559(grid: List[List[str]]) -> bool:
        """
        url: https://leetcode.cn/problems/detect-cycles-in-2d-grid/
        tag: union_find|circle_judge|classical
        """
        m, n = len(grid), len(grid[0])
        uf = UnionFind(m * n)
        for i in range(m):
            for j in range(n):
                if i + 1 < m and grid[i + 1][j] == grid[i][j]:
                    if not uf.union(i * n + j, i * n + n + j):
                        return True
                if j + 1 < n and grid[i][j + 1] == grid[i][j]:
                    if not uf.union(i * n + j, i * n + j + 1):
                        return True
        return False

    @staticmethod
    def lc_2158(paint: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/amount-of-new-area-painted-each-day/
        tag: union_find_range|union_left|union_find_right_root
        """
        m = max(ls[1] for ls in paint) + 10
        uf = UnionFind(m)
        ans = []
        for a, b in paint:
            cnt = 0
            a = uf.find(a)
            while a < b:
                cnt += 1
                uf.union_right(a, a + 1)
                a = uf.find(a + 1)
            ans.append(cnt)
        return ans

    @staticmethod
    def abc_065b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc049/tasks/arc065_b
        tag: union_find|several_union_find
        """
        n, k, ll = ac.read_list_ints()
        ufa = UnionFind(n)
        for _ in range(k):
            p, q = ac.read_list_ints_minus_one()
            ufa.union(p, q)

        ufb = UnionFind(n)
        for _ in range(ll):
            p, q = ac.read_list_ints_minus_one()
            ufb.union(p, q)
        pre = defaultdict(int)
        for i in range(n):
            pre[(ufa.find(i), ufb.find(i))] += 1
        ans = [pre[(ufa.find(i), ufb.find(i))] for i in range(n)]
        ac.lst(ans)
        return

    @staticmethod
    def abc_131f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc131/tasks/abc131_f
        tag: brain_teaser|union_find|counter|hard|classical
        """
        n = ac.read_int()
        m = 10 ** 5
        uf = UnionFind(2 * m)
        for _ in range(n):
            x, y = ac.read_list_ints_minus_one()
            y += m
            uf.union(x, y)
        group = uf.get_root_part()
        ans = 0
        for g in group:
            x = sum(xx < m for xx in group[g])
            y = sum(xx >= m for xx in group[g])
            ans += x * y
        ac.st(ans - n)
        return

    @staticmethod
    def ac_4309(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4309/
        tag: union_right|greedy
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        uf = UnionFind(n * 2 + 2)
        a.sort()
        ans = 0
        for num in a:
            x = uf.find(num)
            ans += x - num
            uf.union_right(x, x + 1)
        ac.st(ans)
        return

    @staticmethod
    def ac_4869(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4869/
        tag: union_find|implemention|size|classical
        """
        n, d = ac.read_list_ints()
        uf = UnionFind(n)
        lst = SortedList([1] * n)
        pre = ans = 1
        for i in range(d):
            x, y = ac.read_list_ints_minus_one()
            if uf.is_connected(x, y):
                pre += 1
                if len(lst) - pre >= 0:
                    ans += lst[len(lst) - pre]
            else:
                for w in [x, y]:
                    i = lst.bisect_left(uf.size(w))
                    if i >= len(lst) - pre:
                        ans -= lst.pop(i)
                        if len(lst) - pre >= 0:
                            ans += lst[len(lst) - pre]
                    else:
                        lst.pop(i)

                uf.union(x, y)
                lst.add(uf.size(x))
                i = lst.bisect_right(uf.size(x))
                if i >= len(lst) - pre:
                    ans += uf.size(x)
                    if len(lst) - pre - 1 >= 0:
                        ans -= lst[len(lst) - pre - 1]
            ac.st(ans - 1)
        return

    @staticmethod
    def lc_2471(root: Optional[TreeNode]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/
        tag: discretization|permutation_circle|classical
        """

        def check():
            nonlocal ans
            ind = {num: i for i, num in enumerate(cur)}
            lst = sorted(cur)
            m = len(lst)
            uf = UnionFind(m)
            for i in range(m):
                uf.union(ind[lst[i]], ind[cur[i]])
            group = uf.get_root_size()
            for p in group:
                ans += group[p] - 1
            return

        ans = 0
        stack = [root] if root else []
        while stack:
            nex = []
            cur = [node.val for node in stack]
            check()
            for node in stack:
                if node.left:
                    nex.append(node.left)
                if node.right:
                    nex.append(node.right)
            stack = nex[:]
        return ans

    @staticmethod
    def cf_1411c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1411/problem/C
        tag: brain_teaser|classical|hard
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            uf = UnionFind(n)
            ans = 0
            for _ in range(m):
                x, y = ac.read_list_ints_minus_one()
                if x == y:
                    continue
                if uf.union(x, y):
                    ans += 1
                else:
                    ans += 2
            ac.st(ans)
        return

    @staticmethod
    def abc_304e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc304/tasks/abc304_e
        tag: union_find|reverse_thinking
        """
        n, m = ac.read_list_ints()
        uf = UnionFind(n)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            uf.union(x, y)
        bad = set()
        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints_minus_one()
            a, b = uf.find(x), uf.find(y)
            bad.add((a, b) if a < b else (b, a))
        for _ in range(ac.read_int()):
            x, y = ac.read_list_ints_minus_one()
            a, b = uf.find(x), uf.find(y)
            if a > b:
                a, b = b, a
            ac.st("Yes" if (a, b) not in bad else "No")
        return

    @staticmethod
    def abc_238e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc238/tasks/abc238_e
        tag: union_find_range|prefix_sum|brain_teaser
        """
        n, q = ac.read_list_ints()
        uf = UnionFind(n + 1)
        for _ in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            uf.union_right(ll, rr + 1)  # pre[rr+1] - pre[ll]
        ac.st("Yes" if uf.is_connected(0, n) else "No")  # pre[n] - pre[0]
        return

    @staticmethod
    def abc_279f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc279/tasks/abc279_f
        tag: union_find_range|brain_teaser|build_graph|classical
        """
        n, q = ac.read_list_ints()
        uf = UnionFind(n + q + q)
        ball_ind = n
        box_ind = n + q
        box = list(range(n))
        dct = list(range(n + q + q))
        for i in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y = [w - 1 for w in lst[1:]]
                uf.union_right(box[y], box[x])
                box[y] = box_ind
                dct[box_ind] = y
                box_ind += 1
            elif lst[0] == 2:
                x = lst[1] - 1
                uf.union_right(ball_ind, box[x])
                ball_ind += 1
            else:
                x = lst[1] - 1
                ac.st(dct[uf.find(x)] + 1)
        return

    @staticmethod
    def cf_1726d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1726/problem/D
        tag: union_find|brain_teaser|classical
        """
        uf = UnionFind(2 * 10 ** 6)
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            edges = [ac.read_list_ints_minus_one() for _ in range(m)]
            for i in range(n):
                uf.root_or_size[i] = -1
            uf.part = n

            color = [1] * m
            blue = []
            for i in range(m):
                x, y = edges[i]
                if not uf.union(x, y):
                    color[i] = 0
                    blue.append(i)
                    if len(blue) == 3:
                        break
            points = set()
            for i in blue:
                x, y = edges[i]
                points.add(x)
                points.add(y)
            if len(blue) == 3 and len(set(points)) == 3:
                ind = blue[0]
                for i in range(n):
                    uf.root_or_size[i] = -1
                uf.part = n
                color[ind] = 1
                uf.union(edges[ind][0], edges[ind][1])
                for i in range(m):
                    if i not in blue:
                        x, y = edges[i]
                        if not uf.union(x, y):
                            color[i] = 0
                            break
            ac.st("".join(str(x) for x in color))
        return

    @staticmethod
    def cf_915f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/915/problem/F
        tag: union_find|contribution_method|counter
        """
        n = ac.read_int()
        nums = [x * n + i for i, x in enumerate(ac.read_list_ints())]
        dct = [[] for _ in range(n)]
        rev = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            if nums[i] > nums[j]:
                dct[i].append(j)
                rev[j].append(i)
            else:
                dct[j].append(i)
                rev[i].append(j)
        nums.sort()

        uf = UnionFind(n)
        ans = 0
        for x in nums:
            val, a = x // n, x % n
            for b in dct[a]:
                left = uf.size(a)
                right = uf.size(b)
                ans += val * left * right
                uf.union(a, b)

        uf = UnionFind(n)
        for i in range(n - 1, -1, -1):
            x = nums[i]
            val, a = x // n, x % n
            for b in rev[a]:
                left = uf.size(a)
                right = uf.size(b)
                ans -= val * left * right
                uf.union(a, b)
        ac.st(ans)
        return

    @staticmethod
    def abc_214d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc214/tasks/abc214_d
        tag: union_find|contribution_method|counter
        """
        n = ac.read_int()
        edges = [ac.read_list_ints() for _ in range(n - 1)]
        edges.sort(key=lambda it: it[2])
        ans = 0
        uf = UnionFind(n)
        for a, b, w in edges:
            left = uf.size(a - 1)
            right = uf.size(b - 1)
            ans += w * left * right
            uf.union(a - 1, b - 1)
        ac.st(ans)
        return

    @staticmethod
    def cf_371d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/371/D
        tag: union_find_right
        """
        n = ac.read_int()
        a = ac.read_list_ints()
        uf = UnionFind(n + 1)
        water = [0] * (n + 1)
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                u, x = lst[1:]
                u -= 1
                root = u
                while root < n and x:
                    root = uf.find(root)
                    if root == n:
                        break
                    c = min(a[root] - water[root], x)
                    x -= c
                    water[root] += c
                    if water[root] == a[root]:
                        uf.union_right(root, root + 1)
                        root = uf.find(root)
            else:
                u = lst[1]
                u -= 1
                ac.st(water[u])
        return

    @staticmethod
    def lg_p5930(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5930
        tag: union_find|classical
        """

        m, n = ac.read_list_ints()
        grid = []
        for i in range(m):
            lst = ac.read_list_ints()
            grid.extend([lst[j] * m * n + i * n + j for j in range(n)])
        uf = UnionFindSP(m * n + 1)
        ans = 0
        for val in sorted(grid):
            h, i, j = val // m // n, (val - (val // m // n) * m * n) // n, val % n
            uf.size[i * n + j] = 1
            uf.height[i * n + j] = h
            if i in [0, m - 1] or j in [0, n - 1]:
                ans += uf.union_right(i * n + j, m * n, h)

            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and uf.size[x * n + y] > 0:
                    ans += uf.union_right(i * n + j, x * n + y, h)
        ac.st(ans)
        return

    @staticmethod
    def lc_407(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/trapping-rain-water-ii/
        tag: union_find|classical
        """
        m, n = len(grid), len(grid[0])
        lst = [grid[i][j] * m * n + i * n + j for j in range(n) for i in range(m)]
        lst.sort()
        uf = UnionFindSP(m * n + 1)
        ans = 0
        for val in lst:
            h, i, j = val // m // n, (val - (val // m // n) * m * n) // n, val % n
            uf.size[i * n + j] = 1
            uf.height[i * n + j] = h
            if i in [0, m - 1] or j in [0, n - 1]:
                ans += uf.union_right(i * n + j, m * n, h)

            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and uf.size[x * n + y] > 0:
                    ans += uf.union_right(i * n + j, x * n + y, h)
        return ans

    @staticmethod
    def cf_292d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/292/D
        tag: union_find_right|prefix_suffix
        """
        n, m = ac.read_list_ints()  # TLE
        pre = [0 for _ in range(m + 1)]
        lst = []
        uf = UnionFind(n)
        lst.append(uf.root_or_size[:])
        parts = [n]
        ind = 0
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        for i, (x, y) in enumerate(edges):
            if uf.union(x, y):
                ind = len(lst)
                lst.append(uf.root_or_size[:])
                parts.append(uf.part)
            pre[i + 1] = ind
        q = ac.read_int()
        ans = [0] * q
        queries = [[] for _ in range(m)]
        for i in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            queries[rr].append((ll, i))
        uf = UnionFind(n)
        cur_uf = UnionFind(n)
        for rr in range(m - 1, -1, -1):
            for ll, i in queries[rr]:
                cur_uf.root_or_size[:] = lst[pre[ll]][:]
                cur_uf.part = parts[pre[ll]]
                for j in range(n):
                    cur_uf.union(j, uf.find(j))
                ans[i] = cur_uf.part
            x, y = edges[rr]
            uf.union(x, y)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def library_check_2(ac=FastIO()):
        """
        url: https://ac.nowcoder.com/acm/contest/7780/C
        tag: union_find|circle_judge
        """
        n, m, k = ac.read_list_ints()
        uf = UnionFind(n)
        edges = [ac.read_list_ints_minus_one() for _ in range(m)]
        ans = 0
        for i, j in edges:
            if i >= k and j >= k:
                uf.union(i, j)
        for i, j in edges:
            if i < k or j < k:
                if not uf.union(i, j):
                    ans += 1
        ac.st(ans)
        return

    @staticmethod
    def cf_566d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/566/D
        tag: union_find_range
        """
        n, q = ac.read_list_ints()
        uf = UnionFind(n)
        uf_range = UnionFind(n)
        for _ in range(q):
            op, x, y = ac.read_list_ints_minus_one()
            if op == 0:
                uf.union(x, y)
            elif op == 1:
                while x < y:
                    uf.union(x, x + 1)
                    uf_range.union_right(x, x + 1)
                    x = uf_range.find(x)
            else:
                ac.st("YES" if uf.is_connected(x, y) else "NO")
        return

    @staticmethod
    def cf_1012b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1012/B
        tag: union_find|brain_teaser|classical
        """
        n, m, q = ac.read_list_ints()
        uf = UnionFind(n + m)
        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            uf.union(x, y + n)
        ac.st(uf.part - 1)
        return

    @staticmethod
    def cf_650c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/650/C
        tag: union_find|matrix_rank|row_column_union_find
        """
        m, n = ac.read_list_ints()
        matrix = [ac.read_list_ints() for _ in range(m)]
        uf = UnionFind(m + n)

        groups = defaultdict(list)
        for i in range(m):
            for j in range(n):
                groups[matrix[i][j]].append((i, j))

        rank_r, rank_c = [0] * m, [0] * n
        for val in sorted(groups):
            for r, c in groups[val]:
                uf.union(r, c + m)

            roots = defaultdict(list)
            for r, c in groups[val]:
                roots[uf.find(r)].append((r, c))

            for lst in roots.values():
                rank = max(rank_r[r] if rank_r[r] >= rank_c[c] else rank_c[c] for r, c in lst) + 1
                for r, c in lst:
                    matrix[r][c] = rank
                    rank_r[r] = rank_c[c] = rank
                    uf.root_or_size[r] = -1
                    uf.root_or_size[c + m] = -1
        for ma in matrix:
            ac.lst(ma)
        return

    @staticmethod
    def lc_1632(matrix: List[List[int]]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/rank-transform-of-a-matrix/
        tag: union_find|matrix_rank|row_column_union_find
        """
        m, n = len(matrix), len(matrix[0])
        uf = UnionFind(m + n)

        groups = defaultdict(list)
        for i in range(m):
            for j in range(n):
                groups[matrix[i][j]].append((i, j))

        rank_r, rank_c = [0] * m, [0] * n
        for val in sorted(groups):
            for r, c in groups[val]:
                uf.union(r, c + m)

            roots = defaultdict(list)
            for r, c in groups[val]:
                roots[uf.find(r)].append((r, c))

            for lst in roots.values():
                rank = max(rank_r[r] if rank_r[r] >= rank_c[c] else rank_c[c] for r, c in lst) + 1
                for r, c in lst:
                    matrix[r][c] = rank
                    rank_r[r] = rank_c[c] = rank
                    uf.root_or_size[r] = -1
                    uf.root_or_size[c + m] = -1
        return matrix

    @staticmethod
    def cf_1253d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1253/D
        tag: union_find_right
        """
        n, m = ac.read_list_ints()
        uf = UnionFind(n)
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            a, b = uf.find(x), uf.find(y)
            if a > b:
                a, b = b, a
            uf.union_right(a, b)
        ans = 0
        for x in range(n - 1):
            if not (x == uf.find(x) or uf.is_connected(x, x + 1)):
                ans += 1
                a, b = uf.find(x), uf.find(x + 1)
                if a > b:
                    a, b = b, a
                uf.union_right(a, b)
        ac.st(ans)
        return

    @staticmethod
    def library_check_3(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/B
        tag: union_find_max|union_find_min
        """
        n, m = ac.read_list_ints()
        uf1 = UnionFind(n)
        uf2 = UnionFind(n)
        for _ in range(m):
            lst = ac.read_list_strs()
            if lst[0] == "union":
                x, y = [int(w) - 1 for w in lst[1:]]
                uf1.union_max(x, y)
                uf2.union_min(x, y)
            else:
                x = int(lst[1]) - 1
                ans = [uf2.find(x) + 1, uf1.find(x) + 1, uf1.size(x)]
                ac.lst(ans)
        return

    @staticmethod
    def library_checker_4(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/C
        tag: union_find|heuristic_merge|classical|hard
        """
        n, m = ac.read_list_ints()
        uf = UnionFind(n)
        node = [0] * n
        root = [0] * n
        group = [[i] for i in range(n)]
        for _ in range(m):
            lst = ac.read_list_strs()
            if lst[0] == "add":
                x, v = [int(w) for w in lst[1:]]
                root[uf.find(x - 1)] += v

            elif lst[0] == "join":
                x, y = [int(w) - 1 for w in lst[1:]]
                x, y = uf.find(x), uf.find(y)
                if x == y:
                    continue
                if uf.size(x) > uf.size(y):
                    x, y = y, x
                gap = root[y] - root[x]
                while group[x]:  # important!
                    i = group[x].pop()
                    group[y].append(i)
                    node[i] -= gap
                uf.union_right(x, y)
            else:
                x = int(lst[1]) - 1
                ac.st(node[x] + root[uf.find(x)])
        return

    @staticmethod
    def library_check_5(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/1/practice/contest/289390/problem/D
        tag: union_find|reverse_thinking|classical
        """
        n, m, q = ac.read_list_ints()
        uf = UnionFind(n)
        for _ in range(m):
            ac.read_list_ints()
        ans = []
        queries = [ac.read_list_strs() for _ in range(q)]
        for i in range(q - 1, -1, -1):
            lst = queries[i]
            x, y = [int(w) - 1 for w in lst[1:]]
            if lst[0] == "ask":
                ans.append("YES" if uf.is_connected(x, y) else "NO")
            else:
                uf.union(x, y)
        ac.st("\n".join(ans[::-1]))
        return

    @staticmethod
    def library_check_6(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/A
        tag: union_find_range
        """
        n, m = ac.read_list_ints()
        uf = UnionFind(n + 2)
        for _ in range(m):
            op, x = ac.read_list_strs()
            x = int(x)
            if op == "?":
                ans = uf.find(x)
                ac.st(ans if ans < n + 1 else -1)
            else:
                uf.union_right(x, x + 1)
        return

    @staticmethod
    def library_check_7(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/B
        tag: union_find_range
        """
        n = ac.read_int()
        uf = UnionFind(n + 2)
        nums = ac.read_list_ints()
        ans = [-1] * n
        for i in range(n):
            x = uf.find(nums[i])
            if x == n + 1:
                x = uf.find(1)
            ans[i] = x
            uf.union_right(x, x + 1)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_8(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/C
        tag: union_find_range
        """
        n, q = ac.read_list_ints()
        uf = UnionFind(n)
        uf_range = UnionFind(n)
        for _ in range(q):
            op, x, y = ac.read_list_ints_minus_one()
            if op == 0:
                uf.union(x, y)
            elif op == 1:
                while x < y:
                    uf.union(x, x + 1)
                    uf_range.union_right(x, x + 1)
                    x = uf_range.find(x)
            else:
                ac.st("YES" if uf.is_connected(x, y) else "NO")
        return

    @staticmethod
    def cf_1609d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1609/D
        tag: union_find|part|sorted_list
        """
        n, q = ac.read_list_ints()
        uf = UnionFind(n)
        lst = SortedList([1] * n)
        cnt = 0
        for _ in range(q):
            i, j = ac.read_list_ints_minus_one()
            if uf.is_connected(i, j):
                cnt += 1
            else:
                lst.discard(uf.size(i))
                lst.discard(uf.size(j))
                uf.union(i, j)
                lst.add(uf.size(i))
            n = len(lst)
            ans = 0
            for i in range(n - 1, n - cnt - 2, -1):
                if i < 0:
                    break
                ans += lst[i]
            ac.st(ans - 1)
        return

    @staticmethod
    def arc_107c(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/AT_arc107_c
        tag: union_find|comb_perm
        """
        n, k = ac.read_list_ints()
        mod = 998244353
        cb = Combinatorics(n, mod)
        grid = [ac.read_list_ints() for _ in range(n)]

        ans = 1
        uf = UnionFind(n)
        for i in range(n):
            for j in range(i + 1, n):
                if all(grid[i][x] + grid[j][x] <= k for x in range(n)):
                    uf.union(i, j)
        for va in uf.get_root_size().values():
            ans *= cb.factorial(va)
            ans %= mod

        uf = UnionFind(n)
        for i in range(n):
            for j in range(i + 1, n):
                if all(grid[x][i] + grid[x][j] <= k for x in range(n)):
                    uf.union(i, j)
        for va in uf.get_root_size().values():
            ans *= cb.factorial(va)
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1850h(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1850/problem/H
        tag: union_find_weighted_dis|classical|hard
        """
        uf = UnionFindWeighted(2 * 10 ** 5)
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            for i in range(n):
                uf.root_or_size[i] = -1
                uf.dis[i] = 0
            ans = "YES"
            for _ in range(m):
                u, v, d = ac.read_list_ints_minus_one()
                d += 1
                if ans == "YES" and uf.union(u, v, d):
                    ans = "NO"
            ac.st(ans)
        return

    @staticmethod
    def abc_328f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc328/tasks/abc328_f
        tag: union_find_weighted_dis|classical|hard
        """
        n, q = ac.read_list_ints()
        uf = UnionFindWeighted(n)
        ans = []
        for i in range(q):
            u, v, d = ac.read_list_ints_minus_one()
            d += 1
            if not uf.union(u, v, d):
                ans.append(i + 1)
        ac.lst(ans)
        return

    @staticmethod
    def library_check_9(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/D
        tag: union_find_weighted_dis|classical|hard
        """
        n, m = ac.read_list_ints()
        uf = UnionFindWeighted(n)
        for _ in range(m):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                a, b = [w - 1 for w in lst[1:]]
                uf.union_right_weight(a, b, 1)
            else:
                c = lst[1] - 1
                uf.find(c)
                ac.st(uf.dis[c])
        return

    @staticmethod
    def cf_766d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/766/D
        tag: union_find_type|build_graph|bipartite_graph
        """
        n, m, q = ac.read_list_ints()
        uf = UnionFind(n * 2)
        words = ac.read_list_strs()
        ind = {w: i for i, w in enumerate(words)}
        for _ in range(m):
            lst = ac.read_list_strs()
            if lst[0] == "1":
                i, j = ind[lst[1]], ind[lst[2]]
                if uf.is_connected(i, j + n):
                    ac.no()
                else:
                    ac.yes()
                    uf.union(i, j)
                    uf.union(i + n, j + n)
            else:
                i, j = ind[lst[1]], ind[lst[2]]
                if uf.is_connected(i, j):
                    ac.no()
                else:
                    ac.yes()
                    uf.union(i, j + n)
                    uf.union(i + n, j)
        for _ in range(q):
            i, j = [ind[w] for w in ac.read_list_strs()]
            if uf.is_connected(i, j):
                ac.st(1)
            elif uf.is_connected(i, j + n):
                ac.st(2)
            else:
                ac.st(3)
        return

    @staticmethod
    def cf_1594d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1594/problem/D
        tag: union_find_type|build_graph|bipartite_graph|2-sat
        """

        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            uf = UnionFind(n * 2)
            for _ in range(m):
                i, j, s = ac.read_list_strs()
                i = int(i) - 1
                j = int(j) - 1
                if s == "crewmate":
                    uf.union(i, j)
                    uf.union(i + n, j + n)
                else:
                    uf.union(i, j + n)
                    uf.union(i + n, j)

            visit = [0] * 2 * n
            ans = 0
            group = uf.get_root_part()
            for i in range(n):
                if uf.is_connected(i, i + n):
                    ac.st(-1)
                    break
                if visit[uf.find(i)] or visit[uf.find(i + n)]:
                    continue
                cur = max(sum(x < n for x in group[uf.find(i)]), sum(x < n for x in group[uf.find(i + n)]))
                ans += cur
                visit[uf.find(i)] = visit[uf.find(i + n)] = 1
            else:
                ac.st(ans)
        return

    @staticmethod
    def lg_p2024(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2024
        tag: union_find_type|build_graph
        """

        n, k = ac.read_list_ints()
        ans = 0
        uf = UnionFind(n * 3)
        for _ in range(k):
            op, x, y = ac.read_list_ints_minus_one()
            if x >= n or y >= n:
                ans += 1
            elif op == 0:
                if uf.is_connected(x, y + n) or uf.is_connected(x, y + 2 * n):
                    ans += 1
                else:
                    uf.union(x, y)
                    uf.union(x + n, y + n)
                    uf.union(x + 2 * n, y + 2 * n)
            else:
                if uf.is_connected(x, y) or uf.is_connected(x + 2 * n, y):
                    ans += 1
                else:
                    uf.union(x, y + 2 * n)
                    uf.union(x + n, y)
                    uf.union(x + 2 * n, y + n)
        ac.st(ans)
        return

    @staticmethod
    def library_check_10(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/7/2/practice/contest/289391/problem/J
        tag: union_find_type|build_graph
        """

        n, k = ac.read_list_ints()
        uf = UnionFind(n * 2)
        for i in range(k):
            x, y = ac.read_list_ints_minus_one()
            if uf.is_connected(x, y):
                ac.st(i + 1)
                break
            uf.union(x, y + n)
            uf.union(x + n, y)
        else:
            ac.st(-1)
        return

    @staticmethod
    def lg_p2391(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2391
        tag: union_find_right|reverse_thinking
        """
        n, m, p, q = [ac.read_int() for _ in range(4)]
        ans = [0] * n
        uf = UnionFind(n + 1)
        for i in range(m, 0, -1):
            x = (i * p + q) % n
            y = (i * q + p) % n
            if x > y:
                x, y = y, x
            x = uf.find(x)
            while x <= y:
                ans[x] = i
                uf.union_right(x, x + 1)
                x = uf.find(x + 1)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_920f_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/920/F
        tag: segment_tree|range_divide|range_sum|classical
        """
        n, m = ac.read_list_ints()
        tree = RangeDivideRangeSum(n, 10 ** 6)
        tree.build(ac.read_list_ints())
        for i in range(m):
            op, ll, rr = ac.read_list_ints_minus_one()
            if op == 0:
                tree.range_divide(ll, rr)
            else:
                ans = tree.range_sum(ll, rr)
                ac.st(ans)
        return

    @staticmethod
    def cf_1618g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1618/problem/G
        tag: union_find_left|union_find_right|classical|offline_query
        """
        n, m, q = ac.read_list_ints()
        ans = [-1] * q
        nums = ac.read_list_ints() + ac.read_list_ints()
        ind = list(range(n + m))
        ind.sort(key=lambda it: nums[it])
        pre = ac.accumulate([nums[i] for i in ind])
        cnt = ac.accumulate([int(i < n) for i in ind])
        edges = [(nums[ind[i + 1]] - nums[ind[i]], i) for i in range(n + m - 1)]
        edges.sort()

        queries = ac.read_list_ints()
        index = list(range(q))
        index.sort(key=lambda it: queries[it])
        uf1 = UnionFind(n + m)
        uf2 = UnionFind(n + m)
        tot = sum(nums[:n])
        j = 0
        for i in index:
            k = queries[i]
            while j < n + m - 1 and edges[j][0] <= k:
                x = edges[j][1]
                if not uf1.is_connected(x, x + 1):
                    l1, r1 = uf1.find(x), uf2.find(x)
                    l2, r2 = uf1.find(x + 1), uf2.find(x + 1)
                    pre_c1 = cnt[r1 + 1] - cnt[l1]
                    pre_c2 = cnt[r2 + 1] - cnt[l2]
                    tot -= pre[r1 + 1] - pre[r1 + 1 - pre_c1]
                    tot -= pre[r2 + 1] - pre[r2 + 1 - pre_c2]
                    tot += pre[r2 + 1] - pre[r2 + 1 - pre_c1 - pre_c2]
                    uf1.union_left(x, x + 1)
                    uf2.union_right(x, x + 1)

                j += 1
            ans[i] = tot
        ac.st("\n".join(str(x) for x in ans))
        return

    @staticmethod
    def abc_314f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc314/tasks/abc314_f
        tag: union_find|bfs|build_graph|expectation|prob
        """
        n = ac.read_int()

        uf = UnionFindGeneral(2 * n - 1)
        uf.size = [1] * n + [0] * (n - 1)
        dct = [[] for _ in range(2 * n - 1)]
        mod = 998244353
        node = [0] * (2 * n - 1)
        for i in range(n - 1):
            p, q = ac.read_list_ints_minus_one()
            ll, rr = uf.size[uf.find(p)], uf.size[uf.find(q)]
            pq = pow(ll + rr, -1, mod)
            root_p, root_q = uf.find(p), uf.find(q)
            uf.union_right(root_p, i + n)
            uf.union_right(root_q, i + n)
            dct[i + n].extend([root_p, root_q])
            node[root_p] += ll * pq % mod
            node[root_q] += rr * pq % mod
        stack = [2 * n - 2]
        while stack:
            i = stack.pop()
            for j in dct[i]:
                node[j] += node[i]
                stack.append(j)
                node[j] %= mod
        ac.lst(node[:n])
        return

    @staticmethod
    def cf_1941g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1941/problem/G
        tag: union_find|build_graph|bfs|brain_teaser|classical
        """
        ac.get_random_seed()
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            color = dict()

            for _ in range(m):
                u, v, c = ac.read_list_ints_minus_one()
                if c ^ ac.random_seed not in color:
                    color[c ^ ac.random_seed] = []
                color[c ^ ac.random_seed].append((u, v))
            dct = [[] for _ in range(n + m)]
            uf = UnionFind(n)
            idx = n
            group = [set() for _ in range(n)]
            for c in color:
                for i, j in color[c]:
                    uf.union(i, j)
                roots = set()
                for i, j in color[c]:
                    group[uf.find(i)].add(j)
                    group[uf.find(i)].add(i)
                    roots.add(uf.find(i))
                for r in roots:
                    for i in group[r]:
                        dct[idx].append(i)
                        dct[i].append(idx)
                    idx += 1
                for i, j in color[c]:
                    uf.root_or_size[i] = -1
                    uf.root_or_size[j] = -1
                for r in roots:
                    group[r] = set()
            b, e = ac.read_list_ints_minus_one()
            dis = [math.inf] * (n + m)
            dis[b] = 0
            stack = [b]
            while stack:
                nex = []
                for i in stack:
                    for j in dct[i]:
                        if dis[j] == math.inf:
                            nex.append(j)
                            dis[j] = dis[i] + 1
                stack = nex[:]
            ac.st(dis[e] // 2)
        return

    @staticmethod
    def abc_295g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc295/tasks/abc295_g
        tag: union_find|implemention|tree|union_min|classical
        """
        n = ac.read_int()
        to = [0] + ac.read_list_ints_minus_one()
        uf = UnionFind(n)
        parent = [0] * n
        for i in range(1, n):
            parent[i] = to[i]
        for _ in range(ac.read_int()):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x, y = lst[1:]
                x -= 1
                y -= 1
                while not uf.is_connected(x, y):
                    uf.union_min(x, parent[x])
                    x = uf.find(x)
            else:
                x = lst[1] - 1
                ac.st(uf.find(x) + 1)
        return

    @staticmethod
    def abc_264e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc264/tasks/abc264_e
        tag: union_right|reverse_order|classical
        """
        n, m, e = ac.read_list_ints()
        edges = [ac.read_list_ints_minus_one() for _ in range(e)]
        queries = [ac.read_int() - 1 for _ in range(ac.read_int())]
        uf = UnionFindGeneral(n + m + 1)
        uf.size = [1] * n + [0] * (m + 1)
        for i in range(n, n + m):
            uf.union_right(i, n + m)
        rem = set(queries)
        for i in range(e):
            if i not in rem:
                u, v = edges[i]
                uf.union_right(u, v)
        ans = [uf.size[uf.find(n + m)]]
        for i in queries[::-1]:
            u, v = edges[i]
            uf.union_right(u, v)
            ans.append(uf.size[uf.find(n + m)])
        ans.pop()
        ans.reverse()
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def abc_259d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc259/tasks/abc259_d
        tag: geometry|union_find|circle_location|classical
        """
        n = ac.read_int()
        sx, sy, tx, ty = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        uf = UnionFind(n + 2)
        for i in range(n):
            x1, y1, r1 = nums[i]
            for j in range(i + 1, n):
                x2, y2, r2 = nums[j]
                dis = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
                if dis > (r1 + r2) ** 2:
                    continue
                if dis < (r1 - r2) ** 2:
                    continue
                uf.union(i, j)
            if (x1 - sx) * (x1 - sx) + (y1 - sy) * (y1 - sy) == r1 * r1:
                uf.union(i, n)
            if (x1 - tx) * (x1 - tx) + (y1 - ty) * (y1 - ty) == r1 * r1:
                uf.union(i, n + 1 )
            if uf.is_connected(n, n + 1):
                ac.yes()
                return
        ac.no()
        return

    @staticmethod
    def abc_350g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc350/tasks/abc350_g
        tag: implemention|union_find|data_range|heuristic_merge|brain_teaser|classical
        """
        n, q = ac.read_list_ints()
        uf = UnionFind(n)
        mod = 998244353
        dct = [set() for _ in range(n)]
        pre = dict()
        ans = 0
        for _ in range(q):
            a, b, c = ac.read_list_ints()
            op, u, v = 1 + ((a * (1 + ans)) % mod) % 2, 1 + ((b * (1 + ans)) % mod) % n, 1 + ((c * (1 + ans)) % mod) % n
            u -= 1
            v -= 1
            op -= 1
            if u > v:
                u, v = v, u
            if op == 0:
                dct[u].add(v)
                dct[v].add(u)
                uf.union(u, v)
            else:
                ans = 0
                if uf.is_connected(u, v):
                    if (u, v) in pre:
                        ans = pre[(u, v)]
                    else:
                        if len(dct[u]) < len(dct[v]):
                            for w in dct[u]:
                                if w in dct[v]:
                                    ans = w + 1
                                    break
                        else:
                            for w in dct[v]:
                                if w in dct[u]:
                                    ans = w + 1
                                    break
                        pre[(u, v)] = ans
                ac.st(ans)
        return

    @staticmethod
    def abc_350d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc350/tasks/abc350_d
        tag: union_find|classical
        """

        n, m = ac.read_list_ints()
        uf = UnionFind(n)
        edges = []
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            uf.union(i, j)
            edges.append((i, j))
        group = defaultdict(int)
        for i, j in edges:
            group[uf.find(i)] += 1
        size = uf.get_root_size()
        ans = 0
        for g in size:
            ans += size[g] * (size[g] - 1) // 2 - group[g]
        ac.st(ans)
        return

    @staticmethod
    def abc_228d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc228/tasks/abc228_d
        tag: union_find_range|classical|implemention
        """
        q = ac.read_int()
        n = 2 ** 20
        uf = UnionFind(n)
        nums = [-1] * n
        for _ in range(q):
            t, x = ac.read_list_ints()
            if t == 1:
                i = uf.find(x % n)
                if nums[i] != -1:
                    i = uf.find(0)
                nums[i] = x
                if i + 1 < n:
                    uf.union_right(i, i + 1)
            else:
                ac.st(nums[x % n])
        return

    @staticmethod
    def abc_351d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc351/tasks/abc351_d
        tag: union_find|bfs|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        uf = UnionFind(m * n)
        safe = [[1] * n for _ in range(m)]
        ind = [(0, 1), (0, -1), (-1, 0), (1, 0)]
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ".":
                    if any(0 <= i + a < m and 0 <= j + b < n and grid[i + a][j + b] == "#" for a, b in ind):
                        safe[i][j] = 0
                    ans = 1
                else:
                    safe[i][j] = 0
        for i in range(m):
            for j in range(n):
                if safe[i][j]:
                    for a, b in ind:
                        if 0 <= i + a < m and 0 <= j + b < n and safe[i + a][j + b]:
                            uf.union(i * n + j, (i + a) * n + j + b)

        group = uf.get_root_part()
        for g in group:
            lst = group[g]
            x = lst[0]
            if safe[x // n][x % n] == 0:
                continue
            cur = len(lst)
            flag = set()
            for x in lst:
                i, j = x // n, x % n
                for a, b in ind:
                    if 0 <= i + a < m and 0 <= j + b < n and grid[i + a][j + b] == "." and not safe[i + a][j + b]:
                        flag.add((i + a, j + b))
            ans = max(ans, cur + len(flag))
        ac.st(ans)
        return

    @staticmethod
    def abc_226e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc226/tasks/abc226_e
        tag: circle_based_tree|union_find|classical
        """
        n, m = ac.read_list_ints()
        uf = UnionFind(n)
        mod = 998244353
        edges = []
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            uf.union(i, j)
            edges.append((i, j))
        group = uf.get_root_part()
        degree = defaultdict(int)
        for i, j in edges:
            degree[uf.find(i)] += 1
        ans = 0
        for g in group:
            if len(group[g]) != degree[g]:
                ac.st(0)
                return
            ans += 1
        ac.st(pow(2, ans, mod))
        return

    @staticmethod
    def abc_214e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc214/tasks/abc214_e
        tag: union_find_right|dict|discretization|implemention|linked_list
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = [ac.read_list_ints() for _ in range(n)]
            nums.sort(key=lambda it: it[1])
            post = dict()
            for a, b in nums:
                x = a
                lst = []
                while x in post:
                    lst.append(x)
                    x = post[x]
                if x > b:
                    ac.no()
                    break
                for y in lst:
                    post[y] = x + 1
                post[x] = x + 1
            else:
                ac.yes()
        return

    @staticmethod
    def abc_355f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc355/tasks/abc355_f
        tag: union_find|brain_teaser|implemention
        """
        n, q = ac.read_list_ints()
        edges = [[] for _ in range(11)]
        for _ in range(n - 1):
            a, b, c = ac.read_list_ints()
            a -= 1
            b -= 1
            edges[c].append((a, b))
        ufs = [UnionFind(n) for _ in range(11)]
        ans = 0
        for x in range(1, 11):
            ufs[x].root_or_size[:] = ufs[x - 1].root_or_size[:]
            for a, b in edges[x]:
                ufs[x].union(a, b)
                ans += x
        for _ in range(q):
            u, v, w = ac.read_list_ints()
            u -= 1
            v -= 1
            for x in range(w + 1):
                if ufs[x].is_connected(u, v):
                    ac.st(ans)
                    break
            else:
                for y in range(w + 1, 11):
                    if ufs[y].is_connected(u, v):
                        ans -= y
                        ans += w
                        for yy in range(w, 11):
                            ufs[yy].union(u, v)
                        break
                ac.st(ans)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/TFALL
        tag: union_find_left|union_find_right|brute_force
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            x = ac.read_list_ints()
            ufr = UnionFind(n)
            p = ac.read_list_ints()
            ufl = UnionFind(n)
            for i in range(1, n):
                if x[i] - x[i - 1] <= p[i]:
                    ufl.union_left(i - 1, i)

            for i in range(n - 2, -1, -1):
                if x[i + 1] - x[i] <= p[i]:
                    ufr.union_right(i, i + 1)
            if ufl.is_connected(0, n - 1) or ufr.is_connected(0, n - 1):
                ac.st("YES")
            else:
                for i in range(n - 1):
                    if ufl.is_connected(0, i) and ufr.is_connected(i + 1, n - 1):
                        ac.st("YES")
                        break
                    if ufr.is_connected(0, i) and ufl.is_connected(i + 1, n - 1):
                        ac.st("YES")
                        break
                    if ufr.is_connected(0, i) and ufr.is_connected(i + 1, n - 1):
                        ac.st("YES")
                        break
                    if ufl.is_connected(0, i) and ufl.is_connected(i + 1, n - 1):
                        ac.st("YES")
                        break
                else:
                    ac.st("NO")
        return

    @staticmethod
    def yuki_2786(ac=FastIO()):
        """
        url: https://yukicoder.me/problems/no/2786
        tag: heuristic_merge|union_find|classical
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        q = ac.read_int()
        ans = [-1] * q
        dct = [[] for _ in range(m * n)]
        for i in range(q):
            x1, y1, x2, y2 = ac.read_list_ints_minus_one()
            dct[x1 * n + y1].append((i, x2 * n + y2))
            dct[x2 * n + y2].append((i, x1 * n + y1))
        ind = list(range(m * n))
        ind.sort(key=lambda it: grid[it // n][it % n])
        uf = UnionFind(m * n)
        for num in ind:
            x, y = num // n, num % n
            for a, b in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
                if 0 <= a < m and 0 <= b < n and grid[a][b] <= grid[x][y] and not uf.is_connected(num, a * n + b):
                    root1, root2 = uf.find(num), uf.find(a * n + b)
                    if len(dct[root1]) < len(dct[root2]):
                        lst = []
                        for i, xx in dct[root1]:
                            if uf.is_connected(xx, root2):
                                ans[i] = grid[x][y]
                            else:
                                lst.append((i, xx))
                        dct[root2].extend(lst)
                        uf.union_left(root2, root1)
                    else:
                        lst = []
                        for i, xx in dct[root2]:
                            if uf.is_connected(xx, root1):
                                ans[i] = grid[x][y]
                            else:
                                lst.append((i, xx))
                        dct[root1].extend(lst)
                        uf.union_left(root1, root2)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_1383a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1383/A
        tag: build_graph|greedy|implemention|union_find|brain_teaser|observation
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            s = ac.read_str()
            t = ac.read_str()
            if all(s[i] <= t[i] for i in range(n)):
                uf = UnionFind(26)
                dct = defaultdict(set)
                for i in range(n):
                    if s[i] < t[i]:
                        dct[t[i]].add(s[i])
                ans = 0
                for w in dct:
                    for y in dct[w]:
                        if uf.union(ord(w) - ord("a"), ord(y) - ord("a")):
                            ans += 1
                ac.st(ans)
            else:
                ac.st(-1)
        return

    @staticmethod
    def cf_1494d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1494/D
        tag: union_right|union_find|implemention|construction
        """
        n = ac.read_int()
        dct = [[] for _ in range(5001)]
        for i in range(n):
            lst = ac.read_list_ints()
            for j in range(n):
                dct[lst[j]].append((i, j))
        uf = UnionFind(n * n)
        parent = [-1] * n * n
        salary = [-1] * n * n
        ind = n
        for d in range(1, 5001):
            for i, j in dct[d]:
                pi, pj = uf.find(i), uf.find(j)
                if pi == pj:
                    salary[pi] = d
                    continue
                if salary[pi] == d:
                    uf.union_right(pj, pi)
                    parent[pj] = pi
                    continue
                if salary[pj] == d:
                    uf.union_right(pi, pj)
                    parent[pi] = pj
                    continue
                parent[pi] = ind
                parent[pj] = ind
                uf.union_right(pi, ind)
                uf.union_right(pj, ind)
                salary[ind] = d
                ind += 1
        ac.st(ind)
        ac.lst(salary[:ind])
        ac.st(ind)
        for i in range(ind - 1):
            ac.lst([i + 1, parent[i] + 1])
        return

    @staticmethod
    def lc_100376(n: int, queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-ii/
        tag: build_graph|union_find|union_right
        """
        uf = UnionFind(n-1)
        ans = []
        for x, y in queries:
            while uf.find(x) < y-1:
                uf.union_right(x, uf.find(x+1))
                x = uf.find(x+1)
            ans.append(uf.part)
        return ans

    @staticmethod
    def cf_776d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/776/D
        tag: union_find|classical|2-sat
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        uf = UnionFind(m + m)
        key = [[] for _ in range(n)]
        for i in range(m):
            lst = ac.read_list_ints_minus_one()
            for x in lst[1:]:
                key[x].append(i)
        for x in range(n):
            a, b = key[x][0], key[x][1]
            if nums[x]:
                uf.union(a, b)
                uf.union(a + m, b + m)
            else:
                uf.union(a + m, b)
                uf.union(a, b + m)
        for i in range(m):
            if uf.is_connected(i, m + i):
                ac.no()
                break
        else:
            ac.yes()
        return


    @staticmethod
    def cf_1278d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1278/D
        tag: union_find|range|binary_search|observation|partial_order|observation|bucket_sort
        """
        n = ac.read_int()
        uf = UnionFind(n)
        line = defaultdict(list)
        m = 2 * n + 2
        for i in range(n):
            ll, rr = ac.read_list_ints()
            line[ll].append(rr * m + i)
        pre = SortedList()

        for ll in sorted(line):
            x = pre.bisect_right(ll * m)
            for val in line[ll]:
                rr, i = val // m, val % m
                j = x
                while j < len(pre) and pre[j] // m < rr:
                    k = pre[j] % m
                    if not uf.union(i, k):
                        ac.no()
                        return
                    j += 1
            for val in line[ll]:
                pre.add(val)
        if uf.part == 1:
            ac.yes()
        else:
            ac.no()
        return

    @staticmethod
    def cf_1994d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1994/D
        tag: reverse_order|pigeonhole_principle|union_find
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            uf = UnionFind(n)
            ac.yes()
            ans = []
            for x in range(n - 1, 0, -1):
                cur = [-1] * x
                for i in range(n):
                    j = nums[i] % x
                    if cur[j] != -1 and uf.union(cur[j], i):
                        ans.append([cur[j] + 1, i + 1])
                        break
                    cur[j] = i
            ans.reverse()
            for ls in ans:
                ac.lst(ls)
        return

    @staticmethod
    def abc_372e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc372/tasks/abc372_e
        tag: heuristic_merge|union_find
        """
        n, q = ac.read_list_ints()
        nodes = [[i] for i in range(n)]
        uf = UnionFind(n)
        for _ in range(q):
            op, a, b = ac.read_list_ints_minus_one()
            if op == 0:
                root1, root2 = uf.find(a), uf.find(b)
                if root1 == root2:
                    continue
                uf.union_right(root1, root2)
                lst1 = nodes[root1]
                lst2 = nodes[root2]
                m1, m2 = len(lst1), len(lst2)
                i1, i2 = 0, 0
                lst = []
                while i1 < m1 and i2 < m2:
                    if lst1[i1] < lst2[i2]:
                        lst.append(lst1[i1])
                        i1 += 1
                    else:
                        lst.append(lst2[i2])
                        i2 += 1
                lst.extend(lst1[i1:])
                lst.extend(lst2[i2:])
                nodes[root1] = None
                nodes[root2] = lst[-10:]
            else:
                root1 = uf.find(a)
                b += 1
                if len(nodes[root1]) < b:
                    ac.st(-1)
                else:
                    ac.st(nodes[root1][-b] + 1)
        return
"""

Algorithm：greedy|reverse_thinking|pigeonhole_principle|inclusion_exclusion|custom_sort|brain_teaser|construction
Description：brain_teaser

====================================LeetCode====================================
30（https://leetcode.cn/problems/p0NxJO）greedy|regret_heapq|brain_teaser
134（https://leetcode.cn/problems/gas-station/）greedy
330（https://leetcode.cn/problems/patching-array/）greedy
1199（https://leetcode.cn/problems/minimum-time-to-build-blocks/）huffman_tree|greedy|classical|heapq
2499（https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/）pigeonhole_principle|greedy
2449（https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/）sort|odd_even|greedy
2448（https://leetcode.cn/problems/minimum-cost-to-make-array-equal/）median|greedy
2412（https://leetcode.cn/problems/minimum-money-required-before-transactions/）custom_sort
2366（https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/）reverse_order|greedy
2350（https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/）brain_teaser|classical
2344（https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/）greedy|range_gcd
2136（https://leetcode.cn/problems/earliest-possible-day-of-full-bloom/）greedy
2071（https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/）greedy|binary_search
517（https://leetcode.cn/problems/super-washing-machines/）greedy|binary_search|brute_force
1798（https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/）greedy
625（https://leetcode.cn/problems/minimum-factorization/）greedy|factorization
2568（https://leetcode.cn/problems/minimum-impossible-or/）brain_teaser|greedy|guess|watch_pattern
6361（https://leetcode.cn/problems/minimum-score-by-changing-two-elements/）brain_teaser|greedy
6316（https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score/）greedy|prefix_sum
2436（https://leetcode.cn/problems/minimum-split-into-subarrays-with-gcd-greater-than-one/）greedy
1029（https://leetcode.cn/problems/two-city-scheduling/）greedy|sort
1353（https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/）brute_force|greedy
1402（https://leetcode.cn/problems/reducing-dishes/）prefix_sum|greedy
1665（https://leetcode.cn/problems/minimum-initial-energy-to-finish-tasks/）greedy|sort|implemention|CF1203F
1675（https://leetcode.cn/problems/minimize-deviation-in-array/）brain_teaser|greedy
1686（https://leetcode.cn/problems/stone-game-vi/）greedy|custom_sort
1808（https://leetcode.cn/problems/maximize-number-of-nice-divisors/）mod|greedy|classical|maximum_mul
1953（https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work/）greedy|classical|maximum|sum
2856（https://leetcode.cn/problems/minimum-array-length-after-pair-removals/）greedy|classical|maximum|sum
858（https://leetcode.cn/problems/mirror-reflection/description/）brain_teaser
1927（https://leetcode.cn/problems/sum-game/description/）game_dp|brain_teaser|classification_discussion
2592（https://leetcode.cn/problems/maximize-greatness-of-an-array/）classical|greedy|sort|two_pointers
1503（https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/）brain_teaser|classical
991（https://leetcode.cn/problems/broken-calculator/）reverse_order|reverse_thinking|greedy|odd_even|implemention
2745（https://leetcode.cn/problems/construct-the-longest-new-string/）brain_teaser|greedy
1657（https://leetcode.cn/problems/determine-if-two-strings-are-close/description/）brain_teaser|greedy
2561（https://leetcode.cn/problems/rearranging-fruits/）brain_teaser|greedy
843（https://leetcode.cn/problems/guess-the-word/）brain_teaser|greedy|implemention|interactive
1946（https://leetcode.cn/problems/largest-number-after-mutating-substring/description/）greedy|classical
1540（https://leetcode.cn/problems/can-convert-string-in-k-moves/）greedy|brain_teaser|pointer
1121（https://leetcode.cn/problems/divide-array-into-increasing-sequences/description/）brain_teaser|greedy|classical|maximum
3012（https://leetcode.com/problems/minimize-length-of-array-using-operations/）brain_teaser|perishu_theorem|hard|greedy
100197（https://leetcode.cn/problems/earliest-second-to-mark-indices-ii/description/）regret_heapq|binary_search|brain_teaser|classical
100227（https://leetcode.cn/problems/minimum-moves-to-pick-k-ones/description/）median_greedy|brute_force|implemention
100367（https://leetcode.cn/problems/minimum-cost-for-cutting-cake-ii/description/）sort|greedy|big_to_small
2576（https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices）observation|greedy|classical

=====================================LuoGu======================================
P1031（https://www.luogu.com.cn/problem/P1031）greedy|prefix_sum|counter
P1286（https://www.luogu.com.cn/problem/P1286）brain_teaser|sorted_list
P1684（https://www.luogu.com.cn/problem/P1684）greedy
P1658（https://www.luogu.com.cn/problem/P1658）greedy
P2001（https://www.luogu.com.cn/problem/P2001）greedy|classical
P1620（https://www.luogu.com.cn/problem/P1620）classification_discussion|greedy
P2773（https://www.luogu.com.cn/problem/P2773）classification_discussion|greedy
P2255（https://www.luogu.com.cn/problem/P2255）pointers|greedy
P2327（https://www.luogu.com.cn/problem/P2327）brain_teaser|brute_force
P2777（https://www.luogu.com.cn/problem/P2777）greedy|brute_force|prefix_suffix
P2649（https://www.luogu.com.cn/problem/P2649）greedy|brain_teaser
P1367（https://www.luogu.com.cn/problem/P1367）brain_teaser|sort|classical
P1362（https://www.luogu.com.cn/problem/P1362）bfs|brute_force|observe_pattern
P1090（https://www.luogu.com.cn/problem/P1090）greedy|small_to_big
P1334（https://www.luogu.com.cn/problem/P1334）reverse_thinking|greedy|small_to_big
P1250（https://www.luogu.com.cn/problem/P1250）greed|segment_tree|range_update|range_sum|binary_search
P1230（https://www.luogu.com.cn/problem/P1230）sort|greedy
P1159（https://www.luogu.com.cn/problem/P1159）greedy|implemention|deque
P1095（https://www.luogu.com.cn/problem/P1095）greedy|implemention
P1056（https://www.luogu.com.cn/problem/P1056）counter|sort|greedy
P8847（https://www.luogu.com.cn/problem/P8847）classification_discussion|greedy
P8845（https://www.luogu.com.cn/problem/P8845）brain_teaser|prime_property|only_even_prime
P2772（https://www.luogu.com.cn/problem/P2772）sort|partial_order
P2878（https://www.luogu.com.cn/problem/P2878）greedy|custom_sort|classical
P2920（https://www.luogu.com.cn/problem/P2920）sort|greedy
P2983（https://www.luogu.com.cn/problem/P2983）greedy|sort
P3173（https://www.luogu.com.cn/problem/P3173）sort|greedy|big_to_small
P5098（https://www.luogu.com.cn/problem/P5098）greedy|partial_order|classification_discussion|prefix_min|sort
P5159（https://www.luogu.com.cn/problem/P5159）xor_property|brute_force|counter|fast_power
P5497（https://www.luogu.com.cn/problem/P5497）pigeonhole_principle|classification_discussion
P5682（https://www.luogu.com.cn/problem/P5682）brain_teaser|sort|greedy|brute_force
P5804（https://www.luogu.com.cn/problem/P5804）sort|greedy|brute_force|binary_search
P5963（https://www.luogu.com.cn/problem/P5963）greedy|sort
P6023（https://www.luogu.com.cn/problem/P6023）pointer|implemention|brain_teaser
P6243（https://www.luogu.com.cn/problem/P6243）greedy|custom_sort
P6179（https://www.luogu.com.cn/problem/P6179）greedy
P6380（https://www.luogu.com.cn/problem/P6380）greedy|implemention
P6446（https://www.luogu.com.cn/problem/P6446）greedy|implemention
P5019（https://www.luogu.com.cn/problem/P5019）greedy|implemention
P6462（https://www.luogu.com.cn/problem/P6462）greedy|classification_discussion
P6549（https://www.luogu.com.cn/problem/P6549）reverse_thinking|sort|implemention
P6785（https://www.luogu.com.cn/problem/P6785）brain_teaser|greedy|counter
P6851（https://www.luogu.com.cn/problem/P6851）greedy|implemention|sort
P7176（https://www.luogu.com.cn/problem/P7176）greedy|classical|maximum_property|observation
P7228（https://www.luogu.com.cn/problem/P7228）brain_teaser|greedy|tree_dfs
P7260（https://www.luogu.com.cn/problem/P7260）greedy|dp|operation
P7319（https://www.luogu.com.cn/problem/P7319）greedy|custom_sort
P7412（https://www.luogu.com.cn/problem/P7412）greedy
P7522（https://www.luogu.com.cn/problem/P7522）classification_discussion|greedy
P7633（https://www.luogu.com.cn/problem/P7633）euler_series|O(nlogn)|implemention|greedy
P7714（https://www.luogu.com.cn/problem/P7714）sort|prefix_max|pointer|counter
P7787（https://www.luogu.com.cn/problem/P7787）brain_teaser|tree|complete_binary_tree
P7813（https://www.luogu.com.cn/problem/P7813）greedy
P1031（https://www.luogu.com.cn/problem/P1031）greedy|card_split_average|classical
P2512（https://www.luogu.com.cn/problem/P2512）greedy|card_split_average|classical|circular_array
P1080（https://www.luogu.com.cn/problem/P1080）greedy|custom_sort
P1650（https://www.luogu.com.cn/problem/P1650）greedy|classical
P2088（https://www.luogu.com.cn/problem/P2088）greedy
P2816（https://www.luogu.com.cn/problem/P2816）sort|greedy|sorted_list
P3819（https://www.luogu.com.cn/problem/P3819）median|greedy
P3918（https://www.luogu.com.cn/problem/P3918）brain_teaser|greedy
P4025（https://www.luogu.com.cn/problem/P4025）greedy|custom_sort
P4266（https://www.luogu.com.cn/problem/P4266）greedy|implemention|suffix_max
P4447（https://www.luogu.com.cn/problem/P4447）greedy|deque
P4575（https://www.luogu.com.cn/problem/P4575）brain_teaser|state_compression
P4653（https://www.luogu.com.cn/problem/P4653）binary_search|pointer|greedy
P5093（https://www.luogu.com.cn/problem/P5093）brain_teaser|classical
P5425（https://www.luogu.com.cn/problem/P5425）mst_like|brain_teaser|greedy
P5884（https://www.luogu.com.cn/problem/P5884）brain_teaser
P5948（https://www.luogu.com.cn/problem/P5948）greedy|implemention
P6196（https://www.luogu.com.cn/problem/P6196）greedy
P6874（https://www.luogu.com.cn/problem/P6874）median_greedy
P8050（https://www.luogu.com.cn/problem/P8050）brain_teaser|coloring_method|operation
P7935（https://www.luogu.com.cn/problem/P7935）brain_teaser
P8109（https://www.luogu.com.cn/problem/P8109）sorted_list|greedy
P8669（https://www.luogu.com.cn/problem/P8669）greedy|maximum_mul
P8709（https://www.luogu.com.cn/problem/P8709）brain_teaser|implemention
P8732（https://www.luogu.com.cn/problem/P8732）greedy|brute_force|custom_sort
P8887（https://www.luogu.com.cn/problem/P8887）brain_teaser|greedy
P1342（https://www.luogu.com.cn/problem/P1342）brain_teaser|greedy
P1842（https://www.luogu.com.cn/problem/P1842）greedy
P2968（https://www.luogu.com.cn/problem/P2968）greedy|implemention|observation
P3619（https://www.luogu.com.cn/problem/P3619）greedy|classical|custom_sort
P3550（https://www.luogu.com.cn/problem/P3550）greedy|observation
P4823（https://www.luogu.com.cn/problem/P4823）greedy|regret_heapq|classical|brain_teaser
P4998（https://www.luogu.com.cn/problem/P4998）brain_teaser|greedy|prefix_sum
P5963（https://www.luogu.com.cn/problem/P5963）pair_wise|greedy|classical|custom_sort
P6002（https://www.luogu.com.cn/problem/P6002）brute_force|greedy|brain_teaser
P7148（https://www.luogu.com.cn/problem/P7148）greedy

===================================CodeForces===================================
1186D（https://codeforces.com/problemset/problem/1186/D）greedy|floor|property
792C（https://codeforces.com/contest/792/problem/C）classification_discussion|greedy
166E（https://codeforces.com/problemset/problem/166/E）implemention|brain_teaser|dp
1025C（https://codeforces.com/problemset/problem/1025/C）brain_teaser
1042C（https://codeforces.com/problemset/problem/1042/C）greedy|classification_discussion|implemention
439C（https://codeforces.com/problemset/problem/439/C）greedy|classification_discussion
1283E（https://codeforces.com/problemset/problem/1283/E）greedy|classification_discussion|linear_dp
1092C（https://codeforces.com/contest/1092/problem/C）brain_teaser|classification_discussion
1280B（https://codeforces.com/problemset/problem/1280/B）brain_teaser|classification_discussion
723C（https://codeforces.com/problemset/problem/723/C）greedy|implemention|construction
712C（https://codeforces.com/problemset/problem/712/C）reverse_thinking|implemention
747D（https://codeforces.com/problemset/problem/747/D）greedy|implemention
1148D（https://codeforces.com/problemset/problem/1148/D）greedy|custom_sort|construction
792C（https://codeforces.com/contest/792/problem/C）classification_discussion|greedy
830A（https://codeforces.com/problemset/problem/830/A）sort|greedy|action_scope
478C（https://codeforces.com/problemset/problem/478/C）greedy|math|property
1329A（https://codeforces.com/problemset/problem/1329/A）greedy|pointer|implemention
1401D（https://codeforces.com/problemset/problem/1401/D）greedy|dfs|brute_force|counter
600C（https://codeforces.com/problemset/problem/600/C）palindrome_substring|counter|greedy
1038D（https://codeforces.com/problemset/problem/1038/D）greedy|implemention|classification_discussion
349B（https://codeforces.com/problemset/problem/349/B）greedy|implemention
1370C（https://codeforces.com/problemset/problem/1370/C）greedy|implemention|winning_state
1822E（https://codeforces.com/contest/1822/problem/E）greedy|implemention|counter
1005E2（https://codeforces.com/contest/1005/problem/E2）median|inclusion_exclusion|prefix_sum|sorted_list|binary_search|LC2488
1512E（https://codeforces.com/contest/1512/problem/E）brain_teaser|greedy|big_to_small
1665C（https://codeforces.com/contest/1665/problem/C）graph|greedy
1649B（https://codeforces.com/contest/1649/problem/B）maximum_greedy|classical
1914E2（https://codeforces.com/contest/1914/problem/E2）greedy|custom_sort
1929D（https://codeforces.com/contest/1920/problem/D）data_range|brute_force|reverse_thinking
724D（https://codeforces.com/contest/724/problem/D）greedy|implemention|brain_teaser
1669D（https://codeforces.com/contest/1669/problem/D）brain_teaser
1807G2（https://codeforces.com/contest/1807/problem/G2）brain_teaser|classical|sorting|greedy
1873G（https://codeforces.com/contest/1873/problem/G）brain_teaser
977D（https://codeforces.com/contest/977/problem/D）brain_teaser|greedy|classical|sorting
978G（https://codeforces.com/contest/978/problem/G）brain_teaser|greedy|sorting|implemention|reverse_thinking
999D（https://codeforces.com/contest/999/problem/D）greedy|brute_force
1144G（https://codeforces.com/contest/1144/problem/G）linear_dp|greedy|classical|construction|brain_teaser
1157G（https://codeforces.com/contest/1157/problem/G）brain_teaser|brute_force|classical|implemention|greedy
1157F（https://codeforces.com/contest/1157/problem/F）greedy|brain_teaser|construction|specific_plan
1157C2（https://codeforces.com/contest/1157/problem/C2）greedy|brain_teaser|implemention
1183G（https://codeforces.com/contest/1183/problem/G）greedy|brain_teaser|implemention|classical
1183D（https://codeforces.com/contest/1183/problem/D）greedy|brain_teaser|implemention|classical
1183F（https://codeforces.com/contest/1183/problem/F）greedy|brain_teaser|classical|brute_force|special_judge
1203F1（https://codeforces.com/contest/1203/problem/F1）greedy|brain_teaser|linear_dp|define_sort|classical
1203F2（https://codeforces.com/contest/1203/problem/F2）greedy|brain_teaser|linear_dp|define_sort|classical
1249D2（https://codeforces.com/contest/1249/problem/D2）greedy|offline_query|sorted_list
1256F（https://codeforces.com/contest/1256/problem/F）greedy|brain_teaser|reverse_pair|bubble_sort|classical
1296E2（https://codeforces.com/contest/1296/problem/E2）greedy|brain_teaser|lis
1296E1（https://codeforces.com/contest/1296/problem/E1）greedy|brain_teaser|lis
1367F2（https://codeforces.com/contest/1367/problem/F2）greedy|brain_teaser|lis
1385F（https://codeforces.com/contest/1385/problem/F）greedy|brain_teaser|topological_sort
1399E2（https://codeforces.com/contest/1399/problem/E2）greedy|graph|brain_teaser|brute_force
1538G（https://codeforces.com/contest/1538/problem/G）greedy|brain_teaser
1512F（https://codeforces.com/contest/1512/problem/F）greedy|brain_teaser
1593G（https://codeforces.com/contest/1593/problem/G）greedy|brain_teaser|prefix_sum
1579E2（https://codeforces.com/contest/1579/problem/E2）greedy|brain_teaser
1560F2（https://codeforces.com/contest/1560/problem/F2）greedy
1660F2（https://codeforces.com/contest/1660/problem/F2）greedy|brain_teaser|sorted_list
1674E（https://codeforces.com/contest/1674/problem/E）greedy|brute_force
1772E（https://codeforces.com/contest/1772/problem/E）greedy|brain_teaser
1759G（https://codeforces.com/contest/1759/problem/G）greedy|brain_teaser
1883F（https://codeforces.com/contest/1883/problem/F）brain_teaser|prefix_suffix
1872G（https://codeforces.com/contest/1872/problem/G）brain_teaser|greedy
1899E（https://codeforces.com/contest/1899/problem/E）brain_teaser|greedy
1923D（https://codeforces.com/contest/1923/problem/D）brain_teaser|greedy|prefix_sum|binary_search
1923B（https://codeforces.com/contest/1923/problem/D）brain_teaser|implemention|greedy
1921E（https://codeforces.com/contest/1921/problem/E）brain_teaser|implemention|greedy|odd_even
1941F（https://codeforces.com/contest/1941/problem/F）brain_teaser|implemention|greedy|median|binary_search
1941C（https://codeforces.com/contest/1941/problem/C）brain_teaser|greedy
1974G（https://codeforces.com/contest/1974/problem/G）regret_heapq|implemention|brain_teaser|classical
1976B（https://codeforces.com/contest/1976/problem/B）brute_force|greedy
985C（https://codeforces.com/problemset/problem/985/C）greedy|brain_teaser|reverse_order
1978D（https://codeforces.com/contest/1978/problem/D）greedy|brain_teaser|implemention
1316C（https://codeforces.com/problemset/problem/1316/C）observation|math|brain_teaser
1156C（https://codeforces.com/problemset/problem/1156/C）greedy|two_pointers|classical|brain_teaser
1684D（https://codeforces.com/problemset/problem/1684/D）greedy|observation|contribution_method
1379C（https://codeforces.com/contest/1379/problem/C）observation|prefix_sum|binary_search|brute_force|greedy
1451D（https://codeforces.com/problemset/problem/1451/D）data_range|observation|classical|greedy|implemention
1295B（https://codeforces.com/problemset/problem/1295/B）observation|brain_teaser|classification_discussion
1870D（https://codeforces.com/problemset/problem/1870/D）observation|greedy|monotonic_stack
1415D（https://codeforces.com/problemset/problem/1415/D）observation|bit_operation|data_range
893D（https://codeforces.com/problemset/problem/893/D）greedy|brain_teaser|implemention|low_to_high
1849D（https://codeforces.com/problemset/problem/1849/D）observation|greedy|implemention
1496D（https://codeforces.com/problemset/problem/1496/D）observation|prefix_suffix|brute_force|greedy|implemention|game
1436D（https://codeforces.com/problemset/problem/1436/D）tree_bfs|greedy|brain_teaser
1621D（https://codeforces.com/problemset/problem/1621/D）greedy|brain_teaser
1700D（https://codeforces.com/problemset/problem/1700/D）greedy|brain_teaser
1430D（https://codeforces.com/problemset/problem/1430/D）greedy|two_pointers
1392D（https://codeforces.com/problemset/problem/1392/D）observation|brain_teaser
1238D（https://codeforces.com/problemset/problem/1238/D）observation
1186C（https://codeforces.com/problemset/problem/1186/C）observation|brain_teaser
372A（https://codeforces.com/problemset/problem/372/A）observation|greedy|classical
1804D（https://codeforces.com/problemset/problem/1804/D）greedy
282B（https://codeforces.com/problemset/problem/282/B）greedy
1257D（https://codeforces.com/problemset/problem/1257/D）suffix_max|greedy|implemention|classical
1539D（https://codeforces.com/problemset/problem/1539/D）greedy|two_pointers|implemention
865D（https://codeforces.com/problemset/problem/865/D）regret_heapq|greedy|classical
713C（https://codeforces.com/problemset/problem/713/C）greedy|brain_teaser|strictly_monotonic_trick|classical
13C（https://codeforces.com/problemset/problem/13/C）greedy|brain_teaser|regret_heapq|classical
1119E（https://codeforces.com/problemset/problem/1119/E）greedy
1515D（https://codeforces.com/problemset/problem/1515/D）greedy|brain_teaser|classification_discussion
1466D（https://codeforces.com/problemset/problem/1466/D）greedy|implemention
1282B2（https://codeforces.com/problemset/problem/1282/B2）greedy|linear_dp
2004D（https://codeforces.com/problemset/problem/2004/D）observation|data_range|brain_teaser|brute_force

====================================AtCoder=====================================
ARC062A（https://atcoder.jp/contests/abc046/tasks/arc062_a）brain_teaser|greedy|custom_sort
ARC088B（https://atcoder.jp/contests/abc083/tasks/arc088_b）brain_teaser|greedy
ABC116D（https://atcoder.jp/contests/abc116/tasks/abc116_d）brain_teaser|greedy
ABC137D（https://atcoder.jp/contests/abc137/tasks/abc137_d）reverse_order|brain_teaser|greedy
ABC333E（https://atcoder.jp/contests/abc333/tasks/abc333_e）reverse_order|greedy
ABC330F（https://atcoder.jp/contests/abc330/tasks/abc330_f）brain_teaser|greedy|brute_force|binary_search|prefix_sum
ABC314D（https://atcoder.jp/contests/abc314/tasks/abc314_d）reverse_order|brain_teaser
ABC313C（https://atcoder.jp/contests/abc313/tasks/abc313_c）brain_teaser|median_greedy
ABC310E（https://atcoder.jp/contests/abc310/tasks/abc310_e）brain_teaser|implemention
ABC308F（https://atcoder.jp/contests/abc308/tasks/abc308_f）brain_teaser|greedy
ABC296F（https://atcoder.jp/contests/abc296/tasks/abc296_f）brain_teaser|greedy|sorted_list|reverse_pair|property
ABC293F（https://atcoder.jp/contests/abc293/tasks/abc293_f）binary_search|brute_force|brain_teaser|classical
ABC290D（https://atcoder.jp/contests/abc290/tasks/abc290_d）brain_teaser|implemention|math
ABC347C（https://atcoder.jp/contests/abc347/tasks/abc347_c）brain_teaser|implemention
ABC347D（https://atcoder.jp/contests/abc347/tasks/abc347_d）greedy
ABC252F（https://atcoder.jp/contests/abc252/tasks/abc252_f）greedy|small_to_big|reverse_order|classical
ABC349D（https://atcoder.jp/contests/abc349/tasks/abc349_d）greedy|brain_teaser
ABC249F（https://atcoder.jp/contests/abc249/tasks/abc249_f）greedy|implemention|reverse_order|classical
ABC230D（https://atcoder.jp/contests/abc230/tasks/abc230_d）greedy
ABC229G（https://atcoder.jp/contests/abc229/tasks/abc229_g）implemention|median_greedy|two_pointers|classical|prefix_sum
ABC209C（https://atcoder.jp/contests/abc209/tasks/abc209_c）greedy|brain_teaser
ABC359F（https://atcoder.jp/contests/abc359/tasks/abc359_f）greedy|implemention|stack

=====================================AcWing=====================================
104（https://www.acwing.com/problem/content/106/）median|greedy
1536（https://www.acwing.com/problem/content/description/1538/）greedy|card_split_average|classical
105（https://www.acwing.com/problem/content/description/1538/）greedy|card_split_average|classical|circular_array
110（https://www.acwing.com/problem/content/112/）greedy
123（https://www.acwing.com/problem/content/description/125/）median_greedy
125（https://www.acwing.com/problem/content/127/）greedy|custom_sort
127（https://www.acwing.com/problem/content/description/129/）partial_order|sort|greedy
145（https://www.acwing.com/problem/content/147/）heapq|greedy
122（https://www.acwing.com/problem/content/124/）greedy|card_split_average|classical|circular_array
4204（https://www.acwing.com/problem/content/description/4207/）construction
4307（https://www.acwing.com/problem/content/description/4310/）lexicographical_order|brute_force|greedy
4313（https://www.acwing.com/problem/content/4316/）full_binary_tree|tree_dp|greedy|LC2673
4426（https://www.acwing.com/problem/content/4429/）brain_teaser|brain_teaser|property
4427（https://www.acwing.com/problem/content/4430/）greedy|construction
4429（https://www.acwing.com/problem/content/description/4432/）greedy|custom_sort|prefix_suffix|brute_force
4430（https://www.acwing.com/problem/content/description/4433/）brute_force|prefix_suffix|bracket
4492（https://www.acwing.com/problem/content/description/4495/）brain_teaser|odd_even
4623（https://www.acwing.com/problem/content/description/4626/）greedy|implemention


=====================================CodeChef=====================================
1（https://www.codechef.com/problems/CHANGEXY）greedy|implemention
2（https://www.codechef.com/problems/DESTBRIDGE2）greedy|implemention

"""
import bisect
import heapq
import math
from bisect import insort_left, bisect_left
from collections import Counter, deque, defaultdict
from functools import reduce
from heapq import heappop, heapify, heappush
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.data_structure.sorted_list.template import SortedList
from src.mathmatics.number_theory.template import NumFactor
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __int__(self):
        return

    @staticmethod
    def cf_1005e2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1005/problem/E2
        tag: median|inclusion_exclusion|prefix_sum|sorted_list|binary_search|LC2488|brain_teaser
        """

        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        def check(x):
            cur = res = s = 0
            dct = defaultdict(int)
            dct[cur ^ ac.random_seed] = 1
            for num in nums:
                if num >= x:
                    s += dct[cur ^ ac.random_seed]
                    cur += 1
                else:
                    cur -= 1
                    s -= dct[cur ^ ac.random_seed]
                res += s
                dct[cur ^ ac.random_seed] += 1
            return res

        ac.st(check(m) - check(m + 1))
        return

    @staticmethod
    def cf_1038d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1038/D
        tag: greedy|implemention|classification_discussion
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        if n == 1:
            ac.st(nums[0])
            return
        if all(num > 0 for num in nums):
            ac.st(sum(nums) - 2 * min(nums))
        elif all(num < 0 for num in nums):
            ac.st(sum(-num for num in nums) + 2 * max(nums))
        else:
            ac.st(sum(abs(num) for num in nums))
        return

    @staticmethod
    def lg_p2512(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2512
        tag: greedy|card_split_average|classical|circular_array
        """
        # 环形均分纸牌问题
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        m = sum(nums) // n
        x = 0
        pre = []
        for i in range(n):
            x += m - nums[i]
            pre.append(x)
        pre.sort()
        y = pre[n // 2]
        ans = sum(abs(num - y) for num in pre)
        ac.st(ans)
        return

    @staticmethod
    def abc_46b(ac=FastIO()):
        # brain_teaser|，不等式greedy
        n = ac.read_int()
        a = b = 1
        for _ in range(n):
            x, y = ac.read_list_ints()
            z1 = a // x + int(a % x > 0)
            z2 = b // y + int(b % y > 0)
            z = max(z1, z2)
            a = z * x
            b = z * y
        ac.st(a + b)
        return

    @staticmethod
    def ac_105(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/1538/
        tag: greedy|card_split_average|classical|circular_array
        """

        def check(nums):
            # 环形均分纸牌
            nn = len(nums)
            s = sum(nums)
            if s % nn:
                return -1
            mm = s // nn
            x = 0
            pre = []
            for i in range(nn):
                x += mm - nums[i]
                pre.append(x)
            pre.sort()
            y = pre[nn // 2]
            ans = sum(abs(num - y) for num in pre)
            return ans

        m, n, t = ac.read_list_ints()
        row = [0] * m
        col = [0] * n
        for _ in range(t):
            xx, yy = ac.read_list_ints_minus_one()
            row[xx] += 1
            col[yy] += 1
        ans1 = check(row)
        ans2 = check(col)
        if ans1 != -1 and ans2 != -1:
            ac.lst(["both", ans1 + ans2])
        elif ans1 != -1:
            ac.lst(["row", ans1])
        elif ans2 != -1:
            ac.lst(["column", ans2])
        else:
            ac.st("impossible")
        return

    @staticmethod
    def ac_123(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/125/
        tag: median_greedy
        """
        # mediangreedy扩展问题，连续相邻sorting减去下标后再sorting
        n = ac.read_int()
        lst_x = []
        lst_y = []
        for _ in range(n):
            x, y = ac.read_list_ints()
            lst_y.append(y)
            lst_x.append(x)
        lst_y.sort()
        mid = lst_y[n // 2]
        ans = sum(abs(pos - mid) for pos in lst_y)

        lst_x.sort()
        lst_x = [lst_x[i] - i for i in range(n)]
        lst_x.sort()
        mid = lst_x[n // 2]
        ans += sum(abs(pos - mid) for pos in lst_x)
        ac.st(ans)
        return

    @staticmethod
    def ac_125(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/127/
        tag: greedy|custom_sort
        """
        # greedy思路，邻项交换
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[0] + it[1])
        ans = -math.inf
        pre = 0
        for w, s in nums:
            ans = max(ans, pre - s)
            pre += w
        ac.st(ans)
        return

    @staticmethod
    def ac_127(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/129/
        tag: partial_order|sort|greedy
        """
        # 二维sortinggreedy
        n, m = ac.read_list_ints()
        machine = [ac.read_list_ints() for _ in range(n)]
        task = [ac.read_list_ints() for _ in range(m)]
        machine.sort(reverse=True)
        task.sort(reverse=True)
        lst = []
        ans = money = j = 0
        for i in range(m):
            tm, level = task[i]
            while j < n and machine[j][0] >= tm:
                insort_left(lst, machine[j][1])
                j += 1
            ind = bisect_left(lst, level)
            if ind < len(lst):
                lst.pop(ind)
                ans += 1
                money += 500 * tm + 2 * level
        ac.lst([ans, money])
        return

    @staticmethod
    def ac_145(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/147/
        tag: heapq|greedy
        """
        # heapq|greedy
        lst = []
        cnt = 0
        while cnt < 10000:
            cur = ac.read_list_ints()
            if not cur:
                cnt += 1
            lst.extend(cur)

        lst = deque(lst)
        while lst:
            n = lst.popleft()
            cur = []
            for _ in range(n):
                p, d = lst.popleft(), lst.popleft()
                cur.append([p, d])
            cur.sort(key=lambda it: it[1])
            stack = []
            for p, d in cur:
                heapq.heappush(stack, p)
                if len(stack) == d + 1:
                    heapq.heappop(stack)
            ac.st(sum(stack))
        return

    @staticmethod
    def lc_2745(x: int, y: int, z: int) -> int:
        """
        url: https://leetcode.cn/problems/construct-the-longest-new-string/
        tag: brain_teaser|greedy
        """
        # brain_teasergreedybrain_teaser|
        return z * 2 + min(x, y) * 4 + int((max(x, y) - min(x, y)) > 0) * 2

    @staticmethod
    def lg_p1080(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1080
        tag: greedy|custom_sort
        """
        # greedy，举例两项确定sorting公式
        n = ac.read_int()
        a, b = ac.read_list_ints()
        lst = [ac.read_list_ints() for _ in range(n)]
        lst.sort(key=lambda x: x[0] * x[1] - x[1])
        ans = 0
        pre = a
        for a, b in lst:
            ans = max(ans, pre // b)
            pre *= a
        ac.st(ans)
        return

    @staticmethod
    def lg_p1650(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1650
        tag: greedy|classical
        """
        # greedy，优先上对上其次下对下最后下对上
        ac.read_int()
        a = deque(sorted(ac.read_list_ints(), reverse=True))
        b = deque(sorted(ac.read_list_ints(), reverse=True))

        ans = 0
        while a and b:
            # 上对上
            if a[0] > b[0]:
                a.popleft()
                b.popleft()
                ans += 200
            # 下对下
            elif a[-1] > b[-1]:
                a.pop()
                b.pop()
                ans += 200
            # 下对上
            else:
                x = a.pop()
                y = b.popleft()
                if x > y:
                    ans += 200
                elif x < y:
                    ans -= 200
        ac.st(ans)
        return

    @staticmethod
    def lg_p2088(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2088
        tag: greedy
        """
        # 队列集合greedy，取空闲的，或者下一个离得最远的
        ans = 0
        k, n = ac.read_list_ints()
        nums = []
        while len(nums) < n:
            nums.extend(ac.read_list_ints())

        busy = set()
        post = defaultdict(deque)
        for i in range(n):
            post[nums[i]].append(i)
        for x in post:
            post[x].append(n)

        for i in range(n):
            if nums[i] in busy:
                continue
            if len(busy) < k:
                busy.add(nums[i])
                continue
            nex = -1
            for x in busy:
                while post[x] and post[x][0] < i:
                    post[x].popleft()
                if nex == -1 or post[x][0] >= post[nex][0]:
                    nex = x
            busy.discard(nex)
            busy.add(nums[i])
            ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p2816(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2816
        tag: sort|greedy|sorted_list
        """
        # sorting后从小到大greedy放置，STL维护当前积木列高度
        lst = SortedList()
        ac.read_int()
        nums = ac.read_list_ints()
        nums.sort()
        for num in nums:
            i = lst.bisect_left(num)
            if (0 <= i < len(lst) and lst[i] > num) or i == len(lst):
                i -= 1
            if 0 <= i < len(lst):
                lst.add(lst.pop(i) + 1)
            else:
                lst.add(1)
        ac.st(len(lst))
        return

    @staticmethod
    def lg_p3819(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3819
        tag: median|greedy
        """
        # mediangreedy题
        length, n = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        s = sum(x for _, x in nums)
        nums.sort()
        pre = 0
        for pos, x in nums:
            pre += x
            if pre >= s // 2:
                ans = sum(abs(x - pos) * y for x, y in nums)
                ac.st(ans)
                break
        return

    @staticmethod
    def lg_p4025(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4025
        tag: greedy|custom_sort
        """
        # greedy血量与增幅custom_sort
        n, z = ac.read_list_ints()
        pos = []
        neg = []
        for i in range(n):
            d, a = ac.read_list_ints()
            if d < a:
                pos.append([d, a, i])
            else:
                neg.append([d, a, i])
        pos.sort(key=lambda it: it[0])
        neg.sort(key=lambda it: -it[1])
        ans = []
        for d, a, i in pos + neg:
            z -= d
            if z <= 0:
                ac.st("NIE")
                return
            z += a
            ans.append(i + 1)
        ac.st("TAK")
        ac.lst(ans)
        return

    @staticmethod
    def lg_p4266(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4266
        tag: greedy|implemention|suffix_max
        """
        # 后缀最大值greedyimplemention
        length, n, rf, rb = ac.read_list_ints()
        nums = [[0, 0]] + [ac.read_list_ints() for _ in range(n)]
        n += 1
        # 记录后缀最大值序列
        post = [n - 1] * n
        ind = n - 1
        for i in range(n - 2, -1, -1):
            post[i] = ind
            if nums[i][1] > nums[ind][1]:
                ind = i
        path = [post[0]]
        while post[path[-1]] != path[-1]:
            path.append(post[path[-1]])
        # implemention
        ans = t = pre = 0
        for i in path:
            cur = nums[i][0]
            c = nums[i][1]
            ans += (cur - pre) * (rf - rb) * c
            t += (cur - pre) * rf
            pre = cur
        ac.st(ans)
        return

    @staticmethod
    def lg_p4447(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4447
        tag: greedy|deque
        """
        # greedy队列使得连续值序列最少的分组长度最大
        ac.read_int()
        lst = ac.read_list_ints()
        lst.sort()
        # 记录末尾值为 num 的连续子序列长度
        cnt = defaultdict(list)
        for num in lst:
            if cnt[num - 1]:
                # 将最小的长度取出添上
                val = heapq.heappop(cnt[num - 1])
                heapq.heappush(cnt[num], val + 1)
            else:
                # 单独成为一个序列
                heapq.heappush(cnt[num], 1)
        ac.st(min(min(cnt[k]) for k in cnt if cnt[k]))
        return

    @staticmethod
    def lg_p4575(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4575
        tag: brain_teaser|state_compression
        """
        # brain_teaser|状压运算
        for _ in range(ac.read_int()):
            m = ac.read_int()
            k = ac.read_int()
            dct = [set() for _ in range(m)]
            for _ in range(k):
                i, j = ac.read_list_ints()
                dct[i].add(j)

            dp = [sum((1 << j) for j in dct[i]) for i in range(m)]
            ans = True
            for i in range(m):
                if not ans:
                    break
                for j in range(i + 1, m):
                    if dp[i] & dp[j] and dp[i] ^ dp[j]:
                        ans = False
                        break
            ac.st("Yes" if ans else "No")
        return

    @staticmethod
    def lg_p4653(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4653
        tag: binary_search|pointer|greedy
        """
        # 看似binary_searchpointergreedy选取
        n = ac.read_int()
        nums1 = []
        nums2 = []
        for _ in range(n):
            x, y = ac.read_list_floats()
            nums1.append(x)
            nums2.append(y)
        nums1.sort(reverse=True)
        nums2.sort(reverse=True)
        # two_pointers选择
        ans = i = j = a = b = 0
        light_a = light_b = 0
        while i < n or j < n:
            if i < n and (a - light_b < b - light_a or j == n):
                a += nums1[i] - 1
                i += 1
                light_a += 1
            else:
                b += nums2[j] - 1
                j += 1
                light_b += 1
            ans = max(ans, min(a - light_b, b - light_a))
        ac.st("%.4f" % ans)
        return

    @staticmethod
    def lg_p5093(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5093
        tag: brain_teaser|classical
        """
        # brain_teaser集合确定轮数
        n, k = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        pre = set()
        ans = 1
        for num in nums:
            pre.add(num)
            if len(pre) == k:
                ans += 1
                pre = set()
        ac.st(ans)
        return

    @staticmethod
    def lg_p5425(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5425
        tag: mst_like|brain_teaser|greedy
        """
        # 看似mst|，实则brain_teasergreedy距离
        n, k = ac.read_list_ints()
        ans = (2019201913 * (k - 1) + 2019201949 * n) % 2019201997
        ac.st(ans)
        return

    @staticmethod
    def lg_p5884(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5884
        tag: brain_teaser|reverse_order|mst
        """
        n = ac.read_int()
        last = [0] * n
        edges = []
        for x in range(n * (n - 1) // 2):
            i, j = ac.read_list_ints()
            if i > j:
                i, j = j, i
            last[i] = x
            edges.append(i*n+j)
        for x, val in enumerate(edges):
            i, j = val//n, val%n
            if last[i] == x:
                ac.st(1)
            else:
                ac.st(0)
        return

    @staticmethod
    def lg_p6196(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6196
        tag: greedy
        """
        # greedy 1 分段代价
        ac.read_int()
        nums = ac.read_list_ints()
        ans = 0
        lst = []
        for num in nums:
            if num == 1:
                if lst:
                    m = len(lst)
                    ans += min(lst)
                    for i in range(1, m):
                        ans += lst[i - 1] * lst[i]
                ans += 1
                lst = []
            else:
                lst.append(num)
        if lst:
            m = len(lst)
            ans += min(lst)
            for i in range(1, m):
                ans += lst[i - 1] * lst[i]
        ac.st(ans)
        return

    @staticmethod
    def lg_p6874(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6874
        tag: median_greedy|brain_teaser
        """
        n = ac.read_int()  # MLE
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        for i in range(n):
            w = abs(i - n // 2)
            a[i] -= w
            b[i] -= w
        a.extend(b)
        del b
        a.sort()
        x = max(0, a[n])
        ac.st(sum(abs(x - num) for num in a))
        return

    @staticmethod
    def lg_p8050(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8050
        tag: brain_teaser|coloring_method|operation
        """
        # brain_teaser黑白coloring_method任意操作不改变黑白元素和的差值
        m1, n1, m2, n2, k = ac.read_list_ints()
        black = white = cnt = state = 0
        for i in range(m1 + m2):
            lst = ac.read_list_ints()
            for j in range(len(lst)):
                if lst[j] != 999999:
                    if (i + j) % 2:
                        black += lst[j]
                        cnt += 1
                    else:
                        white += lst[j]
                else:
                    state = (i + j) % 2
                    cnt += (i + j) % 2
        ans = (2 * cnt - m1 * n1 - m2 * n2) * k - black + white
        if not state:
            ans = -ans
        ac.st(ans)
        return

    @staticmethod
    def lg_p8732(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8732
        tag: greedy|brute_force|custom_sort
        """
        # greedybrute_force两项优先级公式
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: sum(it))
        ans = pre = 0
        for s, a, e in nums:
            pre += s + a
            ans += pre
            pre += e
        ac.st(ans)
        return

    @staticmethod
    def ac_4307(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4310/
        tag: lexicographical_order|brute_force|greedy
        """
        # lexicographical_orderbrute_forcegreedy
        a = [int(w) for w in str(ac.read_int())]
        b = [int(w) for w in str(ac.read_int())]
        a.sort()
        if len(a) < len(b):
            res = a[::-1]
        else:
            n = len(a)
            res = []
            for x in range(n):
                for i in range(n - 1 - x, -1, -1):
                    tmp = a[:]
                    tmp.pop(i)
                    if res + [a[i]] + tmp <= b:
                        res.append(a[i])
                        a.pop(i)
                        break
        ac.st("".join(str(x) for x in res))
        return

    @staticmethod
    def ac_4313(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4316/
        tag: full_binary_tree|tree_dp|greedy|LC2673
        """
        # 满二叉树tree_dpgreedy
        n = ac.read_int()
        m = 2 ** (n + 1)
        dp = [0] * m
        nums = ac.read_list_ints()
        ans = 0
        for i in range(m // 2 - 1, 0, -1):
            left = dp[i * 2] + nums[i * 2 - 2]
            right = dp[i * 2 + 1] + nums[i * 2 - 1]
            x = max(left, right)
            dp[i] = x
            ans += x * 2 - left - right
        ac.st(ans)
        return

    @staticmethod
    def ac_4426(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4429/
        tag: brain_teaser|brain_teaser|property
        """
        # brain_teaser|brain_teaser，等价于末尾两位数字可以被4整除
        s = ac.read_str()
        ans = 0
        n = len(s)
        for i in range(n):
            if i - 1 >= 0 and int(s[i - 1:i + 1]) % 4 == 0:
                ans += i  # 两位数及以上
            if int(s[i]) % 4 == 0:
                ans += 1  # 一位数
        ac.st(ans)
        return

    @staticmethod
    def ac_4427(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4430/
        tag: greedy|construction
        """
        # 树形greedyconstruction
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        parent = ac.read_list_ints_minus_one()
        for i in range(n - 1):
            dct[parent[i]].append(i + 1)
        s = ac.read_list_ints()
        ans = [0] * n

        stack = [[0, 0, 0]]
        while stack:
            x, pre, ss = stack.pop()
            pre += 1
            if pre % 2:  # 奇数位没得选
                ans[x] = s[x] - ss
            else:
                lst = []  # 偶数位greedy取最大值
                for y in dct[x]:
                    lst.append(s[y])
                if lst:
                    ans[x] = min(lst) - ss

            for y in dct[x]:
                stack.append([y, pre, ss + ans[x]])

        ac.st(sum(ans) if all(x >= 0 for x in ans) else -1)
        return

    @staticmethod
    def ac_4429(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4432/
        tag: greedy|custom_sort|prefix_suffix|brute_force
        """
        # 邻项公式greedysorting，prefix_suffixbrute_force
        n, x1, y1, x2, y2 = ac.read_list_ints()
        pos = [ac.read_list_ints() for _ in range(n)]
        dis1 = [(x - x1) * (x - x1) + (y - y1) * (y - y1) for x, y in pos]
        dis2 = [(x - x2) * (x - x2) + (y - y2) * (y - y2) for x, y in pos]
        # sorting
        ind = list(range(n))
        ind.sort(key=lambda it: dis1[it] - dis2[it])
        # 后缀最大值
        post = [0] * (n + 1)
        ceil = 0
        for i in range(n - 1, -1, -1):
            ceil = max(dis2[ind[i]], ceil)
            post[i] = ceil

        # brute_force前缀
        ans = post[0]
        pre = 0
        for i in range(n):
            pre = max(pre, dis1[ind[i]])
            if pre + post[i + 1] < ans:
                ans = pre + post[i + 1]
        ac.st(ans)
        return

    @staticmethod
    def ac_4430(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4433/
        tag: brute_force|prefix_suffix|bracket
        """
        # 括号匹配brute_force，prefix_suffix遍历
        n = ac.read_int()
        s = ac.read_str()
        ans = 0

        # 左变右
        post = [-1] * (n + 1)
        post[n] = 0
        right = 0
        for i in range(n - 1, -1, -1):
            if s[i] == ")":
                right += 1
            else:
                if not right:
                    break
                right -= 1
            post[i] = right

        left = 0
        for i in range(n):
            if s[i] == ")":
                if not left:
                    break
                left -= 1
            else:
                if post[i + 1] + 1 == left and post[i + 1] != -1:
                    ans += 1
                left += 1

        # 右变左
        pre = [-1] * (n + 1)
        pre[0] = 0
        left = 0
        for i in range(n):
            if s[i] == "(":
                left += 1
            else:
                if not left:
                    break
                left -= 1
            pre[i + 1] = left

        right = 0
        for i in range(n - 1, -1, -1):
            if s[i] == "(":
                if not right:
                    break
                right -= 1
            else:
                if pre[i] + 1 == right and pre[i] != -1:
                    ans += 1
                right += 1
        ac.st(ans)
        return

    @staticmethod
    def ac_4492(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4495/
        tag: brain_teaser|odd_even
        """
        # brain_teaser分为奇数与偶数讨论
        n = ac.read_int()
        if n % 2 == 0:
            ac.st(n // 2)
        else:
            lst = NumFactor().get_prime_factor(n)
            x = lst[0][0]
            ac.st(1 + (n - x) // 2)
        return

    @staticmethod
    def ac_4623(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4626/
        tag: greedy|implemention
        """
        # greedyimplemention
        n, t = ac.read_list_ints()
        a = ac.read_list_ints()
        ans = 0
        while a:
            s = sum(a)
            ans += (t // s) * len(a)
            t %= s
            b = []
            for num in a:
                if t >= num:
                    t -= num
                    ans += 1
                    b.append(num)
            a = b[:]
        ac.st(ans)
        return

    @staticmethod
    def cf_1665c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1665/problem/C
        tag: graph|greedy
        """

        def solve():
            n = ac.read_int()
            dct = [[] for _ in range(n)]
            parent = ac.read_list_ints_minus_one()
            for i in range(n - 1):
                dct[parent[i]].append(i + 1)
            lst = [len(dct[i]) for i in range(n) if dct[i]] + [1]
            lst.sort(reverse=True)
            m = len(lst)
            ans = m
            for i in range(m):
                lst[i] -= m - i
            stack = [-x for x in lst if x > 0]
            heapq.heapify(stack)
            cnt = 0
            while stack and -stack[0] > cnt:
                cnt += 1
                x = heapq.heappop(stack)
                x += 1
                if x:
                    heapq.heappush(stack, x)
            ans += cnt
            ac.st(ans)
            return

        for _ in range(ac.read_int()):
            solve()
        return

    @staticmethod
    def lc_858(p: int, q: int) -> int:
        """
        url: https://leetcode.cn/problems/mirror-reflection/description/
        tag: brain_teaser
        """
        # brain_teaserbrain_teaser|

        g = math.gcd(p, q)
        # 求解等式 k*p = m*q

        # 左右次数k合计为偶数
        k = p // g
        if k % 2 == 0:
            return 2

        # 上下次数m合计为偶数
        m = q // g
        if m % 2 == 0:
            return 0
        return 1

    @staticmethod
    def lc_991(start: int, target: int) -> int:
        """
        url: https://leetcode.cn/problems/broken-calculator/
        tag: reverse_order|reverse_thinking|greedy|odd_even|implemention
        """
        # 逆向greedy，偶数除2奇数|1
        ans = 0
        while target > start:
            if target % 2:
                target += 1
            else:
                target //= 2
            ans += 1
        return ans + start - target

    @staticmethod
    def lc_1503(n: int, left: List[int], right: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/last-moment-before-all-ants-fall-out-of-a-plank/
        tag: brain_teaser|classical
        """
        # 
        ans = 0
        for x in left:
            if x > ans:
                ans = x
        for x in right:
            if n - x > ans:
                ans = n - x
        return ans

    @staticmethod
    def lc_1675(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimize-deviation-in-array/
        tag: brain_teaser|greedy
        """
        # brain_teaserbrain_teaser|greedy
        lst = SortedList([num if num % 2 == 0 else num * 2 for num in nums])
        ans = lst[-1] - lst[0]
        while True:
            cur = lst[-1] - lst[0]
            ans = ans if ans < cur else cur
            if lst[-1] % 2:
                break
            lst.add(lst.pop() // 2)
        return ans

    @staticmethod
    def lc_1808(prime_factors: int) -> int:
        """
        url: https://leetcode.cn/problems/maximize-number-of-nice-divisors/
        tag: mod|greedy|classical|maximum_mul
        """
        # 按照模3的因子个数greedy处理，将和拆分成最大乘积
        mod = 10 ** 9 + 7
        if prime_factors <= 2:
            return prime_factors
        if prime_factors % 3 == 0:
            return pow(3, prime_factors // 3, mod)
        elif prime_factors % 3 == 1:
            return (4 * pow(3, prime_factors // 3 - 1, mod)) % mod
        else:
            return (2 * pow(3, prime_factors // 3, mod)) % mod

    @staticmethod
    def lc_1927(num: str) -> bool:
        """
        url: https://leetcode.cn/problems/sum-game/description/
        tag: game_dp|brain_teaser|classification_discussion
        """

        # 博弈brain_teaser|classification_discussion
        def check(s):
            res = 0
            cnt = 0
            for w in s:
                if w.isnumeric():
                    res += int(w)
                else:
                    cnt += 1
            return [res, cnt]

        # 左右两边的数字和以及问号个数
        n = len(num)
        a, x = check(num[:n // 2])
        b, y = check(num[n // 2:])

        # Alice把宝压在右边
        b_add = 9 * (y // 2 + y % 2)
        if y % 2 == 0:
            a_add = 9 * (x // 2)
        else:
            a_add = 9 * (x // 2 + x % 2)
        if a + a_add < b + b_add:
            return True

        # Alice把宝压在左边
        a_add = 9 * (x // 2 + x % 2)
        if x % 2 == 0:
            b_add = 9 * (y // 2)
        else:
            b_add = 9 * (y // 2 + y % 2)
        if b + b_add < a + a_add:
            return True

        # 左右都不能获胜
        return False

    @staticmethod
    def lc_2592(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximize-greatness-of-an-array/
        tag: classical|greedy|sort|two_pointers
        """
        # classicalgreedysorting后two_pointers
        n = len(nums)
        nums.sort()
        j = 0
        ans = 0
        for i in range(n):
            while j < n and nums[i] >= nums[j]:
                j += 1
            if j < n:
                ans += 1
                j += 1
        return ans

    @staticmethod
    def lc_2568(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-impossible-or/
        tag: brain_teaser|greedy|guess|watch_pattern
        """
        # brain_teasergreedy，可以根据打表观察规律
        dct = set(nums)
        for i in range(34):
            if 1 << i not in dct:
                return 1 << i
        return -1

    @staticmethod
    def lg_p1286(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1286
        tag: brain_teaser|sorted_list
        """
        while True:
            nums = ac.read_list_strs()
            if not nums:
                break
            n = int(nums[0])
            nums = sorted([int(x) for x in nums[1:]])
            s = sum(nums) // (n - 1)

            def check():
                ans = [a1]
                lst = SortedList(nums)
                for _ in range(n - 1):
                    x = lst[0] - ans[0]
                    if x >= ans[-1]:
                        ans.append(x)
                        for num in ans[:-1]:
                            j = lst.bisect_left(num + x)
                            if not (0 <= j < len(lst) and lst[j] == num + x):
                                return []
                            lst.pop(j)
                    else:
                        return []
                return ans

            for a1 in range(0, s // n + 1):
                res = check()
                if res:
                    ac.lst(res)
                    break
            else:
                ac.st("Impossible")
        return

    @staticmethod
    def cf_1929d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1920/problem/D
        tag: data_range|brute_force|reverse_thinking
        """
        ceil = 10 ** 18
        for _ in range(ac.read_int()):
            ac.get_random_seed()
            n, q = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(n)]
            queries = ac.read_list_ints()
            c = 0
            ops = []
            for i in range(n):
                b, x = nums[i]
                if b == 2:
                    ops.append([2, x + 1, i, i])
                    c *= (x + 1)
                else:
                    if not ops or ops[-1][0] != 1:
                        ops.append([1, 1, i, i])
                    else:
                        ops[-1][1] += 1
                        ops[-1][-1] = i
                    c += 1
                if c > ceil:
                    break

            ans = [0] * q
            m = len(ops)
            for i, kk in enumerate(queries):

                cc = c
                for ii in range(m - 1, -1, -1):
                    bb, xx, ss, tt = ops[ii]
                    if bb == 2:
                        if cc // xx > kk:
                            cc //= xx
                        else:
                            kk = kk % (cc // xx)
                            if kk == 0:
                                kk = (cc // xx)
                            cc //= xx
                    else:
                        if cc - xx >= kk:
                            cc -= xx
                        else:
                            cc -= xx
                            ans[i] = nums[ss + kk - cc - 1][1]
                            break
            ac.lst(ans)
        return

    @staticmethod
    def lc_3012(nums: List[int]) -> int:
        """
        url: https://leetcode.com/problems/minimize-length-of-array-using-operations/
        tag: brain_teaser|perishu_theorem|hard|greedy
        """
        low = min(nums)
        gcd = reduce(math.gcd, nums)
        if gcd < low:
            return 1
        cnt = nums.count(low)
        return (cnt + 1) // 2

    @staticmethod
    def cf_724d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/724/problem/D
        tag: greedy|implemention|brain_teaser
        """
        m = ac.read_int()
        s = ac.read_str()
        n = len(s)
        for i in range(26):
            ind = []
            w = chr(i + ord("a"))
            diff = [0] * n
            for j in range(n):
                if ord(s[j]) - ord("a") <= i:
                    ind.append(j)
                    diff[j] = 1
            pre = ac.accumulate(diff)
            if all(pre[i + 1] - pre[i - m + 1] > 0 for i in range(m - 1, n)):
                stack = [-1]
                for j in ind:
                    while len(stack) >= 2 and s[stack[-1]] == w and j - stack[-2] <= m:
                        stack.pop()
                    stack.append(j)
                while len(stack) >= 2 and s[stack[-1]] == w and stack[-2] >= n - m:
                    stack.pop()
                lst = [s[x] for x in stack[1:]]
                lst.sort()
                ac.st("".join(lst))
                return
        return

    @staticmethod
    def cf_1144g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1144/problem/G
        tag: linear_dp|greedy|classical|construction|brain_teaser
        """
        ascend = -math.inf
        descend = math.inf
        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = [0] * n
        for i in range(n):
            if ascend < nums[i] and descend <= nums[i]:
                ascend = nums[i]
            elif ascend >= nums[i] and descend > nums[i]:
                descend = nums[i]
                ans[i] = 1
            elif ascend < nums[i] < descend:
                if i + 1 < n and nums[i + 1] < nums[i]:
                    ans[i] = 1
                    descend = nums[i]
                else:
                    ascend = nums[i]
            else:
                ac.no()
                break
        else:
            ac.yes()
            ac.lst(ans)
        return

    @staticmethod
    def cf_1157g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1157/problem/G
        tag: brain_teaser|brute_force|classical|implemention|greedy
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]

        tmp = [g[:] for g in grid]
        row = [0] * m
        col = [0] * n
        for j in range(n):  # first_row = 0
            if tmp[0][j]:
                col[j] = 1
                for i in range(m):
                    tmp[i][j] = 1 - tmp[i][j]

        cnt = 0
        for i in range(1, m):
            if cnt >= 2:
                break
            dct = set(tmp[i])
            if len(dct) == 1:
                if cnt:
                    if dct != {1}:
                        row[i] = 1
                else:
                    if dct != {0}:
                        row[i] = 1
                continue
            pre = tmp[i][0]
            cur = 1
            for num in tmp[i][1:]:
                if num != pre:
                    cur += 1
                pre = num
                if cur > 2:
                    break
            if cur > 2:
                cnt = 2
            else:
                if tmp[i][0]:
                    row[i] = 1
                cnt += 1
        if cnt <= 1:
            ac.yes()
            ac.st("".join(str(x) for x in row))
            ac.st("".join(str(x) for x in col))
            return

        tmp = [g[:] for g in grid]  # last_row = 1
        row = [0] * m
        col = [0] * n
        for j in range(n):
            if tmp[-1][j] == 0:
                col[j] = 1
                for i in range(m):
                    tmp[i][j] = 1 - tmp[i][j]

        cnt = 0
        for i in range(m - 2, -1, -1):
            if cnt >= 2:
                break
            dct = set(tmp[i])
            if len(dct) == 1:
                if cnt:
                    if dct != {0}:
                        row[i] = 1
                else:
                    if dct != {1}:
                        row[i] = 1
                continue
            pre = tmp[i][0]
            cur = 1
            for num in tmp[i][1:]:
                if num != pre:
                    cur += 1
                pre = num
                if cur > 2:
                    break
            if cur > 2:
                cnt = 2
            else:
                if tmp[i][0]:
                    row[i] = 1
                cnt += 1
        if cnt <= 1:
            ac.yes()
            ac.st("".join(str(x) for x in row))
            ac.st("".join(str(x) for x in col))
            return
        ac.no()
        return

    @staticmethod
    def cf_1157f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1157/problem/F
        tag: greedy|brain_teaser|construction|specific_plan
        """
        ac.read_int()
        a = ac.read_list_ints()
        m = 2 * 10 ** 5
        cnt = [0] * (m + 1)
        for num in a:
            cnt[num] += 1
        ans = 0
        res = [-1, -1]
        pre = c = 0
        for num in range(1, m + 1):
            if cnt[num]:
                cur = c + cnt[num]
                if cur > ans:
                    ans = cur
                    res = [num - pre, num]
                if cnt[num] > 1:
                    pre += 1
                    c += cnt[num]
                else:
                    pre = 1
                    c = 1
            else:
                pre = c = 0
        ac.st(ans)
        lst = [res[0]]
        cnt[res[0]] -= 1
        for i in range(res[0] + 1, res[1] + 1):
            lst.append(i)
            cnt[i] -= 1
        for i in range(res[1], res[0] - 1, -1):
            lst.extend([i] * cnt[i])
        ac.lst(lst)
        return

    @staticmethod
    def cf_1183f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1183/problem/F
        tag: greedy|brain_teaser|classical|brute_force|special_judge
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            ceil = max(nums)
            ans = ceil
            for num in nums:
                if ceil % num:
                    if num + ceil > ans:
                        ans = num + ceil
            if ceil % 30 == 0 and ceil // 2 in nums and ceil // 3 in nums and ceil // 5 in nums:
                x, y, z = ceil // 2, ceil // 3, ceil // 5
                if x % y and y % z and x % z:
                    cur = x + y + z
                    if cur > ans:
                        ans = cur

            nums = [num for num in nums if ceil % num]
            if nums:
                ceil2 = max(nums)
                for num in nums:
                    if ceil2 % num:
                        if num + ceil2 + ceil > ans:
                            ans = num + ceil2 + ceil
            ac.st(ans)

        return

    @staticmethod
    def cf_1883f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1883/problem/F
        tag: brain_teaser|prefix_suffix
        """
        ac.get_random_seed()
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()

            last = dict()
            for i in range(n):
                last[nums[i] ^ ac.random_seed] = i

            first = dict()
            for i in range(n - 1, -1, -1):
                first[nums[i] ^ ac.random_seed] = i

            ans = pre = 0
            for i in range(n):
                if first[nums[i] ^ ac.random_seed] == i:
                    pre += 1
                if last[nums[i] ^ ac.random_seed] == i:
                    ans += pre

            ac.st(ans)
        return

    @staticmethod
    def abc_293f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc293/tasks/abc293_f
        tag: binary_search|brute_force|brain_teaser|classical
        """
        assert 1 << 64 > 10 ** 18

        def compute(bb):
            res = 0
            for w in cur:
                res = res * bb + w
            return res

        def check(bb):
            return compute(bb) >= n

        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = {n, n - 1}

            for num in range(2, 1 << 5):
                cur = [int(w) for w in bin(num)[2:]]
                x = BinarySearch().find_int_left(0, n, check)
                if compute(x) == n:
                    ans.add(x)

            for x in range(5, 65):
                if 1 << x > n:
                    break
                high = int(n ** (1 / x))
                low = int(n ** (1 / (x + 1)))
                for b in range(max(low, 2), min(high + 10, n - 1)):
                    num = n
                    while num:
                        if num % b > 1:
                            break
                        num //= b
                    else:
                        ans.add(b)

            ac.st(len([x for x in ans if x >= 2]))
        return

    @staticmethod
    def abc_252f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc252/tasks/abc252_f
        tag: greedy|small_to_big|reverse_order|classical
        """
        n, ll = ac.read_list_ints()
        nums = ac.read_list_ints()
        tot = sum(nums)
        if ll > tot:
            nums.append(ll - tot)
        heapify(nums)
        ans = 0
        while len(nums) >= 2:
            a, b = heappop(nums), heappop(nums)
            ans += a + b
            heappush(nums, a + b)
        ac.st(ans)
        return

    @staticmethod
    def abc_349d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc349/tasks/abc349_d
        tag: greedy|brain_teaser
        """
        lst = []
        for _ in range(3):
            lst.extend(ac.read_list_ints())
        ind = list()
        ind.append([[i, i] for i in range(3)])
        ind.append([[i, 2 - i] for i in range(3)])
        ind.extend([[i, j] for j in range(3)] for i in range(3))
        ind.extend([[i, j] for i in range(3)] for j in range(3))
        ll, rr = ac.read_list_ints()
        ans = []
        while ll < rr:
            for i in range(60, -1, -1):
                if ll % (1 << i) == 0 and ll + (1 << i) <= rr:
                    ans.append((ll, ll + (1 << i)))
                    ll += 1 << i
                    break
        ac.st(len(ans))
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def abc_249f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc249/tasks/abc249_f
        tag: greedy|implemention|reverse_order|classical
        """
        n, k = ac.read_list_ints()
        not_use = []
        post = 0
        nums = [[1, 0]] + [ac.read_list_ints() for _ in range(n)]
        nums.reverse()
        ans = -math.inf
        for t, y in nums:
            if t == 1:
                while len(not_use) > k:
                    x = heapq.heappop(not_use)
                    post -= x
                k -= 1
                ans = max(ans, post + y)
                if k < 0:
                    break
            else:
                if y >= 0:
                    post += y
                else:
                    heapq.heappush(not_use, -y)
        ac.st(ans)
        return

    @staticmethod
    def abc_229g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc229/tasks/abc229_g
        tag: implemention|median_greedy|two_pointers|classical|prefix_sum
        """
        s = ac.read_str()
        k = ac.read_int()
        n = len(s)
        ind = [i for i in range(n) if s[i] == "Y"]
        m = len(ind)
        pre = ac.accumulate(ind)

        def check(x, y):
            mid = (x + y) // 2
            res = 0
            cnt = mid - x
            if cnt:
                start = ind[mid] - cnt
                res += (start + start + cnt - 1) * cnt // 2 - (pre[mid] - pre[x])

            cnt = y - mid
            if cnt:
                start = ind[mid] + 1
                res += -(start + start + cnt - 1) * cnt // 2 + (pre[y + 1] - pre[mid + 1])
            return res

        ans = j = 0
        for i in range(m):
            if j < i:
                j = i
            while j + 1 < m and check(i, j + 1) <= k:
                j += 1
            ans = max(ans, j - i + 1)
        ac.st(ans)
        return

    @staticmethod
    def cf_1974g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1974/problem/G
        tag: regret_heapq|implemention|brain_teaser|classical
        """
        for _ in range(ac.read_int()):
            m, x = ac.read_list_ints()
            nums = ac.read_list_ints()
            stack = []
            ans = 0
            pre = x
            for num in nums[1:]:
                if pre >= num:
                    ans += 1
                    pre -= num
                    heapq.heappush(stack, -num)
                elif stack and -stack[0] > num:
                    pre -= heapq.heappop(stack)
                    ans -= 1
                    if pre >= num:
                        ans += 1
                        pre -= num
                        heapq.heappush(stack, -num)
                pre += x
            ac.st(ans)
        return

    @staticmethod
    def cf_1976b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1976/problem/B
        tag: brute_force|greedy
        """
        for _ in range(ac.read_int()):
            ac.get_random_seed()
            n = ac.read_int()
            a = ac.read_list_ints()
            b = ac.read_list_ints()
            tot = sum(abs(a[i] - b[i]) for i in range(n))
            ans = math.inf
            target = b[-1]
            for i in range(n):
                num = a[i]
                cur = tot - abs(a[i] - b[i])
                bb = b[i]
                if num <= target <= b[i] or num >= target >= b[i]:
                    cur += 1 + abs(a[i] - b[i])
                else:
                    if target <= num <= bb or bb <= num <= target:
                        cur += abs(num - target) + 1 + abs(a[i] - b[i])
                    else:
                        cur += abs(bb - target) + 1 + abs(a[i] - b[i])
                ans = min(ans, cur)
            ac.st(ans)
        return

    @staticmethod
    def abc_209c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc209/tasks/abc209_c
        tag: greedy|brain_teaser
        """
        ac.read_int()
        nums = ac.read_list_ints()
        nums.sort()
        mod = 10 ** 9 + 7
        ans = 1
        for i, num in enumerate(nums):
            if num <= i:
                ans = 0
                break
            ans *= (num - i)
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_985c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/985/C
        tag: greedy|brain_teaser|reverse_order
        """
        n, k, ll = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums.sort()
        post = ans = 0
        ceil = nums[0] + ll
        for i in range(n * k - 1, -1, -1):
            if nums[i] <= ceil and post >= k - 1:
                post -= k - 1
                ans += nums[i]
            else:
                post += 1
        ac.st(ans if post == 0 else 0)
        return

    @staticmethod
    def cf_1156c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1156/C
        tag: greedy|two_pointers|classical|brain_teaser
        """
        n, z = ac.read_list_ints()
        nums = ac.read_list_ints()
        nums.sort()
        ans = 0
        j = n//2
        for i in range(n//2):
            while j < n and nums[j] < z + nums[i]:
                j += 1
            if j < n:
                ans += 1
                j += 1
            else:
                break
        ac.st(ans)
        return

    @staticmethod
    def cf_1684d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1684/D
        tag: greedy|observation|contribution_method
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()
            ind = list(range(n))
            ind.sort(key=lambda it: nums[it] - (n - it - 1), reverse=True)
            for i in ind[:k]:
                nums[i] = 0
            ans = pre = 0
            for i in range(n):
                if nums[i] == 0:
                    pre += 1
                else:
                    ans += nums[i] + pre
            ac.st(ans)
        return

    @staticmethod
    def cf_1379c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1379/problem/C
        tag: observation|prefix_sum|binary_search|brute_force|greedy
        """
        q = ac.read_int()
        for i in range(q):
            n, m = ac.read_list_ints()
            nums = [ac.read_list_ints() for _ in range(m)]
            if i < q - 1:
                ac.read_str()
            lst = [a for a, _ in nums]
            lst.sort()
            if n == 1:
                ac.st(max(lst))
                continue

            pre = ac.accumulate(lst)
            ans = max(lst[-n:])
            for a, b in nums:
                rest = n - 2
                cur = a + b
                i = bisect.bisect_left(lst, b)
                x = min(rest, m - i)
                cur += pre[m] - pre[m - x]
                if x and a > b:
                    x -= 1
                    cur -= a
                rest -= x
                cur += rest * b
                ans = max(ans, cur)
            ac.st(ans)
        return

    @staticmethod
    def cf_1415d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1415/D
        tag: observation|bit_operation|data_range
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        if n > 65:
            ac.st(1)
            return
        pre = [0] * (n + 1)
        for i in range(n):
            pre[i + 1] = pre[i] ^ nums[i]

        ans = math.inf
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(i, j):
                    if pre[k + 1] ^ pre[i] > pre[j + 1] ^ pre[k + 1]:
                        ans = min(ans, j - i - 1)
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p2968(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2968
        tag: greedy|implemention|observation
        """
        pos = 0
        speed = 1
        ans = 1
        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(k)]
        nums.sort()
        for i in range(k - 2, -1, -1):
            nums[i][1] = min(nums[i][1], nums[i + 1][1] + (nums[i + 1][0] - nums[i][0]))
        for p, s in nums:
            x = min((p + s - pos - speed) // 2, p - pos)
            ans = max(ans, speed + x)
            speed = min(speed + x, s)
            pos = p
        ans = max(ans, speed + n - pos)
        ac.st(ans)
        return

    @staticmethod
    def lg_p4823(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4823
        tag: greedy|regret_heapq|classical|brain_teaser
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        h = ac.read_int()
        nums.sort(key=lambda x: x[0] + x[1])
        post = [0] * (n + 1)
        for i in range(n - 1, -1, -1):
            post[i] = post[i + 1] + nums[i][0]
        ans = tot = 0
        stack = []
        for i, (a, b) in enumerate(nums):
            if tot + post[i] + b >= h:
                heappush(stack, -a)
                ans += 1
            else:
                if stack and -stack[0] > a:
                    tot -= heappop(stack)
                    heappush(stack, -a)
                else:
                    tot += a
        ac.st(ans)
        return

    @staticmethod
    def lg_p6002(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6002
        tag: brute_force|greedy|brain_teaser
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = 0
        for x in range(1, 1001):
            cur = sum(num // x for num in nums)
            if cur >= k:
                ans = max(ans, x * k // 2)
            elif cur >= k // 2:
                lst = sorted([num % x for num in nums], reverse=True)
                ans = max(ans, (cur - k // 2) * x + sum(lst[:k - cur]))
            else:
                break
        ac.st(ans)
        return

    @staticmethod
    def cf_1257d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1257/D
        tag: suffix_max|greedy|implemention|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            m = ac.read_int()
            post = [0] * (n + 1)
            for _ in range(m):
                p, s = ac.read_list_ints()
                post[s] = max(post[s], p)
            for i in range(n - 1, -1, -1):
                post[i] = max(post[i], post[i + 1])
            if max(nums) > post[1]:
                ac.st(-1)
                continue
            ans = i = 0
            while i < n:
                j = i
                cur = nums[i]
                while j + 1 < n and max(cur, nums[j + 1]) <= post[j - i + 2]:
                    cur = max(cur, nums[j + 1])
                    j += 1
                ans += 1
                i = j + 1
            ac.st(ans)
        return

    @staticmethod
    def cf_1539d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1539/D
        tag: greedy|two_pointers|implemention
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: -it[1])
        i, j = 0, n - 1
        ans = 0
        cost = 0
        while i <= j:
            if nums[j][0] == 0:
                j -= 1
                continue
            if nums[i][0] == 0:
                i += 1
                continue
            if ans >= nums[j][1]:
                ans += nums[j][0]
                cost += nums[j][0]
                nums[j][0] = 0
                j -= 1
                continue
            cur = min(nums[j][1] - ans, nums[i][0])
            ans += cur
            cost += cur * 2
            nums[i][0] -= cur

        ac.st(cost)
        return

    @staticmethod
    def cf_865d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/865/D
        tag: regret_heapq|greedy|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ans = 0
        pre = []
        for num in nums:
            if pre and num > pre[0]:
                cur = heappop(pre)
                ans += num - cur
                heappush(pre, num)
            heappush(pre, num)
        ac.st(ans)
        return

    @staticmethod
    def cf_713c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/713/C
        tag: greedy|brain_teaser|strictly_monotonic_trick|classical
        """
        n = ac.read_int()
        ans = 0
        stack = []
        nums = ac.read_list_ints()
        for i in range(n):
            x = nums[i] - i  # important
            heappush(stack, -x)
            if stack and x < -stack[0]:
                heappush(stack, -x)
                ans += -heappop(stack) - x
        ac.st(ans)
        return

    @staticmethod
    def cf_13c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/13/C
        tag: greedy|brain_teaser|regret_heapq|classical
        """
        n = ac.read_int()
        ans = 0
        stack = []
        nums = ac.read_list_ints()
        for i in range(n):
            x = nums[i]
            heappush(stack, -x)
            if stack and x < -stack[0]:
                heappush(stack, -x)
                ans += -heappop(stack) - x
        ac.st(ans)
        return
"""

Algorithm：longest_increasing_subsequence|lis|lds|longest_decreasing_subsequence|longest_monotonic_subsequence|lms
Description：longest_non_increasing_subsequence|longest_non_decreasing_subsequence|dilworth|lexicographical_order
Dilworth：
minimum_group_non_decreasing_subsequence_partition=length_of_longest_increasing_subsequence
minimum_group_non_increasing_subsequence_partition=length_of_longest_decreasing_subsequence
minimum_group_increasing_subsequence_partition=length_of_longest_non_increasing_subsequence
minimum_group_decreasing_subsequence_partition=length_of_longest_non_decreasing_subsequence

====================================LeetCode====================================
354（https://leetcode.cn/problems/russian-doll-envelopes/）partial_order|lis
673（https://leetcode.cn/problems/number-of-longest-increasing-subsequence/）lis|counter|O(nlogn)|classical
1092（https://leetcode.cn/problems/shortest-common-supersequence/）lcs_by_lis|super_sequence
1671（https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/）lis|prefix_suffix
2111（https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/）lis|dp|greedy
17（https://leetcode.cn/problems/circus-tower-lcci/）partial_order|greedy|sort|lis
1691（https://leetcode.cn/problems/maximum-height-by-stacking-cuboids/submissions/）md_partial_order
1713（https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/）lcs_by_lis
1940（https://leetcode.cn/problems/longest-common-subsequence-between-sorted-arrays/）lcs_by_lis
2826（https://leetcode.cn/problems/sorting-three-groups/）longest_non_decreasing_subsequence|classical
1964（https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/）lis
2945（https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/description/）linear dp|deque|greedy|prefix_sum
1035（https://leetcode.cn/problems/uncrossed-lines/description/）lcs|classical
3288（https://leetcode.cn/problems/length-of-the-longest-increasing-path/）lis|partial_order|classical

===================================CodeForces===================================
1682C（https://codeforces.com/contest/1682/problem/C）lis|lds|greedy|counter
486E（https://codeforces.com/problemset/problem/486/E）lis|greedy|brain_teaser|classical
650D（https://codeforces.com/problemset/problem/650/D）lis|brain_teaser|classical|offline_query
1922E（https://codeforces.com/problemset/problem/1922/E）lis|construction|divide_and_conquer

=====================================LuoGu======================================
P1020（https://www.luogu.com.cn/problem/P1020）greedy|binary_search|longest_non_increasing_subsequence|longest_non_decreasing_subsequence
P1439（https://www.luogu.com.cn/problem/P1439）greedy|binary_search|lis
P1091（https://www.luogu.com.cn/problem/P1091）prefix_suffix|lis
P1233（https://www.luogu.com.cn/problem/P1233）partial_order|lis
P2782（https://www.luogu.com.cn/problem/P2782）partial_order|lis
P3902（https://www.luogu.com.cn/problem/P3902）lis
P6403（https://www.luogu.com.cn/problem/P6403）longest_non_decreasing_subsequence
P5939（https://www.luogu.com.cn/problem/P5939）lis
P5978（https://www.luogu.com.cn/problem/P5978）lis|greedy|brute_force
P7957（https://www.luogu.com.cn/problem/P7957）lis|lds|construction
P1410（https://www.luogu.com.cn/problem/P1410）dilworth|lis
P2516（https://www.luogu.com.cn/problem/P2516）length_of_lcs|cnt_of_lcs
P1108（https://www.luogu.com.cn/problem/P1108）matrix_dp|lis|classical|brain_teaser

=====================================AcWing=====================================
3549（https://www.acwing.com/problem/content/3552/）liner_dp|greedy
2694（https://www.acwing.com/problem/content/description/2696/）lcs_by_lis|counter|dp
3662（https://www.acwing.com/problem/content/description/3665/）lis|counter|discretization|tree_array|liner_dp|segment_tree

====================================AtCoder=====================================
ABC134E（https://atcoder.jp/contests/abc134/tasks/abc134_e）minimum_group_increasing_subsequence_partition|length_of_longest_non_increasing_subsequence
ABC354F（https://atcoder.jp/contests/abc354/tasks/abc354_f）lis|classical
ABC360G（https://atcoder.jp/contests/abc360/tasks/abc360_g）lis|greedy|implemention|classical|linear_dp|prefix_suffix

（https://www.nowcoder.com/questionTerminal/30fb9b3cab9742ecae9acda1c75bf927?orderByHotValue=1&questionTypes=000100&difficulty=11111&mutiTagIds=593&page=10&onlyReference=false）lis|lexicographical_order

"""

import bisect
import random
from collections import deque, Counter
from itertools import accumulate

from typing import List

from src.data_structure.segment_tree.template import RangeAscendRangeMax
from src.data_structure.tree_array.template import PointAscendPreMax
from src.greedy.longest_increasing_subsequence.template import LongestIncreasingSubsequence, LcsComputeByLis
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_134e(ac=FastIO()):
        # 分成最少组数的上升子序列，等于最长不上升的子序列长度
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        ans = LongestIncreasingSubsequence().definitely_not_increase(nums)
        ac.st(ans)
        return

    @staticmethod
    def lc_1713(target: List[int], arr: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/
        tag: lcs_by_lis
        """
        # 最长递增子序列模板题
        ind = {num: i for i, num in enumerate(target)}
        lst = [ind[num] for num in arr if num in ind]
        return len(target) - LongestIncreasingSubsequence().definitely_increase(lst)

    @staticmethod
    def lc_1964(obstacles: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/find-the-longest-valid-obstacle-course-at-each-position/
        tag: lis
        """
        # LIS求以每个位置结尾的最长不降子序列长度
        pre = []
        dp = []
        for num in obstacles:
            i = bisect.bisect_right(dp, num)
            if 0 <= i < len(dp):
                dp[i] = num
                pre.append(i + 1)
            else:
                dp.append(num)
                pre.append(len(dp))
        return pre

    @staticmethod
    def lc_2111(arr: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-operations-to-make-the-array-k-increasing/
        tag: lis|dp|greedy
        """
        # 最长不降子序列
        ans = 0
        for i in range(k):
            lst = arr[i::k]
            ans += len(lst) - LongestIncreasingSubsequence().definitely_not_reduce(lst)
        return ans

    @staticmethod
    def lc_2826(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/sorting-three-groups/
        tag: longest_non_decreasing_subsequence|classical
        """
        # 转换为求最长不降子序列
        n = len(nums)
        return n - LongestIncreasingSubsequence().definitely_not_reduce(nums)

    @staticmethod
    def lc_2945(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/find-maximum-non-decreasing-array-length/description/
        tag: linear dp|deque|greedy|prefix_sum
        """
        n = len(nums)
        stack = deque([0])
        dp = [0] * (n + 1)
        last = [0] * (n + 1)
        pre = list(accumulate(nums, initial=0))
        for i in range(n):
            while len(stack) > 1 and last[stack[1]] + pre[stack[1]] <= pre[i + 1]:
                stack.popleft()
            dp[i + 1] = dp[stack[0]] + 1
            last[i + 1] = pre[i + 1] - pre[stack[0]]
            while stack and last[stack[-1]] + pre[stack[-1]] >= last[i + 1] + pre[i + 1]:
                stack.pop()
            stack.append(i + 1)
        return dp[n]

    @staticmethod
    def lc_p1020(ac=FastIO()):
        # 根据 dilworth 最长不升子序列的长度与分成不降子序列的最小组数（最长上升子序列的长度）
        nums = ac.read_list_ints()
        lis = LongestIncreasingSubsequence()
        ac.st(lis.definitely_not_increase(nums))
        ac.st(lis.definitely_increase(nums))
        return

    @staticmethod
    def lg_1439(ac=FastIO()):
        # 最长公共子序列求解hash映射转换为最长上升子序列
        n = ac.read_int()
        nums = ac.read_list_ints()
        ind = [0] * (n + 1)
        for i, num in enumerate(nums):
            ind[num] = i
        nums = [ind[x] for x in ac.read_list_ints()]
        ac.st(LongestIncreasingSubsequence().definitely_increase(nums))
        return

    @staticmethod
    def lg_p5939(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5939
        tag: lis
        """
        # 旋转后转换为 LIS 问题
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums = [[x + y, y - x] for x, y in nums]
        nums.sort(key=lambda it: [it[0], -it[1]])
        dp = []
        for _, y in nums:
            i = bisect.bisect_left(dp, y)
            if 0 <= i < len(dp):
                dp[i] = y
            else:
                dp.append(y)
        ac.st(len(dp))
        return

    @staticmethod
    def lg_p5978(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5978
        tag: lis|greedy|brute_force
        """
        #  LIS 变形问题，greedybrute_force前半部分
        n, x = ac.read_list_ints()
        nums = ac.read_list_ints()
        # preprocess后缀部分的最长 LIS 序列
        post = [0] * (n + 1)
        dp = []
        for i in range(n - 1, -1, -1):
            j = bisect.bisect_left(dp, -nums[i])
            post[i] = j + 1
            if 0 <= j < len(dp):
                dp[j] = -nums[i]
            else:
                dp.append(-nums[i])

        # greedy减少前缀值并维护最长子序列
        ans = max(post)
        dp = []
        for i in range(n):
            j = bisect.bisect_left(dp, nums[i])
            ans = max(ans, j + post[i])
            j = bisect.bisect_left(dp, nums[i] - x)
            if 0 <= j < len(dp):
                dp[j] = nums[i] - x
            else:
                dp.append(nums[i] - x)
        ac.st(ans)
        return

    @staticmethod
    def lg_p7957(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7957
        tag: lis|lds|construction
        """
        #  LMS 逆问题construction
        n, k = ac.read_list_ints()
        if k * k < n:
            ac.st(-1)
            return
        ans = []
        x = 1
        while len(ans) < n:
            rest = min(n - len(ans), k)
            for y in range(x + rest - 1, x - 1, -1):
                ans.append(y)
            x = x + rest
        ac.lst(ans)
        return

    @staticmethod
    def cf_1682c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1682/problem/C
        tag: lis|lds|greedy|counter
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            cnt = Counter([num ^ ac.random_seed for num in nums])
            s = t = 0
            for va in cnt.values():
                if va >= 2:
                    s += 1
                else:
                    t += 1
            ac.st(s + (t + 1) // 2)
        return

    @staticmethod
    def lc_673(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-longest-increasing-subsequence/
        tag: lis|counter|O(nlogn)|classical
        """
        return LcsComputeByLis().length_and_cnt_of_lis(nums)

    @staticmethod
    def lc_1092(str1: str, str2: str) -> str:
        """
        url: https://leetcode.cn/problems/shortest-common-supersequence/
        tag: lcs_by_lis|super_sequence
        """
        # 利用LIS求LCS的最短公共超序列
        if len(str1) > len(str2):
            str1, str2 = str2, str1
        lcs_lis = LcsComputeByLis().index_of_lcs(str1, str2)
        i = j = 0
        ans = ""
        for ind in lcs_lis:
            w = str2[ind]
            while str1[i] != w:
                ans += str1[i]
                i += 1
            while str2[j] != w:
                ans += str2[j]
                j += 1
            ans += w
            i += 1
            j += 1
        ans += str1[i:] + str2[j:]
        return ans

    @staticmethod
    def lg_p1410(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1410
        tag: dilworth|lis
        """
        # 最长不上升子序列
        while True:
            lst = ac.read_list_ints()
            if not lst:
                break
            lst = lst[1:]
            dp = []
            for num in lst:
                i = bisect.bisect_right(dp, -num)
                if i < len(dp):
                    dp[i] = -num
                else:
                    dp.append(-num)
            ac.st("Yes!" if len(dp) <= 2 else "No!")
        return

    @staticmethod
    def ac_3549(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3552/
        tag: liner_dp|greedy
        """
        # 翻转连续子数组获得最长不降子序列
        ac.read_int()
        nums = ac.read_list_ints()
        s1 = s12 = s121 = s1212 = 0
        for num in nums:
            if num == 1:
                s1 += 1
                s121 = max(s12 + 1, s121 + 1)
            else:
                s12 = max(s1 + 1, s12 + 1)
                s1212 = max(s121 + 1, s1212 + 1)
        ac.st(max(s1212, s1, s12, s121))
        return

    @staticmethod
    def ac_3662_1(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3665/
        tag: lis|counter|discretization|tree_array|liner_dp|segment_tree
        """
        # 所有长度的严格上升子序列的最大子序列和，discretizationtree_array|与liner_dp，也可segment_tree|
        ac.read_int()
        nums = ac.read_list_ints()
        ind = {num: i for i, num in enumerate(sorted(list(set(nums))))}
        n = len(ind)
        tree = PointAscendPreMax(n)

        for num in nums:
            if ind[num] == 0:
                tree.point_ascend(1, num)
            else:
                tree.point_ascend(ind[num] + 1, tree.pre_max(ind[num]) + num)
        ac.st(tree.pre_max(n))
        return

    @staticmethod
    def ac_3662_2(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3665/
        tag: lis|counter|discretization|tree_array|liner_dp|segment_tree
        """
        # 所有长度的严格上升子序列的最大子序列和，discretizationtree_array|与liner_dp，也可segment_tree|
        ac.read_int()
        nums = ac.read_list_ints()
        ind = {num: i for i, num in enumerate(sorted(list(set(nums))))}
        n = len(ind)
        tree = RangeAscendRangeMax(n)
        for num in nums:
            if ind[num] == 0:
                tree.range_ascend(0, 0, num)
            else:
                pre = tree.range_max(0, ind[num] - 1)
                tree.range_ascend(ind[num], ind[num], pre + num)
        ac.st(tree.range_max(0, n - 1))
        return

    @staticmethod
    def ac_2694(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/2696/
        tag: lcs_by_lis|counter|dp
        """
        # LIS的方法求解LCS的长度与个数
        mod = 10 ** 8
        s1 = ac.read_str()[:-1]
        s2 = ac.read_str()[:-1]
        length, cnt = LcsComputeByLis().length_and_cnt_of_lcs(s1, s2, mod)
        ac.st(length)
        ac.st(cnt % mod)
        return

    @staticmethod
    def lg_p2516(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2516
        tag: lcs|matrix_dp|length_of_lcs|cnt_of_lcs|rolling_array
        """
        mod = 10 ** 8
        ans = LcsComputeByLis().length_and_cnt_of_lcs(ac.read_str()[:-1], ac.read_str()[:-1], mod)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def main(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc354/tasks/abc354_f
        tag: lis|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            pre = [0] * n
            dp = []
            for x, num in enumerate(nums):
                i = bisect.bisect_left(dp, num)
                pre[x] = i
                if 0 <= i < len(dp):
                    dp[i] = num
                else:
                    dp.append(num)
            ceil = len(dp)
            post = [0] * n
            dp = []
            for x in range(n - 1, -1, -1):
                num = -nums[x]
                i = bisect.bisect_left(dp, num)
                post[x] = i
                if 0 <= i < len(dp):
                    dp[i] = num
                else:
                    dp.append(num)
            res = []
            for i in range(n):
                if pre[i] + post[i] + 1 == ceil:
                    res.append(i + 1)
            ac.st(len(res))
            ac.lst(res)
        return

    @staticmethod
    def abc_354f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc354/tasks/abc354_f
        tag: lis|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            pre = [0] * n
            dp = []
            for x, num in enumerate(nums):
                i = bisect.bisect_left(dp, num)
                pre[x] = i
                if 0 <= i < len(dp):
                    dp[i] = num
                else:
                    dp.append(num)
            ceil = len(dp)
            post = [0] * n
            dp = []
            for x in range(n - 1, -1, -1):
                num = -nums[x]
                i = bisect.bisect_left(dp, num)
                post[x] = i
                if 0 <= i < len(dp):
                    dp[i] = num
                else:
                    dp.append(num)
            res = []
            for i in range(n):
                if pre[i] + post[i] + 1 == ceil:
                    res.append(i + 1)
            ac.st(len(res))
            ac.lst(res)
        return

    @staticmethod
    def cf_486e_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/486/E
        tag: lis|greedy|brain_teaser|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        pre = [0] * n
        dp = []
        for x, num in enumerate(nums):
            i = bisect.bisect_left(dp, num)
            pre[x] = i
            if 0 <= i < len(dp):
                dp[i] = num
            else:
                dp.append(num)
        ceil = len(dp)
        post = [0] * n
        dp = []
        for x in range(n - 1, -1, -1):
            num = -nums[x]
            i = bisect.bisect_left(dp, num)
            post[x] = i
            if 0 <= i < len(dp):
                dp[i] = num
            else:
                dp.append(num)

        cnt = [0] * n
        for i in range(n):
            if pre[i] + post[i] + 1 == ceil:
                cnt[pre[i]] += 1

        ans = ["1"] * n
        for i in range(n):
            if pre[i] + post[i] + 1 != ceil:
                continue
            if cnt[pre[i]] == 1:
                ans[i] = "3"
            else:
                ans[i] = "2"
        ac.st("".join(ans))
        return
    
    @staticmethod
    def cf_486e_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/486/E
        tag: lis|greedy|brain_teaser|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = random.getrandbits(64)
        dp = []  # LIS array
        s = []  # index is length and value is sum
        q = []  # index is length and value is [num, cnt]
        pre = [0] * n
        cnt = [0] * n
        for x, num in enumerate(nums):
            if not dp or num > dp[-1]:
                dp.append(num)
                length = len(dp)
            else:
                i = bisect.bisect_left(dp, num)
                dp[i] = num
                length = i + 1
            while len(s) <= len(dp):
                s.append(0)
            while len(q) <= len(dp):
                q.append(deque())

            if length == 1:
                s[length] += 1
                q[length].append([num, 1])
            else:
                while q[length - 1] and q[length - 1][0][0] >= num:
                    s[length - 1] -= q[length - 1].popleft()[1]
                s[length] += s[length - 1]
                s[length] %= mod
                q[length].append([num, s[length - 1]])
            pre[x] = length - 1
            cnt[x] = s[length - 1] if length - 1 else 1

        dp = []  # LIS array
        s = []  # index is length and value is sum
        q = []  # index is length and value is [num, cnt]
        post = [0] * n
        cnt_post = [0] * n
        for x in range(n - 1, -1, -1):
            num = -nums[x]
            if not dp or num > dp[-1]:
                dp.append(num)
                length = len(dp)
            else:
                i = bisect.bisect_left(dp, num)
                dp[i] = num
                length = i + 1
            while len(s) <= len(dp):
                s.append(0)
            while len(q) <= len(dp):
                q.append(deque())

            if length == 1:
                s[length] += 1
                q[length].append([num, 1])
            else:
                while q[length - 1] and q[length - 1][0][0] >= num:
                    s[length - 1] -= q[length - 1].popleft()[1]
                s[length] += s[length - 1]
                s[length] %= mod
                q[length].append([num, s[length - 1]])
            post[x] = length - 1
            cnt_post[x] = s[length - 1] if length - 1 else 1

        ceil = len(dp)
        tot = s[-1] % mod
        ans = ["1"] * n
        for i in range(n):
            if pre[i] + post[i] + 1 != ceil:
                continue
            if (cnt[i] * cnt_post[i]) % mod == tot:
                ans[i] = "3"
            else:
                ans[i] = "2"
        ac.st("".join(ans))
        return

    @staticmethod
    def cf_650d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/650/D
        tag: lis|brain_teaser|classical|offline_query
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        queries = [1] * m
        pos = [[] for _ in range(n)]
        for x in range(m):
            i, j = ac.read_list_ints()
            pos[i - 1].append((j, x))

        pre = [0] * n
        dp = []
        for x, num in enumerate(nums):
            i = bisect.bisect_left(dp, num)
            for a, j in pos[x]:
                queries[j] += bisect.bisect_left(dp, a)
            pre[x] = i
            if 0 <= i < len(dp):
                dp[i] = num
            else:
                dp.append(num)

        ceil = len(dp)
        post = [0] * n
        dp = []
        for x in range(n - 1, -1, -1):
            num = -nums[x]
            i = bisect.bisect_left(dp, num)
            for a, j in pos[x]:
                queries[j] += bisect.bisect_left(dp, -a)
            post[x] = i
            if 0 <= i < len(dp):
                dp[i] = num
            else:
                dp.append(num)

        cnt = [0] * n
        for i in range(n):
            if pre[i] + post[i] + 1 == ceil:
                cnt[pre[i]] += 1
        for i in range(n):
            for a, j in pos[i]:
                if cnt[pre[i]] > 1 or pre[i] + post[i] + 1 < ceil:
                    queries[j] = max(queries[j], ceil)
                else:
                    queries[j] = max(queries[j], ceil - 1)
        for q in queries:
            ac.st(q)
        return

    @staticmethod
    def abc_360g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc360/tasks/abc360_g
        tag: lis|greedy|implemention|classical|linear_dp|prefix_suffix
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        post = [(0, 0) for _ in range(n + 1)]
        post[n] = (0, math.inf)
        dp = []
        for x in range(n - 1, -1, -1):
            num = -nums[x]
            i = bisect.bisect_left(dp, num)
            post[x] = post[x + 1]
            if 0 <= i < len(dp):
                dp[i] = num
                cur = i + 1
            else:
                dp.append(num)
                cur = len(dp)
            if (cur, -num) > post[x]:
                post[x] = (cur, -num)

        ans = post[0][0]
        pre = (0, math.inf)
        dp = []
        for x, num in enumerate(nums):
            i = bisect.bisect_left(dp, num)
            if x + 1 < n and post[x + 1][1] > -pre[1] + 1:
                ans = max(ans, post[x + 1][0] + pre[0] + 1)
            if 0 <= i < len(dp):
                dp[i] = num
                cur = i + 1
            else:
                dp.append(num)
                cur = len(dp)
            if (cur, -num) > pre:
                pre = (cur, -num)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1108(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1108
        tag: matrix_dp|lis|classical|brain_teaser
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        length = [1] * n
        dedup = [1] * n
        res2 = 0
        for i in range(n):
            for j in range(i):
                if nums[j] > nums[i]:
                    if length[j] + 1 > length[i]:
                        length[i] = length[j] + 1
                        dedup[i] = dedup[j]
                    elif length[j] + 1 == length[i]:
                        dedup[i] += dedup[j]
                elif nums[j] == nums[i]:
                    dedup[j] = length[j] = 0
        res1 = max(length)
        for i in range(n):
            if length[i] == res1:
                res2 += dedup[i]
        ac.lst([res1, res2])
        return

    @staticmethod
    def lc_3288(coordinates: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/length-of-the-longest-increasing-path/
        tag: lis|partial_order|classical
        """
        kx, ky = coordinates[k]
        coordinates.sort(key=lambda it: (it[0], -it[1]))
        dp = []
        for x, y in coordinates:
            if (x < kx and y < ky) or (x > kx and y > ky):
                i = bisect.bisect_left(dp, y)
                if 0 <= i < len(dp):
                    dp[i] = y
                else:
                    dp.append(y)
        return len(dp) + 1
"""

Algorithm：bit_operation
Description：bit_wise|xor|or|and|brute_force
Property：(4*i)^(4*i+1)^(4*i+2)^(4*i+3)=0  (2*n)^(2*n+1)=1 (a&b)^(a&c) = a&(b^c)

====================================LeetCode====================================
2354（https://leetcode.cn/problems/number-of-excellent-pairs/）brain_teaser|hash|counter|brute_force
260（https://leetcode.cn/problems/single-number-iii/）bit_operation|cor_property|lowest_bit
2571（https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/）operation|bit_property
2568（https://leetcode.cn/problems/minimum-impossible-or/）greedy
2564（https://leetcode.cn/problems/substring-xor-queries/）bit_operation|bit_property
1238（https://leetcode.cn/problems/circular-permutation-in-binary-representation/）gray_code|classical
89（https://leetcode.cn/problems/gray-code/）gray_code|classical
137（https://leetcode.cn/problems/single-number-ii/）bit_operation|counter
56（https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/）bit_operation|counter
260（https://leetcode.cn/problems/single-number-iii/）bit_operation|counter
2546（https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal/）xor_property|brain_teaser
1486（https://leetcode.cn/problems/xor-operation-in-an-array/）xor_property
1734（https://leetcode.cn/problems/decode-xored-permutation/）math|xor_property|odd_xor
1787（https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/）xor_property|data_range|brute_force
1835（https://leetcode.cn/problems/find-xor-sum-of-all-pairs-bitwise-and/）bit_operation|implemention
1611（https://leetcode.cn/problems/minimum-one-bit-operations-to-make-integers-zero/）gray_code|classical
2275（https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/）range_add|classical|st
2527（https://leetcode.cn/problems/find-xor-beauty-of-array/description/）brute_force|brain_teaser|bit_operation
2680（https://leetcode.cn/problems/maximum-or/description/）greedy|brute_force|prefix_suffix
100087（https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares/）bit_wise|bit_operation|greedy
3007（https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/）bit_operation|binary_search|bit_operation|binary_search|digital_dp
100179（https://leetcode.com/problems/minimize-or-of-remaining-elements-using-operations/）bit_operation|greedy|brain_teaser
3145（https://leetcode.cn/problems/find-products-of-elements-of-big-array/description/）bit_operation|data_range|classical|inclusion_exclusion|counter
233（https://leetcode.cn/problems/number-of-digit-one/description/）bit_operation|digital_dp|circular_section
3315（https://leetcode.com/problems/construct-the-minimum-bitwise-array-ii/）construction|guess_table|bit_operation

=====================================LuoGu======================================
P5657（https://www.luogu.com.cn/problem/P5657）bit_operation
P6102（https://www.luogu.com.cn/problem/P6102）bit_operation|and
P7442（https://www.luogu.com.cn/problem/P7442）bit_operation|implemention|observe_pattern
P7617（https://www.luogu.com.cn/problem/P7617）bit_operation|brute_force
P7627（https://www.luogu.com.cn/problem/P7627）bit_operation|brute_force
P7649（https://www.luogu.com.cn/problem/P7649）3-base|greedy|implemention
P1582（https://www.luogu.com.cn/problem/P1582）base|brain_teaser
P2114（https://www.luogu.com.cn/problem/P2114）bit_operation|implemention|greedy
P2326（https://www.luogu.com.cn/problem/P2326）bit_operation|implemention|greedy|maximum_and
P4144（https://www.luogu.com.cn/problem/P4144）bit_operation|greedy|brain_teaser
P4310（https://www.luogu.com.cn/problem/P4310）linear_dp|bit_operation
P5390（https://www.luogu.com.cn/problem/P5390）bit_operation
P6824（https://www.luogu.com.cn/problem/P6824）bit_operation|xor|diff_array|action_scope|counter
P8842（https://www.luogu.com.cn/problem/P8842）prime_factorization|prefix_sum|counter
P8965（https://www.luogu.com.cn/problem/P8965）tree_dp|xor
P3760（https://www.luogu.com.cn/problem/P3760）bit_operation|contribution_method|classical|two_pointers|sorted_list|brain_teaser
U360500（https://www.luogu.com.cn/problem/U360500）bit_operation|contribution_method|classical|two_pointers|sorted_list|brain_teaser
P5390（ttps://www.luogu.com.cn/problem/P5390）bit_operation|contribution_method

===================================CodeForces===================================
305C（https://codeforces.com/problemset/problem/305/C）2-base
878A（https://codeforces.com/problemset/problem/878/A）bit_operation
282C（https://codeforces.com/problemset/problem/282/C）bit_operation
1554C（https://codeforces.com/contest/1554/problem/C）bit_operation|greedy
1800F（https://codeforces.com/contest/1800/problem/F）bit_operation|brute_force|counter
276D（https://codeforces.com/contest/276/problem/D）maximum_xor|classical
1742G（https://codeforces.com/contest/1742/problem/G）prefix_or|lexicographical_order|construction|specific_plan
1851F（https://codeforces.com/contest/1851/problem/F）minimum_xor_pair|classical|sort|adjacent_pair|brain_teaser
1879D（https://codeforces.com/contest/1879/problem/D）bit_operation|bit_contribution_method|prefix_sum|counter|prefix_or
1368D（https://codeforces.com/problemset/problem/1368/D）implemention|greedy|bit_wise|bit_operation
1802C（https://codeforces.com/contest/1802/problem/C）construction|xor_property
1918C（https://codeforces.com/contest/1918/problem/C）greedy|bit_operation
1669H（https://codeforces.com/contest/1669/problem/H）bit_operation
1760G（https://codeforces.com/contest/1760/problem/G）bit_operation|dfs|brute_force
1066E（https://codeforces.com/contest/1066/problem/E）bit_operation|brute_force|implemention|prefix_sum
1790E（https://codeforces.com/contest/1790/problem/E）bit_operation
1968F（https://codeforces.com/contest/1968/problem/F）brute_force|bit_operation|binary_search
1973B（https://codeforces.com/contest/1973/problem/B）bit_operation|implemention|greedy
1362C（https://codeforces.com/problemset/problem/1362/C）bit_count|bit_operation
1981B（https://codeforces.com/contest/1981/problem/B）bit_operation|classical|range_or
1285D（https://codeforces.com/problemset/problem/1285/D）bitwise_xor|minimax|divide_and_conquer
1982E（https://codeforces.com/contest/1982/problem/E）divide_and_conquer|bit_operation|brain_teaser|segment_tree
1303D（https://codeforces.com/problemset/problem/1303/D）bit_operation|greedy|implemention
1466E（https://codeforces.com/problemset/problem/1466/E）bit_operation|math|contribution_method|classical
1491D（https://codeforces.com/problemset/problem/1491/D）bit_operation|observation|brain_teaser
1322B（https://codeforces.com/problemset/problem/1322/B）bit_operation|contribution_method|classical|two_pointers
1557C（https://codeforces.com/problemset/problem/1557/C）bit_operation|brain_teaser|brute_force|observation
1592C（https://codeforces.com/contest/1592/problem/C）bit_operation|tree_xor|construction|observation
1720D1（https://codeforces.com/problemset/problem/1720/D1）linear_dp|data_range|observation|bit_operation
1632C（https://codeforces.com/problemset/problem/1632/C）bit_operation|brute_force|construction
2020C（https://codeforces.com/contest/2020/problem/C）bit_operation|construction
1715D（https://codeforces.com/problemset/problem/1715/D）greedy|construction|bit_operation
1416C（https://codeforces.com/problemset/problem/1416/C）bit_operation|divide_and_conquer|reverse_pair

====================================AtCoder=====================================
ABC117D（https://atcoder.jp/contests/abc117/tasks/abc117_d）bit_operation|greedy|brain_teaser
ABC147D（https://atcoder.jp/contests/abc147/tasks/abc147_d）classical|xor_sum
ABC121D（https://atcoder.jp/contests/abc121/tasks/abc121_d）classical|xor_sum
ABC308G（https://atcoder.jp/contests/abc308/tasks/abc308_g）minimum_pair_xor|dynamic
ABC281F（https://atcoder.jp/contests/abc281/tasks/abc281_f）bit_operation|sort|binary_trie|greedy|dfs|implemention|divide_conquer|merge
ABC261E（https://atcoder.jp/contests/abc261/tasks/abc261_e）bit_operation|brain_teaser|implemention|classical
ABC356D（https://atcoder.jp/contests/abc356/tasks/abc356_d）bit_count|classical|math|digital_dp
ARC092B（https://atcoder.jp/contests/arc092/tasks/arc092_b）bit_operation|contribution_method|classical|two_pointers
ABC365E（https://atcoder.jp/contests/abc365/tasks/abc365_e）bit_operation|prefix_sum
ABC201E（https://atcoder.jp/contests/abc201/tasks/abc201_e）bit_operation|classical

=====================================AcWing=====================================
998（https://www.acwing.com/problem/content/1000/）or|xor|and|bit_operation|greedy
4614（https://www.acwing.com/problem/content/4617/）bit_operation|brute_force|prefix_sum|preprocess

=====================================Library=====================================
1（https://ac.nowcoder.com/acm/contest/53485/F）minimum_pair_xor|dynamic|classical
2（https://www.codechef.com/problems/LEXMAX）bit_operation|maximum_and|lexicographically_maximal|prefix_and|greedy|classical
3（https://www.codechef.com/problems/PREFSUFF）bit_operation|construction

https://blog.csdn.net/qq_35473473/article/details/106320878
"""
from collections import defaultdict, Counter
from functools import lru_cache
from functools import reduce
from operator import xor, or_
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.data_structure.sorted_list.template import SortedList
from src.mathmatics.bit_operation.template import BitOperation, MinimumPairXor
from src.mathmatics.comb_perm.template import Combinatorics
from src.utils.fast_io import FastIO



class Solution:

    def __int__(self):
        return

    @staticmethod
    def cf_1742g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1742/problem/G
        tag: prefix_or|lexicographical_order|construction|specific_plan
        """

        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            tot = reduce(or_, nums)
            pre = 0
            ans = []
            for i in range(n):
                if pre == tot or len(ans) == n:
                    break
                nex = val = -1
                for j in range(n):
                    if nums[j] >= 0 and pre | nums[j] > val:
                        val = pre | nums[j]
                        nex = j
                pre |= nums[nex]
                ans.append(nums[nex])
                nums[nex] = -1
            for i in range(n):
                if nums[i] >= 0:
                    ans.append(nums[i])
            ac.lst(ans)
        return

    @staticmethod
    def cf_276d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/276/problem/D
        tag: maximum_xor|classical|hard|brain_teaser
        """

        a, b = ac.read_list_ints()
        n = len(bin(b)) - 2
        ans = 0
        for i in range(n - 1, -1, -1):
            if b - a >= (1 << i):
                ans |= (1 << i)
            else:
                if (a ^ b) & (1 << i):
                    ans |= (1 << i)
        ac.st(ans)
        return

    @staticmethod
    def cf_1800f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1800/problem/F
        tag: bit_operation|brute_force|counter|odd_even|brain_teaser|hard
        """

        ac.get_random_seed()
        n = ac.read_int()
        ans = 0
        mask = (1 << 26) - 1
        state = [mask ^ (1 << j) for j in range(26)]
        dct = dict()
        for _ in range(n):
            a = b = 0
            for w in ac.read_str():
                i = ord(w) - ord("a")
                a ^= (1 << i)
                b |= (1 << i)
            if a ^ ac.random_seed not in dct:
                dct[a ^ ac.random_seed] = [0] * 26
            for j in range(26):
                if not b & (1 << j):
                    if a ^ state[j] ^ ac.random_seed in dct:
                        ans += dct[a ^ state[j] ^ ac.random_seed][j]
                    dct[a ^ ac.random_seed][j] += 1
        ac.st(ans)
        return

    @staticmethod
    def lc_260(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/single-number-iii/
        tag: bit_operation|counter|brain_teaser
        """

        s = reduce(xor, nums)
        last = s & (-s)
        one = two = 0
        for num in nums:
            if num & last:
                one ^= num
            else:
                two ^= num
        return [one, two]

    @staticmethod
    def lc_137(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/single-number-ii/
        tag: bit_operation|counter|classical
        """

        floor = (1 << 31) + 1
        dp = [0] * 33
        for num in nums:
            num += floor
            for i in range(33):
                if num & (1 << i):
                    dp[i] += 1
        ans = 0
        for i in range(33):
            if dp[i] % 3:
                ans |= (1 << i)
        return ans - floor

    @staticmethod
    def cf_1554c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1554/problem/C
        tag: bit_operation|greedy|mex_like|brain_teaser|classical|hard|reverse_thinking
        """

        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            assert 0 <= n <= 10 ** 9
            assert 0 <= m <= 10 ** 9
            p = m + 1
            ans = 0  # n^ans >= m+1
            for i in range(30, -1, -1):
                if ans ^ n >= p:
                    break
                if n & (1 << i) == p & (1 << i):
                    continue
                if p & (1 << i):
                    ans |= (1 << i)
            ac.st(ans)
        return

    @staticmethod
    def lc_1787(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/make-the-xor-of-all-segments-equal-to-zero/
        tag: xor_property|data_range|brute_force|hard
        """
        m = max(len(bin(num)) - 2 for num in nums)
        pre = [math.inf] * (1 << m)
        pre[0] = 0
        for i in range(k):
            lst = nums[i::k]
            n = len(lst)
            cnt = Counter(lst)
            low = min(pre)
            cur = [low + n for _ in pre]
            for j in range(1 << m):
                for num in cnt:
                    a, b = cur[j], pre[j ^ num] + n - cnt[num]
                    cur[j] = a if a < b else b
            pre = cur[:]
        return pre[0]

    @staticmethod
    def lc_2568(nums):
        """
        url: https://leetcode.cn/problems/minimum-impossible-or/
        tag: greedy|brain_teaser
        """

        dct = set(nums)
        ans = 1
        while ans in dct:
            ans *= 2
        return ans

    @staticmethod
    def lc_2571_1(n):
        """
        url: https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/
        tag: operation|bit_property
        """

        @lru_cache(None)
        def dfs(k):
            if not k:
                return 0
            if k.bit_count() == 1:
                return 1
            low = k & (-k)
            return 1 + min(dfs(k - low), dfs(k + low))

        return dfs(n)  # (3 * n ^ n).bit_count()

    @staticmethod
    def lc_2571_2(n):
        """
        url: https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/
        tag: operation|bit_property
        """
        ans = cnt = 0
        m = n.bit_length()
        for i in range(m):
            if n & (1 << i):
                cnt += 1
            else:
                if cnt == 1:
                    ans += 1
                    cnt = 0
                elif cnt >= 2:
                    if n & (1 << (i + 1)):
                        ans += 1
                        cnt = 1
                    else:
                        ans += 2
                        cnt = 0
        if cnt:
            ans += 1 if cnt == 1 else 2
        return ans

    @staticmethod
    def lc_2275(candidates: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/
        tag: range_add|classical|st
        """

        count = [0] * 24
        for num in candidates:
            for i in range(24):
                if num & (1 << i):
                    count[i] += 1
        return max(count)

    @staticmethod
    def lc_2564(s, queries):
        """
        url: https://leetcode.cn/problems/substring-xor-queries/
        tag: bit_operation|bit_property|data_range
        """

        dct = defaultdict(set)
        m = len(queries)
        for i in range(m):
            a, b = queries[i]
            x = bin(a ^ b)[2:]
            dct[x].add(i)
        ceil = max(len(x) for x in dct)
        ans = [[-1, -1] for _ in range(m)]
        n = len(s)
        for i in range(n):
            for j in range(max(i - ceil + 1, 0), i + 1):
                st = s[j:i + 1]
                if dct[st]:
                    for k in dct[st]:
                        ans[k] = [j, i]
                    dct[st] = set()
        return ans

    @staticmethod
    def lc_1238(n: int, start: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/circular-permutation-in-binary-representation/
        tag: gray_code|classical
        """

        ans = BitOperation().get_graycode(n)
        i = ans.index(start)
        return ans[i:] + ans[:i]

    @staticmethod
    def lc_89(n: int) -> List[int]:
        """
        url: https://leetcode.cn/problems/gray-code/
        tag: gray_code|classical
        """

        ans = BitOperation().get_graycode(n)
        return ans

    @staticmethod
    def abc_117d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc117/tasks/abc117_d
        tag: bit_operation|greedy|brain_teaser|implemention|hard|bit_property
        """

        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = pre = 0
        for i in range(40, -1, -1):
            cnt = Counter(int(num & (1 << i) > 0) for num in nums)
            if cnt[1] >= cnt[0] or pre + (1 << i) > k:  # half|bit
                ans += cnt[1] * (1 << i)
            else:
                pre += (1 << i)
                ans += cnt[0] * (1 << i)
        ac.st(ans)
        return

    @staticmethod
    def abc_121d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc121/tasks/abc121_d
        tag: classical|xor_sum
        """
        a, b = ac.read_list_ints()
        ans = BitOperation().sum_xor(b)
        if a:
            ans ^= BitOperation().sum_xor((a - 1))
        ac.st(ans)
        return

    @staticmethod
    def ac_998(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/1000/
        tag: or|xor|and|bit_operation|greedy|implemention
        """

        n, m = ac.read_list_ints()
        ans = [[0, 1 << i] for i in range(32)]
        for _ in range(n):
            op, t = ac.read_list_strs()
            t = int(t)
            if op == "AND":
                for i in range(32):
                    ans[i][0] &= t & (1 << i)
                    ans[i][1] &= t & (1 << i)
            elif op == "OR":
                for i in range(32):
                    ans[i][0] |= t & (1 << i)
                    ans[i][1] |= t & (1 << i)
            else:
                for i in range(32):
                    ans[i][0] ^= t & (1 << i)
                    ans[i][1] ^= t & (1 << i)
        res = x = 0
        for i in range(31, -1, -1):
            if ans[i][1] > ans[i][0] and (x | (1 << i)) <= m:
                x |= (1 << i)
                res += ans[i][1]
            else:
                res += ans[i][0]
        ac.st(res)
        return

    @staticmethod
    def lg_p1582(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1582
        tag: base|brain_teaser
        """
        n, k = ac.read_list_ints()
        ans = 0
        while n.bit_count() > k:
            ans += n & (-n)
            n += n & (-n)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2114(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2114
        tag: bit_operation|implemention|greedy
        """

        n, m = ac.read_list_ints()
        one = [1 << i for i in range(32)]
        zero = [0] * 32
        for _ in range(n):
            op, t = ac.read_list_strs()
            t = int(t)
            for i in range(32):
                if op == "AND":
                    one[i] &= (t & (1 << i))
                    zero[i] &= (t & (1 << i))
                elif op == "OR":
                    one[i] |= (t & (1 << i))
                    zero[i] |= (t & (1 << i))
                else:
                    one[i] ^= (t & (1 << i))
                    zero[i] ^= (t & (1 << i))

        ans = 0
        for i in range(31, -1, -1):
            if one[i] > zero[i] and m >= (1 << i):
                m -= (1 << i)
                ans += one[i]
            else:
                ans += zero[i]
        ac.st(ans)
        return

    @staticmethod
    def lg_p2326(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2326
        tag: bit_operation|implemention|greedy|maximum_and
        """

        for case in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            ans = 0
            while nums:
                cnt = [0] * 32
                for num in nums:
                    for i in range(21):
                        if num & (1 << i):
                            cnt[i] += 1
                for i in range(20, -1, -1):
                    if cnt[i] >= 2:
                        ans |= (1 << i)
                        nums = [num ^ (1 << i) for num in nums if num & (1 << i) and num ^ (1 << i)]
                        break
                else:
                    nums = []
            ac.st(f"Case #{case + 1}: {ans}")
        return

    @staticmethod
    def lg_p4144(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4144
        tag: bit_operation|greedy|brain_teaser|hard|classical
        """

        n, b, p = ac.read_list_ints()
        nums = ac.read_list_ints()
        ans = max(nums) * 2
        ac.st(pow(ans + 233, b, p))
        return

    @staticmethod
    def lg_p4310(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4310
        tag: linear_dp|bit_operation|classical
        """

        ac.read_int()
        nums = ac.read_list_ints()
        cnt = [0] * 32
        for num in nums:
            pre = 0
            lst = []
            for j in range(32):
                if num & (1 << j):
                    lst.append(j)
                    pre = max(pre, cnt[j])
            pre += 1
            for j in lst:
                cnt[j] = pre
        ac.st(max(cnt))
        return

    @staticmethod
    def lg_p5390(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5390
        url: https://www.luogu.com.cn/problem/U360642
        tag: bit_operation|odd_even|classical
        """

        mod = 998244353
        for _ in range(ac.read_int()):
            nums = ac.read_list_ints()
            n = nums[0]
            num = reduce(or_, nums[1:])
            pp = pow(2, n - 1, mod)
            ans = 0
            for i in range(32):
                if num & (1 << i):
                    ans += (1 << i) * pp
            ac.st(ans % mod)
        return

    @staticmethod
    def lg_p6824(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6824
        tag: bit_operation|xor|diff_array|action_scope|counter|classical|hard
        """

        n, k = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        m = len(bin(max(k, max(nums)))) - 1
        diff = [0] * ((1 << m) + 1)
        for a in nums:
            pre = 0
            for i in range(m - 1, -1, -1):
                if k & (1 << i):
                    if a & (1 << i):
                        low = pre ^ (1 << i)
                        high = low ^ ((1 << i) - 1)
                        diff[low] += 1
                        diff[high + 1] -= 1
                    else:
                        low, high = pre, pre ^ ((1 << i) - 1)
                        diff[low] += 1
                        diff[high + 1] -= 1
                        pre ^= (1 << i)
                else:
                    if a & (1 << i):
                        pre ^= (1 << i)
            diff[pre] += 1
            diff[pre + 1] -= 1
        ac.st(max(ac.accumulate(diff)))
        return

    @staticmethod
    def lg_p8842(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8842
        tag: prime_factorization|prefix_sum|counter|classical|hard
        """

        n = 1 << 21
        prime = [0] * (n + 1)
        prime[0] = 0
        prime[1] = 1
        for i in range(2, n + 1):
            if not prime[i]:
                for j in range(i * i, n + 1, i):
                    prime[j] = 1
            prime[i] += prime[i - 1]
        for _ in range(ac.read_int()):
            x = ac.read_int()
            ans = 0
            for k in range(21):
                if x & (1 << k):
                    ans += (1 << (k + 1)) - (1 << k) - (prime[(1 << (k + 1)) - 1] - prime[(1 << k) - 1])
            ac.st(ans)
        return

    @staticmethod
    def lc_1486(n: int, start: int) -> int:
        """
        url: https://leetcode.cn/problems/xor-operation-in-an-array/
        tag: xor_property|hard
        """

        s = start // 2
        bo = BitOperation()
        e = n & start & 1
        return (bo.sum_xor(s - 1) ^ bo.sum_xor(s + n - 1)) * 2 + e

    @staticmethod
    def lc_1734(encoded: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/decode-xored-permutation/
        tag: math|xor_property|odd_xor
        """

        n = len(encoded) + 1
        total = BitOperation().sum_xor(n)
        odd = reduce(xor, encoded[1::2])
        ans = [total ^ odd]
        for num in encoded:
            ans.append(ans[-1] ^ num)
        return ans

    @staticmethod
    def ac_4614(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4617/
        tag: bit_operation|brute_force|prefix_sum|preprocess|brain_teaser|classical
        """

        n, m, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        lst = [ac.read_str() for _ in range(m)]
        cnt = Counter(lst)
        dct = [0] * (1 << n)
        for va in cnt:
            dct[int("0b" + va, 2)] = cnt[va]

        weight = [0] * (1 << n)
        for i in range(1 << n):
            weight[i] = sum(nums[j] for j in range(n) if not i & (1 << (n - 1 - j)))

        res = [[0] * 101 for _ in range(1 << n)]
        for i in range(1 << n):
            for j in range(1 << n):
                s = weight[i ^ j]
                if s <= 100:
                    res[i][s] += dct[j]

        for i in range(1 << n):
            for j in range(1, 101):
                res[i][j] += res[i][j - 1]

        for _ in range(q):
            t, k = ac.read_list_strs()
            k = int(k)

            ac.st(res[int("0b" + t, 2)][k])
        return

    @staticmethod
    def lc_3007(k: int, x: int) -> int:

        """
        url: https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/description/
        tag: bit_operation|binary_search|digital_dp
        """

        def check(num):
            num += 1
            cnt = 0
            for i in range(x, 64, x):
                n = 1 << (i - 1)
                if n > num:
                    break
                cnt += (num // (n << 1)) * n
                if num % (n << 1) > n:
                    cnt += (num % (n << 1)) - n
            return cnt <= k

        ans = BinarySearch().find_int_right(0, 10 ** 15, check)
        return ans

    @staticmethod
    def abc_308g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc308/tasks/abc308_g
        tag: minimum_pair_xor|dynamic|classical
        """
        q = ac.read_int()
        minimum_xor = MinimumPairXor()
        for _ in range(q):
            lst = ac.read_list_ints()

            if lst[0] == 1:
                minimum_xor.add(lst[1])
            elif lst[0] == 2:
                minimum_xor.remove(lst[1])
            else:
                ac.st(minimum_xor.query())
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://ac.nowcoder.com/acm/contest/53485/F
        tag: minimum_pair_xor|dynamic|classical
        """
        q = ac.read_int()
        minimum_xor = MinimumPairXor()
        for _ in range(q):
            lst = ac.read_list_strs()

            if lst[0] == "ADD":
                minimum_xor.add(int(lst[1]))
            elif lst[0] == "DEL":
                minimum_xor.remove(int(lst[1]))
            else:
                ac.st(minimum_xor.query())
        return

    @staticmethod
    def lc_100179(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.com/problems/minimize-or-of-remaining-elements-using-operations/
        tag: bit_operation|greedy|brain_teaser
        """
        ans = mask = 0
        for i in range(max(nums).bit_length(), -1, -1):
            mask |= 1 << i
            pre = -1
            cnt = 0
            for num in nums:
                pre &= num & mask
                if pre == 0:
                    pre = -1
                else:
                    cnt += 1
            if cnt > k:
                ans |= 1 << i
                mask ^= 1 << i
        return ans

    @staticmethod
    def cf_1918c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1918/problem/C
        tag: bit_operation|greedy
        """
        for _ in range(ac.read_int()):
            a, b, r = ac.read_list_ints()
            for i in range((a ^ b).bit_length() - 2, -1, -1):
                bit = 1 << i
                if (a ^ b) & bit and bit <= r and abs((a ^ bit) - (b ^ bit)) < abs(a - b):
                    a ^= bit
                    b ^= bit
                    r -= bit
            ac.st(abs(a - b))
        return

    @staticmethod
    def abc_281f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc281/tasks/abc281_f
        tag: bit_operation|sort|binary_trie|greedy|dfs|implemention|divide_conquer|merge
        """
        ac.read_int()
        nums = ac.read_list_ints()
        nums.sort()
        n = len(nums)

        def dfs(i, ll, rr):
            if i == -1:
                return 0
            mid = -1
            for j in range(ll, rr + 1):
                if nums[j] & (1 << i):
                    mid = j
                    break
            if mid == -1 or mid == ll:
                return dfs(i - 1, ll, rr)

            return min(dfs(i - 1, ll, mid - 1), dfs(i - 1, mid, rr)) | (1 << i)

        ans = dfs(29, 0, n - 1)
        ac.st(ans)
        return

    @staticmethod
    def abc_261e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc261/tasks/abc261_e
        tag: bit_operation|brain_teaser|implemention|classical
        """
        n, c = ac.read_list_ints()
        o = (1 << 31) - 1
        z = 0
        for _ in range(n):
            t, a = ac.read_list_ints()
            if t == 1:
                o &= a
                z &= a
            elif t == 2:
                o |= a
                z |= a
            else:
                o ^= a
                z ^= a
            c = (c & o) | (~c & z)
            ac.st(c)
        return

    @staticmethod
    def cc_2(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/LEXMAX
        tag: bit_operation|maximum_and|lexicographically_maximal|prefix_and|greedy|classical
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            ans = [max(nums)]
            nums.remove(ans[0])
            while nums:
                val = max(num & ans[-1] for num in nums)
                cnt = sum((num & ans[-1]) == val for num in nums)
                ans.extend([val] * cnt)
                nums = [num for num in nums if (num & ans[-1]) != val]
            ac.lst(ans)
        return

    @staticmethod
    def abc_356d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc356/tasks/abc356_d
        tag: bit_count|classical|math|digital_dp
        """
        n, m = ac.read_list_ints()
        mod = 998244353
        ans = 0
        for i in range(61):
            if m & (1 << i):
                circle = 1 << (i + 1)
                ans += (1 << i) * ((n + 1) // circle)
                if (n + 1) % circle > (1 << i):
                    ans += (n + 1) % circle - (1 << i)
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1981b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1981/problem/B
        tag: bit_operation|classical|range_or
        """
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()

            low = max(n - m, 0)
            high = n + m
            ans = 0
            for i in range(64):
                cc = 1 << (i + 1)
                pp = 1 << i
                if 1 <= (high + 1) % cc <= pp and 1 <= (low + 1) % cc <= pp and (high + 1) // cc == (low + 1) // cc:
                    continue
                ans |= 1 << i
            ac.st(ans)
        return

    @staticmethod
    def cf_1285d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1285/D
        tag: bitwise_xor|minimax|divide_and_conquer
        """
        ac.read_int()

        nums = ac.read_list_ints()

        def check(lst, bit):
            if bit == -1:
                return 0
            one = []
            zero = []
            for num in lst:
                if (num >> bit) & 1:
                    one.append(num)
                else:
                    zero.append(num)
            if not one:
                return check(zero, bit - 1)
            if not zero:
                return check(one, bit - 1)
            return min(check(one, bit - 1), check(zero, bit - 1)) + (1 << bit)

        ans = check(nums, 29)
        ac.st(ans)
        return

    @staticmethod
    def cf_1982e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1982/problem/E
        tag: divide_and_conquer|bit_operation|brain_teaser|segment_tree
        """
        mod = 10 ** 9 + 7

        def compute(x):
            return (x * (x + 1) // 2) % mod

        @lru_cache(None)
        def dfs(nn, kk):
            m = nn.bit_length()
            if m <= kk:
                return compute(nn + 1), nn + 1, nn + 1
            if nn == 0:
                return compute(1), 1, 1
            if kk == 0:
                return compute(1), 1, 0
            m -= 1
            res1, s1, e1 = dfs((1 << m) - 1, kk)
            res2, s2, e2 = dfs(nn - (1 << m), kk - 1)
            res1 -= compute(s1)
            if not s1 == e1 == 1 << m:
                res1 -= compute(e1)

            res2 -= compute(s2)
            if not s2 == e2 == nn - (1 << m) + 1:
                res2 -= compute(e2)

            res = res1 + res2
            if s1 == e1 == 1 << m and s2 == e2 == nn - (1 << m) + 1:
                res += compute(s1 + s2)
                return res % mod, s1 + s2, e1 + e2
            elif s1 == e1 == 1 << m:
                res += compute(s1 + s2) + compute(e2)
                return res % mod, s1 + s2, e2
            elif s2 == e2 == nn - (1 << m) + 1:
                res += compute(s1) + compute(e1 + e2)
                return res % mod, s1, e2 + e1

            res += compute(s1) + compute(s2) + compute(e1) + compute(e2)
            return res % mod, s1, e2

        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            ans = dfs(n - 1, k)[0]
            ac.st(ans)
        return

    @staticmethod
    def cf_1303d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1303/D
        tag: bit_operation|greedy|implemention
        """

        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = ac.read_list_ints()
            cnt = [0] * 64
            for num in nums:
                cnt[num.bit_length() - 1] += 1
            ans = 0
            for x in range(64):
                if x:
                    cnt[x] += cnt[x - 1] // 2
                if not n & (1 << x):
                    continue
                if cnt[x] == 0:
                    for i in range(x + 1, 64):
                        if cnt[i]:
                            for j in range(i - 1, x - 1, -1):
                                ans += 1
                                cnt[j + 1] -= 1
                                cnt[j] += 2
                            break
                if cnt[x]:
                    cnt[x] -= 1
                    n ^= (1 << x)
                else:
                    break
            if n:
                ac.st(-1)
            else:
                ac.st(ans)
        return

    @staticmethod
    def cf_1466e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1466/E
        tag: bit_operation|math|contribution_method|classical
        """
        mod = 10 ** 9 + 7

        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            ans = 0
            cnt = [0] * 61
            for x in range(61):
                for num in nums:
                    if (num >> x) & 1:
                        cnt[x] += 1
            for num in nums:
                left = right = 0
                for x in range(61):
                    if (num >> x) & 1:
                        left += (1 << x) * cnt[x]
                        right += n * (1 << x)
                    else:
                        right += cnt[x] * (1 << x)
                ans += left * right
                ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def cf_1491d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1491/D
        tag: bit_operation|observation|brain_teaser
        """
        for _ in range(ac.read_int()):
            u, v = ac.read_list_ints()
            if u > v:
                ac.no()
                continue
            if u == v:
                ac.yes()
                continue
            uu = vv = 0
            for i in range(30):
                if (u >> i) & 1:
                    uu += 1
                if (v >> i) & 1:
                    vv += 1
                if uu < vv:
                    ac.no()
                    break
            else:
                ac.yes()
        return

    @staticmethod
    def cf_1322b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1322/B
        tag: bit_operation|contribution_method|classical|two_pointers
        """
        max_bit = 25
        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = 0
        for x in range(max_bit):
            one, zero = [], []
            for num in nums:
                if (num >> x) & 1:
                    one.append(num)
                else:
                    zero.append(num)
            nums = zero + one

            mask = (1 << (x + 1)) - 1
            tmp = [(1 << x, (1 << (x + 1)) - 1), ((1 << x) + (1 << (x + 1)), (1 << (x + 2)) - 1)]
            cnt = 0
            for aa, bb in tmp:
                j1 = j2 = n - 1
                res = 0
                for ii in range(n):
                    while j2 >= 0 and nums[j2] & mask > bb - (nums[ii] & mask):
                        j2 -= 1
                    while j1 >= 0 and nums[j1] & mask >= aa - (nums[ii] & mask):
                        j1 -= 1
                    cur = j2 - j1
                    if j1 + 1 <= ii <= j2:
                        cur -= 1
                    res += cur
                assert res % 2 == 0
                cnt += res // 2
            if cnt % 2:
                ans |= 1 << x
        ac.st(ans)
        return

    @staticmethod
    def arc_092b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/arc092/tasks/arc092_b
        tag: bit_operation|contribution_method|classical|two_pointers
        """
        max_bit = 30
        n = ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        ans = 0
        for x in range(max_bit):
            one, zero = [], []
            for num in a:
                if (num >> x) & 1:
                    one.append(num)
                else:
                    zero.append(num)
            a = zero + one

            one = []
            zero = []
            for num in b:
                if (num >> x) & 1:
                    one.append(num)
                else:
                    zero.append(num)
            b = zero + one

            mask = (1 << (x + 1)) - 1

            tmp = [(1 << x, (1 << (x + 1)) - 1), ((1 << x) + (1 << (x + 1)), (1 << (x + 2)) - 1)]
            cnt = 0
            for aa, bb in tmp:
                j1 = j2 = n - 1
                for ii in range(n):
                    while j2 >= 0 and b[j2] & mask > bb - (a[ii] & mask):
                        j2 -= 1
                    while j1 >= 0 and b[j1] & mask >= aa - (a[ii] & mask):
                        j1 -= 1
                    cur = j2 - j1
                    cnt += cur
            if cnt % 2:
                ans |= 1 << x
        ac.st(ans)
        return

    @staticmethod
    def lg_u360500(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/U360500
        tag: bit_operation|contribution_method|classical|two_pointers|sorted_list|brain_teaser
        """

        max_bit = 25
        n = ac.read_int()
        nums = ac.read_list_ints()
        nums = ac.accumulate(nums)
        n += 1
        ans = c = 0
        for x in range(max_bit):
            a0, a1 = [], []
            sum_idx = 0
            for idx, num in enumerate(nums):
                if (num >> x) & 1:
                    a1.append(num)
                else:
                    a0.append(num)
                    sum_idx += idx
            n0, n1 = len(a0), len(a1)
            if c ^ (n0 * n1 % 2):
                ans |= 1 << x
            c ^= (n0 * (n0 - 1) // 2 - sum_idx) % 2
            nums = a0 + a1
        ac.st(ans)
        return

    @staticmethod
    def lc_3145(queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/find-products-of-elements-of-big-array/
        tag: bit_operation|data_range|classical|inclusion_exclusion|counter
        """
        m = 60
        count = [1] + [(1 << (i - 1)) * i + 1 for i in
                       range(1, m)]  # count[i]=sum(num.bit_count() for num in range((1<<i)|1))

        def check(num):
            ceil = pre = bit = 0
            for x in range(m - 1, -1, -1):
                if pre + count[x] + (bit << x) <= num:
                    ceil |= 1 << x
                    pre += count[x] + (bit << x)
                    bit += 1
            res = []
            ceil += 1
            for x in range(m):
                c = (ceil // (1 << (x + 1))) * (1 << x)
                if ceil % (1 << (x + 1)) > (1 << x):
                    c += ceil % (1 << (x + 1)) - (1 << x)
                res.append(c)

            diff = num - sum(res)
            if diff:
                for x in range(m):
                    if (ceil >> x) & 1:
                        res[x] += 1
                        diff -= 1
                        if not diff:
                            break
            return sum([j * res[j] for j in range(m)])

        ans = []
        for a, b, mod in queries:
            ans.append(pow(2, check(b + 1) - check(a) if a else check(b + 1), mod))
        return ans

    @staticmethod
    def cf_1557c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1557/C
        tag: bit_operation|brain_teaser|brute_force|observation
        """
        mod = 10 ** 9 + 7
        cb = Combinatorics(2 * 10 ** 5 + 10, mod)
        p = [0] * (2 * 10 ** 5 + 1)
        p[0] = 1
        for i in range(1, 2 * 10 ** 5 + 1):
            p[i] = p[i - 1] * 2 % mod
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            ans = 0
            pre = 1
            even = sum(cb.comb(n, x) for x in range(0, n, 2) if x < n)

            for i in range(k - 1, -1, -1):
                if n % 2 == 0:  # >
                    ans += pre * pow(p[i], n, mod)
                if n % 2:  # =
                    pre *= (even + 1)
                else:
                    pre *= even
                pre %= mod
                ans %= mod
            ans += pre
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def cf_1720d1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1720/D1
        tag: linear_dp|data_range|observation|bit_operation
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            dp = [1] * n
            for i in range(1, n):
                for j in range(max(0, i - 400), i):
                    if (nums[j] ^ i) < (nums[i] ^ j):
                        dp[i] = max(dp[i], dp[j] + 1)
            ac.st(max(dp))
        return

    @staticmethod
    def cf_1715d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1715/D
        tag: greedy|construction|bit_operation
        """
        n, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        ans = [(1 << 30) - 1] * n
        for _ in range(q):
            x, y, num = ac.read_list_ints_minus_one()
            num += 1
            ans[x] &= num
            ans[y] &= num
            dct[x].append(y)
            dct[y].append(x)
        for i in range(n):
            if i not in dct[i]:
                v = ans[i]
                for j in dct[i]:
                    v &= ans[j]
                ans[i] ^= v
        ac.lst(ans)
        return

    @staticmethod
    def cf_1416c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1416/C
        tag: bit_operation|divide_and_conquer|reverse_pair
        """
        ac.read_int()
        nums = ac.read_list_ints()

        res = pre = 0
        arr = [nums[:]]
        for i in range(31, -1, -1):
            cur_one = 0
            cur_zero = 0
            nex = []
            for ls in arr:
                one = []
                zero = []
                for num in ls:
                    if (num >> i) & 1:
                        one.append(num)
                        cur_one += len(zero)
                    else:
                        zero.append(num)
                        cur_zero += len(one)
                if len(one) > 1:
                    nex.append(one)
                if len(zero) > 1:
                    nex.append(zero)
            arr = nex
            if cur_zero <= cur_one:
                pre += cur_zero
                continue
            pre += cur_one
            res |= 1 << i
        ac.lst([pre, res])
        return
"""
Algorithm：cantor_expands
Description：the_kth_rank_perm|the_rank_of_perm|cantor_expands

=====================================LuoGu======================================
P3014（https://www.luogu.com.cn/problem/P3014）the_kth_rank_perm|the_rank_of_perm|cantor_expands
P5367（https://www.luogu.com.cn/problem/P5367）the_kth_rank_perm|the_rank_of_perm|cantor_expands



=====================================AcWing=====================================
5052（https://www.acwing.com/problem/content/5055/）the_kth_rank_perm|the_rank_of_perm|cantor_expands|bfs


"""

import math

from src.mathmatics.cantor_expands.template import CantorExpands
from src.mathmatics.lexico_graphical_order.template import LexicoGraphicalOrder
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p5367(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5367
        tag: the_kth_rank_perm|the_rank_of_perm|cantor_expands
        """

        n = ac.read_int()  # TLE
        nums = ac.read_list_ints()
        mod = 998244353
        ce = CantorExpands(n, mod)
        ac.st(ce.array_to_rank(nums) % mod)  # array_to_rank_with_tree
        return

    @staticmethod
    def lg_p3014_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3014
        tag: the_kth_rank_perm|the_rank_of_perm|cantor_expands
        """

        n, q = ac.read_list_ints()
        ct = CantorExpands(n, mod=math.factorial(n + 2))
        for _ in range(q):
            s = ac.read_str()
            lst = ac.read_list_ints()
            if s == "P":
                ac.lst(ct.rank_to_array(n, lst[0]))
            else:
                ac.st(ct.array_to_rank(lst))
        return

    @staticmethod
    def lg_p3014_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3014
        tag: the_kth_rank_perm|the_rank_of_perm|cantor_expands
        """

        n, q = ac.read_list_ints()
        og = LexicoGraphicalOrder()
        for _ in range(q):
            s = ac.read_str()
            lst = ac.read_list_ints()
            if s == "P":
                ac.lst(og.get_kth_subset_perm(n, lst[0]))
            else:
                ac.st(og.get_subset_perm_kth(n, lst))
        return

    @staticmethod
    def ac_5052(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/5055/
        tag: the_kth_rank_perm|the_rank_of_perm|cantor_expands|bfs
        """

        n, k = ac.read_list_ints()
        low = max(1, n - 12)
        high = n

        if math.factorial(high - low + 1) < k:
            ac.st(-1)
            return

        lst = list(range(low, high + 1))
        m = high - low + 1
        ce = CantorExpands(m, 10 ** 20)
        ind = ce.rank_to_array(m, k)
        perm = [lst[i - 1] for i in ind]
        ans = 0
        stack = [0]
        while stack:
            x = stack.pop()
            if x > n:
                continue
            stack.append(x * 10 + 4)
            stack.append(x * 10 + 7)
            if 1 <= x <= n:
                a_x = x if x < low else perm[x - low]
                if all(w in "47" for w in str(a_x)):
                    ans += 1
        ac.st(ans)
        return
"""

Algorithm：math|comb|counter|mod_reverse|lucas|perm|factorial|rev
Description：combination|permutation|counter|partition_method|fault_perm|stirling_number|catalan_number|inclusion_exclusion
Lucas:（comb(n, m)%p = comb(n%p, m%p)*comb(n//p, m//p)）%p  

====================================LeetCode====================================
96（https://leetcode.cn/problems/unique-binary-search-trees/）catalan_number
95（https://leetcode.cn/problems/unique-binary-search-trees/）catalan_number|recursion|specific_plan
634（https://leetcode.cn/problems/find-the-derangement-of-an-array/）fault_perm|counter|dp
1259（https://leetcode.cn/problems/handshakes-that-dont-cross/）catalan_number
2338（https://leetcode.cn/problems/count-the-number-of-ideal-arrays/）partition_method|factorization|specific_plan|counter|classical
1735（https://leetcode.cn/problems/count-ways-to-make-array-with-product/）prime_factorization|partition_method|classical
1621（https://leetcode.cn/problems/number-of-sets-of-k-non-overlapping-line-segments/）partition_method|comb_perm
1866（https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/）stirling_number|first_kind_stirling_number
1916（https://leetcode.cn/problems/count-ways-to-build-rooms-in-an-ant-colony/）tree_dp|math|comb|counter
1929（https://leetcode.cn/problems/distribute-candies-among-children-ii）comb|inclusion_exclusion|partition_method
100305（https://leetcode.cn/problems/find-the-n-th-value-after-k-seconds/）yanghui_triangle
3317（https://leetcode.com/problems/find-the-number-of-possible-ways-for-an-event/）comb|inclusion_exclusion|brute_force

=====================================LuoGu======================================
P4071（https://www.luogu.com.cn/problem/P4071）mod_reverse|comb|perm|recursion|fault_perm
P1287（https://www.luogu.com.cn/problem/P1287）second_kind_stirling_number|factorial|dp
P1375（https://www.luogu.com.cn/problem/P1375）catalan_number
P1754（https://www.luogu.com.cn/problem/P1754）catalan_number
P2193（https://www.luogu.com.cn/problem/P2193）partition_method|factorization|comb|specific_plan|classical
P1338（https://www.luogu.com.cn/problem/P1338）brute_force|reverse_order_pair
P1313（https://www.luogu.com.cn/problem/P1313）math|comb|polynomial
P1061（https://www.luogu.com.cn/problem/P1061）implemention|lexicographical_order|nex_perm
P3197（https://www.luogu.com.cn/problem/P3197）counter|fast_power|inclusion_exclusion
P3414（https://www.luogu.com.cn/problem/P3414）comb|odd_even|fast_power
P4369（https://www.luogu.com.cn/problem/P4369）brain_teaser|comb|construction
P5520（https://www.luogu.com.cn/problem/P5520）partition_method|comb
P3807（https://www.luogu.com.cn/problem/P3807）lucas
P1044（https://www.luogu.com.cn/problem/P1044）catalan_number
P1655（https://www.luogu.com.cn/problem/P1655）matrix_dp|stirling_number
P1680（https://www.luogu.com.cn/problem/P1680）partition_method|mod_reverse|lucas|comb(a,b)%m
P2265（https://www.luogu.com.cn/problem/P2265）comb|comb(n+m, m)
P2638（https://www.luogu.com.cn/problem/P2638）partition_method|specific_plan|classical
P2822（https://www.luogu.com.cn/problem/P2822）counter|comb(i, j) % k == 0
P3223（https://www.luogu.com.cn/problem/P3223）inclusion_exclusion|partition_method
P3904（https://www.luogu.com.cn/problem/P3904）second_stirling_number|dp|classical
P5684（https://www.luogu.com.cn/problem/P5684）inclusion_exclusion|counter
P6057（https://www.luogu.com.cn/problem/P6057）inclusion_exclusion|counter
P3811（https://www.luogu.com.cn/problem/P3811）mod_reverse
P5431（https://www.luogu.com.cn/problem/P5431）mod_reverse|prefix_mul|postfix_mul|inclusion_exclusion
P2613（https://www.luogu.com.cn/problem/P2613）mod_reverse
P6184（https://www.luogu.com.cn/problem/P6184）comb|inclusion_exclusion|partition_method
P7158（https://www.luogu.com.cn/problem/P7158）comb

===================================CodeForces===================================
1795D（https://codeforces.com/problemset/problem/1795/D）comb|counter|mod|mod_reverse
300C（https://codeforces.com/problemset/problem/300/C）brute_force|comb|specific_plan|counter
559C（https://codeforces.com/contest/559/problem/C）inclusion_exclusion|counter
1436C（https://codeforces.com/contest/1436/problem/C）binary_search|comb
414B（https://codeforces.com/contest/414/problem/B）min_prime|partition_method|counter|dp
1879C（https://codeforces.com/contest/1879/problem/C）greedy|brute_force|comb|counter
1833F（https://codeforces.com/contest/1833/problem/F）prefix_mul|mod
1420D（https://codeforces.com/problemset/problem/1420/D）contribution_method|comb|range
1359E（https://codeforces.com/problemset/problem/1359/E）math|comb|brute_force
1992G（https://codeforces.com/contest/1992/problem/G）brute_force|contribution_method|comb
1444B（https://codeforces.com/problemset/problem/1444/B）observation|math|comb
895C（https://codeforces.com/problemset/problem/895/C）bit_operation|comb|prime_factor|odd_even
1312D（https://codeforces.com/problemset/problem/1312/D）comb|observation|reverse_thinking
1545B（https://codeforces.com/problemset/problem/1545/B）comb|brain_teaser
1332E（https://codeforces.com/problemset/problem/1332/E）brute_force|comb|binomial_expansion|odd_even
1207D（https://codeforces.com/problemset/problem/1207/D）inclusion_exclusion
1288C（https://codeforces.com/problemset/problem/1288/C）comb|math
1091D（https://codeforces.com/problemset/problem/1091/D）perm|math

====================================AtCoder=====================================
ARC058B（https://atcoder.jp/contests/abc042/tasks/arc058_b）inclusion_exclusion|comb|counter
ARC077B（https://atcoder.jp/contests/abc066/tasks/arc077_b）inclusion_exclusion|comb|counter
ABC110D（https://atcoder.jp/contests/abc110/tasks/abc110_d）prime_factorization|partition_method|counter
ABC127E（https://atcoder.jp/contests/abc127/tasks/abc127_e）contribution_method|comb|counter
ABC132D（https://atcoder.jp/contests/abc132/tasks/abc132_d）comb|math|counter|classical|equation
ABC266G（https://atcoder.jp/contests/abc266/tasks/abc266_g）comb|brain_teaser|inclusion_exclusion|classical
ABC262E（https://atcoder.jp/contests/abc262/tasks/abc262_e）brain_teaser|comb|classical
ABC240G（https://atcoder.jp/contests/abc240/tasks/abc240_g）math|comb|counter|classical
ABC235G（https://atcoder.jp/contests/abc235/tasks/abc235_g）inclusion_exclusion|comb|counter|math|brain_teaser|classical
ABC232E（https://atcoder.jp/contests/abc232/tasks/abc232_e）brute_force|linear_dp|comb
ABC295E（https://atcoder.jp/contests/abc295/tasks/abc295_e）expectation|brute_force|inclusion_exclusion|brain_teaser|classical
ABC226F（https://atcoder.jp/contests/abc226/tasks/abc226_f）bag_dp|brute_force|comb
ABC205E（https://atcoder.jp/contests/abc205/tasks/abc205_e）comb|math|geometry|brain_teaser|corner_case

=====================================AcWing=====================================
132（https://www.acwing.com/problem/content/132/）catalan_number
4005（https://www.acwing.com/problem/content/4005/）matrix_dp|partition_method|classical
4499（https://www.acwing.com/problem/content/4499/）partition_method|counter
5058（https://www.acwing.com/problem/content/5058/）math|comb|mod

1（https://www.codechef.com/problems/LUCMAT）math|comb|brute_force|classical

catalan_number（https://oi-wiki.org/math/combinatorics/catalan/）
"""
import math
from collections import Counter, defaultdict
from functools import lru_cache
from typing import List

from src.data_structure.sorted_list.template import SortedList
from src.mathmatics.comb_perm.template import Combinatorics, Lucas
from src.mathmatics.number_theory.template import NumFactor, PrimeSieve
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def abc_110d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc110/tasks/abc110_d
        tag: prime_factorization|partition_method|counter|classical|hard
        """

        n, m = ac.read_list_ints()
        mod = 10 ** 9 + 7
        cb = Combinatorics(n + 100, mod)
        ans = 1
        for _, c in NumFactor().get_prime_factor(m):
            ans *= cb.comb(c + n - 1, n - 1)  # n non-negative number sum c
            # equal sum(cb.comb(n, k)*cb.comb(c-1, k-1) for k in range(1, c+1))
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1436c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1436/problem/C
        tag: binary_search|comb|classical
        """

        n, x, pos = ac.read_list_ints()
        big = small = 0

        left = 0
        right = n
        while left < right:
            mid = (left + right) // 2
            if mid <= pos:
                small += int(mid != pos)
                left = mid + 1
            else:
                right = mid
                big += 1

        if small >= x or big > n - x:
            ac.st(0)
            return
        mod = 10 ** 9 + 7
        comb = Combinatorics(n, mod)
        ans = comb.comb(n - x, big) * comb.factorial(big) * math.comb(x - 1, small) * math.factorial(small)
        ans *= comb.factorial(n - big - small - 1)
        ac.st(ans % mod)
        return

    @staticmethod
    def cf_559c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/559/problem/C
        tag: inclusion_exclusion|counter|classical
        """

        m, n, k = ac.read_list_ints()
        mod = 10 ** 9 + 7
        cb = Combinatorics(m + n, mod)
        pos = [ac.read_list_ints_minus_one() for _ in range(k)]
        pos.sort()

        def dist(x1, y1, x2, y2):
            return cb.comb(x2 + y2 - x1 - y1, x2 - x1)

        ans = dist(0, 0, m - 1, n - 1)
        bad = []
        for x in range(k):
            i, j = pos[x]
            cur = dist(0, 0, i, j)
            for y in range(x):
                a, b = pos[y]
                if b <= j:
                    cur -= dist(a, b, i, j) * bad[y]
                    cur %= mod
            bad.append(cur)
            ans -= cur * dist(i, j, m - 1, n - 1)
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lc_1259_1(num_people: int) -> int:
        """
        url: https://leetcode.cn/problems/handshakes-that-dont-cross/
        tag: catalan_number|classical|
        """
        mod = 10 ** 9 + 7
        cm = Combinatorics(1002, mod)  # preprocess
        n = num_people // 2
        if num_people <= 1:
            return 1
        ans = cm.catalan(n)
        return ans % mod

    @staticmethod
    def lc_1259_2(num_people: int) -> int:
        """
        url: https://leetcode.cn/problems/handshakes-that-dont-cross/
        tag: catalan_number|classical
        """

        n = num_people // 2
        mod = 10 ** 9 + 7
        dp = [1] * (n + 1)
        for i in range(1, n + 1):  # catalan_number dp version_1
            dp[i] = sum(dp[j] * dp[i - 1 - j] for j in range(i)) % mod
        return dp[n]

    @staticmethod
    def lg_p1375(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1375
        tag: catalan_number|classical
        """

        n = ac.read_int()
        mod = 10 ** 9 + 7
        cm = Combinatorics(2 * n + 2, mod)
        ans = cm.catalan(n)
        ac.st(ans % mod)
        return

    @staticmethod
    def lg_p1754(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1754
        url: https://oi-wiki.org/math/combinatorics/catalan/
        tag: catalan_number|classical|regular_bracket_number
        """
        n = ac.read_int()
        # catalan_number dp version_2
        # dp[i][j] = dp[i-1][j]+dp[i][j-1]
        # catalan_number dp version_3
        # h(n) = h(n-1)*(4*n-2)//(n+1) = math.comb(2*n, n)//(n+1)
        ans = math.comb(2 * n, n) - math.comb(2 * n, n - 1)
        assert ans == math.comb(2 * n, n) // (n + 1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1044(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1044
        tag: catalan_number
        """
        n = ac.read_int()
        ans = math.comb(2 * n, n) - math.comb(2 * n, n - 1)
        ac.st(ans)
        return

    @staticmethod
    def lc_634(n):
        """
        url: https://leetcode.cn/problems/find-the-derangement-of-an-array/
        tag: fault_perm|counter|dp
        """
        mod = 10 ** 9 + 7
        fault = [0, 0, 1, 2]
        for i in range(4, n + 1):
            fault.append((i - 1) * (fault[i - 1] + fault[i - 2]) % mod)
        return fault[n]

    @staticmethod
    def cf_300c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/300/C
        tag: brute_force|comb|specific_plan|counter|classical
        """
        mod = 10 ** 9 + 7
        a, b, n = ac.read_list_ints()
        c = Combinatorics(n + 1, mod)

        dct = set(f"{a}{b}")
        ans = 0
        for i in range(n + 1):
            num = a * i + b * (n - i)
            if all(w in dct for w in str(num)):
                ans += c.comb(n, i)
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1795d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1795/D
        tag: comb|counter|mod|mod_reverse
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        mod = 998244353
        c = Combinatorics(n // 3 + 1, mod)
        ans = 1
        for i in range(0, n - 2, 3):
            lst = nums[i:i + 3]
            ans *= lst.count(min(lst))
            ans %= mod
        ans *= c.comb(n // 3, n // 6)
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p1287_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1287
        tag: second_stirling_number|factorial|dp|inclusion_exclusion|counter
        """

        @lru_cache(None)
        def dfs(a, b):
            if a < b or b < 0:
                return 0
            if a == b:
                return 1
            return dfs(a - 1, b - 1) + b * dfs(a - 1, b)

        n, r = ac.read_list_ints()
        x = dfs(n, r) * math.factorial(r)
        return x

    @staticmethod
    def lg_p1287_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1287
        tag: second_stirling_number|factorial|dp|inclusion_exclusion|counter|classical|hard
        """

        n, r = ac.read_list_ints()
        ans = 0
        for k in range(r):
            cur = ((-1) ** k) * math.comb(r, k) * ((r - k) ** n)
            ans += cur
        ac.st(ans)
        return

    @staticmethod
    def lg_p4071(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4071
        tag: fault_perm|specific_plan|counter|classical|partition_method
        """
        mod = 10 ** 9 + 7
        cb = Combinatorics(10 ** 6, mod)
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            if m > n:
                ac.st(0)
                continue
            ans = cb.comb(n, m) * cb.fault[n - m]
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def lg_p3807(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3807
        tag: lucas|classical|can_not_be_comb
        """
        for _ in range(ac.read_int()):
            n, m, p = ac.read_list_ints()
            ans = Lucas().lucas_iter(n + m, n, p)
            ac.st(ans)
        return

    @staticmethod
    def abc_058b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc042/tasks/arc058_b
        tag: inclusion_exclusion|comb|counter
        """

        mod = 10 ** 9 + 7
        h, w, a, b = ac.read_list_ints()
        cb = Combinatorics(h + w + 2, mod)
        ans = cb.comb(h + w - 2, h - 1)
        for x in range(h - a + 1, h + 1):
            y = b
            cur = cb.comb(x + y - 2, x - 1) * cb.comb(h - x + w - y - 1, h - x)
            ans = (ans - cur) % mod
        ac.st(ans)
        return

    @staticmethod
    def abc_077b(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc066/tasks/arc077_b
        tag: inclusion_exclusion|comb|counter|classical|hard
        """
        mod = 10 ** 9 + 7
        n = ac.read_int()
        nums = ac.read_list_ints()
        ind = [-1, -1]
        pre = defaultdict(list)
        for i in range(n + 1):
            pre[nums[i]].append(i)
            if len(pre[nums[i]]) == 2:
                ind = pre[nums[i]]
                break

        x = ind[0]
        y = n - ind[-1]
        cb = Combinatorics(n + 10, mod)
        for k in range(1, n + 2):
            ans = cb.comb(n + 1, k)
            if 1 <= k <= x + y + 1:
                ans -= cb.comb(x + y, k - 1)
            ac.st(ans % mod)
        return

    @staticmethod
    def abc_127e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc127/tasks/abc127_e
        tag: contribution_method|comb|counter|classical|hard
        """

        mod = 10 ** 9 + 7
        m, n, k = ac.read_list_ints()
        cb = Combinatorics(m * n, mod)
        cnt = cb.comb(m * n - 2, k - 2)
        ans = 0
        for i in range(m):
            for j in range(n):
                up = n * i * (i + 1) // 2 if i else 0
                down = n * (m - 1 - i + 1) * (m - 1 - i) // 2 if i < m - 1 else 0
                left = m * j * (j + 1) // 2 if j else 0
                right = m * (n - 1 - j + 1) * (n - 1 - j) // 2 if j < n - 1 else 0
                ans += cnt * (left + right + up + down)
                ans %= mod
        ans *= pow(2, -1, mod)
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def ac_132(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/132/
        tag: catalan_number|classical|prime_factor
        """
        n = ac.read_int()
        nt = PrimeFactor(2 * n + 1)
        cnt = defaultdict(int)
        for i in range(1, 2 * n + 1):
            for num, y in nt.prime_factor[i]:
                if i <= n:
                    cnt[num] -= y
                else:
                    cnt[num] += y
        ans = 1
        for w in cnt:
            ans *= w ** cnt[w]
        ac.st(ans // (n + 1))  # h(n) = C(2n, n)//(n+1) = ((n+1)*..*(2*n))//(1*2*..*(n+1))
        return

    @staticmethod
    def lg_p1655_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1655
        tag: matrix_dp|second_stirling_number|partition_method
        """
        n = m = 101
        dp = [[0] * m for _ in range(n)]
        for i in range(1, n):
            dp[i][i] = dp[i][1] = 1
            for j in range(2, i):
                dp[i][j] = dp[i - 1][j - 1] + j * dp[i - 1][j]
        while True:
            lst = ac.read_list_ints()
            if not lst:
                break
            n, m = lst
            ac.st(dp[n][m])
        return

    @staticmethod
    def lg_p1655_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1655
        tag: matrix_dp|second_stirling_number|partition_method
        """
        while True:
            lst = ac.read_list_ints()
            if not lst:
                break
            n, m = lst
            ans = 0
            for k in range(m):
                cur = ((-1) ** k) * math.comb(m, k) * ((m - k) ** n)
                ans += cur
            ans //= math.factorial(m)
            ac.st(ans)
        return

    @staticmethod
    def lg_p1680_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1680
        tag: partition_method|mod_reverse|lucas|comb(n,m)%p
        """
        n, m = ac.read_list_ints()
        n -= sum([ac.read_int() for _ in range(m)])
        m -= 1
        n -= 1
        p = 10 ** 9 + 7
        ans = Lucas().comb(n, m, p)  # comb for compute with any prime p such as p < n and p < m
        ac.st(ans)
        return

    @staticmethod
    def lg_p1680_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1680
        tag: partition_method|mod_reverse|lucas|comb(n,m)%p
        """
        n, m = ac.read_list_ints()
        n -= sum([ac.read_int() for _ in range(m)])
        mod = 10 ** 9 + 7
        cb = Combinatorics(n, mod)
        ans = cb.comb(n - 1, m - 1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2265(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2265
        tag: comb|comb(n+m, m)
        """
        mod = 1000000007
        n, m = ac.read_list_ints()
        cb = Combinatorics(n + m, mod)
        ans = cb.comb(n + m, m)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2638(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2638
        tag: partition_method|specific_plan|classical|hard|brain_teaser
        """

        n, a, b = ac.read_list_ints()
        ans = math.comb(a + (n + 1) - 1, (n + 1) - 1) * math.comb(b + (n + 1) - 1, (n + 1) - 1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2822(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2822
        tag: counter|comb(i, j) % k == 0|prefix_sum|brute_force|brain_teaser|hard|classical
        """

        t, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(t)]
        x = max(n for n, _ in nums) + 1
        dp = [[0] * x for _ in range(x)]
        dp[0][0] = 1 % k
        for i in range(1, x):
            dp[i][0] = 1 % k
            for j in range(1, i):
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % k
            dp[i][i] = 1 % k

        dp[0][0] = int(dp[0][0] == 0)
        for i in range(1, x):
            dp[i][0] = int(dp[i][0] == 0) + dp[i - 1][0]
            for j in range(1, i):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + int(dp[i][j] == 0)
            dp[i][i] = dp[i][i - 1] + int(dp[i][i] == 0)

        for n, m in nums:
            ac.st(dp[n][min(m, n)])
        return

    @staticmethod
    def lg_p3223(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3223
        tag: inclusion_exclusion|partition_method|classical
        """

        n, m = ac.read_list_ints()
        ans1 = math.factorial(n + 2) * math.factorial(m) * math.comb(n + 3, m)
        ans2 = math.factorial(2) * math.factorial(n + 1) * math.factorial(m) * math.comb(n + 2, m)
        ac.st(ans1 - ans2)
        return

    @staticmethod
    def lg_p3904_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3904
        tag: second_stirling_number|dp|classical
        """
        n, m = ac.read_list_ints()
        dp = [[0] * m for _ in range(n)]
        dp[0][0] = 1
        for i in range(1, n):
            dp[i][0] = 1
            for j in range(1, m):
                dp[i][j] = dp[i - 1][j] * (j + 1) + dp[i - 1][j - 1]
        ac.st(dp[n - 1][m - 1])
        return

    @staticmethod
    def lg_p3904_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3904
        tag: second_stirling_number|dp|classical
        """
        n, m = ac.read_list_ints()
        ans = 0
        for k in range(m):
            cur = ((-1) ** k) * math.comb(m, k) * ((m - k) ** n)
            ans += cur
        ans //= math.factorial(m)
        ac.st(ans)
        return

    @staticmethod
    def lg_p5684(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5684
        tag: inclusion_exclusion|counter
        """

        n = ac.read_int()
        mod = 10 ** 9 + 7
        cb = Combinatorics(n, mod)
        s = ac.read_str()
        cnt = Counter(s)
        odd = sum(cnt[x] % 2 for x in cnt)
        if odd > 1:
            ans = 0
        else:
            lst = [cnt[x] // 2 for x in cnt if cnt[x] > 1]
            ans = 1
            s = sum(lst)
            for x in lst:
                ans *= cb.comb(s, x)
                s -= x
                ans %= mod
        total = 1
        s = n
        mu = 1
        for x in cnt:
            total *= cb.comb(s, cnt[x])
            s -= cnt[x]
            total %= mod
            mu *= cb.factorial(cnt[x])
            mu %= mod
        ac.st((total - ans) * mu % mod)
        return

    @staticmethod
    def lg_p6057(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6057
        tag: inclusion_exclusion|counter|classical|brain_teaser|hard
        """

        n, m = ac.read_list_ints()
        degree = [0] * n
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            degree[x] += 1
            degree[y] += 1
        ans = 0
        for i in range(n):
            ans += (n - 1 - degree[i]) * degree[i]
        ans //= 2
        ac.st(n * (n - 1) * (n - 2) // 6 - ans)
        return

    @staticmethod
    def cf_414b_1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/414/problem/B
        tag: min_prime|partition_method|counter|dp|classical|hard
        """
        mod = 10 ** 9 + 7
        n, k = ac.read_list_ints()
        mp = PrimeFactor(n)
        rp = Combinatorics(15 + 1, mod)
        cnt = [0] * (n + 1)  # last mi
        res = [0] * (n + 1)  # last cnt
        cnt[1] = res[1] = ans = 1
        for last in range(2, n + 1):
            p = mp.min_prime[last]
            pre = last // p
            if mp.min_prime[pre] == p:
                cnt[last] = cnt[pre] + 1
                res[last] = res[pre] * (k + cnt[last] - 1) * rp.inv(cnt[last]) % mod
            else:
                cnt[last] = 1
                res[last] = res[pre] * k % mod
            ans = (ans + res[last]) % mod
        ac.st(ans)
        return

    @staticmethod
    def cf_414b_2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/414/problem/B
        tag: min_prime|partition_method|counter|dp|classical|hard
        """
        mod = 10 ** 9 + 7
        n, k = ac.read_list_ints()
        np = PrimeFactor(n)
        res = 0
        for last in range(1, n + 1):
            temp = 1
            for _, cnt in np.prime_factor[last]:
                temp *= math.comb(cnt + k - 1, k - 1) % mod
            res = (res + temp) % mod
        ac.st(res)
        return

    @staticmethod
    def lc_1735(queries: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/count-ways-to-make-array-with-product/
        tag: prime_factorization|partition_method|classical|hard
        """
        mod = 10 ** 9 + 7
        nt = PrimeFactor(10 ** 4)
        cb = Combinatorics(10 ** 4 + 15, mod)

        ans = []
        for n, k in queries:
            cur = 1
            for _, c in nt.prime_factor[k]:
                cur *= cb.comb(c + n - 1, n - 1)
                cur %= mod
            ans.append(cur)
        return ans

    @staticmethod
    def lc_1866(n: int, k: int) -> int:
        """
        url: https://leetcode.cn/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/
        tag: first_stirling_number|dp|classical|hard
        """
        mod = 10 ** 9 + 7
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for i in range(n):
            for j in range(k):
                dp[i + 1][j + 1] = (dp[i][j] + dp[i][j + 1] * i) % mod
        return dp[n][k]

    @staticmethod
    def abc_132d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc132/tasks/abc132_d
        tag: comb|math|counter|classical|equation
        """

        n, k = ac.read_list_ints()
        mod = 10 ** 9 + 7
        cb = Combinatorics(n, mod)
        for i in range(1, k + 1):
            if n - k + 1 < i:
                ac.st(0)
                continue
            blue = cb.comb(k - 1, i - 1)
            red = cb.comb(n - k + 1, i)
            ans = blue * red
            ac.st(ans % mod)
        return

    @staticmethod
    def ac_4005(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4005/
        tag: matrix_dp|partition_method|classical|hard
        """

        n, m = ac.read_list_ints()
        cb = Combinatorics(n + 2 * m, 10 ** 9 + 7)
        ac.st(cb.comb(n + 2 * m - 1, 2 * m - 1))
        return

    @staticmethod
    def ac_4499(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4499/
        tag: partition_method|counter
        """

        mod = 998244353
        n, m, k = ac.read_list_ints()
        cb = Combinatorics(n, mod)
        ans = cb.comb(n - 1, k) * pow(m - 1, k, mod) * m
        ac.st(ans % mod)
        return

    @staticmethod
    def ac_5058(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/5058/
        tag: math|comb|mod|classical
        """
        mod = 10 ** 9 + 7
        n, m, k = ac.read_list_ints()
        cb = Combinatorics(m + n, mod)
        ac.st(cb.comb(n - 1, 2 * k) * cb.comb(m - 1, 2 * k) % mod)
        return

    @staticmethod
    def lg_p3811(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3811
        tag: mod_reverse|classical|hard
        """
        n, p = ac.read_list_ints()
        cb = Combinatorics(n, p)
        for x in range(1, n + 1):
            ac.st(cb.inv[x])
        return

    @staticmethod
    def cf_1833f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1833/problem/F
        tag: prefix_mul|mod
        """
        ac.get_random_seed()
        mod = 10 ** 9 + 7
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = sorted(ac.read_list_ints())
            cnt = Counter([num ^ ac.random_seed for num in nums])
            lst = sorted(list(set(nums)))
            pre = [1]
            ans = 0
            k = len(lst)
            for i in range(k):
                pre.append((pre[-1] * cnt[lst[i] ^ ac.random_seed]) % mod)
                if i >= m - 1 and lst[i - m + 1] + m - 1 == lst[i]:
                    ans += pre[-1] * pow(pre[i - m + 1], -1, mod)
                    ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def lg_p5431(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5431
        tag: mod_reverse|prefix_mul|postfix_mul|inclusion_exclusion
        """
        n, p, k = ac.read_list_ints()
        a = ac.read_list_ints()  # MLE
        post = [1] * (n + 1)
        for i in range(n - 1, -1, -1):
            post[i] = (post[i + 1] * a[i]) % p

        kk = k
        pre = 1
        ans = 0
        for i in range(n):
            ans += kk * pre * post[i + 1]
            ans %= p
            kk = (kk * k) % p
            pre = (pre * a[i]) % p
        ans *= pow(pre, -1, p)
        ans %= p
        ac.st(ans)
        return

    @staticmethod
    def cf_1929f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1929/problem/F
        tag: comb_perm|number_theory|partition_method
        """
        mod = 998244353
        for _ in range(ac.read_int()):
            n, c = ac.read_list_ints()
            dct = [[[] for _ in range(2)] for _ in range(n)]
            low = [1] * n
            high = [c] * n
            for i in range(n):
                ll, rr, val = ac.read_list_ints()
                if val != -1:
                    low[i] = high[i] = val
                if ll != -1:
                    dct[i][0].append(ll - 1)
                if rr != -1:
                    dct[i][1].append(rr - 1)

            order = []
            stack = [0]
            while stack:
                x = stack.pop()
                if x >= 0:
                    for y in dct[x][1]:
                        stack.append(y)
                    stack.append(~x)
                    for y in dct[x][0]:
                        stack.append(y)
                else:
                    x = ~x
                    order.append(x)
            for i in range(1, n):
                low[order[i]] = max(low[order[i - 1]], low[order[i]])
            for i in range(n - 2, -1, -1):
                high[order[i]] = min(high[order[i + 1]], high[order[i]])

            def comb(a, b):
                res = 1
                for aa in range(a, a - b, -1):
                    res *= aa
                    res %= mod
                p = 1
                for bb in range(1, b + 1):
                    p *= bb
                    p %= mod
                res *= pow(p, -1, mod)
                return res % mod

            pre_low = low[order[0]]
            pre_high = high[order[0]]
            cnt = 1
            ans = 1
            for i in order[1:]:
                if low[i] == pre_low and high[i] == pre_high:
                    cnt += 1
                else:
                    ans *= comb(pre_high - pre_low + 1 + cnt - 1, cnt)
                    cnt = 1
                    pre_low = low[i]
                    pre_high = high[i]
                    ans %= mod
            ans *= comb(pre_high - pre_low + 1 + cnt - 1, cnt)
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def abc_295e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc295/tasks/abc295_e
        tag: expectation|brute_force|inclusion_exclusion|brain_teaser|classical
        """
        mod = 998244353
        n, m, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        zero = nums.count(0)
        tot = pow(m, zero, mod)
        pre = [0] * (m + 2)
        cb = Combinatorics(n + 100, mod)
        for num in range(1, m + 1):
            more = sum(x >= num for x in nums)
            cur = 0
            for x in range(zero + 1):
                y = zero - x
                if x and num == 1:
                    continue
                if more + y >= n - k + 1:
                    cur += cb.comb(zero, x) * pow(num - 1, x, mod) * pow(m - num + 1, y, mod)
                    cur %= mod
            pre[num] = cur
        ans = sum(x * (pre[x] - pre[x + 1]) for x in range(1, m + 1)) % mod
        ans = ans * pow(tot, -1, mod) % mod
        ac.st(ans)
        return

    @staticmethod
    def abc_266g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc266/tasks/abc266_g
        tag: comb|brain_teaser|inclusion_exclusion|classical
        """
        mod = 998244353
        r, g, b, k = ac.read_list_ints()
        cb = Combinatorics(2 * 10 ** 6, mod)
        ans = cb.comb(g + b, g - k) * cb.comb(b + k, k) * cb.comb(b + r, b + k)
        ac.st(ans % mod)
        return

    @staticmethod
    def abc_266g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc266/tasks/abc266_g
        tag: comb|brain_teaser|inclusion_exclusion|classical
        """
        mod = 998244353
        r, g, b, k = ac.read_list_ints()
        cb = Combinatorics(2 * 10 ** 6, mod)
        ans = cb.comb(g + b, g - k) * cb.comb(b + k, k) * cb.comb(b + r, b + k)
        ac.st(ans % mod)
        return

    @staticmethod
    def abc_262e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc262/tasks/abc262_e
        tag: brain_teaser|comb|classical
        """
        n, m, k = ac.read_list_ints()
        degree = [0] * n
        mod = 998244353
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            degree[u] += 1
            degree[v] += 1
        odd = sum(x % 2 for x in degree)
        ans = 0
        cb = Combinatorics(n + 10, mod)
        for x in range(0, odd + 1, 2):
            if x <= k <= n - odd + x:
                ans += cb.comb(odd, x) * cb.comb(n - odd, k - x)
                ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_240g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc240/tasks/abc240_g
        tag: math|comb|counter|classical
        """
        n, x, y, z = ac.read_list_ints()
        mod = 998244353
        x = abs(x)
        y = abs(y)
        z = abs(z)
        m = n - x - y - z
        if m < 0 or m % 2:
            ac.st(0)
            return

        def check(step, target):
            if step >= target and (step - target) % 2 == 0:
                return cb.comb(step, (step + target) // 2)
            return 0

        cb = Combinatorics(n, mod)
        ans = 0
        for a in range(x, n - y - z + 1):
            ans += cb.comb(n, a) * check(a, x) * check(n - a, z + y) * check(n - a, abs(z - y))
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_235g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc235/tasks/abc235_g
        tag: inclusion_exclusion|comb|counter|math|brain_teaser|classical
        """
        mod = 998244353
        n, a, b, c = ac.read_list_ints()
        cb = Combinatorics(n + 10, mod)

        def check(m):
            f = [0] * (n + 1)
            f[n] = sum(cb.comb(n, j) for j in range(m + 1)) % mod
            for i in range(n - 1, -1, -1):
                f[i] = (f[i + 1] + cb.comb(i, m)) * cb.inv[2]
                f[i] %= mod
            return f

        fa = check(a)
        fb = check(b)
        fc = check(c)

        ans = 0
        for x in range(n + 1):
            sign = 1 if x % 2 == 0 else -1
            ans += sign * cb.comb(n, x) * fa[n - x] * fb[n - x] * fc[n - x]
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_232e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc232/tasks/abc232_e
        tag: brute_force|linear_dp|comb
        """
        mod = 998244353
        m, n, k = ac.read_list_ints()
        x1, y1, x2, y2 = ac.read_list_ints()
        cb = Combinatorics(k + 10, mod)

        def check(tot, start, target):
            dp = [[0, 0]]
            if start == target:
                dp[0][0] = 1
            else:
                dp[0][1] = 1
            for _ in range(k):
                a, b = dp[-1]
                aa = b
                bb = a * (tot - 1) + b * (tot - 2)
                dp.append([aa % mod, bb % mod])
            return dp

        dp1 = check(m, x1, x2)
        dp2 = check(n, y1, y2)
        ans = 0
        for x in range(k + 1):
            c = cb.comb(k, x) * dp1[x][0] * dp2[k - x][0]
            ans += c
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def abc_226f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc226/tasks/abc226_f
        tag: bag_dp|brute_force|comb
        """

        n, k = ac.read_list_ints()
        mod = 998244353

        dp = [set() for _ in range(n + 1)]
        dp[0].add(tuple())
        for num in range(1, n + 1):
            for i in range(num, n + 1):
                dp[i] |= {tuple(list(p) + [num]) for p in dp[i - num]}

        ans = 0
        f = [1] * (n + 1)
        for x in range(1, n + 1):
            f[x] = f[x - 1] * x
            f[x] %= mod

        cb = Combinatorics(n + 10, mod)

        @lru_cache(None)
        def dfs(a, b):
            return math.lcm(a, b)

        for tp in dp[-1]:
            dct = Counter(tp)
            cnt = 1
            tot = n
            g = 1
            for x in sorted(dct, reverse=True):
                cc = dct[x]
                if x > 1:
                    g = dfs(g, x)
                    for _ in range(cc):
                        cnt *= cb.comb(tot, x) * f[x - 1]
                        cnt %= mod
                        tot -= x
                    cnt *= cb.rev[cc]
                    cnt %= mod
                else:
                    break
            ans += pow(g, k, mod) * cnt
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lc_2929(n: int, limit: int) -> int:
        """
        url: https://leetcode.cn/problems/distribute-candies-among-children-ii
        tag: comb|inclusion_exclusion|partition_method
        """

        def comb2(a):
            return math.comb(a, 2) if a >= 2 else 0

        ans = comb2(n + 2)
        ans -= comb2(n - (limit + 1) + 2) * math.comb(3, 1)
        ans += comb2(n - ((limit + 1) * 2) + 2) * math.comb(3, 1)
        ans -= comb2(n - ((limit + 1) * 3) + 2)
        return ans

    @staticmethod
    def cc_1_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/LUCMAT
        tag: math|comb|brute_force|classical
        """
        mod = 10 ** 9 + 7
        rev = pow(2, -1, mod)
        cb = Combinatorics(2 * 10 ** 5 + 10, mod)
        for _ in range(ac.read_int()):
            n, m, k, x, y = ac.read_list_ints()
            p = x * pow(y, -1, mod) % mod
            p = (1 - 2 * p) % mod
            pre = 1
            ans = 0
            for s in range(1, min(k + 1, n + 1)):
                pre = (pre * p) % mod
                even = rev * (1 + pre) % mod
                ans += cb.comb(n, s) * pow(even, m, mod)
            ac.st(ans % mod)
        return

    @staticmethod
    def cc_1_2(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/LUCMAT
        tag: math|comb|
        """
        mod = 10 ** 9 + 7

        cb = Combinatorics(2 * 10 ** 5 + 10, mod)
        for _ in range(ac.read_int()):
            n, m, k, x, y = ac.read_list_ints()
            p = x * pow(y, -1, mod) % mod
            odd = 0
            even = 1
            ans = 0
            for s in range(1, min(k + 1, n + 1)):
                odd, even = (even * p + odd * (1 - p)) % mod, (odd * p + even * (1 - p)) % mod
                ans += cb.comb(n, s) * pow(even, m, mod)
            ac.st(ans % mod)
        return

    @staticmethod
    def cf_1420d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1420/D
        tag: contribution_method|comb|range
        """
        mod = 998244353
        cb = Combinatorics(3 * 10 ** 5, mod)
        n, k = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]
        lst = SortedList()
        nums.sort()
        ans = 0
        for ll, rr in nums:
            cur = len(lst) - lst.bisect_left(ll)
            if cur >= k - 1:
                ans += cb.comb(cur, k - 1)
            lst.add(rr)
        ac.st(ans % mod)
        return

    @staticmethod
    def cf_1359e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1359/E
        tag: math|comb|brute_force
        """
        mod = 998244353
        cb = Combinatorics(5 * 10 ** 5, mod)
        n, k = ac.read_list_ints()
        ans = 0
        for x in range(1, n + 1):
            if n // x < k:
                break
            ans += cb.comb(n // x - 1, k - 1)
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def cf_1992g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1992/problem/G
        tag: brute_force|contribution_method|comb
        """
        mod = 10 ** 9 + 7
        cb = Combinatorics(5000, mod)

        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = 0
            for x in range(1, 2 * n + 2):
                for size in range(x // 2, min(n + 1, x)):
                    small = x - size - 1
                    big = size - small
                    cnt = cb.comb(min(x - 1, n), small)
                    if max(n - x, 0) < big:
                        break
                    if x < n:
                        cnt *= cb.comb(n - x, big)
                    ans += x * cnt
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def cf_895c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/895/C
        tag: bit_operation|comb|prime_factor|odd_even
        """
        mod = 10 ** 9 + 7
        primes = PrimeSieve().eratosthenes_sieve(70)
        k = len(primes)
        cnt = [0] * 71
        ac.read_int()
        nums = ac.read_list_ints()
        for num in nums:
            cnt[num] += 1
        pf = PrimeFactor(70)
        ind = {p: i for i, p in enumerate(primes)}
        dp = [0] * (1 << k)
        dp[0] = 1
        for num in range(1, 71):
            if cnt[num]:
                ndp = dp[:]
                state = 0
                for p, c in pf.prime_factor[num]:
                    if c % 2:
                        state |= 1 << ind[p]
                odd = pow(2, cnt[num] - 1, mod)  # sum(cb.comb(cnt[num], x) for x in range(1, cnt[num], 2))
                even = (odd - 1) % mod
                for s in range(1 << k):
                    ndp[s ^ state] += dp[s] * odd
                    ndp[s] += dp[s] * even
                    ndp[s] %= mod
                    ndp[s ^ state] %= mod
                dp = [x % mod for x in ndp]
        ans = (dp[0] - 1) % mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p6184(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6184
        tag: comb|inclusion_exclusion|partition_method
        """
        n = ac.read_int()
        ans = (n - 1) * (n - 2) * (n - 3) // 6 - (n // 2 - 1) * (n // 2) * (n // 2 * 2 - 1) // 3 + 2 + (n // 2 + 1) * (
                n // 2 - 2)
        ac.st(ans)
        return

    @staticmethod
    def abc_205e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc205/tasks/abc205_e
        tag: comb|math|geometry|brain_teaser|corner_case
        """
        n, m, k = ac.read_list_ints()
        mod = 10 ** 9 + 7
        if n > m + k:
            ac.st(0)
            return
        cb = Combinatorics(m + n + 10, mod)
        ans = cb.comb(m + n, m) - cb.comb(m + n, m + k + 1)
        ac.st(ans % mod)
        return

    @staticmethod
    def lc_3317(n: int, x: int, y: int) -> int:
        """
        url: https://leetcode.com/problems/find-the-number-of-possible-ways-for-an-event/
        tag: comb|inclusion_exclusion|brute_force
        """
        mod = 10 ** 9 + 7
        cb = Combinatorics(1000, mod)
        ans = 0
        cnt = [pow(xx, n, mod) for xx in range(1, x + 1)]
        for i in range(1, x + 1):
            pre = 0
            for j in range(1, i):
                pre += cb.comb(i, j) * cnt[j - 1]
            cnt[i - 1] -= pre
            cnt[i - 1] %= mod

        pp = 1
        for xx in range(1, min(x, n) + 1):
            pp = pp * y % mod
            cur = cb.comb(x, xx) * cnt[xx - 1] * pp % mod
            ans += cur % mod
            ans %= mod
        return ans
"""
Algorithm：convex_hull|minimum_circle_coverage|random_increment_method
Description：convex_hull

====================================LeetCode====================================
1924（https://leetcode.cn/problems/erect-the-fence-ii/）convex_hull|tripart_pack_tripart|minimum_circle_coverage

=====================================LuoGu======================================
P1742（https://www.luogu.com.cn/problem/P1742）random_increment_method|minimum_circle_coverage
P3517（https://www.luogu.com.cn/problem/P3517）binary_search_of_binary_search|random_increment_method|minimum_circle_coverage

"""

from typing import List

from src.mathmatics.convex_hull.template import MinCircleOverlap
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1924(trees: List[List[int]]) -> List[float]:
        """
        url: https://leetcode.cn/problems/erect-the-fence-ii/
        tag: convex_hull|tripart_pack_tripart|minimum_circle_coverage
        """
        # 随机增量法求最小圆覆盖
        ans = MinCircleOverlap().get_min_circle_overlap(trees)
        return list(ans)

    @staticmethod
    def lg_p1742(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1742
        tag: random_increment_method|minimum_circle_coverage
        """
        # 随机增量法求最小圆覆盖
        n = ac.read_int()
        nums = [ac.read_list_floats() for _ in range(n)]
        x, y, r = MinCircleOverlap().get_min_circle_overlap(nums)
        ac.st(r)
        ac.lst([x, y])
        return

    @staticmethod
    def lg_3517(ac=FastIO()):

        # 随机增量法求最小圆覆盖
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(n)]

        def check(r):

            def circle(lst):
                x, y, rr = MinCircleOverlap().get_min_circle_overlap(lst)
                return x, y, rr

            cnt = i = 0
            res = []
            while i < n:
                left = i
                right = n - 1
                while left < right - 1:
                    mm = left + (right - left) // 2
                    if circle(nums[i:mm + 1])[2] <= r:
                        left = mm
                    else:
                        right = mm
                ll = circle(nums[i:right + 1])
                if ll[2] > r:
                    ll = circle(nums[i:left + 1])
                    i = left + 1
                else:
                    i = right + 1
                res.append(ll[:-1])
                cnt += 1
            return res, cnt <= m

        low = 0
        high = 4 * 10 ** 6
        error = 10 ** (-6)
        while low < high - error:
            mid = low + (high - low) / 2
            if check(mid)[1]:
                high = mid
            else:
                low = mid

        nodes, flag = check(low)
        rrr = low
        if not flag:
            nodes, flag = check(high)
            rrr = high
        ac.st(rrr)
        ac.st(len(nodes))
        for a in nodes:
            ac.lst([round(a[0], 10), round(a[1], 10)])
        return
"""
Algorithm：chinese_remainder_theorem|extended_chinese_remainder_theorem|ex_crt|crt
Description：equation|same_mod


====================================LeetCode====================================

=====================================LuoGu======================================
p1495（https://www.luogu.com.cn/problem/p1495）mod_coprime|chinese_reminder_theorem|classical
P4777（https://www.luogu.com.cn/problem/P4777）mod_not_coprime|crt|chinese_reminder_theorem|classical
P3868（https://www.luogu.com.cn/problem/P3868）ex_crt|chinese_reminder_theorem|classical

====================================AtCoder=====================================
ABC286F（https://atcoder.jp/contests/abc286/tasks/abc286_f）chinese_reminder_theorem|interaction|circular_section|classical
ABC371G（https://atcoder.jp/contests/abc371/tasks/abc371_g）ex_crt|implemention|greedy|classical


===================================CodeForces===================================

"""
from src.mathmatics.extend_crt.template import CRT, ExtendCRT
from src.mathmatics.number_theory.template import PrimeSieve
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def main(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc286/tasks/abc286_f
        tag: chinese_reminder_theorem|interaction|circular_section|classical
        """
        ac.flush = True
        lst = [x for x in PrimeSieve().eratosthenes_sieve(110) if x < 110]
        tot = lst[:9]
        tot[0] *= tot[0]
        tot[1] *= tot[1]
        m = sum(tot)
        assert m == 108
        nums = list(range(1, m + 1))
        pre = 0
        circle = dict()
        for num in tot:
            tmp = nums[pre:pre + num]
            nums[pre:pre + num] = tmp[1:] + tmp[:1]
            circle[pre + 1] = tmp[1:] + tmp[:1]
            pre += num
        ac.st(m)
        ac.lst(nums)
        b = ac.read_list_ints_minus_one()
        mod_res = []
        pre = 0
        for num in tot:
            tmp = b[pre:pre + num]
            mod_res.append((num, (tmp[0] - pre) % num))
            pre += num
        ans = CRT().chinese_remainder(mod_res)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1495(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1495
        tag: chinese_reminder_theorem|classical
        """
        n = ac.read_int()
        crt = CRT()
        pairs = [ac.read_list_ints() for _ in range(n)]
        ans = crt.chinese_remainder(pairs)
        ac.st(ans)
        return

    @staticmethod
    def lg_p4777(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4777
        tag: chinese_reminder_theorem|classical
        """
        n = ac.read_int()
        ex_crt = ExtendCRT()
        pairs = [ac.read_list_ints()[::-1] for _ in range(n)]
        ans = ex_crt.pipline(pairs)[0]
        ac.st(ans)
        return

    @staticmethod
    def lg_p3868(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3868
        tag: chinese_reminder_theorem|classical
        """
        ac.read_int()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        ex_crt = ExtendCRT()
        pairs = [[x % y, y] for x, y in zip(a, b)]
        ans = ex_crt.pipline(pairs)[0]
        ac.st(ans)
        return
"""
Algorithm：fast_power|matrix_fast_power|dp|mod_reverse
Description：mod|power|doubling|multiplication_method

====================================LeetCode====================================
450（https://leetcode.cn/problems/number-of-distinct-binary-strings-after-applying-operations/）brain_teaser|fast_power
1931（https://leetcode.cn/problems/painting-a-grid-with-three-different-colors/）matrix_fast_power|dp
2851（https://leetcode.cn/problems/string-transformation/description/）kmp|matrix_fast_power|classical
1622（https://leetcode.cn/problems/fancy-sequence/description/）reverse_thinking|mod_reverse|inclusion_exclusion
552（https://leetcode.cn/problems/student-attendance-record-ii）matrix_fast_power|dp

=====================================LuoGu======================================
P1630（https://www.luogu.com.cn/problem/P1630）fast_power|counter|mod
P1939（https://www.luogu.com.cn/problem/P1939）matrix_fast_power
P1962（https://www.luogu.com.cn/problem/P1962）matrix_fast_power
P3390（https://www.luogu.com.cn/problem/P3390）matrix_fast_power
P3811（https://www.luogu.com.cn/problem/P3811）mod_reverse
P5775（https://www.luogu.com.cn/problem/P5775）implemention|prefix_sum|matrix_fast_power|implemention
P6045（https://www.luogu.com.cn/problem/P6045）brain_teaser|counter|fast_power|brute_force
P6075（https://www.luogu.com.cn/problem/P6075）comb|counter|fast_power
P6392（https://www.luogu.com.cn/problem/P6392）math|fast_power
P1045（https://www.luogu.com.cn/problem/P1045）math|fast_power
P3509（https://www.luogu.com.cn/problem/P3509）two_pointers|implemention|fast_power
P1349（https://www.luogu.com.cn/problem/P1349）matrix_fast_power
P2233（https://www.luogu.com.cn/problem/P2233）matrix_fast_power
P2613（https://www.luogu.com.cn/problem/P2613）mod_reverse
P3758（https://www.luogu.com.cn/problem/P3758）matrix_dp|matrix_fast_power
P5789（https://www.luogu.com.cn/problem/P5789）matrix_dp|matrix_fast_power
P5343（https://www.luogu.com.cn/problem/P5343）linear_dp|matrix_fast_power
P8557（https://www.luogu.com.cn/problem/P8557）brain_teaser|fast_power|counter
P8624（https://www.luogu.com.cn/problem/P8624）matrix_dp|matrix_fast_power
P1306（https://www.luogu.com.cn/problem/P1306）matrix_fast_power|math|fibonacci_property|classical
P2174（https://www.luogu.com.cn/problem/P2174）mod_reverse


=====================================CodeForces=====================================
1117D（https://codeforces.com/problemset/problem/1117/D）matrix_fast_power|classical|observation


=====================================AcWing=====================================
27（https://www.acwing.com/problem/content/26/）float_fast_power|classical

=====================================AtCoder=====================================
ABC236G（https://atcoder.jp/contests/abc236/tasks/abc236_g）matrix_fast_power|matrix_fast_power_min|brain_teaser|classical
ABC204F（https://atcoder.jp/contests/abc204/tasks/abc204_f）matrix_fast_power|bag_dp|brute_force|build_graph
ABC199F（https://atcoder.jp/contests/abc199/tasks/abc199_f）expectation|matrix_fast_power|classical

"""
import math


from src.mathmatics.fast_power.template import MatrixFastPower, FastPower, MatrixFastPowerFlatten, MatrixFastPowerMin
from src.strings.kmp.template import KMP
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_2851(s: str, t: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/string-transformation/description/
        tag: kmp|matrix_fast_power|classical
        """
        mod = 10 ** 9 + 7
        n = len(s)
        kmp = KMP()
        z = kmp.prefix_function(t + "#" + s + s)
        p = sum(z[i] == n for i in range(2 * n, 3 * n))
        q = n - p
        mat = [[p - 1, p], [q, q - 1]]
        vec = [1, 0] if z[2 * n] == n else [0, 1]
        res = MatrixFastPower().matrix_pow(mat, k, mod)
        ans = vec[0] * res[0][0] + vec[1] * res[0][1]
        return ans % mod

    @staticmethod
    def lg_p1045(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1045
        tag: math|fast_power
        """

        p = ac.read_int()
        ans1 = int(p * math.log10(2)) + 1
        ans2 = pow(2, p, 10 ** 501) - 1
        ans2 = str(ans2)[-500:]
        ac.st(ans1)
        ans2 = "0" * (500 - len(ans2)) + ans2
        for i in range(0, 500, 50):
            ac.st(ans2[i:i + 50])
        return

    @staticmethod
    def lg_p1630(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1630
        tag: fast_power|counter|mod|brain_teaser|permutation_circle|classical|hard
        """

        mod = 10 ** 4
        for _ in range(ac.read_int()):
            a, b = ac.read_list_ints()
            rest = [0] + [pow(i, b, mod) for i in range(1, mod)]
            ans = sum(rest) * (a // mod) + sum(rest[:a % mod + 1])
            ac.st(ans % mod)
        return

    @staticmethod
    def lg_p1939(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1939
        tag: matrix_fast_power
        """

        mat = [[1, 0, 1], [1, 0, 0], [0, 1, 0]]
        lst = [1, 1, 1]
        mod = 10 ** 9 + 7
        mfp = MatrixFastPower()
        for _ in range(ac.read_int()):
            n = ac.read_int()
            if n > 3:
                nex = mfp.matrix_pow(mat, n - 3)
                ans = sum(nex[0]) % mod
                ac.st(ans)
            else:
                ac.st(lst[n - 1])
        return

    @staticmethod
    def lg_p3509(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3509
        tag: two_pointers|implemention|fast_power|sparse_matrix_fast_power|classical|hard|multiplication_method
        """

        n, k, m = ac.read_list_ints()
        nums = ac.read_list_ints()

        ans = list(range(n))
        nex = [0] * n
        head = 0
        tail = k
        for i in range(n):
            while tail + 1 < n and nums[tail + 1] - nums[i] < nums[i] - nums[head]:
                head += 1
                tail += 1
            if nums[tail] - nums[i] <= nums[i] - nums[head]:
                nex[i] = head
            else:
                nex[i] = tail

        while m:
            if m & 1:
                ans = [nex[ans[i]] for i in range(n)]
            nex = [nex[nex[i]] for i in range(n)]
            m >>= 1
        ac.lst([a + 1 for a in ans])
        return

    @staticmethod
    def lg_p1349(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1349
        tag: matrix_fast_power
        """
        p, q, a1, a2, n, m = ac.read_list_ints()
        if n == 1:
            ac.st(a1 % m)
            return
        if n == 2:
            ac.st(a2 % m)
            return
        mat = [[p, q], [1, 0]]
        res = MatrixFastPower().matrix_pow(mat, n - 2, m)
        ans = res[0][0] * a2 + res[0][1] * a1
        ans %= m
        ac.st(ans)
        return

    @staticmethod
    def lg_p2233(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2233
        tag: matrix_fast_power
        """
        n = ac.read_int()
        mat = [[0, 1, 0, 0, 0, 0, 0, 1],
               [1, 0, 1, 0, 0, 0, 0, 0],
               [0, 1, 0, 1, 0, 0, 0, 0],
               [0, 0, 1, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 1, 0],
               [0, 0, 0, 0, 0, 1, 0, 1],
               [1, 0, 0, 0, 0, 0, 1, 0]]
        res = [1, 0, 0, 0, 0, 0, 0, 0]
        mat_pow = MatrixFastPower().matrix_pow(mat, n - 1, 1000)
        ans = [sum(mat_pow[i][j] * res[j] for j in range(8)) for i in range(8)]
        final = (ans[3] + ans[5]) % 1000
        ac.st(final)
        return

    @staticmethod
    def lg_p2613(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2613
        tag: mod_reverse
        """
        mod = 19260817
        a = ac.read_int()
        b = ac.read_int()
        ans = a * pow(b, -1, mod)
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p3758(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3758
        tag: matrix_dp|matrix_fast_power
        """

        n, m = ac.read_list_ints()
        grid = [[0] * (n + 1) for _ in range(n + 1)]
        for i in range(n + 1):
            grid[i][i] = 1
            grid[0][i] = 1
        for _ in range(m):
            u, v = ac.read_list_ints()
            grid[u][v] = grid[v][u] = 1

        initial = [0] * (n + 1)
        initial[1] = 1
        mod = 2017
        t = ac.read_int()
        ans = MatrixFastPower().matrix_pow(grid, t, mod)
        res = 0
        for i in range(n + 1):
            res += sum(ans[i][j] * initial[j] for j in range(n + 1))
            res %= mod
        ac.st(res)
        return

    @staticmethod
    def lg_p5343(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5343
        tag: linear_dp|matrix_fast_power
        """

        mod = 10 ** 9 + 7
        n = ac.read_int()
        ac.read_int()
        a = set(ac.read_list_ints())
        ac.read_int()  # TLE
        pre = sorted(list(a.intersection(set(ac.read_list_ints()))))
        m = max(pre)

        dp = [0] * (m + 1)
        dp[0] = 1
        for i in range(1, m + 1):
            for j in pre:
                if i < j:
                    break
                dp[i] += dp[i - j]
            dp[i] %= mod
        if n <= m:
            ac.st(dp[n])
            return

        mat = [0] * (m + 1) * (m + 1)
        for i in range(m, 0, -1):
            mat[i * (m + 1) + i - 1] = 1
        for j in pre:
            mat[j - 1] = 1

        res = MatrixFastPowerFlatten().matrix_pow_flatten(mat, m + 1, n - m, mod)
        ans = 0
        for j in range(m + 1):
            ans += res[j] * dp[m - j]
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p8557(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8557
        tag: brain_teaser|fast_power|counter|classical|hard
        """
        mod = 998244353
        n, k = ac.read_list_ints()
        ans = pow((pow(2, k, mod) - 1) % mod, n, mod)
        ac.st(ans)
        return

    @staticmethod
    def lg_p8624(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8624
        tag: matrix_dp|matrix_fast_power
        """

        mod = 10 ** 9 + 7
        n, m = ac.read_list_ints()
        rem = [[0] * 6 for _ in range(6)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            rem[i][j] = rem[j][i] = 1
        rev = [3, 4, 5, 0, 1, 2]
        cnt = [1] * 6
        mat = [[0] * 6 for _ in range(6)]
        for i in range(6):
            for j in range(6):
                if not rem[j][rev[i]]:
                    mat[i][j] = 1
        res = MatrixFastPower().matrix_pow(mat, n - 1, mod)
        ans = sum([sum([res[i][j] * cnt[j] for j in range(6)])
                   for i in range(6)])
        ans *= FastPower().fast_power(4, n, mod)
        ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def ac_27(base, exponent):
        """
        url: https://www.acwing.com/problem/content/26/
        tag: float_fast_power|classical
        """

        if base == 0:
            return 0
        if exponent == 0:
            return 1
        return FastPower().float_fast_pow(base, exponent)

    @staticmethod
    def lg_p1306(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1306
        tag: matrix_fast_power|math|fibonacci_property|classical
        """
        n, m = ac.read_list_ints()
        g = math.gcd(n, m)
        base = [[0, 1], [1, 1]]
        mod = 10 ** 8
        ans = MatrixFastPower().matrix_pow(base, g, mod)
        ac.st(ans[0][1])
        return

    @staticmethod
    def abc_236g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc236/tasks/abc236_g
        tag: matrix_fast_power|matrix_fast_power_min|brain_teaser|classical
        """
        n, t, ll = ac.read_list_ints()
        grid = [[math.inf] * n for _ in range(n)]
        for i in range(1, t + 1):
            u, v = ac.read_list_ints_minus_one()
            grid[v][u] = i
        initial = [0] + [math.inf] * (n - 1)
        res = MatrixFastPowerMin().matrix_pow(grid, ll)
        ans = [max(res[i][0], initial[0]) for i in range(n)]
        ans = [x if x < math.inf else -1 for x in ans]
        ac.lst(ans)
        return

    @staticmethod
    def abc_204f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc204/tasks/abc204_f
        tag: matrix_fast_power|bag_dp|brute_force|build_graph
        """
        m, n = ac.read_list_ints()
        mod = 998244353

        grid = [[0] * (1 << m) for _ in range(1 << m)]
        for s in range(1 << m):
            for row in range(1 << m):
                for col in range(1 << m):
                    for one in range(1 << m):
                        cur = s
                        nex = 0
                        flag = 1
                        for r in range(m):
                            if (row >> r) & 1:
                                if cur & (1 << r) or nex & (1 << r):
                                    flag = 0
                                    break
                                cur |= 1 << r
                                nex |= 1 << r
                        for c in range(m):
                            if (col >> c) & 1:
                                if c == m - 1:
                                    flag = 0
                                    break
                                if cur & (1 << c) or cur & (1 << (c + 1)):
                                    flag = 0
                                    break
                                cur |= 1 << c
                                cur |= 1 << (c + 1)
                        if cur & one:
                            flag = 0
                        if (cur | one) != (1 << m) - 1:
                            flag = 0
                        if flag:
                            grid[nex][s] += 1

        cnt = []
        for s in range(1 << m):
            dp = [0] * (m + 1)
            dp[0] = 1
            for i in range(m):
                if (s >> i) & 1:
                    dp[i + 1] = dp[i]
                else:
                    dp[i + 1] = dp[i]
                    if i - 1 >= 0 and not (s >> (i - 1)) & 1:
                        dp[i + 1] += dp[i - 1]
            cnt.append(dp[-1])

        original = [0] * (1 << m)
        original[-1] = 1
        res = MatrixFastPower().matrix_pow(grid, n, mod)
        ans = 0
        for i in range(1 << m):
            ans += res[i][-1] * original[-1] * cnt[i]
        ac.st(ans % mod)
        return

    @staticmethod
    def abc_199f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc199/tasks/abc199_f
        tag: expectation|matrix_fast_power|classical
        """
        n, m, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        mod = 10 ** 9 + 7
        p = pow(2 * m, -1, mod)

        grid = [[0] * n for _ in range(n)]
        for x in range(n):
            grid[x][x] = 1
            for y in dct[x]:
                grid[x][y] = p
            grid[x][x] -= len(dct[x]) * p
            grid[x][x] %= mod
        res = MatrixFastPower().matrix_pow(grid, k, mod)
        for i in range(n):
            ac.st(sum(res[i][j] * nums[j] for j in range(n)) % mod)
        return
"""
Algorithm：ex_gcd|binary_gcd|bin_gcd|peishu_theorem
Description：single_equation

====================================LeetCode====================================
365（https://leetcode.cn/problems/water-and-jug-problem/）peishu_theorem|greedy
2543（https://leetcode.cn/contest/biweekly-contest-96/problems/check-if-point-is-reachable/）binary_gcd|ex_gcd

=====================================LuoGu======================================
P1082（https://www.luogu.com.cn/problem/P1082）same_mod|equation
P5435（https://www.luogu.com.cn/problem/P5435）binary_gcd|classical
P5582（https://www.luogu.com.cn/problem/P5582）greedy|brain_teaser|ex_gcd|peishu_theorem
P1516（https://www.luogu.com.cn/problem/P1516）single_equation


=====================================AtCoder======================================
ABC340F（https://atcoder.jp/contests/abc340/tasks/abc340_f）ex_gcd|equation|math

=====================================CodeForces======================================
1152C（https://codeforces.com/problemset/problem/1152/C）gcd_like|observation|brute_force
1260C（https://codeforces.com/problemset/problem/1260/C）gcd_like|brain_teaser|math|partition_method

=====================================AcWing=====================================
4299（https://www.acwing.com/problem/content/4299/）single_equation|ex_gcd

"""
import math

from src.mathmatics.gcd_like.template import GcdLike
from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def ac_4299(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4299/
        tag: single_equation|extend_gcd
        """
        n, a, b = [ac.read_int() for _ in range(3)]
        lst = GcdLike().solve_equation(a, b, n)
        if not lst:
            ac.no()
        else:
            gcd, x0, y0 = lst
            low = math.ceil((-x0 * gcd) / b)
            high = (y0 * gcd) // a
            if low <= high:
                x = x0 + (b // gcd) * low
                ac.yes()
                ac.lst([x, (n - a * x) // b])
            else:
                ac.no()
        return

    @staticmethod
    def abc_340f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc340/tasks/abc340_f
        tag: ex_gcd|equation|math
        """
        x, y = ac.read_list_ints()
        if x == 0:
            if 2 % abs(y) == 0:
                ac.lst([2 // abs(y), 0])
            else:
                ac.st(-1)
            return
        if y == 0:
            if 2 % abs(x) == 0:
                ac.lst([0, 2 // abs(x)])
            else:
                ac.st(-1)
            return

        lst = GcdLike().solve_equation(y, -x, 2)
        if not lst:
            ac.st(-1)
            return
        gcd, x0, y0 = lst[:]
        ac.lst([x0, y0])
        return
"""
Algorithm：geometry|plane|closest_pair
Description：triangle|rectangle|square|line|circle|cube

====================================LeetCode====================================
149（https://leetcode.cn/problems/max-points-on-a-line/）line_slope|brute_force|classical
1453（https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/）circle|classical|circle_center
939（https://leetcode.cn/problems/minimum-area-rectangle/）brute_force|rectangle
16（https://leetcode.cn/problems/intersection-lcci/）line_segment|intersection
16（https://leetcode.cn/problems/best-line-lcci/）line_slope|brute_force|classical
2013（https://leetcode.cn/problems/detect-squares/）brute_force|hash|counter|square
2280（https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/）line_slope
1401（https://leetcode.cn/problems/circle-and-rectangle-overlapping/）geometry|rectangle
1603（https://leetcode.cn/problems/intersection-lcci/description/）geometry

=====================================LuoGu======================================
P1665（https://www.luogu.com.cn/problem/P1665）brute_force|diagonal|square
P2313（https://www.luogu.com.cn/problem/P2313）square|circle
P2358（https://www.luogu.com.cn/problem/P2358）geometry|cube
P2665（https://www.luogu.com.cn/problem/P2665）slope
P1355（https://www.luogu.com.cn/problem/P1355）triangle|area|location
P1142（https://www.luogu.com.cn/problem/P1142）line_slope|brute_force|classical
P2778（https://www.luogu.com.cn/problem/P2778）brute_force|circle|location
P3021（https://www.luogu.com.cn/problem/P3021）inclusion_exclusion|counter|brute_force
P1257（https://www.luogu.com.cn/problem/P1257）closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
P7883（https://www.luogu.com.cn/problem/P7883）closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
P1429（https://www.luogu.com.cn/problem/P1429）closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
P2449（https://www.luogu.com.cn/problem/P2449）rectangle_overlap|rectangle_edge_touch|rectangle_corner_touch|geometry
P3844（https://www.luogu.com.cn/problem/P3844）geometry|implemention
P6341（https://www.luogu.com.cn/problem/P6341）line_scope|brute_force|right_triangle

===================================CodeForces===================================
961D（https://codeforces.com/contest/961/problem/D)）pigeonhole_principle|brute_force|line_slope|collinearity
429D（https://codeforces.com/contest/429/problem/D）closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
1133D（https://codeforces.com/contest/1133/problem/D）line_slope
1979E（https://codeforces.com/contest/1979/problem/E）manhattan_distance|chebyshev_distance|brute_force|two_pointers|map
1C（https://codeforces.com/contest/1/problem/C）geometry|circle|triangle
1354C1（https://codeforces.com/problemset/problem/1354/C1）geometry
1354C2（https://codeforces.com/problemset/problem/1354/C2）geometry
1552C（https://codeforces.com/problemset/problem/1552/C）geometry
598C（https://codeforces.com/problemset/problem/598/C）math|geometry|high_precision|angle_with_x_axis|angle_between_vectors
559A（https://codeforces.com/problemset/problem/559/A）geometry

===================================AtCoder===================================
ABC343E（https://atcoder.jp/contests/abc343/tasks/abc343_e）brute_force|brain_teaser|inclusion_exclusion|math|classical
ABC292F（https://atcoder.jp/contests/abc292/tasks/abc292_f）brain_teaser|math
ABC275C（https://atcoder.jp/contests/abc275/tasks/abc275_c）brute_force|geometry|square|angle|classical
ABC266C（https://atcoder.jp/contests/abc266/tasks/abc266_c）math|geometry|is_convex_quad|classical
ABC250F（https://atcoder.jp/contests/abc250/tasks/abc250_f）geometry|circular_array|two_pointers|brain_teaser
ABC234H（https://atcoder.jp/contests/abc234/tasks/abc234_h）closest_pair|brain_teaser|classical
ABC351E（https://atcoder.jp/contests/abc351/tasks/abc351_e）chebyshev_distance|manhattan_distance|brain_teaser|tree_array|classical
ABC226D（https://atcoder.jp/contests/abc226/tasks/abc226_d）geometry|linear_scope|classical
ABC224C（https://atcoder.jp/contests/abc224/tasks/abc224_c）geometry
ABC218D（https://atcoder.jp/contests/abc218/tasks/abc218_d）brute_force|rectangle
ABC354D（https://atcoder.jp/contests/abc354/tasks/abc354_d）brute_force|inclusion_exclusion
ABC361C（https://atcoder.jp/contests/abc361/tasks/abc361_c）geometry
ABC362B（https://atcoder.jp/contests/abc362/tasks/abc362_b）geometry|linear_scope|classical|vertical_triangular
ABC197D（https://atcoder.jp/contests/abc197/tasks/abc197_d）geometry

=====================================AcWing=====================================
119（https://www.acwing.com/problem/content/121/）closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
4309（https://www.acwing.com/problem/content/4312/）line_slope
4499（https://www.acwing.com/problem/content/4502/）geometry|equation
（https://www.hackerrank.com/contests/2023-1024-1/challenges/challenge-4219）collinearity|random

"""
import math
from collections import defaultdict, Counter
from itertools import accumulate, pairwise

from typing import List

from src.graph.union_find.template import UnionFind
from src.mathmatics.geometry.template import Geometry, ClosetPair
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1603(start1: List[int], end1: List[int], start2: List[int], end2: List[int]) -> List[float]:
        """
        url: https://leetcode.cn/problems/intersection-lcci/
        tag: geometry
        """
        gm = Geometry()
        return gm.line_intersection_line(start1, end1, start2, end2)

    @staticmethod
    def lc_2280(stock: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/
        tag: line_slope
        """
        stock.sort()
        gm = Geometry()
        pre = [-1, -1]
        ans = 0
        for (x1, y1), (x2, y2) in pairwise(stock):
            cur = gm.compute_slope(x1, y1, x2, y2)
            ans += pre != cur
            pre = cur
        return ans

    @staticmethod
    def lc_149(points: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/max-points-on-a-line/
        tag: line_slope|brute_force|classical
        """
        ans = 0
        n = len(points)
        gm = Geometry()
        for i in range(n):
            dct = defaultdict(int)
            dct[0] = 0
            x1, y1 = points[i]
            for x2, y2 in points[i + 1:]:
                dct[gm.compute_slope(x1, y1, x2, y2)] += 1
            ans = max(ans, max(dct.values()) + 1)
        return ans

    @staticmethod
    def lg_p1665(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1665
        tag: brute_force|diagonal|square
        """

        n = ac.read_int()
        lst = [ac.read_list_ints() for _ in range(n)]
        dct = set(tuple(p) for p in lst)
        ans = 0
        m = len(lst)
        gm = Geometry()
        for i in range(m):
            x1, y1 = lst[i]
            for j in range(i + 1, m):
                x2, y2 = lst[j]
                point1, point2 = gm.compute_square_point_non_vertical(x1, y1, x2, y2)

                a, b = point1
                if int(a) != a or int(b) != b:
                    continue
                point1 = (int(a), int(b))

                a, b = point2
                if int(a) != a or int(b) != b:
                    continue
                point2 = (int(a), int(b))

                if point1 in dct and point2 in dct:
                    ans += 1
        ac.st(ans // 2)
        return

    @staticmethod
    def cf_429d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/429/problem/D
        tag: closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
        """

        n = ac.read_int()
        nums = ac.read_list_ints()
        n = int(n)
        nums = list(accumulate(nums))
        nums = [[i, nums[i]] for i in range(n)]
        # ans = ClosetPair().bucket_grid(n, nums)
        # ans = ClosetPair().divide_and_conquer(nums)
        ans = ClosetPair().sorted_pair(nums)
        ac.st(ans)
        return

    @staticmethod
    def ac_119(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/121/
        tag: closet_pair|divide_and_conquer|hash|block_plane|sorted_list|classical
        """

        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums1 = [ac.read_list_ints() for _ in range(n)]
            nums2 = [ac.read_list_ints() for _ in range(n)]
            ans = ClosetPair().bucket_grid_between_two_sets(n, nums1, nums2)
            ac.st("%.3f" % (ans ** 0.5))
        return

    @staticmethod
    def lc_1453(darts: List[List[int]], r: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/
        tag: circle|classical|circle_center
        """

        n = len(darts)
        ans = 1
        go = Geometry()
        for i in range(n):
            x1, y1 = darts[i]
            for j in range(i + 1, n):
                x2, y2 = darts[j]
                if (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) > 4 * r * r:
                    continue
                for x, y in go.compute_center(x1, y1, x2, y2, r):
                    cur = sum((x - x0) * (x - x0) + (y - y0) * (y - y0) <= r * r for x0, y0 in darts)
                    ans = ans if ans > cur else cur
        return ans

    @staticmethod
    def ac_4309(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4312/
        tag: line_slope
        """
        n, x1, y1 = ac.read_list_ints()
        dct = set()
        gm = Geometry()
        for _ in range(n):
            x2, y2 = ac.read_list_ints()
            dct.add(gm.compute_slope(x1, y1, x2, y2))
        ac.st(len(dct))
        return

    @staticmethod
    def ac_4499(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4502/
        tag: geometry|equation
        """

        r, x1, y1, x2, y2 = ac.read_list_ints()
        if (x1 - x2) ** 2 + (y1 - y2) ** 2 > r * r:
            ans = [x1, y1, r]
            ac.lst(["%.6f" % x for x in ans])
            return

        dis = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 + r
        ans = [0, 0, dis / 2]
        if x1 == x2:
            if y1 > y2:
                x0, y0 = x2, y2 + dis / 2
            else:
                x0, y0 = x2, y2 - dis / 2
            ans[0] = x0
            ans[1] = y0
        else:
            k = (y2 - y1) / (x2 - x1)
            b = y1 - k * x1

            aa = k ** 2 + 1
            bb = -2 * k * (y2 - b) - 2 * x2
            cc = (y2 - b) ** 2 - dis ** 2 + x2 ** 2
            for xx in [(-bb + (bb * bb - 4 * aa * cc) ** 0.5) / 2 / aa,
                       (-bb - (bb * bb - 4 * aa * cc) ** 0.5) / 2 / aa]:
                yy = k * xx + b
                if int(x2 - xx > 0) == int(x2 - x1 > 0):
                    ans[0] = (xx + x2) / 2
                    ans[1] = (yy + y2) / 2
                    break
        ac.lst(["%.6f" % x for x in ans])
        return

    @staticmethod
    def abc_343e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc343/tasks/abc343_e
        tag: brute_force|brain_teaser|inclusion_exclusion|math|classical
        """

        def three(x, y, z, xx, yy, zz, xxx, yyy, zzz):
            res = 1
            res *= max(0, min(x, xx, xxx) + 7 - max(x, xx, xxx))
            res *= max(0, min(y, yy, yyy) + 7 - max(y, yy, yyy))
            res *= max(0, min(z, zz, zzz) + 7 - max(z, zz, zzz))
            return res

        def two(x, y, z, xx, yy, zz):
            res = 1
            res *= max(0, min(x, xx) + 7 - max(x, xx))
            res *= max(0, min(y, yy) + 7 - max(y, yy))
            res *= max(0, min(z, zz) + 7 - max(z, zz))
            return res

        a1 = b1 = c1 = 0
        low = -1
        high = 7
        v1, v2, v3 = ac.read_list_ints()

        for a2 in range(low, high + 1):
            for b2 in range(low, high + 1):
                for c2 in range(low, high + 1):
                    for a3 in range(low, high + 1):
                        for b3 in range(low, high + 1):
                            for c3 in range(low, high + 1):
                                inter3 = three(a1, b1, c1, a2, b2, c2, a3, b3, c3)
                                inter2 = (two(a1, b1, c1, a2, b2, c2)
                                          + two(a1, b1, c1, a3, b3, c3)
                                          + two(a2, b2, c2, a3, b3, c3)
                                          - inter3 * 3)
                                inter1 = 3 * (7 * 7 * 7) - 2 * inter2 - 3 * inter3
                                if (v1, v2, v3) == (inter1, inter2, inter3):
                                    ac.yes()
                                    ac.lst([a1, b1, c1, a2, b2, c2, a3, b3, c3])
                                    return
        ac.no()
        return

    @staticmethod
    def abc_275c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc275/tasks/abc275_c
        tag: brute_force|geometry|square|angle|classical
        """
        grid = [ac.read_str() for _ in range(9)]

        ind = []
        for i in range(9):
            for j in range(9):
                if grid[i][j] == "#":
                    ind.append((i, j))

        def dis(p1, p2):
            return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2

        gm = Geometry()
        points = set(ind)
        ans = 0
        k = len(ind)
        for i in range(k):
            x0, y0 = ind[i]
            for j in range(i + 1, k):
                x2, y2 = ind[j]
                (x1, y1), (x3, y3) = gm.compute_square_point_non_vertical(x0, y0, x2, y2)
                x1 = int(x1)
                y1 = int(y1)
                x3 = int(x3)
                y3 = int(y3)
                if (x1, y1) in points and (x3, y3) in points:
                    perm = [(x0, y0), (x1, y1), (x2, y2), (x3, y3)]
                    if len(set(dis(perm[i], perm[i + 1]) for i in range(3))) == 1:
                        if gm.vertical_angle(perm[0], perm[1], perm[2]):
                            ans += 1
        ac.st(ans // 2)
        return

    @staticmethod
    def abc_266c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc266/tasks/abc266_c
        tag: math|geometry|is_convex_quad|classical
        """
        points = [ac.read_list_ints() for _ in range(4)]
        ac.st("Yes" if Geometry().is_convex_quad(points) else "No")
        return

    @staticmethod
    def abc_248e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc248/tasks/abc248_e
        tag: linear_scope|compute_slope|geometry|brute_force
        """
        n, k = ac.read_list_ints()
        points = [ac.read_list_ints() for _ in range(n)]
        dct = Counter((x, y) for x, y in points)
        if max(dct.values()) >= k:
            ac.st("Infinity")
            return
        ans = 0
        gm = Geometry()
        points = list(dct.keys())
        n = len(points)
        pre = set()
        for i in range(n):
            x1, y1 = points[i]
            cur = defaultdict(lambda: [(x1, y1)])
            for j in range(i + 1, n):
                x2, y2 = points[j]
                s = gm.compute_slope(x1, y1, x2, y2)
                if (x1, y1, s) not in pre:
                    cur[s].append((x2, y2))
            for s in cur:
                tot = sum(dct[t] for t in cur[s])
                ans += tot >= k
                pre |= {(x, y, s) for x, y in cur[s]}
        ac.st(ans)
        return

    @staticmethod
    def abc_250f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc250/tasks/abc250_f
        tag: geometry|circular_array|two_pointers|brain_teaser
        """
        gm = Geometry()
        n = ac.read_int()
        points = [ac.read_list_ints() for _ in range(n)]
        points += points
        tot = 0
        x1, y1 = points[0]
        for i in range(1, n - 1):
            x2, y2 = points[i]
            x3, y3 = points[i + 1]
            tot += gm.compute_triangle_area_double(x1, y1, x2, y2, x3, y3)
        ans2 = math.inf
        j = pre = 0
        for i in range(len(points) - 2):
            x1, y1 = points[i]
            if j < i + 1:
                j = i + 1
                x2, y2 = points[j]
                x3, y3 = points[j + 1]
                pre = gm.compute_triangle_area_double(x1, y1, x2, y2, x3, y3)
            ans2 = min(ans2, abs(tot - 4 * pre))
            while pre * 4 < tot and j + 2 < len(points):
                j += 1
                x2, y2 = points[j]
                x3, y3 = points[j + 1]
                pre += gm.compute_triangle_area_double(x1, y1, x2, y2, x3, y3)
                if pre < tot:
                    ans2 = min(ans2, abs(tot - 4 * pre))
            x2, y2 = points[i + 1]
            x3, y3 = points[j + 1]
            pre -= gm.compute_triangle_area_double(x1, y1, x2, y2, x3, y3)
        ac.st(ans2)
        return

    @staticmethod
    def abc_234h(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc234/tasks/abc234_h
        tag: closest_pair|brain_teaser|classical
        """
        n, k = ac.read_list_ints()
        points = [ac.read_list_ints() for _ in range(n)]
        dct = defaultdict(list)
        ans = []
        for i, (x, y) in enumerate(points):
            a, b = x // k, y // k
            for aa in range(-1, 2):
                for bb in range(-1, 2):
                    for j in dct[(a + aa, b + bb)]:
                        x0, y0 = points[j]
                        if (x - x0) * (x - x0) + (y - y0) * (y - y0) <= k * k:
                            ans.append((j + 1, i + 1))
            dct[(a, b)].append(i)
        ac.st(len(ans))
        ans.sort()
        for a in ans:
            ac.lst(a)
        return

    @staticmethod
    def abc_351e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc351/tasks/abc351_e
        tag: chebyshev_distance|manhattan_distance|brain_teaser|tree_array|classical
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]

        def check(lst):
            if not lst:
                return 0
            x, y = lst[0]
            w = (x - y) % 2
            cur = [(x - y + w) // 2 for x, y in lst]
            cur.sort()
            res = pre = 0
            for i, val in enumerate(cur):
                pre += val
                res += (i + 1) * val - pre
            cur = [(x + y + w) // 2 for x, y in lst]
            cur.sort()
            pre = 0
            for i, val in enumerate(cur):
                pre += val
                res += (i + 1) * val - pre
            return res

        ans = sum(check([[x, y] for x, y in nums if (x - y) % 2 == w]) for w in range(2))
        ac.st(ans)
        return

    @staticmethod
    def abc_226d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc226/tasks/abc226_d
        tag: geometry|linear_scope|classical
        """
        n = ac.read_int()
        points = [ac.read_list_ints() for _ in range(n)]
        ans = set()
        for i in range(n):
            x1, y1 = points[i]
            for j in range(n):
                if i == j:
                    continue
                x2, y2 = points[j]
                a = x2 - x1
                b = y2 - y1
                if b == 0:
                    a = -1 if a < 0 else 1
                elif a == 0:
                    b = -1 if b < 0 else 1
                else:
                    g = math.gcd(abs(a), abs(b))
                    a //= g
                    b //= g
                ans.add((a, b))
        ac.st(len(ans))
        return

    @staticmethod
    def abc_224c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc224/tasks/abc224_c
        tag: geometry
        """
        n = ac.read_int()
        ans = 0
        points = [ac.read_list_ints() for _ in range(n)]
        for i in range(n - 2):
            for j in range(i + 1, n - 1):
                for k in range(j + 1, n):
                    if not Geometry().same_line(points[i], points[j], points[k]):
                        ans += 1
        ac.st(ans)
        return

    @staticmethod
    def abc_224c_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc224/tasks/abc224_c
        tag: geometry
        """
        n = ac.read_int()
        points = [ac.read_list_ints() for _ in range(n)]
        ans = n * (n - 1) * (n - 2) // 6
        for i in range(n - 1):
            dct = defaultdict(int)
            x1, y1 = points[i]
            for j in range(i + 1, n):
                x2, y2 = points[j]
                dct[Geometry().compute_slope(x1, y1, x2, y2)] += 1
            for va in dct.values():
                if va >= 2:
                    ans -= va * (va - 1) // 2
        ac.st(ans)
        return

    @staticmethod
    def abc_354d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc354/tasks/abc354_d
        tag: brute_force|inclusion_exclusion
        """
        a, b, c, d = ac.read_list_ints()
        c -= 1
        d -= 1
        w = c - a + 1
        h = d - b + 1
        ww = 4 * ((w + 3) // 4)
        hh = 4 * ((h + 3) // 4)
        grid = [[1, 2, 1, 0], [2, 1, 0, 1], [1, 2, 1, 0], [2, 1, 0, 1]]
        ans = 8 * (ww // 4) * (hh // 4) * 2
        lst = [3, 3, 1, 1]
        for rr in range(a + w, a + ww):
            ans -= (hh // 4) * 2 * lst[rr % 4]
        lst = [2, 2, 2, 2]
        for cc in range(b + h, b + hh):
            ans -= (ww // 4) * 2 * lst[cc % 4]

        for xx in range(a + w, a + ww):
            for yy in range(b + h, b + hh):
                rr = xx % 4
                cc = yy % 4
                ans += grid[-cc - 1][rr]
        ac.st(ans)
        return

    @staticmethod
    def cf_1979e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1979/problem/E
        tag: manhattan_distance|chebyshev_distance|brute_force|two_pointers|map
        """

        def check():
            n, d = ac.read_list_ints()
            nums = []
            for _ in range(n):
                x, y = ac.read_list_ints()
                nums.append((x + y, x - y))

            for _ in range(2):
                dct = defaultdict(list)
                for i, (x, y) in enumerate(nums):
                    dct[x].append((i, y))
                for x in dct:
                    dct[x].sort(key=lambda it: it[1])
                keys = set(dct.keys())
                for x in keys:
                    for w in [x - d, x + d]:
                        if w in keys:
                            m = len(dct[w])
                            pre = dict()
                            j = 0
                            for i, y in dct[x]:
                                while j < m and dct[w][j][1] <= y + d:
                                    if dct[w][j][1] >= y and dct[w][j][1] - d in pre:
                                        return [i + 1, dct[w][j][0] + 1, pre[dct[w][j][1] - d] + 1]
                                    pre[dct[w][j][1]] = dct[w][j][0]
                                    j += 1
                nums = [ls[::-1] for ls in nums]
            return [0, 0, 0]

        for _ in range(ac.read_int()):
            ac.lst(check())
        return

    @staticmethod
    def cf_1c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1/problem/C
        tag: geometry|circle|triangle
        """

        x1, y1 = [float(x) for x in ac.read_list_strs()]
        x2, y2 = [float(x) for x in ac.read_list_strs()]
        x3, y3 = [float(x) for x in ac.read_list_strs()]

        x, y, r = Geometry().circumscribed_circle_of_triangle(x1, y1, x2, y2, x3, y3)

        theta1 = Geometry().get_circle_sector_angle(x1, y1, x2, y2, r)
        theta2 = Geometry().get_circle_sector_angle(x1, y1, x3, y3, r)
        theta3 = 2 * math.pi - theta1 - theta2

        lst = theta1 * 0.5 / math.pi, theta2 * 0.5 / math.pi, theta3 * 0.5 / math.pi

        n = 0
        error = 1e-5
        for d in range(3, 201):
            if all(abs(p * d - int(p * d + error)) < error for p in lst):
                n = d
                break
        theta = 2 * math.pi / n
        ans = n * 0.5 * (r ** 2) * math.sin(theta)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2449(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2449
        tag: rectangle_overlap|rectangle_edge_touch|rectangle_corner_touch|geometry
        """
        n = ac.read_int()
        uf = UnionFind(n)
        pre = []

        def check_overlap(rec1, rec2):
            x1, y1, x2, y2 = rec1
            x3, y3, x4, y4 = rec2
            if x2 <= x3 or x4 <= x1 or y4 <= y1 or y2 <= y3:
                return False
            return True

        def check_edge_touch(rec1, rec2):
            x1, y1, x2, y2 = rec1
            a1, b1, a2, b2 = rec2
            edge_touch = ((x1 == a2 or x2 == a1) and (y1 < b2 and y2 > b1)) or \
                         ((y1 == b2 or y2 == b1) and (x1 < a2 and x2 > a1))
            return edge_touch

        for i in range(n):
            a, b, c, d = ac.read_list_ints()
            pre.append([a, b, c, d])
            for j in range(i):
                if check_overlap(pre[i], pre[j]) or check_edge_touch(pre[i], pre[j]):
                    uf.union(i, j)
        ac.st(uf.part)
        return

    @staticmethod
    def lg_p3844(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3844
        tag: geometry|implemention
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: it[2])
        color = [0] * n
        parent = [-1] * n
        area = [0] * n
        pre = []
        for i, (x, y, r) in enumerate(nums):
            cur = r * r
            for j in range(i):
                xx, yy, rr = nums[j]
                if (x - xx) ** 2 + (y - yy) ** 2 <= r * r:
                    if parent[j] == -1:
                        parent[j] = i
                        cur -= rr * rr
                    color[j] = 1 - color[j]
            color[i] = 1
            area[i] = cur
        ans = sum(area[i] for i in range(n) if color[i]) * math.pi
        ans = str(round(ans, 2))
        if "." not in ans:
            ans += ".00"
        else:
            while len(ans) - ans.index(".") < 3:
                ans += "0"
        ac.st(ans)
        return

    @staticmethod
    def lg_p6341(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6341
        tag: line_scope|brute_force|right_triangle
        """
        n = ac.read_int()  # MLE
        pos = [ac.read_list_ints() for _ in range(n)]
        row = defaultdict(int)
        col = defaultdict(int)
        for x, y in pos:
            row[x] += 1
            col[y] += 1
        ans = 0
        for x, y in pos:
            ans += (row[x] - 1) * (col[y] - 1)

        for i in range(n):
            pre = dict()
            x, y = pos[i]
            for j in range(n):
                if j != i:
                    a, b = pos[j]
                    if a == x or b == y:
                        continue
                    g = math.gcd(x - a, y - b)
                    aa = (x - a) // g
                    bb = (y - b) // g
                    if bb < 0:
                        bb *= -1
                        aa *= -1
                    aaa = -bb
                    bbb = aa
                    if bbb < 0:
                        bbb *= -1
                        aaa *= -1
                    ans += pre.get((aaa, bbb), 0)
                    pre[(aa, bb)] = pre.get((aa, bb), 0) + 1
        ac.st(ans)
        return

    @staticmethod
    def cf_598c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/598/C
        tag: math|geometry|high_precision|angle_with_x_axis|angle_between_vectors
        """
        gm = Geometry()
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        angle = [gm.angle_with_x_axis(x, y) for x, y in nums]
        ind = [(angle[i], i) for i in range(n)]
        ind.sort()
        ind = [i for _, i in ind]
        res = gm.angle_between_vector(nums[ind[0]], nums[ind[-1]])
        ans = [ind[0], ind[n - 1]]
        for i in range(1, n):
            cur = gm.angle_between_vector(nums[ind[i - 1]], nums[ind[i]])
            k1, k2 = cur
            k3, k4 = res
            if k1 * k4 > k2 * k3:
                res = cur
                ans = [ind[i - 1], ind[i]]
        ac.lst([x + 1 for x in ans])
        return
"""
Algorithm：big_number_factorization|is_prime|high_precision|float_to_frac|frac_to_float
Description：xxx

====================================LeetCode====================================
166（https://leetcode.cn/problems/fraction-to-recurring-decimal/）frac_to_float
172（https://leetcode.cn/problems/factorial-trailing-zeroes/）suffix_zero|factorial
1883（https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/）matrix_dp|high_precision|float_to_frac
2117（https://leetcode.cn/problems/abbreviating-the-product-of-a-range/）prefix_suffix|implemention
972（https://leetcode.cn/problems/equal-rational-numbers/）float_to_frac

=====================================LuoGu======================================
P2388（https://www.luogu.com.cn/problem/P2388）suffix_zero|factorial_of_factorial

P1920（https://www.luogu.com.cn/problem/P1920）high_precision|math
P1729（https://www.luogu.com.cn/problem/P1729）high_precision|e|math
P1727（https://www.luogu.com.cn/problem/P1727）high_precision|π|math
P1517（https://www.luogu.com.cn/problem/P1517）high_precision|float_power
P2394（https://www.luogu.com.cn/problem/P2394）high_precision
P2393（https://www.luogu.com.cn/problem/P2393）high_precision

P2399（https://www.luogu.com.cn/problem/P2399）float_to_frac
P1530（https://www.luogu.com.cn/problem/P1530）frac_to_float
P1298（https://www.luogu.com.cn/problem/P1298）high_precision|frac_to_float|brute_force

===================================CodeForces===================================
1144E（https://codeforces.com/contest/1144/problem/E）big_number|minus|mul|divide|high_precision|classical
1883E（https://codeforces.com/contest/1883/problem/E）high_precision|big_number|math|log
1995D（https://codeforces.com/contest/1995/problem/C）high_precision|greedy|implemention
1543C（https://codeforces.com/contest/1543/problem/C）high_precision|prob|expectation|implemention

====================================AtCoder=====================================
ABC148E（https://atcoder.jp/contests/abc148/tasks/abc148_e）suffix_zero|odd_even|factorial


====================================AtCoder=====================================
1（https://judge.yosupo.jp/problem/many_aplusb）big_number|high_precision|plus

"""

import math
from decimal import Decimal
from typing import List

from src.mathmatics.high_precision.template import HighPrecision, FloatToFrac
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def abc_148e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc148/tasks/abc148_e
        tag: suffix_zero|odd_even|factorial
        """

        n = ac.read_int()
        if n % 2:
            ac.st(0)
        else:
            ans = HighPrecision().factorial_suffix_zero_cnt(n // 10) + n // 10
            ac.st(ans)
        return

    @staticmethod
    def cf_1144e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1144/problem/E
        tag: big_number|minus|mul|divide|n_base
        """

        n = ac.read_int()
        s = ac.read_str()
        t = ac.read_str()
        lst1 = [0] + [ord(w) - ord("a") for w in s]
        lst2 = [0] + [ord(w) - ord("a") for w in t]

        for i in range(n, 0, -1):
            lst1[i] += lst2[i]
            lst1[i - 1] += lst1[i] // 26
            lst1[i] %= 26

        for i in range(n + 1):
            rem = lst1[i] % 2
            lst1[i] //= 2
            if i + 1 <= n:
                lst1[i + 1] += rem * 26
            else:
                assert rem == 0

        ac.st("".join(chr(i + ord("a")) for i in lst1[1:]))
        return

    @staticmethod
    def lc_172(n):
        """
        url: https://leetcode.cn/problems/factorial-trailing-zeroes/
        tag: suffix_zero|factorial
        """
        return HighPrecision().factorial_suffix_zero_cnt(n)

    @staticmethod
    def lc_972(s: str, t: str) -> bool:
        """
        url: https://leetcode.cn/problems/equal-rational-numbers/
        tag: float_to_frac
        """
        hp = HighPrecision()
        return hp.decimal_to_fraction(s) == hp.decimal_to_fraction(t)

    @staticmethod
    def lg_p2338(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2388
        tag: suffix_zero|factorial_of_factorial
        """
        n = ac.read_int()
        ac.st(HighPrecision().factorial_factorial_suffix_zero_cnt(n))
        return

    @staticmethod
    def lg_p2399(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2399
        tag: float_to_frac
        """
        s = ac.read_str()
        a, b = HighPrecision().decimal_to_fraction(s)
        ac.st(f"{a}/{b}")
        return

    @staticmethod
    def lc_2117(left: int, right: int) -> str:
        """
        url: https://leetcode.cn/problems/abbreviating-the-product-of-a-range/
        tag: prefix_suffix|implemention
        """
        mod = 10 ** 20
        base = 10 ** 10
        zero = 0
        suffix = 1
        for x in range(left, right + 1):
            suffix *= x
            while suffix % 10 == 0:
                zero += 1
                suffix //= 10

            suffix %= mod

        prefix = 1
        for x in range(left, right + 1):
            prefix *= x
            while prefix % 10 == 0:
                prefix //= 10

            while prefix > mod:
                prefix //= 10

        if prefix >= base:
            return str(prefix)[:5] + "..." + str(suffix)[-5:] + "e" + str(zero)
        else:
            return str(prefix) + "e" + str(zero)

    @staticmethod
    def lg_p1530(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1530
        tag: frac_to_float
        """
        n, d = ac.read_list_ints()
        ans = HighPrecision().fraction_to_decimal(n, d)
        while ans:
            ac.st(ans[:76])
            ans = ans[76:]
        return

    @staticmethod
    def lc_1883_1(dist: List[int], speed: int, hours: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/
        tag: matrix_dp|high_precision|float_to_frac
        """

        n = len(dist)
        if sum(dist) > hours * speed:
            return -1

        ff = FloatToFrac()
        dp = [[[hours * 2, 1] for _ in range(n + 1)] for _ in range(n)]
        dp[0][0] = [0, 1]
        for i in range(n - 1):
            dp[i + 1][0] = ff.frac_add(dp[i][0], [ff.frac_ceil([dist[i], speed]), 1])
            for j in range(1, i + 2):
                pre1 = [ff.frac_ceil(ff.frac_add(dp[i][j], [dist[i], speed])), 1]
                pre2 = ff.frac_add(dp[i][j - 1], [dist[i], speed])
                dp[i + 1][j] = ff.frac_min(pre1, pre2)
        for j in range(n + 1):
            cur = ff.frac_add(dp[n - 1][j], [dist[n - 1], speed])
            if cur[0] <= hours * cur[1]:
                return j
        return -1

    @staticmethod
    def lc_1883_2(dist: List[int], speed: int, hours: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/
        tag: matrix_dp|high_precision|float_to_frac
        """

        cost = [Decimal(d) / Decimal(speed) for d in dist]
        n = len(dist)
        dp = [[hours * 2] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        for i in range(1, n):
            dp[i][0] = dp[i - 1][0] + math.ceil(cost[i - 1])
            for j in range(1, i):
                a, b = dp[i - 1][j - 1] + cost[i - 1], math.ceil(dp[i - 1][j] + cost[i - 1])
                dp[i][j] = a if a < b else b

            dp[i][i] = dp[i - 1][i - 1] + cost[i - 1]

        for j in range(n + 1):
            if dp[n - 1][j] + cost[-1] <= hours:
                return j
        return -1

"""
Algorithm：lexicographical_order|lexicographical_order_rank|comb|subset|perm
Description：kth_lexicographical_order|lexicographical_order_rank|subset_lexicographical_order|kth_subset_lexicographical|comb|perm

====================================LeetCode====================================
31（https://leetcode.cn/problems/next-permutation/）next_permutation|classical
60（https://leetcode.cn/problems/permutation-sequence/）kth_perm|lexicographical_order
440（https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/）10-tree|kth
1415（https://leetcode.cn/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/）lexicographical_order|construction
1643（https://leetcode.cn/problems/kth-smallest-instructions/）lexicographical_order
1830（https://leetcode.cn/problems/minimum-number-of-operations-to-make-string-sorted/）lexicographical_order_rank|rank_order
1842（https://leetcode.cn/problems/next-palindrome-using-same-digits/）lexicographical_order|greedy
1850（https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/）next_lexicographical_order|bubble|greedy

=====================================LuoGu======================================
P1243（https://www.luogu.com.cn/problem/P1243）kth_subset
P1338（https://www.luogu.com.cn/problem/P1338）reverse_order_pair|counter|lexicographical_order
P2524（https://www.luogu.com.cn/problem/P2524）lexicographical_order|rank_of_perm
P2525（https://www.luogu.com.cn/problem/P2525）lexicographical_order|rank_of_perm|pre_lexicographical_order

=====================================AtCoder======================================
ABC276C（https://atcoder.jp/contests/abc276/tasks/abc276_c）prev_permutation|classical
ABC202D（https://atcoder.jp/contests/abc202/tasks/abc202_d）lexicographical_order|rank|construction

===================================CodeForces===================================
1328B（https://codeforces.com/contest/1328/problem/B）comb|lexicographical_order
1620C（https://codeforces.com/contest/1620/problem/C）reverse_thinking|lexicographical_order
1509E（https://codeforces.com/contest/1509/problem/E）lexicographical_order|kth_rank|classical

"""
from typing import List

from src.mathmatics.lexico_graphical_order.template import LexicoGraphicalOrder, Permutation
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1328b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1328/problem/B
        tag: comb|lexicographical_order
        """
        lgo = LexicoGraphicalOrder()
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            ind = lgo.get_kth_subset_comb(n, 2, n * (n - 1) // 2 - k + 1)
            ans = ["a"] * n
            for i in ind:
                ans[i - 1] = "b"
            ac.st("".join(ans))
        return

    @staticmethod
    def lc_440(n, k):
        """
        url: https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/
        tag: 10-tree|kth
        """
        return LexicoGraphicalOrder().get_kth_num(n, k)

    @staticmethod
    def lg_p1243(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1243
        tag: kth_subset
        """
        n, k = ac.read_list_ints()
        lst = LexicoGraphicalOrder().get_kth_subset(n, k)
        ac.lst(lst)
        return

    @staticmethod
    def lg_p2524(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2524
        tag: lexicographical_order|rank_of_perm
        """
        n = ac.read_int()
        lst = [int(w) for w in ac.read_str()]
        rk = LexicoGraphicalOrder().get_subset_perm_kth(n, lst)
        ac.st(rk)
        return

    @staticmethod
    def lc_60(n: int, k: int) -> str:
        """
        url: https://leetcode.cn/problems/permutation-sequence/
        tag: kth_perm|lexicographical_order
        """
        ans = LexicoGraphicalOrder().get_kth_subset_perm(n, k)
        return "".join(str(x) for x in ans)

    @staticmethod
    def abc_276c_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc276/tasks/abc276_c
        tag: prev_permutation|classical
        """
        ac.read_int()
        lst = ac.read_list_ints()
        ac.lst(Permutation().prev_permutation(lst))
        return

    @staticmethod
    def abc_276c_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc276/tasks/abc276_c
        tag: prev_permutation|classical
        """
        n = ac.read_int()
        lst = ac.read_list_ints()
        lgo = LexicoGraphicalOrder()
        k = lgo.get_subset_perm_kth(n, lst)
        ac.lst(lgo.get_kth_subset_perm(n, k - 1))
        return

    @staticmethod
    def lc_31(nums: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/next-permutation/
        tag: next_permutation|classical
        """
        nums = Permutation().next_permutation(nums)
        return nums
"""
Algorithm：linear_basis|kth_subset_xor|rank_of_xor
Description：subset_xor|kth_xor|rank_of_xor

=====================================LuoGu======================================
P3812（https://www.luogu.com.cn/problem/P3812）linear_basis|classical
P3857（https://www.luogu.com.cn/problem/P3857）linear_basis|classical
P4570（https://www.luogu.com.cn/problem/P4570）linear_basis|classical
P4301（https://www.luogu.com.cn/problem/P4301）linear_basis|classical
P4151（https://www.luogu.com.cn/problem/P4151）todo
P3265（https://www.luogu.com.cn/problem/P3265）todo tle

=====================================CodeForces======================================
CF845G（https://codeforces.com/problemset/problem/845/G）todo

=====================================AtCoder======================================
ABC283G（https://atcoder.jp/contests/abc283/tasks/abc283_g）linear_basis|classical
ABC236F（https://atcoder.jp/contests/abc236/tasks/abc236_f）linear_basis|mst|greedy|classical

=====================================AcWing======================================
3167（https://www.acwing.com/problem/content/description/3167/）linear_basis|classical


"""

from src.mathmatics.linear_basis.template import LinearBasis, LinearBasisVector
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p3812(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3812
        tag: linear_basis
        """
        ac.read_int()
        lst = ac.read_list_ints()
        linear_basis = LinearBasis(50)
        for num in lst:
            linear_basis.add(num)
        ans = linear_basis.query_max()
        ac.st(ans)
        return

    @staticmethod
    def abc_283g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc283/tasks/abc283_g
        tag: linear_basis|classical
        """
        n, ll, rr = ac.read_list_ints()
        lst = ac.read_list_ints()
        linear_basis = LinearBasis(60)
        for num in lst:
            linear_basis.add(num)
        ans = [linear_basis.query_kth_xor(k) for k in range(ll - 1, rr)]
        ac.lst(ans)
        return

    @staticmethod
    def ac_3167(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3167/
        tag: linear_basis|classical
        """
        ac.read_int()
        lst = ac.read_list_ints()
        linear_basis = LinearBasis(64)
        for num in lst:
            linear_basis.add(num)
        ans = linear_basis.query_max()
        ac.st(ans)
        return

    @staticmethod
    def lg_p3857(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3857
        tag: linear_basis|classical
        """
        n, m = ac.read_list_ints()
        linear_basis = LinearBasis(n)
        for _ in range(m):
            s = ac.read_str().replace("O", "1").replace("X", "0")
            linear_basis.add(int("0b" + s, 2))
        ans = linear_basis.tot % 2008
        ac.st(ans)
        return

    @staticmethod
    def lg_p4570(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4570
        tag: linear_basis|classical
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        nums.sort(key=lambda it: -it[1])
        linear_basis = LinearBasis(64)
        ans = 0
        for num, magic in nums:
            if linear_basis.add(num):
                ans += magic
        ac.st(ans)
        return

    @staticmethod
    def lg_p4301(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4301
        tag: linear_basis|classical
        """
        ac.read_int()
        nums = ac.read_list_ints()
        nums.sort(reverse=True)
        linear_basis = LinearBasis(32)
        ans = 0
        for num in nums:
            if not linear_basis.add(num):
                ans += num
        ac.st(ans)
        return

    @staticmethod
    def lg_p3265(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3265
        tag: linear_basis|classical
        """
        n, m = ac.read_list_ints()  # TLE
        nums = [ac.read_list_ints() for _ in range(n)]
        cost = ac.read_list_ints()

        ind = list(range(n))
        ind.sort(key=lambda it: cost[it])
        linear_basis = LinearBasisVector(m)
        ans = tot = 0
        for i in ind:
            if linear_basis.add(nums[i]):
                tot += 1
                ans += cost[i]
        ac.lst([tot, ans])
        return

    @staticmethod
    def abc_236f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc236/tasks/abc236_f
        tag: linear_basis|mst|greedy|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ind = list(range(1, 1 << n))
        ind.sort(key=lambda it: nums[it - 1])
        linear = LinearBasis()
        ans = 0
        for i in ind:
            if linear.add(i):
                ans += nums[i - 1]
        ac.st(ans)
        return"""
Algorithm：Minimum Excluded Element
Ability：brain storming like or g greedy
Reference：

====================================LeetCode====================================
330（https://leetcode.cn/problems/patching-array/）greedy|sort|implemention|mex
1798（https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/）greedy|sort|implemention|mex
2952（https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/）greedy|sort|implemention|mex

======================================Luogu=====================================
P9202（https://www.luogu.com.cn/problem/P9202）mex|operation
P9199（https://www.luogu.com.cn/problem/P9199）mex|operation

===================================CodeForces===================================
1905D（https://codeforces.com/contest/1905/problem/D）mex|contribution_method|diff_array|implemention|classical
1364C（https://codeforces.com/problemset/problem/1364/C）mex|construction

===================================CodeChef===================================
1（https://www.codechef.com/problems/LIMITMEX）monotonic_stack|contribution_method|brain_teaser|classical

"""
from typing import List

from src.utils.fast_io import FastIO


class Solution:
    def __int__(self):
        return

    @staticmethod
    def lc_330(nums: List[int], n: int) -> int:
        """
        url: https://leetcode.cn/problems/patching-array/
        tag: greedy|sort|implemention|mex|classical
        """
        nums.sort()
        m = len(nums)
        i = 0
        mex = 1
        ans = 0
        while mex <= n:
            if i < m and nums[i] <= mex:
                mex += nums[i]
                i += 1
            else:
                ans += 1
                mex *= 2
        return ans

    @staticmethod
    def lc_2952(nums: List[int], n: int) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/
        tag: greedy|sort|implemention|mex
        """
        nums.sort()
        m = len(nums)
        i = 0
        mex = 1
        ans = 0
        while mex <= n:
            if i < m and nums[i] <= mex:
                mex += nums[i]
                i += 1
            else:
                ans += 1
                mex *= 2
        return ans

    @staticmethod
    def lc_1798(coins: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-consecutive-values-you-can-make/
        tag: greedy|sort|implemention|mex
        """
        coins.sort()
        mex = 1
        for coin in coins:
            if coin <= mex:
                mex += coin
        return mex

    @staticmethod
    def cf_1905d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1905/problem/D
        tag：mex|contribution_method|diff_array|implemention|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            ind = [-1] * n
            for i in range(n):
                ind[nums[i]] = i

            pre = [-1] * n
            stack = []
            for i in range(n - 1, -1, -1):
                while stack and nums[stack[-1]] > nums[i]:
                    pre[stack.pop()] = i
                stack.append(i)

            post = [-1] * n
            stack = []
            for i in range(n):
                while stack and nums[stack[-1]] > nums[i]:
                    post[stack.pop()] = i
                stack.append(i)

            diff = [0] * n
            pre_min = pre_max = ind[0]
            for i in range(1, n):
                x = ind[i]
                if post[x] != -1:
                    a = post[x]
                else:
                    a = pre_min
                if pre[x] != -1:
                    b = pre[x]
                else:
                    b = pre_max

                pre_min = min(pre_min, x)
                pre_max = max(pre_max, x)

                move1 = n - a
                move1 %= n
                cur_x = (x + move1) % n
                cur_b = (b + move1) % n

                length = cur_x - cur_b

                move2 = n - cur_x - 1
                if move1 + move2 <= n - 1:
                    diff[move1] += i * length
                    if move1 + move2 + 1 < n:
                        diff[move1 + move2 + 1] -= i * length
                else:
                    diff[move1] += i * length
                    xx = (move1 + move2) % n
                    diff[0] += i * length
                    if xx + 1 < n:
                        diff[xx + 1] -= i * length

            for i in range(1, n):
                diff[i] += diff[i - 1]
            ac.st(max(diff) + n)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/LIMITMEX
        tag: monotonic_stack|contribution_method|brain_teaser|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()

            n = len(nums)
            post = [n - 1] * n  # initial can be n or n-1 or -1 dependent on usage
            pre = [0] * n  # initial can be 0 or -1 dependent on usage
            stack = []
            for i in range(n):  # can be also range(n-1, -1, -1) dependent on usage
                while stack and nums[stack[-1]] < nums[i]:  # can be < or > or <=  or >=  dependent on usage
                    post[stack.pop()] = i - 1  # can be i or i-1 dependent on usage
                if stack:  # which can be done only pre and post are no-repeat such as post bigger and pre not-bigger
                    pre[i] = stack[-1] + 1  # can be stack[-1] or stack[-1]-1 dependent on usage
                stack.append(i)
            ans = 0
            for i in range(n):
                ans += (nums[i] + 1) * (i - pre[i] + 1) * (post[i] - i + 1)

            post = [n - 1] * n  # initial can be n or n-1 or -1 dependent on usage
            pre = [0] * n  # initial can be 0 or -1 dependent on usage
            dct = dict()
            for i in range(n):  # can be also range(n-1, -1, -1) dependent on usage
                if nums[i] in dct:
                    post[dct[nums[i]]] = i - 1
                dct[nums[i]] = i  # can be i or i-1 dependent on usage
            for i in range(n):
                ans -= (i - pre[i] + 1) * (post[i] - i + 1)
            ac.st(ans)
        return"""

Algorithm：nim_game|sg_theorem
Description：game_dp|winning_state|lose_state|sprague_grundy|sg_theorem

=====================================LuoGu======================================
P2197（https://www.luogu.com.cn/problem/P2197）xor_sum|classical

===================================CodeForces===================================
1396B（https://codeforces.com/contest/1396/problem/B）greedy|game_dp
2004E（https://codeforces.com/problemset/problem/2004/E）sprague_grundy|sg_theorem|game


"""

from src.mathmatics.nim_game.template import Nim
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1396b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1396/problem/B
        tag: greedy|game_dp
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            ceil = max(nums)
            s = sum(nums)
            if ceil > s - ceil or s % 2:
                ac.st("T")
            else:
                ac.st("HL")
        return

    @staticmethod
    def lg_p2197(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2197
        tag: xor_sum|classical
        """
        for _ in range(ac.read_int()):
            ac.read_int()
            lst = ac.read_list_ints()
            nim = Nim(lst)
            if nim.gen_result():
                ans = "Yes"
            else:
                ans = "No"
            ac.st(ans)
        return

    @staticmethod
    def cf_2004e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/2004/E
        tag: sprague_grundy|sg_theorem|game
        """
        ceil = 10 ** 7
        pf = PrimeFactor(ceil + 10)
        sg = [0] * (ceil + 1)
        sg[1] = 1
        tot = 1
        for i in range(3, ceil + 1):
            if pf.min_prime[i] == i:
                tot += 1
                sg[i] = tot
            else:
                sg[i] = sg[pf.min_prime[i]]

        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            ans = 0
            for num in nums:
                ans ^= sg[num]
            if ans:
                ac.st("Alice")
            else:
                ac.st("Bob")
        return
"""
Algorithm：number_theory|euler_sieve|linear_sieve|prime|euler_phi|factorization|prime_factorization|base
Description：digital_dp|n_base|prime_factorization|factorization|linear_sieve|euler_phi|pollard_rho|meissel_lehmer|range_prime_count

====================================LeetCode====================================
264（https://leetcode.cn/problems/ugly-number-ii/）pointer|dp|ugly_number|classical
1201（https://leetcode.cn/problems/ugly-number-iii/）ugly_number
313（https://leetcode.cn/problems/super-ugly-number/）ugly_number
12（https://leetcode.cn/problems/integer-to-roman/）integer_to_roman
13（https://leetcode.cn/problems/roman-to-integer/）roman_to_integer
2572（https://leetcode.cn/problems/count-the-number-of-square-free-subsets/）ag_dp|counter
1994（https://leetcode.cn/problems/the-number-of-good-subsets/）bag_dp|counter
2464（https://leetcode.cn/problems/minimum-subarrays-in-a-valid-split/）prime_factorization|counter|dp
14（https://leetcode.cn/problems/qie-fen-shu-zu/）prime_factorization|counter|dp
279（https://leetcode.cn/problems/perfect-squares/）four_square
650（https://leetcode.cn/problems/2-keys-keyboard/）prime_factorization
1390（https://leetcode.cn/problems/four-divisors/）preprocess|factorization
1819（https://leetcode.cn/problems/number-of-different-subsequences-gcds/）preprocess|factorization|brute_force|gcd
1017（https://leetcode.cn/problems/convert-to-base-2/）negative_base|classical
1073（https://leetcode.cn/problems/adding-two-negabinary-numbers/）negative_base|classical
8041（https://leetcode.cn/problems/maximum-element-sum-of-a-complete-subset-of-indices/description/）prime_factorization|hash|classical|odd
100436（https://leetcode.com/problems/sorted-gcd-pair-queries/）inclusion_exclusion|math|number_theory|classical

=====================================LuoGu======================================
P1865（https://www.luogu.com.cn/problem/P1865）linear_sieve|prime|binary_search|range_prime_count
P1748（https://www.luogu.com.cn/problem/P1748）heapq|implemention|pointer|inclusion_exclusion|binary_search
P2723（https://www.luogu.com.cn/problem/P2723）ugly_number
P1952（https://www.luogu.com.cn/problem/P1952）n_base
P1555（https://www.luogu.com.cn/problem/P1555）2-base|3-base
P1465（https://www.luogu.com.cn/problem/P1465）int_to_roman
P1112（https://www.luogu.com.cn/problem/P1112）brute_force
P2926（https://www.luogu.com.cn/problem/P2926）prime_factorization|counter
P5535（https://www.luogu.com.cn/problem/P5535）prime|is_prime5|greedy|brain_teaser
P1876（https://www.luogu.com.cn/problem/P1876）odd_even|factorization|classical
P1887（https://www.luogu.com.cn/problem/P1887）classical|maximum_mul
P2043（https://www.luogu.com.cn/problem/P2043）prime_factorization|prime_sieve|factorial
P2192（https://www.luogu.com.cn/problem/P2192）divide|property|classical
P7191（https://www.luogu.com.cn/problem/P7191）mod|math|factorization
P7517（https://www.luogu.com.cn/problem/P7517）prime_sieve|brute_force|factorization|counter
P7588（https://www.luogu.com.cn/problem/P7588）prime|brute_force|is_prime4
P7696（https://www.luogu.com.cn/problem/P7696）prime_factorization
P4718（https://www.luogu.com.cn/problem/P4718）pollard_rho|prime_factorization|prime
P2429（https://www.luogu.com.cn/problem/P2429）brute_force|prime_factorization|inclusion_exclusion|counter
P1069（https://www.luogu.com.cn/problem/P1069）prime_factorization|counter
P1072（https://www.luogu.com.cn/problem/P1072）brute_force|factorization
P1593（https://www.luogu.com.cn/problem/P1593）prime_factorization|fast_power|classical
P2527（https://www.luogu.com.cn/problem/P2527）ugly_number
P2557（https://www.luogu.com.cn/problem/P2557）prime_factorization|math
P4446（https://www.luogu.com.cn/problem/P4446）is_prime
P4752（https://www.luogu.com.cn/problem/P4752）is_prime
P5248（https://www.luogu.com.cn/problem/P5248）base
P5253（https://www.luogu.com.cn/problem/P5253）math
P7960（https://www.luogu.com.cn/problem/P7960）prime_sieve|preprocess
P8762（https://www.luogu.com.cn/problem/P8762）inclusion_exclusion|prefix_sum|counter
P8778（https://www.luogu.com.cn/problem/P8778）brute_force|prime_factorization|O(n^0.25)|classical
P8782（https://www.luogu.com.cn/problem/P8782）base|greedy|classical
P5091（https://www.luogu.com.cn/problem/P5091）extend_euler_theorem|classical
P1619（https://www.luogu.com.cn/problem/P1619）prime_factor|pollard_rho
P2104（https://www.luogu.com.cn/problem/P2104）stack|n_bin
P2441（https://www.luogu.com.cn/problem/P2441）implemention|data_range|observation|math
P3383（https://www.luogu.com.cn/problem/P3383）eratosthenes_sieve
P3601（https://www.luogu.com.cn/problem/P3601）euler_phi|math|number_theory
P4282（https://www.luogu.com.cn/problem/P4282）math|n_base|classical|high_precision
P1601（https://www.luogu.com.cn/problem/P1601）math|n_base|classical|high_precision
P1303（https://www.luogu.com.cn/problem/P1303）math|n_base|classical|high_precision
P6366（https://www.luogu.com.cn/problem/P6366）n_base|observation
P6539（https://www.luogu.com.cn/problem/P6539）euler_series|classical|brute_force

===================================CodeForces===================================
1771C（https://codeforces.com/problemset/problem/1771/C）pollard_rho|prime_factorization
1349A（https://codeforces.com/contest/1349/problem/A）prime_factorization|brute_force
1295D（https://codeforces.com/contest/1295/problem/D）euler_phi|n_coprime
1538D（https://codeforces.com/problemset/problem/1538/D）pollard_rho|prime_factorization
1458A（https://codeforces.com/problemset/problem/1458/A）gcd|math
1444A（https://codeforces.com/problemset/problem/1444/A）greedy|brute_force|prime_factorization
1823C（https://codeforces.com/contest/1823/problem/C）prime_factorization|greedy
1744E2（https://codeforces.com/contest/1744/problem/E2）brute_force|factorization
1612D（https://codeforces.com/contest/1612/problem/D）gcd_like
1920C（https://codeforces.com/contest/1920/problem/C）brute_force|num_factor|gcd_like
1029F（https://codeforces.com/contest/1029/problem/F）num_factor|brute_force|greedy
1154G（https://codeforces.com/contest/1154/problem/G）num_factor|brute_force|greedy|brain_teaser|classical|minimum_lcm_pair
1360H（https://codeforces.com/contest/1360/problem/H）n_base
1475G（https://codeforces.com/contest/1475/problem/G）linear_dp|brute_force|euler_series|reverse_thinking|brute_force
1512G（https://codeforces.com/contest/1512/problem/G）euler_sieve|number_theory|all_factor_sum|multiplicative_function|classical
1593D2（https://codeforces.com/contest/1593/problem/D2）brute_force|number_theory|classical
1822G2（https://codeforces.com/contest/1822/problem/G2）eratosthenes_sieve|get_all_factor_square
1811E（https://codeforces.com/contest/1811/problem/E）n_base
1878F（https://codeforces.com/contest/1878/problem/F）number_theory|brute_force
1982D（https://codeforces.com/contest/1982/problem/D）peishu_theorem|math|implemention|brute_force|prefix_sum_matrix
1656D（https://codeforces.com/problemset/problem/1656/D）math|odd_even|observation|bain_teaser
1992F（https://codeforces.com/contest/1992/problem/F）greedy|implemention|math
1361B（https://codeforces.com/problemset/problem/1361/B）observation|limited_operation|data_range|brain_teaser|math
1478D（https://codeforces.com/problemset/problem/1478/D）math|peishu_theorem
1228C（https://codeforces.com/problemset/problem/1228/C）math|num_factor|contribution_method
1601C（https://codeforces.com/contest/1061/problem/C）get_all_factor|classical
1542C（https://codeforces.com/problemset/problem/1542/C）math|inclusion_exclusion|brain_teaser|prefix_lcm
1614D2（https://codeforces.com/problemset/problem/1614/D2）euler_series|number_theory|linear_dp|classical|factor_cnt
632D（https://codeforces.com/problemset/problem/632/D）linear_dp|math|classical|euler_series
1753B（https://codeforces.com/contest/1753/problem/B）math|n_base
2013E（https://codeforces.com/contest/2013/problem/E）greedy|gcd_like|number_theory|observation
1750D（https://codeforces.com/problemset/problem/1750/D）number_theory|observation|data_range|limited_operation|inclusion_exclusion|gcd_like|num_factor|classical
687B（https://codeforces.com/problemset/problem/687/B）math|mod|lcm|classical
2020B（https://codeforces.com/contest/2020/problem/B）factor_cnt|number_theory|classical
1114C（https://codeforces.com/problemset/problem/1114/C）get_prime_factor|num_factor|inclusion_exclusion|n_base
2007C（https://codeforces.com/problemset/problem/2007/C）peishu_theorem|gcd_like|greedy|brain_teaser|implemention|math

====================================AtCoder=====================================
ABC114D（https://atcoder.jp/contests/abc114/tasks/abc114_d）prime_factorization|counter
ABC134D（https://atcoder.jp/contests/abc134/tasks/abc134_d）reverse_thinking|construction
ABC337E（https://atcoder.jp/contests/abc337/tasks/abc337_e）n_base|classical
ABC304F（https://atcoder.jp/contests/abc304/tasks/abc304_f）classical|inclusion_exclusion
ABC300D（https://atcoder.jp/contests/abc300/tasks/abc300_d）brute_force|two_pointers
ABC293E（https://atcoder.jp/contests/abc293/tasks/abc293_e）power_reverse|frac_pow|classical|math|recursion|divide_conquer
ABC284D（https://atcoder.jp/contests/abc284/tasks/abc284_d）get_prime_with_pollard_rho|num_factor|classical
ABC280D（https://atcoder.jp/contests/abc280/tasks/abc280_d）prime_factorization|brain_teaser|greedy|classical
ABC259E（https://atcoder.jp/contests/abc259/tasks/abc259_e）brute_force|lcm|num_factor
ABC253D（https://atcoder.jp/contests/abc253/tasks/abc253_d）inclusion_exclusion|lcm|math|corner_case|classical
ABC250D（https://atcoder.jp/contests/abc250/tasks/abc250_d）brute_force|counter|contribution_method|math
ABC245D（https://atcoder.jp/contests/abc245/tasks/abc245_d）implemention|math|data_range|classical
ABC242F（https://atcoder.jp/contests/abc242/tasks/abc242_f）inclusion_exclusion|counter|brute_force|classical
ABC242E（https://atcoder.jp/contests/abc242/tasks/abc242_e）n_base|math
ABC233E（https://atcoder.jp/contests/abc233/tasks/abc233_e）big_number|prefix_sum|data_range
ABC230E（https://atcoder.jp/contests/abc230/tasks/abc230_e）brain_teaser|math|divide_block|template
ABC228E（https://atcoder.jp/contests/abc228/tasks/abc228_e）math|fast_power|classical
ABC210E（https://atcoder.jp/contests/abc210/tasks/abc210_e）math|brain_teaser|ring_mst
ABC356E（https://atcoder.jp/contests/abc356/tasks/abc356_e）contribution_method|math
ABC361F（https://atcoder.jp/contests/abc361/tasks/abc361_f）inclusion_exclusion|math
ABC206E（https://atcoder.jp/contests/abc206/tasks/abc206_e）inclusion_exclusion|math|contribution_method|brute_force

=====================================AcWing=====================================
99（https://www.acwing.com/problem/content/99/）a^b|math|factorization
126（https://www.acwing.com/problem/content/126/）base
198（https://www.acwing.com/problem/content/198/）counter
200（https://www.acwing.com/problem/content/200/）anti_prime_number
201（https://www.acwing.com/problem/content/description/201/）brute_force
3730（https://www.acwing.com/problem/content/description/3730/）brain_teaser|base
4002（https://www.acwing.com/problem/content/description/4002/）CF1295D
4322（https://www.acwing.com/problem/content/4322/）prime_factorization|prefix_hash|counter
4487（https://www.acwing.com/problem/content/4487/）base
4489（https://www.acwing.com/problem/content/description/4489/）prime_factorization|greedy
4625（https://www.acwing.com/problem/content/description/4625/）brain_teaser|greedy|construction
5052（https://www.acwing.com/problem/content/description/5052/）prime_factorization|comb


1（https://www.codechef.com/problems/UQR）math|brain_teaser

"""
import bisect
import math
from collections import Counter, deque
from collections import defaultdict
from functools import reduce, lru_cache
from itertools import accumulate
from operator import mul
from sys import stdout
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.basis.diff_array.template import PreFixSumMatrix
from src.mathmatics.comb_perm.template import Combinatorics
from src.mathmatics.gcd_like.template import GcdLike
from src.mathmatics.number_theory.template import EulerPhi, NumFactor, PrimeSieve, NumTheory, PrimeJudge, NumBase
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_2572(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/count-the-number-of-square-free-subsets/
        tag: bag_dp|counter|classical|hard
        """

        dct = {2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30}
        mod = 10 ** 9 + 7
        cnt = Counter(nums)
        pre = defaultdict(int)
        for num in cnt:
            if num in dct:
                cur = pre.copy()
                for p in pre:
                    if math.gcd(p, num) == 1:
                        cur[p * num] += pre[p] * cnt[num]
                        cur[p * num] %= mod
                cur[num] += cnt[num]
                pre = cur.copy()

        p = pow(2, cnt[1], mod)
        ans = sum(pre.values()) * p
        ans += p - 1
        return ans % mod

    @staticmethod
    def cf_1295d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1295/problem/D
        tag: euler_phi|n_coprime|classical|hard|gcd|classical
        """
        for _ in range(ac.read_int()):  # gcd(a, b) = gcd(a - b, b) = gcd(a % b, b)
            a, m = ac.read_list_ints()
            g = math.gcd(a, m)
            mm = m // g
            ans = EulerPhi().euler_phi_with_prime_factor(mm)
            ac.st(ans)
        return

    @staticmethod
    def cf_1458a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1458/A
        tag: gcd|math|classical|hard
        """
        m, n = ac.read_list_ints()  # gcd(x, y) = gcd(x - y, y)
        a = ac.read_list_ints()  # gcd(a1, a2, ... , an) = gcd(a1, a2 - a1, ... , an - a1)
        b = ac.read_list_ints()
        g = 0
        for i in range(1, m):
            g = math.gcd(g, a[i] - a[0])
        ans = [math.gcd(g, a[0] + num) for num in b]
        ac.lst(ans)
        return

    @staticmethod
    def ac_97(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/99/
        tag: math|factorization|classical|hard
        """

        mod = 9901
        a, b = ac.read_list_ints()
        if a == 1 or b == 0:
            ac.st(1)
        elif a == 0:
            ac.st(0)
        else:
            ans = 1
            gl = GcdLike()
            for p, c in NumFactor().get_prime_factor(a):
                c *= b
                if math.gcd(p - 1, mod) == 1:
                    ans *= (pow(p, c + 1, mod) - 1) * gl.mod_reverse(p - 1, mod)
                    ans %= mod
                else:
                    ans *= (c + 1)
                    ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def ac_124(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/126/
        tag: base
        """

        st = "0123456789"
        for i in range(26):
            st += chr(i + ord("A"))
        for i in range(26):
            st += chr(i + ord("a"))
        ind = {w: i for i, w in enumerate(st)}
        for _ in range(ac.read_int()):
            a, b, word = ac.read_list_strs()
            a = int(a)
            b = int(b)
            num = 0
            for w in word:
                num *= a
                num += ind[w]
            ac.lst([a, word])
            ans = ""
            while num:
                ans += st[num % b]
                num //= b
            if not ans:
                ans = "0"
            ac.lst([b, ans[::-1]])
            ac.st("")
        return

    @staticmethod
    def ac_196(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/198/
        tag: counter|classical|hard|prime_sieve
        """

        ceil = 2 ** 31 - 1
        primes = PrimeSieve().eratosthenes_sieve(int(ceil ** 0.5) + 1)
        while True:
            lst = ac.read_list_ints()
            if not lst:
                break

            left, right = lst
            dp = [0] * (right - left + 1)
            for p in primes:
                x = max(math.ceil(left / p), 2) * p
                while left <= x <= right:
                    dp[x - left] = 1
                    x += p

            rest = [x + left for x in range(right - left + 1) if not dp[x] and x + left > 1]
            if len(rest) < 2:
                ac.st("There are no adjacent primes.")
            else:
                ans1 = [rest[0], rest[1]]
                ans2 = [rest[0], rest[1]]
                m = len(rest)
                for i in range(2, m):
                    a, b = rest[i - 1], rest[i]
                    if b - a < ans1[1] - ans1[0]:
                        ans1 = [a, b]
                    if b - a > ans2[1] - ans2[0]:
                        ans2 = [a, b]
                ac.st(f"{ans1[0]},{ans1[1]} are closest, {ans2[0]},{ans2[1]} are most distant.")
        return

    @staticmethod
    def ac_198(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/200/
        tag: anti_prime_number|classical|hard|data_range|brute_force|dfs
        """

        n = ac.read_int()
        primes = PrimeSieve().eratosthenes_sieve(50)
        x = reduce(mul, primes)
        while x > n:
            x //= primes.pop()

        m = len(primes)
        ans = [1, 1]
        stack = [(1, 1, int(math.log2(n)) + 1, 0)]
        while stack:
            x, cnt, mi, i = stack.pop()
            if mi == 0 or i == m:
                if cnt > ans[1] or (cnt == ans[1] and x < ans[0]):
                    ans = [x, cnt]
                continue
            for y in range(mi, -1, -1):
                if x * primes[i] ** y <= n:
                    stack.append((x * primes[i] ** y, cnt * (y + 1), y, i + 1))
        ac.st(ans[0])
        return

    @staticmethod
    def ac_199(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/201/
        tag: brute_force|classical|hard|data_range
        """
        n, k = ac.read_list_ints()
        ans = n * k
        left = 1
        while left <= min(n, k):
            right = min(k // (k // left), n)
            ans -= (k // left) * (left + right) * (right - left + 1) // 2
            left = right + 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p1069(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1069
        tag: prime_factorization|counter|greedy
        """
        ac.read_int()
        m1, m2 = ac.read_list_ints()
        lst = NumFactor().get_prime_factor(m1)
        ans = math.inf
        for num in ac.read_list_ints():
            res = 0
            for p, c in lst:
                if num % p != 0:
                    break
                tmp = num
                x = 0
                while tmp % p == 0:
                    tmp //= p
                    x += 1
                res = max(res, math.ceil(c * m2 / x))
            else:
                ans = min(ans, res)
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p1072(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1072
        tag: brute_force|factorization
        """
        nt = NumFactor()
        for _ in range(ac.read_int()):
            a0, a1, b0, b1 = ac.read_list_ints()
            factor = [num for num in nt.get_all_with_pollard_rho(b1)
                      if num % a1 == 0 and math.gcd(num, a0) == a1
                      and b0 * num // math.gcd(num, b0) == b1]
            ac.st(len(factor))
        return

    @staticmethod
    def lg_p1593(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1593
        tag: prime_factorization|fast_power|classical|hard
        """
        mod = 9901
        a, b = ac.read_list_ints()
        if a == 1 or b == 0:
            ac.st(1)
        else:
            ans = 1
            for p, c in NumFactor().get_prime_factor(a):
                c *= b
                if math.gcd(p - 1, mod) == 1:
                    ans *= (pow(p, c + 1, mod) - 1) * pow(p - 1, -1, mod)
                    ans %= mod
                else:
                    ans *= (c + 1)
                    ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def lg_p2429(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2429
        tag: brute_force|prime_factorization|inclusion_exclusion|counter|data_range
        """

        n, m = ac.read_list_ints()
        primes = sorted(ac.read_list_ints())
        stack = [(0, 1, 0)]
        ans = 0
        mod = 376544743

        while stack:
            i, value, cnt = stack.pop()
            if value > m:
                continue
            if i == n:
                if cnt:
                    num = m // value
                    ans += value * (num * (num + 1) // 2) * (-1) ** (cnt + 1)
                    ans %= mod
                continue
            stack.append((i + 1, value * primes[i], cnt + 1))
            stack.append((i + 1, value, cnt))
        ac.st(ans)
        return

    @staticmethod
    def lg_p2527(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2527
        tag: ugly_number
        """
        _, k = ac.read_list_ints()
        primes = ac.read_list_ints()
        ans = NumTheory().nth_super_ugly_number(k + 1, primes)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2557(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2557
        tag: prime_factorization|math
        """
        a, b = ac.read_list_ints()
        cnt = dict()
        for p, c in NumFactor().get_prime_factor(a):
            cnt[p] = c
        ans = 1
        for k in cnt:
            c = cnt[k] * b
            ans *= (k ** (c + 1) - 1) // (k - 1)
        ac.st(ans)
        return

    @staticmethod
    def lg_p4446(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4446
        tag: prime_sieve|hard|classical|brute_force
        """
        ac.read_int()
        nums = ac.read_list_ints()
        prime = PrimeSieve().eratosthenes_sieve(int(max(nums) ** 0.25) + 1)
        for num in nums:
            ans = 1
            for p in prime:
                if p ** 3 > num:
                    break
                c = 0
                while num % p == 0:
                    c += 1
                    num //= p
                ans *= p ** (c // 3)

            low = 1
            high = int(num ** (1 / 3)) + 1
            while low < high - 1:
                mid = low + (high - low) // 2
                if mid ** 3 <= num:
                    low = mid
                else:
                    high = mid
            if high ** 3 == num:
                ans *= high
            elif low ** 3 == num:
                ans *= low
            ac.st(ans)
        return

    @staticmethod
    def lg_p4752(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4752
        tag: is_prime
        """
        pj = PrimeJudge()
        for _ in range(ac.read_int()):
            ac.read_list_ints()
            cnt = Counter(ac.read_list_ints())
            for num in ac.read_list_ints():
                cnt[num] -= 1
            rest = []
            for num in cnt:
                if cnt[num] and num != 1:
                    rest.append((num, cnt[num]))
            if len(rest) != 1:
                ac.no()
            elif len(rest) == 1:
                if rest[0][1] > 1:
                    ac.no()
                else:
                    if pj.is_prime_speed(rest[0][0]):
                        ac.yes()
                    else:
                        ac.no()
        return

    @staticmethod
    def lg_p5248(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5248
        tag: n_base|classical
        """
        n, fn = ac.read_list_ints()
        lst = []
        while fn:
            lst.append(fn % n)
            fn //= n
        ac.st(len(lst))
        ac.lst(lst)
        return

    @staticmethod
    def lg_p5253(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5253
        tag: math|classical|hard
        """
        n = ac.read_int()  # (x - n) * (y - n) = n ^ 2
        lst = NumFactor().get_prime_factor(n)
        ans = 1
        for _, c in lst:
            ans *= (2 * c + 1)
        ac.st(ans // 2 + 1)
        return

    @staticmethod
    def lg_p7960(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P7960
        tag: prime_sieve|preprocess
        """
        n = 10 ** 7
        dp = [0] * (n + 1)
        for x in range(1, n + 1):
            if "7" in str(x):
                y = 1
                while x * y <= n:
                    dp[x * y] = 1
                    y += 1
        post = 10 ** 7 + 1
        for i in range(n, -1, -1):
            if dp[i] == 1:
                dp[i] = -1
            else:
                dp[i] = post
                post = i
        for _ in range(ac.read_int()):
            ac.st(dp[ac.read_int()])
        return

    @staticmethod
    def lg_p8778(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8778
        tag: brute_force|prime_factorization|O(n^0.25)|classical
        """

        primes = PrimeSieve().eratosthenes_sieve(4000)

        def check(xx):
            for r in range(2, 4):
                a = int(xx ** (1 / r))
                for ww in [a - 1, a, a + 1, a + 2]:
                    if ww ** r == xx:
                        return True
            return False

        n = ac.read_int()
        for _ in range(n):
            num = ac.read_int()
            flag = True
            for p in primes:
                if p > num:
                    break
                x = 0
                while num % p == 0:
                    x += 1
                    num //= p
                if x == 1:
                    flag = False
                    break
            if flag and check(num):
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def lc_1073(arr1: List[int], arr2: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/problems/adding-two-negabinary-numbers/
        tag: negative_base|classical
        """

        def check(tmp):
            res = 0
            for num in tmp:
                res = (-2) * res + num
            return res

        ans = check(arr1) + check(arr2)
        return NumBase().get_k_bin_of_n(ans, -2)

    @staticmethod
    def ac_3730(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/3730/
        tag: brain_teaser|base
        """

        for _ in range(ac.read_int()):
            def check():
                n, k = ac.read_list_ints()
                cnt = Counter()
                for num in ac.read_list_ints():
                    lst = []
                    while num:
                        lst.append(num % k)
                        num //= k
                    for i, va in enumerate(lst):
                        cnt[i] += va
                        if cnt[i] > 1:
                            ac.no()
                            return
                ac.yes()
                return

            check()

        return

    @staticmethod
    def ac_4484(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4487/
        tag: n_base
        """

        for _ in range(ac.read_int()):

            def check():
                nonlocal q
                while q > 1:
                    gg = math.gcd(q, b)
                    if gg == 1:
                        break
                    q //= gg
                return q == 1

            p, q, b = ac.read_list_ints()
            g = math.gcd(p, q)
            p //= g
            q //= g

            ac.st("YES" if check() else "NO")
        return

    @staticmethod
    def ac_4486(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4489/
        tag: prime_factorization|greedy
        """

        n = ac.read_int()
        if n == 1:
            ac.lst([1, 0])
            return

        res = NumFactor().get_prime_factor(n)

        ans = 1
        x = 0
        ind = [2 ** i for i in range(32)]
        lst = []
        for p, c in res:
            ans *= p
            for i in range(32):
                if ind[i] >= c:
                    if ind[i] > c:
                        x = 1
                    lst.append(i)
                    break
        cnt = max(w for w in lst)
        if any(w < cnt for w in lst) or x:
            cnt += 1
        ac.lst([ans, cnt])
        return

    @staticmethod
    def ac_4622(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4625/
        tag: brain_teaser|greedy|construction
        """

        n = ac.read_int()
        if n < 4:
            ac.st(1)
        elif n % 2 == 0:
            ac.st(2)
        else:
            if PrimeJudge().is_prime_speed(n - 2):
                ac.st(2)
            else:
                ac.st(3)
        return

    @staticmethod
    def cf_1612d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1612/problem/D
        tag: gcd_like
        """
        for _ in range(ac.read_int()):
            a, b, x = ac.read_list_ints()
            while True:
                if a < b:
                    a, b = b, a
                if x == a or x == b:
                    ac.yes()
                    break
                if x > a or b == 0:
                    ac.no()
                    break
                if (a - x) % b == 0:
                    ac.yes()
                    break
                y = ac.ceil(a, b) - 1
                a -= y * b
                if y == 0:
                    ac.no()
                    break

        return

    @staticmethod
    def cf_1744_e2(ac=FastIO()):
        # 因数brute_force
        for _ in range(ac.read_int()):
            a, b, c, d = ac.read_list_ints()
            lst_a = NumFactor().get_all_factor(a)
            lst_b = NumFactor().get_all_factor(b)

            def check():
                for x in lst_a:
                    for y in lst_b:
                        g = x * y
                        yy = a * b // g
                        low_1 = a // g + 1
                        high_1 = c // g

                        low_2 = b // yy + 1
                        high_2 = d // yy
                        if low_2 <= high_2 and low_1 <= high_1:
                            ac.lst([low_1 * g, low_2 * yy])
                            return
                ac.lst([-1, -1])
                return

            check()
        return

    @staticmethod
    def lc_1017(n: int) -> str:
        """
        url: https://leetcode.cn/problems/convert-to-base-2/
        tag: negative_base|classical
        """
        lst = NumBase().get_k_bin_of_n(n, -2)
        return "".join(str(x) for x in lst)

    @staticmethod
    def cf_1920c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1920/problem/C
        tag: brute_force|num_factor|gcd_like
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = 0
            a = ac.read_list_ints()
            seen = set()
            lst = NumFactor().get_all_factor(n)
            m = len(lst)
            for ii in range(m):
                k = lst[ii]
                if k in seen:
                    continue
                gcd = 0
                for j in range(n - k):
                    gcd = math.gcd(gcd, a[k + j] - a[j])
                    if gcd == 1:
                        break
                if gcd == 1:
                    continue
                for w in lst[ii:]:
                    if w % k == 0 and w not in seen:
                        seen.add(w)
                        ans += gcd != 1
            ac.st(ans)
        return

    @staticmethod
    def abc_337e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc337/tasks/abc337_e
        tag: n_base|classical
        """
        n = ac.read_int()
        m = n.bit_length() if n.bit_count() > 1 else n.bit_length() - 1

        dct = [[] for _ in range(m + 1)]
        for i in range(1, n + 1):
            for j in range(m):
                if i & (1 << j):
                    dct[j + 1].append(i)

        ac.st(m)
        for ls in dct[1:]:
            ac.lst([len(ls)] + ls[:])
        stdout.flush()

        s = ac.read_str()
        ans = 0
        for i in range(m):
            if s[i] == "1":
                ans |= 1 << i
        ac.st(ans if ans else n)
        stdout.flush()
        return

    @staticmethod
    def cf_1029f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1029/problem/F
        tag: num_factor|brute_force|greedy
        """
        a, b = ac.read_list_ints()
        lst_a = NumFactor().get_all_factor(a)
        lst_b = NumFactor().get_all_factor(b)
        lst_ab = NumFactor().get_all_factor(a + b)
        ma = len(lst_a)
        mb = len(lst_b)
        ans = 2 * (a + b + 1)
        i = j = 0
        pre = a + b + 1
        for x in lst_ab:
            y = (a + b) // x
            while i < ma and lst_a[i] <= x:
                pre = min(pre, a // lst_a[i])
                i += 1
            while j < mb and lst_b[j] <= x:
                pre = min(pre, b // lst_b[j])
                j += 1
            if pre <= y and 2 * (x + y) < ans:
                ans = 2 * (x + y)
        ac.st(ans)
        return

    @staticmethod
    def cf_1154g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1154/problem/G
        tag: num_factor|brute_force|greedy|brain_teaser|classical|minimum_lcm_pair
        """
        ac.read_int()
        nums = ac.read_list_ints()
        m = 10 ** 7 + 1
        cnt = [-2] * m
        ans = []
        res = 10 ** 14 + 1
        for num in nums:
            if cnt[num] == -1:
                if num < res:
                    res = num
                    ans = [num, num]
            else:
                cnt[num] = -1

        arr = sorted(set(nums))
        k = len(arr)
        for i, num in enumerate(arr):
            cnt[num] = i

        if k > 1:
            cur = arr[0] * arr[1] // math.gcd(arr[0], arr[1])
            if cur < res:
                ans = [arr[0], arr[1]]
                res = cur

            for i in range(2, m):
                lst = []
                for j in range(i, m, i):
                    if cnt[j] >= 0:
                        lst.append(cnt[j])
                        if len(lst) >= 2:
                            break
                if len(lst) == 2:
                    x, y = lst[0], lst[1]
                    cur = arr[x] * arr[y] // math.gcd(arr[x], arr[y])
                    if cur < res:
                        res = cur
                        ans = [arr[x], arr[y]]
                if lst:
                    if lst[0] == 0:
                        y = 1
                    else:
                        y = 0
                    x = lst[0]
                    cur = arr[x] * arr[y] // math.gcd(arr[x], arr[y])
                    if cur < res:
                        res = cur
                        ans = [arr[x], arr[y]]
        i = nums.index(ans[0])
        nums[i] = -1
        j = nums.index(ans[1])
        ac.lst(sorted([i + 1, j + 1]))
        return

    @staticmethod
    def cf_1512g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1512/problem/G
        tag: euler_sieve|number_theory|all_factor_sum|multiplicative_function|classical
        """
        ceil = 10 ** 7
        dp = [1] * (ceil + 1)
        for p in range(2, ceil + 1):
            if dp[p] == 1:
                for i in range(p, ceil + 1, p):
                    z = i // p
                    if z % p == 0:
                        dp[i] = dp[z] + (dp[z] - dp[z // p]) * p
                    else:
                        dp[i] = dp[z] * (p + 1)

        res = [-1] * (ceil + 1)
        for i in range(1, ceil + 1):
            x = dp[i]
            if x <= ceil and res[x] == -1:
                res[x] = i
        for _ in range(ac.read_int()):
            ac.st(res[ac.read_int()])
        return

    @staticmethod
    def cf_1208d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1822/problem/G2
        tag: eratosthenes_sieve|get_all_factor_square
        """
        ps = PrimeSieve()
        primes = ps.eratosthenes_sieve(1000)
        nf = NumFactor()
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            nums.sort()
            cnt = dict()
            for num in nums:
                cnt[num] = cnt.get(num, 0) + 1
            ans = 0
            for num in sorted(cnt):
                if cnt[num] > 2:
                    ans += cnt[num] * (cnt[num] - 1) * (cnt[num] - 2)
                square = nf.get_all_factor_square(primes, num)
                for f in square:
                    if f > 1:
                        b = int(f ** 0.5)
                        ans += cnt[num] * cnt.get(num // b, 0) * cnt.get(num // f, 0)
            ac.st(ans)
        return

    @staticmethod
    def abc_304f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc304/tasks/abc304_f
        tag: classical|inclusion_exclusion
        """
        n = ac.read_int()
        s = ac.read_str()
        mod = 998244353
        factor = NumFactor().get_all_factor(n)
        factor.pop()
        pre = defaultdict(int)
        ans = 0
        for m in factor:
            cnt = 0
            for i in range(m):
                if any(s[j] == "." for j in range(i, n, m)):
                    continue
                cnt += 1
            cur = pow(2, cnt, mod)
            for num in pre:
                if m % num == 0:
                    cur -= pre[num]
            cur %= mod
            ans += cur
            ans %= mod
            pre[m] = cur
        ac.st(ans)
        return

    @staticmethod
    def abc_293e_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc293/tasks/abc293_e
        tag: power_reverse|frac_pow|classical|math|recursion|divide_conquer
        """
        a, x, m = ac.read_list_ints()
        if a == 1:
            ac.st(x % m)
            return

        def frac_mod(aa, bb, mm):
            # (aa/bb) % mod and (aa%bb=0)
            return (aa % (mm * bb)) // bb

        mod = m * (a - 1)
        ans = frac_mod((pow(a, x, mod) - 1) % mod, a - 1, m)
        ac.st(ans)
        return

    @staticmethod
    def abc_293e_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc293/tasks/abc293_e
        tag: power_reverse|frac_pow|classical|math|recursion|divide_conquer
        """
        a, x, m = ac.read_list_ints()

        @lru_cache(None)
        def dfs(k):
            if k == 0:
                return 1 % m
            nex = dfs(k // 2)
            res = nex * pow(a, k // 2 + 1, m) + nex
            if k % 2 == 0:
                res -= pow(a, k + 1, m)
            return res % m

        ans = dfs(x - 1)
        ac.st(ans)
        return

    @staticmethod
    def abc_284d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc284/tasks/abc284_d
        tag: get_prime_with_pollard_rho|num_factor|classical
        """
        nf = NumFactor()
        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = nf.get_prime_with_pollard_rho(n)
            p = [x for x in ans if ans[x] == 2][0]
            q = [x for x in ans if ans[x] == 1][0]
            ac.lst([p, q])
        return

    @staticmethod
    def abc_280d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc280/tasks/abc280_d
        tag: prime_factorization|brain_teaser|greedy|classical
        """
        k = ac.read_int()
        lst = NumFactor().get_prime_factor(k)
        dct = {x: y for x, y in lst}
        ans = 0
        for x in dct:
            c = dct[x]
            for y in range(x, x * k + x, x):
                i = y
                while y % x == 0:
                    c -= 1
                    y //= x
                ans = max(ans, i)
                if c <= 0:
                    break
        ac.st(ans)
        return

    @staticmethod
    def abc_253d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc253/tasks/abc253_d
        tag: inclusion_exclusion|lcm|math|corner_case|classical
        """
        n, a, b = ac.read_list_ints()
        ans = n * (n + 1) // 2
        if a != b:
            x = n // a
            ans -= x * (x + 1) * a // 2
            x = n // b
            ans -= x * (x + 1) * b // 2
            gg = math.lcm(a, b)
            x = n // gg
            ans += (x * (x + 1) * gg) // 2
            ac.st(ans)
        else:
            x = n // a
            ans -= x * (x + 1) * a // 2
            ac.st(ans)
        return

    @staticmethod
    def abc_250d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc250/tasks/abc250_d
        tag: brute_force|counter|contribution_method|math
        """
        primes = PrimeSieve().eratosthenes_sieve(10 ** 6)
        n = ac.read_int()
        ans = 0
        for q in primes:
            high = n // (q ** 3)
            high = min(high, q - 1)
            if high >= primes[0]:
                ans += bisect.bisect_right(primes, high)
        ac.st(ans)
        return

    @staticmethod
    def abc_245d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc245/tasks/abc245_d
        tag: implemention|math|data_range|classical
        """
        n, m = ac.read_list_ints()
        a = ac.read_list_ints()
        c = ac.read_list_ints()
        b = [0] * (m + 1)
        for i in range(m, -1, -1):
            pre = 0
            for ii in range(n + 1):
                jj = n + i - ii
                if i < jj <= m:
                    pre += a[ii] * b[jj]
            b[i] = (c[n + i] - pre) // a[n]
        ac.lst(b)
        return

    @staticmethod
    def abc_242f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc242/tasks/abc242_f
        tag: inclusion_exclusion|counter|brute_force|classical
        """
        m, n, b, w = ac.read_list_ints()
        mod = 998244353
        cb = Combinatorics(m * n + 10, mod)

        @lru_cache(None)
        def dfs(row, col, x):
            if x > row * col:
                return 0
            tot = cb.comb(row * col, x)
            for i in range(1, row + 1):
                for j in range(1, col + 1):
                    if i == row and j == col:
                        continue
                    tot -= cb.comb(row, i) * cb.comb(col, j) * dfs(i, j, x)
            return tot % mod

        ans = 0
        for ii in range(1, m + 1):
            for jj in range(1, n + 1):
                if (m - ii) * (n - jj) >= w:
                    ans += cb.comb(m, ii) * cb.comb(n, jj) * dfs(ii, jj, b) * cb.comb((m - ii) * (n - jj), w)
                    ans %= mod
                else:
                    break
        ac.st(ans)
        return

    @staticmethod
    def abc_242e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc242/tasks/abc242_e
        tag: n_base|math
        """
        mod = 998244353
        for _ in range(ac.read_int()):
            n = ac.read_int()
            s = ac.read_str()
            if n % 2:
                t = s[:n // 2 + 1]
            else:
                t = s[:n // 2]
            ans = 0
            for w in t:
                ans = ans * 26 + ord(w) - ord("A")
                ans %= mod
            ans += 1
            if n % 2 and t + t[:-1][::-1] > s:
                ans -= 1
            elif n % 2 == 0 and t + t[::-1] > s:
                ans -= 1
            ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def abc_233e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc233/tasks/abc233_e
        tag: big_number|prefix_sum|data_range
        """
        s = [int(w) for w in ac.read_str()]
        pre = ac.accumulate(s)
        ans = []
        n = len(s)
        x = 0
        for i in range(n - 1, -1, -1):
            x += pre[i + 1]
            ans.append(x % 10)
            x //= 10
        while x:
            ans.append(x % 10)
            x //= 10
        ans.reverse()
        ac.st("".join(str(x) for x in ans))
        return

    @staticmethod
    def abc_230e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc230/tasks/abc230_e
        tag: brain_teaser|math|divide_block|template
        """

        n = ac.read_int()
        ans = 0
        ll = 1
        while ll <= n:
            rr = n // (n // ll)
            ans += (rr - ll + 1) * (n // ll)
            ll = rr + 1
        ac.st(ans)
        return

    @staticmethod
    def abc_228e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc228/tasks/abc228_e
        tag: math|fast_power|classical
        """
        n, k, m = ac.read_list_ints()
        mod = 998244353
        if m % mod == 0:
            ac.st(0)
        else:
            ans = pow(m, pow(k, n, mod - 1), mod)
            ac.st(ans)
        return

    @staticmethod
    def abc_210e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc210/tasks/abc210_e
        tag: math|brain_teaser|ring_mst
        """
        n, m = ac.read_list_ints()
        nums = [ac.read_list_ints() for _ in range(m)]
        nums.sort(key=lambda it: it[1])
        ans = 0
        for a, c in nums:
            g = math.gcd(a, n)
            ans += c * (n - g)
            n = g
        ac.st(ans if n == 1 else -1)
        return

    @staticmethod
    def abc_356e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc356/tasks/abc356_e
        tag: contribution_method|math
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ceil = 10 ** 6 + 1
        cnt = [0] * (ceil + 1)
        for num in nums:
            cnt[num] += 1
        ans = 0
        pre = ac.accumulate(cnt)
        for x in range(1, ceil + 1):
            if cnt[x]:
                for y in range(x, ceil + 1, x):
                    low = y
                    high = min(y + x - 1, ceil)
                    ans += (low // x) * cnt[x] * (pre[high + 1] - pre[low])
                ans -= cnt[x] * cnt[x]
                if cnt[x] > 1:
                    ans += cnt[x] * (cnt[x] - 1) // 2
        ac.st(ans)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/UQR
        tag: math|brain_teaser
        """
        for _ in range(ac.read_int()):
            n, a, b = ac.read_list_ints()
            if a == b:
                ac.st(n // a)
            else:
                a = min(a, b)
                k = n // a
                if k == 0:
                    ac.st(0)
                else:
                    if k <= a:
                        ans = k * (k + 1) // 2 - 1
                    else:
                        ans = a * (a + 1) // 2 - 1 + (k - a) * a
                    ans += min(n % a, k) + 1
                    ac.st(ans)
        return

    @staticmethod
    def cf_1982d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1982/problem/D
        tag: peishu_theorem|math|implemention|brute_force|prefix_sum_matrix
        """
        for _ in range(ac.read_int()):
            m, n, k = ac.read_list_ints()
            grid = [ac.read_list_ints() for _ in range(m)]
            st = [[2 * int(w) - 1 for w in ac.read_str()] for _ in range(m)]
            ans = g = 0
            for i in range(m):
                for j in range(n):
                    ans += grid[i][j] * st[i][j]
            pre = PreFixSumMatrix(st)
            for i in range(m - k + 1):
                for j in range(n - k + 1):
                    g = math.gcd(g, -pre.query(i, j, i + k - 1, j + k - 1))
            ac.st("YES" if g == ans == 0 or (g and ans % g == 0) else "NO")
        return

    @staticmethod
    def cf_1656d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1656/D
        tag: math|odd_even|observation|bain_teaser
        """
        for _ in range(ac.read_int()):
            b = ac.read_int() * 2
            a = 1
            while b % 2 == 0:
                b //= 2
                a *= 2
            if a < b:
                ac.st(a)
            elif a > b > 1:
                ac.st(b)
            else:
                ac.st(-1)
        return

    @staticmethod
    def cf_1992f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1992/problem/F
        tag: greedy|implemention|math
        """

        for _ in range(ac.read_int()):
            n, x = ac.read_list_ints()
            nums = ac.read_list_ints()
            ans = cnt = 0
            pre = {1}
            for num in nums:
                if any(p * num == x for p in pre) or x == num:
                    ans += cnt
                    if x != num:
                        cnt = 1
                        pre = {num} if x % num == 0 else set()
                    else:
                        cnt = 0
                        pre = {1}
                else:
                    pre = {(p * num) for p in pre if x % (p * num) == 0} | pre
                    if x % num == 0:
                        pre.add(num)
                    cnt = 1
            ac.st(ans + cnt)
        return

    @staticmethod
    def cf_1361b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1361/B
        tag: observation|limited_operation|data_range|brain_teaser|math
        """
        mod = 1000000007
        for _ in range(ac.read_int()):
            n, p = ac.read_list_ints()
            nums = ac.read_list_ints()
            if p == 1:
                ac.st(n % 2)
            else:
                ceil = 25
                dct = dict()
                for num in nums:
                    dct[num] = dct.get(num, 0) + 1
                lst = sorted(list(dct.keys()), reverse=True)
                m = len(lst)
                for i, x in enumerate(lst):
                    if dct[x] % 2 == 0:
                        continue
                    pre = 0
                    target = 1
                    for y in range(1, ceil + 1):
                        pre *= p
                        target *= p
                        if pre + dct.get(x - y, 0) >= target:
                            need = target - pre
                            dct[x - y] -= need
                            for w in range(1, y):
                                if x - w in dct:
                                    dct[x - w] = 0
                            break
                        pre += dct.get(x - y, 0)
                    else:
                        ans = pow(p, x, mod)
                        for j in range(i + 1, m):
                            ans -= dct[lst[j]] * pow(p, lst[j], mod)
                            ans %= mod
                        ans %= mod
                        ac.st(ans)
                        break
                else:
                    ac.st(0)
        return

    @staticmethod
    def cf_1478d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1478/D
        tag: math|peishu_theorem
        """
        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()
            g = 0
            for i in range(1, n):
                g = math.gcd(nums[i] - nums[0], g)
            ac.st("YES" if (k - nums[0]) % g == 0 else "NO")
        return

    @staticmethod
    def lg_p5091(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5091
        tag: extend_euler_theorem|classical
        """
        a, m, s = ac.read_list_strs()
        a = int(a)
        m = int(m)
        phi = EulerPhi().euler_phi_with_prime_factor(m)
        b = flag = 0
        for w in s:
            b *= 10
            b += int(w)
            if b >= phi:
                flag = 1
                b %= phi
        if flag:
            b += phi
        ans = pow(a, b, m)
        ac.st(ans)
        return

    @staticmethod
    def lg_p1619(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1619
        tag: prime_factor|pollard_rho
        """
        while True:
            s = ac.read_str()
            s = "".join(w for w in s if w.isdigit())
            ac.st("Enter the number=")
            if not s:
                break
            lst = deque(s)
            while len(lst) >= 2 and lst[0] == "0":
                lst.popleft()
            s = "".join(lst)
            if len(s) >= 10 or int(s) > 4 * 10 ** 7:
                ac.st("Prime? No!")
                ac.st("The number is too large!")
            else:
                s = int(s)
                if s <= 1:
                    ac.st("Prime? No!")
                else:
                    if s <= 10 ** 6:
                        lst = NumFactor().get_prime_factor(s)
                    else:
                        dct = NumFactor().get_prime_with_pollard_rho(s)
                        lst = [(p, dct[p]) for p in sorted(dct)]
                    if len(lst) == 1 and lst[0][1] == 1:
                        ac.st("Prime? Yes!")
                    else:
                        ac.st("Prime? No!")
                        lst = [f"{p}^{c}" for p, c in lst]
                        ac.st(f"{s}=" + "*".join(lst))
            ac.st("")
        return

    @staticmethod
    def lg_p2441(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2441
        tag: implemention|data_range|observation|math
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        parent = [-1] * n
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            parent[y] = x
        for _ in range(k):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                x = lst[1] - 1
                num = nums[x]
                ans = -1
                while parent[x] != -1:
                    x = parent[x]
                    if math.gcd(nums[x], num) > 1:
                        ans = x + 1
                        break
                ac.st(ans)
            else:
                nums[lst[1] - 1] = lst[2]
        return

    @staticmethod
    def lg_p3601(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3601
        tag: euler_phi|math|number_theory
        """
        low, high = ac.read_list_ints()

        n = int(math.sqrt(high)) + 1
        primes = PrimeSieve().eratosthenes_sieve(n + 1)

        euler_phi = list(range(low, high + 1))
        rest = list(range(low, high + 1))

        for p in primes:
            for a in range(low // p, high // p + 2):
                if low <= a * p <= high:
                    num = a * p
                    euler_phi[num - low] *= (p - 1) / p
                    while rest[num - low] % p == 0:
                        rest[num - low] //= p
        for num in range(low, high + 1):
            if rest[num - low] > 1:
                euler_phi[num - low] *= (rest[num - low] - 1) / rest[num - low]

        mod = 666623333
        ans = (high - low + 1) * (low + high) // 2
        ans %= mod
        for num in euler_phi:
            ans -= int(num)
            ans %= mod
        ac.st(ans)
        del euler_phi
        return

    @staticmethod
    def lg_p4282(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4282
        tag: math|n_base|classical
        """
        n = ac.read_int()
        t = [0] + ac.read_list_ints()
        a = [0] + ac.read_list_ints()
        op = ac.read_str()
        b = [0] + ac.read_list_ints()
        ans = [0] * (n + 1)
        if op == "+":
            for i in range(n, 0, -1):
                ans[i] += a[i] + b[i]
                ans[i - 1] += ans[i] // t[i]
                ans[i] %= t[i]
        else:
            for i in range(n, 0, -1):
                ans[i] += a[i] - b[i]
                if ans[i] < 0:
                    ans[i - 1] -= 1
                    ans[i] += t[i]
        ac.lst(ans[1:])
        return

    @staticmethod
    def cf_1601c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1061/problem/C
        tag: get_all_factor|classical
        """
        ac.read_int()
        dp = [0] * (10 ** 6 + 1)
        dp[0] = 1
        mod = 10 ** 9 + 7
        nums = ac.read_list_ints()
        nm = NumFactor()
        for num in nums:
            factor = nm.get_all_factor(num)
            for f in factor[::-1]:
                dp[f] += dp[f - 1]
                dp[f] %= mod
        ans = sum(dp) - 1
        ac.st(ans % mod)
        return

    @staticmethod
    def lg_p6366(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6366
        tag: n_base|observation
        """
        s = ac.read_str()
        nums = []
        for w in s:
            val = int(w, 16)
            for j in range(3, -1, -1):
                if (val >> j) & 1:
                    nums.append(1)
                elif nums:
                    nums.append(0)
        if not nums:
            nums = [0]
        ans = math.inf
        cur = 0
        lst = nums[:]
        n = len(lst)
        if n == 1:
            ac.st(nums[0])
            return
        for i in range(1, n):
            if lst[i - 1]:
                cur += 1
                lst[i - 1] = 1 - lst[i - 1]
                lst[i] = 1 - lst[i]
                if i + 1 < n:
                    lst[i + 1] = 1 - lst[i + 1]
        if sum(lst) == 0:
            ans = cur

        cur = 1
        lst = nums[:]
        lst[0] = 1 - lst[0]
        lst[1] = 1 - lst[1]
        n = len(lst)
        for i in range(1, n):
            if lst[i - 1]:
                cur += 1
                lst[i - 1] = 1 - lst[i - 1]
                lst[i] = 1 - lst[i]
                if i + 1 < n:
                    lst[i + 1] = 1 - lst[i + 1]
        if sum(lst) == 0:
            ans = min(ans, cur)
        ac.st(ans if ans < math.inf else "No")
        return

    @staticmethod
    def lg_p6539(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6539
        tag: euler_series|classical|brute_force
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ceil = 2 * 10 ** 6
        cnt = [0] * (ceil + 1)
        for num in nums:
            cnt[num] += 1
        ans = 0
        for x in range(1, ceil + 1):
            cur = 0
            for y in range(x, ceil + 1, x):
                cur += cnt[y]
            if cur >= 2:
                ans = max(ans, cur * x)
        ac.st(ans)
        return

    @staticmethod
    def abc_361f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc361/tasks/abc361_f
        tag: inclusion_exclusion|math
        """
        n = ac.read_int()
        m = 65
        cnt = [0] * m

        def check(x):
            return x ** b <= n

        for b in range(2, m):
            ans = BinarySearch().find_int_right(1, n, check)
            if ans >= 2:
                cnt[b] = ans - 1
        for i in range(m - 1, 1, -1):
            for j in range(i * 2, m, i):
                cnt[i] -= cnt[j]
        ac.st(sum(cnt) + 1)
        return

    @staticmethod
    def abc_206e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc206/tasks/abc206_e
        tag: inclusion_exclusion|math|contribution_method|brute_force
        """
        ll, rr = ac.read_list_ints()
        cnt = [0] * (rr + 1)
        rest = 0
        for num in range(rr, 1, -1):
            low = ll + (num - ll % num) if ll % num else ll
            high = rr
            if low <= high:
                c = high // num - low // num + 1
                cnt[num] = c * (c - 1) // 2
                rest += c - 1 if low <= num <= high else 0
                for x in range(num + num, rr + 1, num):
                    cnt[num] -= cnt[x]
        ans = sum(cnt) * 2 - rest * 2
        ac.st(ans)
        return

    @staticmethod
    def cf_1542c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1542/C
        tag: math|inclusion_exclusion|brain_teaser|prefix_lcm
        """

        pre = [1] * 42
        for i in range(2, 42):
            pre[i] = math.lcm(pre[i - 1], i)
        assert pre[-1] >= 10 ** 16
        mod = 10 ** 9 + 7
        for _ in range(ac.read_int()):
            n = ac.read_int()
            ans = 0
            for x in range(1, 41):
                ans += (x + 1) * (n // pre[x] - n // pre[x + 1])
            ac.st(ans % mod)
        return

    @staticmethod
    def cf_1614d2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1614/D2
        tag: euler_series|number_theory|linear_dp|classical|factor_cnt
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ceil = 2 * 10 ** 7
        cnt = [0] * (ceil + 1)
        for num in nums:
            cnt[num] += 1
        factor = [0] * (ceil + 1)
        factor[1] = n
        for x in range(2, ceil + 1):
            for y in range(x, ceil + 1, x):
                factor[x] += cnt[y]

        dp = [0] * (ceil + 1)
        for x in range(ceil, 0, -1):
            dp[x] = x * factor[x]
            for y in range(x * 2, ceil + 1, x):
                dp[x] = max(dp[x], dp[y] + (factor[x] - factor[y]) * x)
        ac.st(dp[1])
        return

    @staticmethod
    def cf_2013e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/2013/problem/E
        tag: greedy|gcd_like|number_theory|observation
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            arr = sorted(list(set(nums)))
            g = reduce(math.gcd, arr)
            m = len(arr)
            use = [0] * m
            use[0] = 1
            pre = arr[0]
            ans = pre
            while True:
                cur = math.inf
                nex = -1
                for i in range(m):
                    if not use[i] and math.gcd(pre, arr[i]) < cur:
                        cur = math.gcd(pre, arr[i])
                        nex = i
                if nex == -1:
                    break
                use[nex] = 1
                pre = cur
                ans += pre
                if pre == g:
                    break
            ac.st(ans + (n - sum(use)) * g)
        return

    @staticmethod
    def cf_632d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/632/D
        tag: linear_dp|math|classical|euler_series
        """
        n, m = ac.read_list_ints()
        cnt = [0] * (m + 1)
        nums = ac.read_list_ints()
        for num in nums:
            if num <= m:
                cnt[num] += 1
        dp = [0] * (m + 1)
        for x in range(1, m + 1):
            if cnt[x]:
                for y in range(x, m + 1, x):
                    dp[y] += cnt[x]
        ceil = dp.index(max(dp))
        lst = []
        pre = 1
        for i, num in enumerate(nums):
            if num <= m and ceil % num == 0:
                lst.append(i + 1)
                pre = math.lcm(pre, num)
        ac.lst([pre, dp[ceil]])
        ac.lst(lst)
        return

    @staticmethod
    def cf_1750d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1750/D
        tag: number_theory|observation|data_range|limited_operation|inclusion_exclusion|gcd_like|num_factor|classical
        """
        mod = 998244353
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            nums = ac.read_list_ints()
            ans = 1
            for i in range(1, n):
                if nums[i - 1] % nums[i]:
                    ac.st(0)
                    break
                high = m // nums[i]
                low = 1
                if low > high:
                    ac.st(0)
                    break
                p = nums[i - 1] // nums[i]
                lst = NumFactor.get_all_factor(p)[1:]
                k = len(lst)
                cnt = [0] * k
                for j in range(k - 1, -1, -1):
                    cnt[j] = high // lst[j]
                    for r in range(j + 1, k):
                        if lst[r] % lst[j] == 0:
                            cnt[j] -= cnt[r]
                pre = high - low + 1 - sum(cnt)
                ans *= pre
                ans %= mod
            else:
                ac.st(ans)
        return

    @staticmethod
    def cf_687b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/687/B
        tag: math|mod|lcm|classical
        """
        n, k = ac.read_list_ints()
        nums = ac.read_list_ints()
        pre = 1
        for num in nums:
            pre = math.lcm(pre, num)
            pre %= k
        ac.st("Yes" if pre % k == 0 else "No")
        return

    @staticmethod
    def cf_1114c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1114/C
        tag: get_prime_factor|num_factor|inclusion_exclusion|n_base
        """
        n, b = ac.read_list_ints()
        factors = NumFactor().get_prime_factor(b)
        dct = {p: 0 for p, _ in factors}
        for p in dct:
            cur = p
            cnt = 1
            lst = []
            while cur <= n:
                dct[p] += (n // cur) * cnt
                lst.append(n // cur)
                cnt += 1
                cur *= p
            k = len(lst)
            if not lst:
                continue
            post = 0
            for i in range(k - 1, -1, -1):
                lst[i] -= post
                post += lst[i]
            dct[p] = sum(lst[i] * (i + 1) for i in range(k))
        ans = math.inf
        for p, x in factors:
            ans = min(ans, dct[p] // x)
        ac.st(ans)
        return

    @staticmethod
    def lc_100436(nums: List[int], queries: List[int]) -> List[int]:
        """
        url: https://leetcode.com/problems/sorted-gcd-pair-queries/
        tag: inclusion_exclusion|math|number_theory|classical
        """
        pf = PrimeFactor(5 * 10 ** 4 + 10)
        ceil = max(nums)
        cnt = [0] * (ceil + 1)
        for num in nums:
            for p in pf.all_factor[num]:
                cnt[p] += 1
        for i in range(ceil + 1):
            cnt[i] = cnt[i] * (cnt[i] - 1) // 2
        for i in range(ceil, 0, -1):
            for j in range(i + i, ceil + 1, i):
                cnt[i] -= cnt[j]
        pre = list(accumulate(cnt))
        ans = []
        for i in queries:
            ans.append(bisect.bisect_left(pre, i + 1))
        return ans

    @staticmethod
    def cf_2007c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/2007/C
        tag: peishu_theorem|gcd_like|greedy|brain_teaser|implemention|math
        """
        for _ in range(ac.read_int()):
            n, a, b = ac.read_list_ints()
            g = math.gcd(a, b)
            nums = ac.read_list_ints()
            nums = [x % g for x in nums]
            nums.sort()
            ans = nums[-1] - nums[0]
            for i in range(1, n):
                ans = min(ans, g + nums[i - 1] - nums[i])
            ac.st(ans)
        return
"""
Algorithm：divide_and_conquer|fft
Description：

=====================================LuoGu======================================
P4721（https://www.luogu.com.cn/problem/P4721）divide_and_conquer|fft
"""


def fft_v(x):
    import numpy as np
    x = np.asarray(x, dtype=float)
    n = x.shape[0]
    if np.log2(n) % 1 > 0:
        raise ValueError("must be a power of 2")

    n_min = min(n, 2)

    n = np.arange(n_min)
    k = n[:, None]
    m = np.exp(-2j * np.pi * n * k / n_min)
    xx = np.dot(m, x.reshape((n_min, -1)))
    while xx.shape[0] < n:
        x_even = xx[:, :int(xx.shape[1] / 2)]
        x_odd = xx[:, int(xx.shape[1] / 2):]
        terms = np.exp(-1j * np.pi * np.arange(xx.shape[0])
                       / xx.shape[0])[:, None]
        xx = np.vstack([x_even + terms * x_odd,
                        x_even - terms * x_odd])
    return xx.ravel()
"""
Algorithm：peishu_theorem
Description：ax+by=gcd(a,b)  a!=0 or b!=0

====================================LeetCode====================================
1250（https://leetcode.cn/problems/check-if-it-is-a-good-array/）gcd|peishu_theorem|classical

===================================CodeForces===================================
1478D（https://codeforces.com/contest/1478/problem/D）peishu_theorem|number_theory|math
510D（https://codeforces.com/problemset/problem/510/D）peishu_theorem|linear_dp|observation

=====================================LuoGu======================================
P4549（https://www.luogu.com.cn/problem/P4549）gcd|peishu_theorem
P8646（https://www.luogu.com.cn/problem/P8646）peishu_theorem|bag_dp

"""
import math
from collections import defaultdict

from typing import List

from src.mathmatics.peishu_theorem.template import PeiShuTheorem
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1250(nums: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/check-if-it-is-a-good-array/
        tag: gcd|peishu_theorem|classical
        """
        # 转化为peishu_theorem|数组最大公约数是否等于 1 求解
        return PeiShuTheorem().get_lst_gcd(nums) == 1

    @staticmethod
    def lg_p4549(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4549
        tag: gcd|peishu_theorem
        """
        # 转化为peishu_theorem|数组最大公约数求解
        ac.read_int()
        nums = ac.read_list_ints()
        ac.st(PeiShuTheorem().get_lst_gcd(nums))
        return

    @staticmethod
    def lg_p8646(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8646
        tag: peishu_theorem|bag_dp
        """
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        nums.sort()
        s = 10 ** 4
        dp = [0] * (s + 1)
        dp[0] = 1
        for i in range(1, s + 1):
            for num in nums:
                if num > i:
                    break
                if dp[i - num]:
                    dp[i] = 1
        ans = s + 1 - sum(dp)
        if PeiShuTheorem().get_lst_gcd(nums) != 1:
            ac.st("INF")
        else:
            ac.st(ans)
        return

    @staticmethod
    def cf_510d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/510/D
        tag: peishu_theorem|linear_dp|observation
        """
        n = ac.read_int()
        ll = ac.read_list_ints()
        cc = ac.read_list_ints()
        pre = defaultdict(lambda: math.inf)
        for i in range(n):
            cur = pre.copy()
            for p in pre:
                g = math.gcd(p, ll[i])
                cur[g] = min(cur[g], pre[p] + cc[i])
            cur[ll[i]] = min(cur[ll[i]], cc[i])
            pre = cur
        ac.st(pre[1] if pre[1] < math.inf else -1)
        return
"""
Algorithm：prime_factorization|min_prime|factorization
Description：

====================================LeetCode====================================
2183（https://leetcode.cn/problems/count-array-pairs-divisible-by-k/description/）brute_force|counter|group_by_mul|classical
2584（https://leetcode.cn/problems/split-the-array-to-make-coprime-products/）prime_factorization|counter
3164（https://leetcode.cn/problems/find-the-number-of-good-pairs-ii/）brute_force|euler_series

=====================================LuoGu======================================
P8319（https://www.luogu.com.cn/problem/P8319）prime_factorization|counter

===================================CodeForces===================================
1176D（https://codeforces.com/contest/1176/problem/D）construction|greedy|implemention
1884D（https://codeforces.com/contest/1884/problem/D）factor_dp|gcd_pair|counter|classical
1900D（https://codeforces.com/contest/1900/problem/D）inclusion_exclusion|gcd_pair|counter|classical
1034A（https://codeforces.com/contest/1034/problem/A）prime_factorization
1366D（https://codeforces.com/problemset/problem/1366/D）min_prime|construction
1978E（https://codeforces.com/contest/1978/problem/F）union_find|matrix|math|brain_teaser
1627D（https://codeforces.com/contest/1627/problem/D）euler_series|prime_factor|all_factor|implemention|brute_force
1499D（https://codeforces.com/contest/1499/problem/D）math|prime_factor_cnt|classical
1986G1（https://codeforces.com/contest/1986/problem/G1）all_factor|brute_force|contribution_method
546D（https://codeforces.com/problemset/problem/546/D）prime_factor_mi_cnt
1470B（https://codeforces.com/problemset/problem/1470/B）prime_factor|observation
1826C（https://codeforces.com/problemset/problem/1826/C）math|observation|brain_teaser|construction
1242A（https://codeforces.com/problemset/problem/1242/A）guess_table|brute_force
27E（https://codeforces.com/contest/27/problem/E）linear_dp|brute_force|euler_series|data_range

====================================AtCoder=====================================
ABC215D（https://atcoder.jp/contests/abc215/tasks/abc215_d）prime_factorization

=====================================AcWing=====================================
199（https://www.acwing.com/problem/content/199/）factorial|prime_factorization

1（https://www.codechef.com/problems/COUNTN）min_prime|prime_number

"""
import math
from collections import Counter
from collections import defaultdict
from functools import reduce
from itertools import permutations
from typing import List

from src.graph.union_find.template import UnionFind
from src.mathmatics.number_theory.template import PrimeSieve
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def ac_199(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/199/
        tag: factorial|prime_factorization
        """
        n = ac.read_int()
        pf = PrimeFactor(n)
        dct = defaultdict(int)
        for num in range(2, n + 1):
            for p, c in pf.prime_factor[num]:
                dct[p] += c
        for p in sorted(dct):
            ac.lst([p, dct[p]])
        return

    @staticmethod
    def lc_2584(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/split-the-array-to-make-coprime-products/
        tag: prime_factorization|counter
        """
        pf = PrimeFactor(10 ** 6)
        n = len(nums)
        dct = defaultdict(list)
        for i, num in enumerate(nums):
            for p, _ in pf.prime_factor[num]:
                dct[p].append(i)

        diff = [0] * (n + 1)
        for p in dct:
            i, j = dct[p][0], dct[p][-1]
            a, b = i, j - 1
            if a <= b:
                diff[a] += 1
                diff[b + 1] -= 1
        for i in range(1, n + 1):
            diff[i] += diff[i - 1]
        for i in range(n - 1):
            if not diff[i]:
                return i
        return -1

    @staticmethod
    def cf_1366d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1366/D
        tag: min_prime|construction
        """
        ac.read_int()
        nums = ac.read_list_ints()
        ceil = max(nums)
        pf = PrimeFactor(ceil)
        ans1 = []
        ans2 = []
        for num in nums:
            p = pf.min_prime[num]
            v = num
            while v % p == 0:
                v //= p
            if v == 1:
                ans1.append(-1)
                ans2.append(-1)
            else:
                ans1.append(v)
                ans2.append(num // v)
        ac.lst(ans1)
        ac.lst(ans2)
        return

    @staticmethod
    def cf_1034a(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1034/problem/A
        tag: prime_factorization|min_prime|classical|hard
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ceil = max(nums)
        pf = PrimeFactor(ceil)
        g = reduce(math.gcd, nums)
        cnt = [0] * (ceil + 1)
        for num in nums:
            b = num // g
            while b > 1:
                fac = pf.min_prime[b]  # classical_skills which can speed up a lot
                cnt[fac] += 1
                while b % fac == 0:
                    b //= fac
        res = max(cnt)
        if res == 0:
            ac.st(-1)
        else:
            ac.st(n - res)
        return

    @staticmethod
    def lg_p8319(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8319
        tag: prime_factorization|counter
        """
        q = ac.read_int()
        nums = [ac.read_int() for _ in range(q)]
        n = max(nums)
        f = [1] * (n + 1)
        pf = PrimeFactor(n)
        for x in range(2, n + 1):
            f[x] = f[x // pf.min_prime[x]] - 1 + pf.min_prime[x]

        for i in range(1, n + 1):
            f[i] = max(f[i - 1], f[i])
        for num in nums:
            ac.st(f[num])
        return

    @staticmethod
    def cf_1034a(ac=FastIO()):

        n = ac.read_int()
        nums = ac.read_list_ints()
        ceil = max(nums)

        # 快速 1~ceil 的质数因子数
        p = [0] * (ceil + 1)
        for i in range(2, ceil + 1):
            if p[i] == 0:
                p[i] = i
                # 从 i*i 开始作为 p[j] 的最小质数因子
                for j in range(i * i, ceil + 1, i):
                    p[j] = i

        # gcd
        g = reduce(math.gcd, nums)
        cnt = [0] * (ceil + 1)
        for i in range(n):
            b = nums[i] // g
            while b > 1:
                #  num[i] 除掉 g 以后的质数因子数
                fac = p[b]
                # counter| 1 也可以记录由多少个因子
                cnt[fac] += 1
                while b % fac == 0:
                    b //= fac
        res = max(cnt)
        if res == 0:
            ac.st(-1)
        else:
            ac.st(n - res)
        return

    @staticmethod
    def lc_6334(nums: List[int]) -> int:
        # 非空子集乘积不含除 1 之外任何平方整除数，即乘积质数因子的幂次均为 1（bag_dp|counter）
        dct = {2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30}
        # 集合为质数因子幂次均为 1
        mod = 10 ** 9 + 7
        cnt = Counter(nums)
        pre = defaultdict(int)
        for num in cnt:
            if num in dct:
                cur = pre.copy()
                for p in pre:
                    if math.gcd(p, num) == 1:
                        cur[p * num] += pre[p] * cnt[num]
                        cur[p * num] %= mod
                cur[num] += cnt[num]
                pre = cur.copy()
        # 1 需要特殊处理
        p = pow(2, cnt[1], mod)
        ans = sum(pre.values()) * p
        ans += p - 1
        return ans % mod

    @staticmethod
    def cf_1366d(ac=FastIO()):
        ac.read_int()
        nums = ac.read_list_ints()
        ceil = max(nums)

        # 利用linear_sieve的思想最小的质因数
        min_div = [i for i in range(ceil + 1)]
        for i in range(2, len(min_div)):
            if min_div[i] != i:
                continue
            if i * i >= len(min_div):
                break
            for j in range(i, len(min_div)):
                if i * j >= len(min_div):
                    break
                if min_div[i * j] == i * j:
                    min_div[i * j] = i

        # construction结果
        ans1 = []
        ans2 = []
        for num in nums:
            p = min_div[num]
            v = num
            while v % p == 0:
                v //= p
            if v == 1:
                # 只有一个质因子
                ans1.append(-1)
                ans2.append(-1)
            else:
                ans1.append(v)
                ans2.append(num // v)
        ac.lst(ans1)
        ac.lst(ans2)
        return

    @staticmethod
    def lc_2183(nums: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/count-array-pairs-divisible-by-k/description/
        tag: brute_force|counter|group_by_mul|classical
        """
        # 可以所有因子遍历brute_forcecounter解决，正解为按照 k 的最大公因数分组
        nt = PrimeFactor(10 ** 5)
        ans = 0
        dct = defaultdict(int)
        for i, num in enumerate(nums):
            w = k // math.gcd(num, k)
            ans += dct[w]
            for w in nt.all_factor[num]:
                dct[w] += 1
        return ans

    @staticmethod
    def lc_2464(nums: List[int]) -> int:
        #  1 到 n 的数所有的质因子并动态规划counter
        nt = PrimeFactor(max(nums))
        ind = dict()
        n = len(nums)
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        for i, num in enumerate(nums):
            while num > 1:
                p = nt.min_prime[num]
                while num % p == 0:
                    num //= p
                if p not in ind or dp[i] < dp[ind[p]]:
                    ind[p] = i
                if dp[ind[p]] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[ind[p]] + 1
                if dp[i] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[i] + 1
        return dp[-1] if dp[-1] < math.inf else -1

    @staticmethod
    def lc_8041(nums: List[int]) -> int:
        # preprocess幂次为奇数的质因子hash分组counter
        n = len(nums)
        nt = PrimeFactor(n)
        dct = defaultdict(int)
        for i in range(1, n + 1):
            cur = nt.prime_factor[i]
            cur = [p for p, c in cur if c % 2]
            dct[tuple(cur)] += nums[i - 1]
        return max(dct.values())

    @staticmethod
    def lc_lcp14(nums: List[int]) -> int:
        #  1 到 n 的数所有的质因子并动态规划counter
        nt = PrimeFactor(max(nums))
        ind = dict()
        n = len(nums)
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        for i, num in enumerate(nums):
            while num > 1:
                p = nt.min_prime[num]
                while num % p == 0:
                    num //= p
                if p not in ind or dp[i] < dp[ind[p]]:
                    ind[p] = i
                if dp[ind[p]] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[ind[p]] + 1
                if dp[i] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[i] + 1
        return dp[-1] if dp[-1] < math.inf else -1

    @staticmethod
    def cf_1176d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1176/problem/D
        tag: construction|greedy|implemention
        """
        primes = PrimeSieve().eratosthenes_sieve(2750131)
        ind = {num: i + 1 for i, num in enumerate(primes)}
        m = 2 * 10 ** 5
        max_factor = [0] * (m + 1)
        for i in range(2, m + 1):
            for j in range(2 * i, m + 1, i):
                max_factor[j] = i
        cnt = [0] * (m + 1)
        ac.read_int()
        nums = ac.read_list_ints()
        nums.sort(reverse=True)
        for num in nums:
            if num <= m:
                cnt[num] += 1
        ans = []
        for num in nums:
            if num <= m and not cnt[num]:
                continue
            if num in ind:
                if num <= m:
                    cnt[num] -= 1
                ans.append(ind[num])
                cnt[ind[num]] -= 1
            else:
                ans.append(num)
                if num <= m:
                    cnt[num] -= 1
                cnt[max_factor[num]] -= 1
        ac.lst(ans)
        return

    @staticmethod
    def cf_1349a(ac=FastIO()):
        # prime_factorization|，brute_force最终结果当中质因子的幂次
        n = ac.read_int()
        nums = ac.read_list_ints()
        nmp = PrimeFactor(max(nums))
        dct = defaultdict(list)

        for num in nums:
            for p, c in nmp.prime_factor[num]:
                dct[p].append(c)

        ans = 1
        for p in dct:
            if len(dct[p]) >= n - 1:
                dct[p].sort()
                ans *= p ** dct[p][-n + 1]
        ac.st(ans)
        return

    @staticmethod
    def cf_1458a(ac=FastIO()):
        # gcdmath|求解gcd(x,y)=gcd(x-y,y)
        m, n = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        g = 0
        # 推广到n维
        for i in range(1, m):
            g = math.gcd(g, a[i] - a[i - 1])
        ans = [math.gcd(g, a[0] + num) for num in b]
        ac.lst(ans)
        return

    @staticmethod
    def abc_114d(ac=FastIO()):
        # prime_factorization|counter
        n = ac.read_int()
        nt = PrimeFactor(n + 10)
        cnt = Counter()
        for x in range(1, n + 1):
            for p, c in nt.prime_factor[x]:
                cnt[p] += c
        ans = set()
        for item in permutations(list(cnt.keys()), 3):
            x, y, z = item
            if cnt[x] >= 2 and cnt[y] >= 4 and cnt[z] >= 4:
                if y > z:
                    y, z = z, y
                ans.add((x, y, z))

        for item in permutations(list(cnt.keys()), 2):
            x, y = item
            if cnt[x] >= 2 and cnt[y] >= 24:
                ans.add((x, y, 325))
            if cnt[x] >= 4 and cnt[y] >= 14:
                ans.add((x, y, 515))
        for x in cnt:
            if cnt[x] >= 74:
                ans.add(x)
        ac.st(len(ans))
        return

    @staticmethod
    def ac_124(ac=FastIO()):
        # 不同进制之间的转换
        st = "0123456789"
        for i in range(26):
            st += chr(i + ord("A"))
        for i in range(26):
            st += chr(i + ord("a"))
        ind = {w: i for i, w in enumerate(st)}
        for _ in range(ac.read_int()):
            a, b, word = ac.read_list_strs()
            a = int(a)
            b = int(b)
            num = 0
            for w in word:
                num *= a
                num += ind[w]
            ac.lst([a, word])
            ans = ""
            while num:
                ans += st[num % b]
                num //= b
            if not ans:
                ans = "0"
            ac.lst([b, ans[::-1]])
            ac.st("")
        return

    @staticmethod
    def ac_197(ac=FastIO()):
        # n!阶乘的prime_factorization|即因子与因子的个数
        ceil = ac.read_int()
        min_prime = [0] * (ceil + 1)
        #  1 到 ceil 所有数字的最小质数因子
        for i in range(2, ceil + 1):
            if not min_prime[i]:
                min_prime[i] = i
                for j in range(i * i, ceil + 1, i):
                    min_prime[j] = i

        #  1 到 ceil 所有数字的prime_factorization|结果
        dct = defaultdict(int)
        for num in range(2, ceil + 1):
            while num > 1:
                p = min_prime[num]
                cnt = 0
                while num % p == 0:
                    num //= p
                    cnt += 1
                dct[p] += cnt
        for p in sorted(dct):
            ac.lst([p, dct[p]])
        return

    @staticmethod
    def ac_199(ac=FastIO()):
        #  sum(k%i for i in range(n))
        n, k = ac.read_list_ints()
        ans = n * k
        left = 1
        while left <= min(n, k):
            right = min(k // (k // left), n)
            ans -= (k // left) * (left + right) * (right - left + 1) // 2
            left = right + 1
        ac.st(ans)
        return

    @staticmethod
    def lc_p2429(ac=FastIO()):
        # brute_force质因数组合|inclusion_exclusioncounter
        n, m = ac.read_list_ints()
        primes = sorted(ac.read_list_ints())

        def dfs(i):
            nonlocal ans, value, cnt
            if value > m:
                return
            if i == n:
                if cnt:
                    num = m // value
                    ans += value * (num * (num + 1) // 2) * (-1) ** (cnt + 1)
                    ans %= mod
                return

            value *= primes[i]
            cnt += 1
            dfs(i + 1)
            cnt -= 1
            value //= primes[i]
            dfs(i + 1)
            return

        cnt = ans = 0
        value = 1
        mod = 376544743
        dfs(0)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2527(ac=FastIO()):
        # 丑数即只含特定质因子的数
        n, k = ac.read_list_ints()
        primes = ac.read_list_ints()
        dp = [1] * (k + 1)
        pointer = [0] * n
        for i in range(k):
            num = min(dp[pointer[i]] * primes[i] for i in range(n))
            for x in range(n):
                if dp[pointer[x]] * primes[x] == num:
                    pointer[x] += 1
            dp[i + 1] = num
        ac.st(dp[-1])
        return

    @staticmethod
    def lg_p5248(ac=FastIO()):
        # 进制题目
        m, fm = ac.read_list_ints()
        lst = []
        while fm:
            lst.append(fm % m)
            fm //= m
        ac.st(len(lst))
        ac.lst(lst)
        return

    @staticmethod
    def lg_p7960(ac=FastIO()):
        # 类似prime_sieve的思路preprocess
        n = 10 ** 7
        dp = [0] * (n + 1)
        for x in range(1, n + 1):
            if "7" in str(x):
                y = 1
                while x * y <= n:
                    dp[x * y] = 1
                    y += 1
        post = 10 ** 7 + 1
        for i in range(n, -1, -1):
            if dp[i] == 1:
                dp[i] = -1
            else:
                dp[i] = post
                post = i

        for _ in range(ac.read_int()):
            ac.st(dp[ac.read_int()])
        return

    @staticmethod
    def lg_p8319(ac=FastIO()):
        # prime_factorization|greedy
        n = 2 * 10 ** 6
        f = [1] * (n + 1)
        prime = [0] * (n + 1)
        for x in range(2, n + 1):
            if not prime[x]:
                # 当前值作为质因子的花费次数
                t = 1
                while t * x <= n:
                    c = 1
                    xx = t
                    while xx % x == 0:
                        xx //= x
                        c += 1
                    f[t * x] += (x - 1) * c
                    prime[t * x] = 1
                    t += 1

        # 前缀最大值处理
        for i in range(1, n + 1):
            f[i] = max(f[i - 1], f[i])
        for _ in range(ac.read_int()):
            ac.st(f[ac.read_int()])
        return

    @staticmethod
    def lg_p8646(ac=FastIO()):
        # peishu_theorem|与背包 DP
        n = ac.read_int()
        nums = [ac.read_int() for _ in range(n)]
        s = 10000
        dp = [0] * (s + 1)
        dp[0] = 1
        for num in nums:
            for i in range(num, s + 1):
                if dp[i - num]:
                    dp[i] = 1
        ans = s + 1 - sum(dp)
        if reduce(math.gcd, nums) != 1:
            ac.st("INF")
        else:
            ac.st(ans)
        return

    @staticmethod
    def cf_1900d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1900/problem/D
        tag: inclusion_exclusion|gcd_pair|counter|classical
        """
        ceil = 10 ** 5 + 1
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            nums.sort()
            cnt = [0] * ceil
            last = [-1] * ceil
            for i, num in enumerate(nums):
                cnt[num] += 1
                last[num] = i

            gcd = [0] * ceil
            for g in range(1, ceil):
                small = 0
                for mid in range(g, ceil, g):
                    if not cnt[mid]:
                        continue
                    cur = cnt[mid]
                    cur2 = cur * (cur - 1) // 2
                    cur3 = cur * (cur - 1) * (cur - 2) // 6
                    bigger = n - last[mid] - 1
                    gcd[g] += small * bigger * cur + small * cur2 + bigger * cur2 + cur3
                    small += cur

            for g in range(ceil - 1, 0, -1):
                for gg in range(2 * g, ceil, g):
                    gcd[g] -= gcd[gg]
            ac.st(sum(gcd[i] * i for i in range(ceil)))
        return

    @staticmethod
    def lc_1390(nums: List[int]) -> int:
        # preprocess所有数的所有因子
        nt = PrimeFactor(10 ** 5)
        ans = 0
        for num in nums:
            if len(nt.all_factor[num]) == 4:
                ans += sum(nt.all_factor[num])
        return ans

    @staticmethod
    def lc_1819(nums: List[int]) -> int:
        # preprocess所有整数的所有因子，再brute_forcegcd
        nt = PrimeFactor(2 * 10 ** 5 + 10)
        dct = defaultdict(list)
        for num in set(nums):
            for x in nt.all_factor[num]:
                dct[x].append(num)
        ans = 0
        for num in dct:
            if reduce(math.gcd, dct[num]) == num:
                ans += 1
        return ans

    @staticmethod
    def cf_1884d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1884/problem/D
        tag: factor_dp|gcd_pair|counter|classical
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            cnt = [0] * (n + 1)
            dp = [0] * (n + 1)
            for num in nums:
                cnt[num] += 1
            for num in range(n, 0, -1):
                tot = post = 0
                y = 1
                while num * y <= n:
                    post += dp[num * y]
                    tot += cnt[num * y]
                    y += 1
                dp[num] = tot * (tot - 1) // 2 - post
            for num in range(1, n + 1):
                if cnt[num]:
                    for x in range(num, n + 1, num):
                        dp[x] = 0
            ac.st(sum(dp))
        return

    @staticmethod
    def ac_3727(ac=FastIO()):
        # brain_teaser转换成进制表达问题

        for _ in range(ac.read_int()):
            def check():
                n, k = ac.read_list_ints()
                cnt = Counter()
                for num in ac.read_list_ints():
                    lst = []
                    while num:
                        lst.append(num % k)
                        num //= k
                    for i, va in enumerate(lst):
                        cnt[i] += va
                        if cnt[i] > 1:
                            ac.no()
                            return
                ac.yes()
                return

            check()

        return

    @staticmethod
    def ac_4319(ac=FastIO()):
        # prime_factorization|后prefix_hashcounter
        n, k = ac.read_list_ints()
        a = ac.read_list_ints()
        nt = PrimeFactor(max(a))
        pre = defaultdict(int)
        ans = 0
        for num in a:
            cur = []
            lst = []
            for p, c in nt.prime_factor[num]:
                c %= k
                if c:
                    cur.append((p, c))
                    lst.append((p, k - c))
            ans += pre[tuple(lst)]
            pre[tuple(cur)] += 1
        ac.st(ans)
        return

    @staticmethod
    def ac_4484(ac=FastIO()):
        # 分数在某个进制下是否为有限小数问题
        for _ in range(ac.read_int()):

            def check():
                nonlocal q
                while q > 1:
                    gg = math.gcd(q, b)
                    if gg == 1:
                        break
                    q //= gg

                return q == 1

            p, q, b = ac.read_list_ints()
            g = math.gcd(p, q)
            p //= g
            q //= g

            ac.st("YES" if check() else "NO")
        return

    @staticmethod
    def ac_5049(ac=FastIO()):
        # prime_factorization|组合数
        n, m, h = ac.read_list_ints()
        a = ac.read_list_ints()
        h -= 1
        s = sum(a)
        if s < n:
            ac.st(-1)
            return
        if s - a[h] < n - 1:
            ac.st(1)
            return
        nt = PrimeFactor(s)
        total = nt.comb(s - 1, n - 1)
        part = nt.comb(s - a[h], n - 1)
        ac.st(1 - part / total)
        return

    @staticmethod
    def cf_1978e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1978/problem/F
        tag: union_find|matrix|math|brain_teaser
        """
        pf = PrimeFactor(10 ** 6)

        for _ in range(ac.read_int()):
            n, k = ac.read_list_ints()
            nums = ac.read_list_ints()
            dct = dict()
            uf = UnionFind(2 * n - 1)
            for i in range(1, 2 * n):
                num = nums[i % n]
                for p, _ in pf.prime_factor[num]:
                    if p in dct and i - dct[p] <= k and p > 1:
                        uf.union(dct[p] - 1, i - 1)
                    dct[p] = i
            ans = uf.part
            for i in range(n):
                if nums[i] == 1:
                    ans += n - 2 if i else n - 1
            ac.st(ans)
        return

    @staticmethod
    def cf_1627d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1627/problem/D
        tag: euler_series|prime_factor|all_factor|implemention|brute_force
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ceil = max(nums)
        cnt = [0] * (ceil + 1)
        for num in nums:
            cnt[num] = 1
        ans = 0
        for i in range(ceil, 0, -1):
            if cnt[i]:
                continue
            g = 0
            for j in range(i * 2, ceil + 1, i):
                if cnt[j]:
                    if g == 0:
                        g = j
                    elif math.gcd(g, j) == i:
                        cnt[i] = 1
                        ans += 1
                        break
        ac.st(ans)
        return

    @staticmethod
    def cf_1499d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1499/problem/D
        tag: math|prime_factor_cnt|classical
        """
        n = 2 * 10 ** 7
        min_prime = [0] * (n + 1)
        min_prime[1] = 1
        prime_factor_cnt = [0] * (n + 1)
        for i in range(2, n + 1):
            if not min_prime[i]:
                min_prime[i] = i
                for j in range(i * i, n + 1, i):
                    if not min_prime[j]:
                        min_prime[j] = i
            pre = i // min_prime[i]
            prime_factor_cnt[i] = prime_factor_cnt[pre] + int(min_prime[i] != min_prime[pre])

        def check(g):
            if (x // g + d) % c:
                return 0
            return p[prime_factor_cnt[(x // g + d) // c]]

        p = [1<< x for x in range(32)]
        res = []
        for _ in range(ac.read_int()):
            c, d, x = ac.read_list_ints()
            ans = 0
            for w in range(1, x + 1):
                if w * w > x:
                    break
                if x % w == 0:
                    ans += check(w)
                    if x // w > w:
                        ans += check(x // w)
            res.append(ans)
        for a in res:
            ac.st(a)
        return

    @staticmethod
    def cf_1986g1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1986/problem/G1
        tag: all_factor|brute_force|contribution_method
        """
        n = 10 ** 5
        pf = PrimeFactor(n)
        res = []
        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            need = defaultdict(lambda: defaultdict(int))
            ans = 0
            for i, num in enumerate(nums):
                i += 1
                g = math.gcd(num, i)
                for w in pf.all_factor[num // g]:
                    for k in need[w]:
                        if k % (i // g) == 0:
                            ans += need[w][k]
                need[i // g][num // g] += 1
            res.append(ans)
        for a in res:
            ac.st(a)
        return

    @staticmethod
    def cf_546d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/546/D
        tag: prime_factor_mi_cnt
        """
        n = 5 * 10 ** 6
        prime_factor_mi_cnt = [0] * (n + 1)
        for i in range(2, n + 1):
            if not prime_factor_mi_cnt[i]:
                prime_factor_mi_cnt[i] = 1
                for j in range(i * i, n + 1, i):
                    if not prime_factor_mi_cnt[j]:
                        prime_factor_mi_cnt[j] = i
            else:
                cur = i
                p = prime_factor_mi_cnt[cur]
                cnt = 0
                while cur % p == 0:
                    cnt += 1
                    cur //= p
                prime_factor_mi_cnt[i] = prime_factor_mi_cnt[cur] + cnt

        for num in range(1, n + 1):
            prime_factor_mi_cnt[num] += prime_factor_mi_cnt[num - 1]

        for _ in range(ac.read_int()):
            a, b = ac.read_list_ints()
            cnt = prime_factor_mi_cnt[a] - prime_factor_mi_cnt[b]
            ac.st(cnt)
        return

    @staticmethod
    def cf_1470b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1470/B
        tag: prime_factor|observation
        """
        n = 10 ** 6
        lst = [[] for _ in range(n+1)]

        min_prime = [0]*(n+1)
        for i in range(2, n + 1):
            if not min_prime[i]:
                min_prime[i] = i
                for j in range(i * i, n + 1, i):
                    if not min_prime[j]:
                        min_prime[j] = i

        for num in range(1, n + 1):
            i = num
            cur = 1
            while num > 1:
                p = min_prime[num]
                cnt = 0
                while num % p == 0:
                    num //= p
                    cnt += 1
                if cnt % 2:
                    cur *= p
            lst[i] = cur

        for _ in range(ac.read_int()):
            ac.read_int()
            nums = ac.read_list_ints()
            dct = Counter()
            for num in nums:
                dct[lst[num]] += 1
            ans2 = ans1 = 0
            for w in dct:
                ans1 = max(ans1, dct[w])
                if dct[w] % 2 == 0 or w == 1:
                    ans2 += dct[w]
            ans2 = max(ans2, ans1)
            for _ in range(ac.read_int()):
                w = ac.read_int()
                ac.st(ans2 if w else ans1)
        return

    @staticmethod
    def cf_1826c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1826/C
        tag: math|observation|brain_teaser|construction
        """
        pf = PrimeFactor(10 ** 6)
        for _ in range(ac.read_int()):
            n, m = ac.read_list_ints()
            ac.st("YES" if not 1 < pf.min_prime[n] <= m else "NO")
        return

    @staticmethod
    def cf_1242a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1242/A
        tag: guess_table|brute_force
        """
        n = ac.read_int()
        prime = []
        for x in range(2, n + 1):
            if x * x > n:
                break
            cnt = 0
            while n % x == 0:
                cnt += 1
                n //= x
            if cnt:
                prime.append(x)
        if n > 1:
            prime.append(n)
        if len(prime) == 1:
            ac.st(prime[0])
        else:
            ac.st(1)
        return

    @staticmethod
    def cf_27e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/27/problem/E
        tag: linear_dp|brute_force|euler_series|data_range
        """
        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]
        n = ac.read_int()
        ceil = 10 ** 18
        dp = [ceil] * (n + 1)
        dp[1] = 1
        for p in primes:
            for i in range(n // 2, 0, -1):
                x = p
                c = 2
                while i * c <= n and dp[i] * x <= ceil:
                    dp[i * c] = min(dp[i * c], dp[i] * x)
                    c += 1
                    x *= p
        ac.st(dp[n])
        return
"""
Algorithm：random_like
Description：

====================================LeetCode====================================

====================================CodeForces====================================
1914G2（https://codeforces.com/contest/1914/problem/G2）random_like|brain_teaser|range_cover

====================================AtCoder====================================
ABC272G（https://atcoder.jp/contests/abc272/tasks/abc272_g）random_guess|brute_force|num_factor|classical
ABC238G（https://atcoder.jp/contests/abc238/tasks/abc238_g）random_hash|prime_hash|classical|sqrt_decomposition|offline_query|classical

=====================================LuoGu======================================



"""
import random
from collections import Counter

from src.data_structure.segment_tree.template import RangeSetRangeSumMinMax
from src.mathmatics.number_theory.template import NumFactor
from src.mathmatics.prime_factor.template import PrimeFactor
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1914g2(ac=FastIO()):
        mod = 998244353
        for _ in range(ac.read_int()):

            n = ac.read_int()
            nums = ac.read_list_ints()
            rd = [random.randint(0, 10 ** 18) for _ in range(n)]
            nums = [nums[i] ^ rd[nums[i] - 1] for i in range(n * 2)]
            tree = RangeSetRangeSumMinMax(2 * n)
            start = -1
            dct = dict()
            pre = 0
            dct[pre] = -1
            ans = 1
            tot = 0
            for i, num in enumerate(nums):
                pre ^= num
                if pre in dct:
                    if dct[pre] == start:
                        cur = i - start - tree.range_sum(start + 1, i)
                        ans *= cur
                        ans %= mod
                        dct = dict()
                        pre = 0
                        dct[pre] = i
                        tot += 1
                        start = i
                    else:
                        tree.range_set(dct[pre] + 1, i, 1)
                else:
                    dct[pre] = i

            ac.lst([tot, ans])
        return

    @staticmethod
    def abc_272g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc272/tasks/abc272_g
        tag: random_guess|brute_force|num_factor|classical
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        ceil = 10 ** 9
        nf = NumFactor()
        for _ in range(30):
            i, j = random.randint(0, n - 1), random.randint(0, n - 1)
            while i == j:
                j = random.randint(0, n - 1)
            lst = nf.get_all_factor(abs(nums[i] - nums[j]))
            for m in lst:
                if 3 <= m <= ceil:
                    cur = [num % m for num in nums]
                    if max(Counter(cur).values()) * 2 > n:
                        ac.st(m)
                        return
        ac.st(-1)
        return

    @staticmethod
    def abc_238g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc238/tasks/abc238_g
        tag: random_hash|prime_hash|classical|sqrt_decomposition|offline_query|classical
        """
        ceil = 10 ** 6
        pf = PrimeFactor(ceil)
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        prime_hash = [(0, 0, 0) for _ in range(ceil + 1)]
        for i in range(ceil + 1):
            if pf.is_prime[i]:
                h1 = random.getrandbits(64)
                h2 = random.getrandbits(64)
                h3 = h1 ^ h2
                prime_hash[i] = (h1, h2, h3)

        pre_xor = [0] * (n + 1)
        prime_cnt = [0] * (ceil + 1)
        for i, num in enumerate(nums):
            cur = 0
            while num > 1:
                p = pf.min_prime[num]
                cnt = 0
                while num % p == 0:
                    num //= p
                    cnt += 1
                for _ in range(cnt % 3):
                    cur ^= prime_hash[p][prime_cnt[p] % 3]
                    prime_cnt[p] += 1
            pre_xor[i + 1] = pre_xor[i] ^ cur
        for _ in range(q):
            ll, rr = ac.read_list_ints_minus_one()
            if pre_xor[ll] == pre_xor[rr + 1]:
                ac.yes()
            else:
                ac.no()
        return"""
Algorithm：scan_line
Description：plane|cube

====================================LeetCode====================================
218（https://leetcode.cn/problems/the-skyline-problem/）scan_line
850（https://leetcode.cn/problems/rectangle-area-ii/）scan_line|segment_tree|discretization|O(nlogn)

=====================================LuoGu======================================
P6265（https://www.luogu.com.cn/problem/P6265）scan_line
P5490（https://www.luogu.com.cn/problem/P5490）scan_line
P1884（https://www.luogu.com.cn/problem/P1884）scan_line
P1904（https://www.luogu.com.cn/problem/P1904）scan_line

"""
from src.mathmatics.scan_line.template import ScanLine
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p1884(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1884
        tag: scan_line
        """
        # 矩形覆盖面积
        n = ac.read_int()
        lst = []
        for _ in range(n):
            lst.append(ac.read_list_ints())
        low_x = min(min(ls[0], ls[2]) for ls in lst)
        low_y = min(min(ls[1], ls[3]) for ls in lst)
        # 注意挪到坐标原点
        lst = [[ls[0] - low_x, ls[1] - low_y, ls[2] - low_x, ls[3] - low_y] for ls in lst]
        lst = [[ls[0], ls[3], ls[2], ls[1]] for ls in lst]
        ans = ScanLine().get_rec_area(lst)
        ac.st(ans)
        return
"""
Algorithm：bfs|deque_bfs|discretization_bfs|bound_bfs|coloring_method|odd_circle
Description：multi_source_bfs|bilateral_bfs|0-1bfs|bilateral_bfs|a-star|heuristic_search

====================================LeetCode====================================
1036（https://leetcode.cn/problems/escape-a-large-maze/）bound_bfs|discretization_bfs
2493（https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/）union_find|bfs|brute_force|specific_plan|coloring_method|bipartite_graph
2290（https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/）0-1bfs|deque_bfs
1368（https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/）0-1bfs|deque_bfs
2258（https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/）binary_search|bfs|implemention
2092（https://leetcode.cn/problems/find-all-people-with-secret/）bfs
2608（https://leetcode.cn/contest/biweekly-contest-101/problems/shortest-cycle-in-a-graph/）bfs|undirected_smallest_circle|brute_force|shortest_path
1197（https://leetcode.cn/problems/minimum-knight-moves/?envType=study-plan-v2&id=premium-algo-100）bilateral_bfs
1654（https://leetcode.cn/problems/minimum-jumps-to-reach-home/）bfs|implemention
1926（https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/）deque_bfs|in_place_hash
909（https://leetcode.cn/problems/snakes-and-ladders/）01-bfs|implemention
1210（https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations/description/）01-bfs|implemention
1298（https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/）bfs
928（https://leetcode.cn/problems/minimize-malware-spread-ii/description/）brute_force|bfs
994（https://leetcode.cn/problems/rotting-oranges/description/）deque_bfs|implemention

=====================================LuoGu======================================
P1144（https://www.luogu.com.cn/problem/P1144）number_of_shortest_path
P1747（https://www.luogu.com.cn/problem/P1747）bilateral_bfs|shortest_path
P5507（https://www.luogu.com.cn/problem/P5507）bilateral_bfs|shortest_path
P2040（https://www.luogu.com.cn/problem/P2040）bfs
P2335（https://www.luogu.com.cn/problem/P2335）bfs
P2385（https://www.luogu.com.cn/problem/P2385）bfs|shortest_path|shortest_path
P2630（https://www.luogu.com.cn/problem/P2630）bfs|implemention|lexicographical_order
P1332（https://www.luogu.com.cn/problem/P1332）bfs
P1330（https://www.luogu.com.cn/problem/P1330）bfs|level_wise|coloring_method|union_find|odd_circle
P1215（https://www.luogu.com.cn/problem/P1215）bfs|implemention|hash
P1037（https://www.luogu.com.cn/problem/P1037）bfs|implemention|brute_force
P2853（https://www.luogu.com.cn/problem/P2853）bfs|counter
P2881（https://www.luogu.com.cn/problem/P2881）bfs|complexity
P2895（https://www.luogu.com.cn/problem/P2895）bfs|implemention
P2960（https://www.luogu.com.cn/problem/P2960）bfs
P2298（https://www.luogu.com.cn/problem/P2298）bfs
P3139（https://www.luogu.com.cn/problem/P3139）bfs|memory_search
P3183（https://www.luogu.com.cn/problem/P3183）bfs|counter|number_of_path|dfs|dp
P4017（https://www.luogu.com.cn/problem/P4017）bfs|counter|number_of_path|dfs|dp
P3395（https://www.luogu.com.cn/problem/P3395）bfs|implemention
P3416（https://www.luogu.com.cn/problem/P3416）bfs|memory_search
P3916（https://www.luogu.com.cn/problem/P3916）reverse_thinking|reverse_graph|reverse_order
P3958（https://www.luogu.com.cn/problem/P3958）build_graph|bfs
P4328（https://www.luogu.com.cn/problem/P4328）bfs|implemention
P4961（https://www.luogu.com.cn/problem/P4961）brute_force|implemention|counter
P6207（https://www.luogu.com.cn/problem/P6207）bfs|shortest_path|specific_plan
P6582（https://www.luogu.com.cn/problem/P6582）bfs|comb|counter|fast_power
P7243（https://www.luogu.com.cn/problem/P7243）bfs|gcd
P3496（https://www.luogu.com.cn/problem/P3496）brain_teaser|bfs|coloring_method|level_wise
P1432（https://www.luogu.com.cn/problem/P1432）memory_search|bfs
P1379（https://www.luogu.com.cn/problem/P1379）bilateral_bfs
P5507（https://www.luogu.com.cn/problem/P5507）bilateral_bfs|a-star|heuristic_search
P5908（https://www.luogu.com.cn/problem/P5908）bfs
P1038（https://www.luogu.com.cn/problem/P1038）topological_sorting
P1126（https://www.luogu.com.cn/problem/P1126）bfs
P1213（https://www.luogu.com.cn/problem/P1213）state_compression|01-bfs
P1902（https://www.luogu.com.cn/problem/P1902）binary_search|bfs|in_place_hash
P2199（https://www.luogu.com.cn/problem/P2199）deque_bfs|01-bfs
P2226（https://www.luogu.com.cn/problem/P2226）bfs
P2296（https://www.luogu.com.cn/problem/P2296）reverse_graph|bfs
P2919（https://www.luogu.com.cn/problem/P2919）bfs
P2937（https://www.luogu.com.cn/problem/P2937）01-bfs|monotonic_queue
P3456（https://www.luogu.com.cn/problem/P3456）bfs
P3496（https://www.luogu.com.cn/problem/P3496）brain_teaser|bfs
P3818（https://www.luogu.com.cn/problem/P3818）01-bfs|deque_bfs
P3855（https://www.luogu.com.cn/problem/P3855）bfs|md_state
P3869（https://www.luogu.com.cn/problem/P3869）bfs|state_compression
P4554（https://www.luogu.com.cn/problem/P4554）classical|01-bfs|implemention
P4667（https://www.luogu.com.cn/problem/P4667）01-bfs|implemention
P5096（https://www.luogu.com.cn/problem/P5096）state_compression|bfs|implemention
P5099（https://www.luogu.com.cn/problem/P5099）01-bfs|implemention
P5195（https://www.luogu.com.cn/problem/P5195）bfs
P6131（https://www.luogu.com.cn/problem/P6131）bfs|union_find
P6909（https://www.luogu.com.cn/problem/P6909）preprocess|bfs
P8628（https://www.luogu.com.cn/problem/P8628）01-bfs
P8673（https://www.luogu.com.cn/problem/P8673）01-bfs|implemention
P8674（https://www.luogu.com.cn/problem/P8674）preprocess|build_graph|bfs|implemention
P9065（https://www.luogu.com.cn/problem/P9065）brain_teaser|bfs|brute_force
P1099（https://www.luogu.com.cn/problem/P1099）tree_diameter|two_pointers|brute_force|monotonic_queue
P1363（https://www.luogu.com.cn/problem/P1363）classical|brain_teaser|observation|bfs
P2130（https://www.luogu.com.cn/problem/P2130）bfs|data_range
P6909（https://www.luogu.com.cn/problem/P6909）01-bfs|preprocess|classical

===================================CodeForces===================================
1594D（https://codeforces.com/contest/1594/problem/D）build_graph|coloring_method|bfs|bipartite_graph
1272E（https://codeforces.com/problemset/problem/1272/E）reverse_graph|multi_source_bfs
1572A（https://codeforces.com/problemset/problem/1572/A）brain_teaser|build_graph|bfs|circle_judge|dag_dp|classical
1037D（https://codeforces.com/problemset/problem/1037/D）01-bfs|implemention|classical
1176E（https://codeforces.com/contest/1176/problem/E）bds|color_method|classical
1520G（https://codeforces.com/contest/1520/problem/G）brain_teaser|bfs|classical
1611E2（https://codeforces.com/contest/1611/problem/E2）brain_teaser|bfs|implemention|classical
1607F（https://codeforces.com/contest/1607/problem/F）classical|topological_sort
1593E（https://codeforces.com/contest/1593/problem/E）classical|topological_sort|undirected
1702E（https://codeforces.com/contest/1702/problem/E）color_method|odd_circle_check
1674G（https://codeforces.com/contest/1674/problem/G）classical|brain_teaser|dag_dp|topologic_sort
1790F（https://codeforces.com/contest/1790/problem/F）classical|data_range|limit_operation
1840F（https://codeforces.com/contest/1840/problem/F）bfs|classical
796D（https://codeforces.com/problemset/problem/796/D）bfs
1063B（https://codeforces.com/problemset/problem/1063/B）bfs|observation|classical
1344B（https://codeforces.com/contest/1344/problem/B）bfs|observation
877D（https://codeforces.com/problemset/problem/877/D）bfs|observation|brain_teaser|union_find
987D（https://codeforces.com/contest/987/problem/D）several_source|bfs|brute_force
82C（https://codeforces.com/problemset/problem/82/C）implemention|bfs
1093D（https://codeforces.com/problemset/problem/1093/D）bfs|color_method|classical
1349C（https://codeforces.com/problemset/problem/1349/C）bfs|observation|implemention
1214D（https://codeforces.com/problemset/problem/1214/D）bfs|greedy|classical
1276B（https://codeforces.com/problemset/problem/1276/B）bfs|unweighted_graph|multiplication_method

====================================AtCoder=====================================
ARC090B（https://atcoder.jp/contests/abc087/tasks/arc090_b）bfs|differential_constraint|O(n^2)
ABC133E（https://atcoder.jp/contests/abc133/tasks/abc133_e）bfs|coloring_method|counter
ABC070D（https://atcoder.jp/contests/abc070/tasks/abc070_d）classical|lca|offline_lca
ABC336F（https://atcoder.jp/contests/abc336/tasks/abc336_f）bilateral_bfs|classical|matrix_rotate
ABC339B（https://atcoder.jp/contests/abc339/tasks/abc339_b）bfs|visit
ABC339D（https://atcoder.jp/contests/abc339/tasks/abc339_d）bfs
ABC335E（https://atcoder.jp/contests/abc335/tasks/abc335_e）bfs|union_find|linear_dp
ABC329E（https://atcoder.jp/contests/abc329/tasks/abc329_e）bfs|matrix_dp|classical
ABC327D（https://atcoder.jp/contests/abc327/tasks/abc327_d）bfs|color_method|classical
ABC320D（https://atcoder.jp/contests/abc320/tasks/abc320_d）bfs
ABC317E（https://atcoder.jp/contests/abc317/tasks/abc317_e）bfs
ABC315E（https://atcoder.jp/contests/abc315/tasks/abc315_e）bfs|dfs|classical
ABC315D（https://atcoder.jp/contests/abc315/tasks/abc315_d）bfs|classical|implemention
ABC311D（https://atcoder.jp/contests/abc311/tasks/abc311_d）bfs
ABC302F（https://atcoder.jp/contests/abc302/tasks/abc302_f）build_graph|bfs|brain_teaser
ABC289E（https://atcoder.jp/contests/abc289/tasks/abc289_e）bfs
ABC282D（https://atcoder.jp/contests/abc282/tasks/abc282_d）color_method|bipartite_graph|bfs|classical
ABC280F（https://atcoder.jp/contests/abc280/tasks/abc280_f）bfs|negative_circle|positive_circle|brain_teaser|classical
ABC277F（https://atcoder.jp/contests/abc277/tasks/abc277_e）bfs
ABC277C（https://atcoder.jp/contests/abc277/tasks/abc277_c）bfs
ABC276E（https://atcoder.jp/contests/abc276/tasks/abc276_e）bfs
ABC244F（https://atcoder.jp/contests/abc244/tasks/abc244_f）bfs|bit_operation|brain_teaser
ABC246E（https://atcoder.jp/contests/abc246/tasks/abc246_e）bfs|union_find|brain_teaser|prune|classical
ABC241F（https://atcoder.jp/contests/abc241/tasks/abc241_f）bfs|implemention
ABC226C（https://atcoder.jp/contests/abc226/tasks/abc226_c）reverse_graph|bfs
ABC224D（https://atcoder.jp/contests/abc224/tasks/abc224_d）bfs|classical
ABC218F（https://atcoder.jp/contests/abc218/tasks/abc218_f）shortest_path|bfs|brute_force|brain_teaser
ABC216D（https://atcoder.jp/contests/abc216/tasks/abc216_d）topological_sort
ABC211E（https://atcoder.jp/contests/abc211/tasks/abc211_e）bfs|classical|not_dfs_back_trace
ABC209E（https://atcoder.jp/contests/abc209/tasks/abc209_e）build_graph|reverse_graph|brain_teaser|game_dp
ABC361D（https://atcoder.jp/contests/abc361/tasks/abc361_d）bfs|classical
ABC197F（https://atcoder.jp/contests/abc197/tasks/abc197_f）bfs|classical

=====================================AcWing=====================================
175（https://www.acwing.com/problem/content/175/）multi_source_bfs|classical
177（https://www.acwing.com/problem/content/177/）monotonic_queue|bfs
179（https://www.acwing.com/problem/content/179/）multi_source_bfs|bilateral_bfs
4418（https://www.acwing.com/problem/content/description/4418）bfs|coloring_method|odd_circle|specific_plan|counter
4484（https://www.acwing.com/problem/content/description/4484/）01-bfs

=====================================CodeChef=====================================
1（https://www.codechef.com/problems/PRISON）01-bfs


"""
import bisect
from collections import deque, defaultdict
from heapq import heappush, heappop
from typing import List

from src.graph.dijkstra.template import UnWeightedGraph
from src.graph.union_find.template import UnionFind
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_2608_1(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/contest/biweekly-contest-101/problems/shortest-cycle-in-a-graph/
        tag: bfs|undirected_smallest_circle|brute_force|shortest_path
        """
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)

        ans = math.inf
        for i in range(n):
            dist = [math.inf] * n
            par = [-1] * n
            dist[i] = 0
            q = deque([i])
            while q:
                x = q.popleft()
                for child in graph[x]:
                    if dist[x] > ans:
                        break
                    if dist[child] == math.inf:
                        dist[child] = 1 + dist[x]
                        par[child] = x
                        q.append(child)
                    elif par[x] != child and par[child] != x:
                        cur = dist[x] + dist[child] + 1
                        ans = ans if ans < cur else cur
        return ans if ans != math.inf else -1

    @staticmethod
    def lc_2608_2(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/contest/biweekly-contest-101/problems/shortest-cycle-in-a-graph/
        tag: bfs|undirected_smallest_circle|brute_force|shortest_path
        """

        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        ans = math.inf
        for i in range(n):
            q = deque([(i, -1, 1)])
            visited = {(i, -1)}
            while q:
                u, parent, dist = q.popleft()
                if dist > ans:
                    break
                for v in graph[u]:
                    if v == parent:
                        continue
                    if v == i:
                        ans = ans if ans < dist else dist
                        break
                    if (v, u) not in visited:
                        visited.add((v, u))
                        q.append((v, u, dist + 1))
        return ans if ans < math.inf else -1

    @staticmethod
    def lc_2608_3(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/contest/biweekly-contest-101/problems/shortest-cycle-in-a-graph/
        tag: bfs|undirected_smallest_circle|brute_force|shortest_path
        """

        g = [[] for _ in range(n)]
        for u, v in edges:
            g[u].append(v)
            g[v].append(u)

        def bfs(start: int) -> int:
            dis = [-1] * n
            dis[start] = 0
            q = deque([(start, -1)])
            res = math.inf
            while q:
                x, fa = q.popleft()
                for y in g[x]:
                    if dis[y] < 0:
                        dis[y] = dis[x] + 1
                        q.append((y, x))
                    elif y != fa:
                        res = res if res < dis[x] + dis[y] + 1 else dis[x] + dis[y] + 1
            return res

        ans = min(bfs(i) for i in range(n))
        return ans if ans < math.inf else -1

    @staticmethod
    def lc_2608_4(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/contest/biweekly-contest-101/problems/shortest-cycle-in-a-graph/
        tag: bfs|undirected_smallest_circle|brute_force|shortest_path
        """

        graph = [set() for _ in range(n)]
        for x, y in edges:
            graph[x].add(y)
            graph[y].add(x)

        ans = math.inf
        for x, y in edges:
            graph[x].discard(y)
            graph[y].discard(x)
            dis = [math.inf] * n
            dis[x] = 0
            stack = deque([x])
            while stack:
                m = len(stack)
                for _ in range(m):
                    i = stack.popleft()
                    for j in graph[i]:
                        if dis[j] == math.inf:
                            dis[j] = dis[i] + 1
                            stack.append(j)
            ans = ans if ans < dis[y] else dis[y]
            graph[x].add(y)
            graph[y].add(x)
        return ans + 1 if ans < math.inf else -1

    @staticmethod
    def cf_1272e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1272/E
        tag: reverse_graph|multi_source_bfs
        """

        n = ac.read_int()
        nums = ac.read_list_ints()
        ans = [-1] * n

        edge = [[] for _ in range(n)]
        for i in range(n):
            for x in [i + nums[i], i - nums[i]]:
                if 0 <= x < n:
                    edge[x].append(i)

        for x in [0, 1]:
            stack = [i for i in range(n) if nums[i] % 2 == x]
            visit = set(stack)
            step = 1
            while stack:
                nex = []
                for i in stack:
                    for j in edge[i]:
                        if j not in visit:
                            ans[j] = step
                            nex.append(j)
                            visit.add(j)
                step += 1
                stack = nex
        ac.lst(ans)
        return

    @staticmethod
    def lg_p3183(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3183
        tag: bfs|counter|number_of_path|dfs|dag_dp
        """

        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        degree = [0] * n
        out_degree = [0] * n
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            edge[i].append(j)
            degree[j] += 1
            out_degree[i] += 1
        ind = [i for i in range(n) if degree[i] and not out_degree[i]]
        cnt = [0] * n
        stack = [i for i in range(n) if not degree[i]]
        for x in stack:
            cnt[x] = 1
        while stack:
            nex = []
            for i in stack:
                for j in edge[i]:
                    degree[j] -= 1
                    cnt[j] += cnt[i]
                    if not degree[j]:
                        nex.append(j)
            stack = nex
        ans = sum(cnt[i] for i in ind)
        return ans

    @staticmethod
    def lg_p1747(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1747
        tag: bilateral_bfs|shortest_path
        """

        x0, y0 = ac.read_list_ints()
        x2, y2 = ac.read_list_ints()

        def check(x1, y1):
            if (x1, y1) == (1, 1):
                return 0

            visit1 = {(x1, y1): 0}
            visit2 = {(1, 1): 0}
            directions = [[1, 2], [1, -2], [-1, 2], [-1, -2],
                          [2, 1], [2, -1], [-2, 1], [-2, -1]]
            directions.extend([[2, 2], [2, -2], [-2, 2], [-2, -2]])
            stack1 = [[x1, y1]]
            stack2 = [[1, 1]]
            step = 1

            while True:
                nex1 = []
                for i, j in stack1:
                    for a, b in directions:
                        if 0 < i + a <= 20 and 0 < j + b <= 20 and (i + a, j + b) not in visit1:
                            visit1[(i + a, j + b)] = step
                            nex1.append([i + a, j + b])
                            if (i + a, j + b) in visit2:
                                return step + visit2[(i + a, j + b)]

                stack1 = nex1

                nex2 = []
                for i, j in stack2:
                    for a, b in directions:
                        if 0 < i + a <= 20 and 0 < j + b <= 20 and (i + a, j + b) not in visit2:
                            visit2[(i + a, j + b)] = step
                            nex2.append([i + a, j + b])
                            if (i + a, j + b) in visit1:
                                return step + visit1[(i + a, j + b)]

                stack2 = nex2
                step += 1

        ac.st(check(x0, y0))
        ac.st(check(x2, y2))
        return

    @staticmethod
    def lc_2290(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/
        tag: 0-1bfs|deque_bfs|limited_shortest_path
        """
        m, n = len(grid), len(grid[0])
        visit = [[0] * n for _ in range(m)]
        q = deque([(0, 0, 0)])
        while q:
            d, x, y = q.popleft()
            for nx, ny in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):
                if 0 <= nx < m and 0 <= ny < n and not visit[nx][ny]:
                    if [nx, ny] == [m - 1, n - 1]:
                        return d + grid[nx][ny]
                    visit[nx][ny] = 1
                    if not grid[nx][ny]:
                        q.appendleft((d, nx, ny))
                    else:
                        q.append((d + 1, nx, ny))
        return -1

    @staticmethod
    def lc_2493(n: int, edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/
        tag: union_find|bfs|brute_force|specific_plan|coloring_method|bipartite_graph
        """
        dct = [[] for _ in range(n)]
        uf = UnionFind(n)
        for i, j in edges:
            uf.union(i - 1, j - 1)
            dct[i - 1].append(j - 1)
            dct[j - 1].append(i - 1)

        group = uf.get_root_part()
        ans = 0
        for g in group:
            cur = -math.inf
            lst = group[g]
            edge = [[i - 1, j - 1] for i, j in edges if uf.find(i - 1) == uf.find(j - 1) == g]
            for i in lst:
                stack = [i]
                visit = {i: 1}
                deep = 1
                while stack:
                    nex = []
                    for x in stack:
                        for y in dct[x]:
                            if y not in visit:
                                visit[y] = visit[x] + 1
                                deep = visit[x] + 1
                                nex.append(y)
                    stack = nex[:]
                if all(abs(visit[x] - visit[y]) == 1 for x, y in edge):
                    if deep > cur:
                        cur = deep
            if cur == -math.inf:
                return -1
            ans += cur
        return ans

    @staticmethod
    def lc_1368(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/
        tag: 0-1bfs|deque_bfs|limited_shortest_path
        """

        m, n = len(grid), len(grid[0])
        ceil = int(1e9)
        dist = [0] + [ceil] * (m * n - 1)
        seen = set()
        q = deque([(0, 0)])

        while q:
            x, y = q.popleft()
            if (x, y) in seen:
                continue
            seen.add((x, y))
            cur_pos = x * n + y
            for i, (nx, ny) in enumerate([(x, y + 1), (x, y - 1), (x + 1, y), (x - 1, y)]):
                new_pos = nx * n + ny
                new_dis = dist[cur_pos] + (1 if grid[x][y] != i + 1 else 0)
                if 0 <= nx < m and 0 <= ny < n and new_dis < dist[new_pos]:  # important!!!
                    dist[new_pos] = new_dis  # O(mn)
                    if grid[x][y] == i + 1:
                        q.appendleft((nx, ny))
                    else:
                        q.append((nx, ny))
        return dist[m * n - 1]

    @staticmethod
    def lc_1926(maze: List[List[str]], entrance: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/
        tag: deque_bfs|in_place_hash
        """
        m, n = len(maze), len(maze[0])
        x0, y0 = entrance[:]
        stack = deque([[x0, y0, 0]])
        maze[x0][y0] = "+"
        while stack:
            i, j, d = stack.popleft()
            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= x < m and 0 <= y < n and maze[x][y] == ".":
                    if x in [0, m - 1] or y in [0, n - 1]:
                        return d + 1
                    stack.append([x, y, d + 1])
                    maze[x][y] = "+"
        return -1

    @staticmethod
    def cf_1572a(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1572/A
        tag: brain_teaser|build_graph|bfs|circle_judge|dag_dp|classical|longest_path
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            dct = [dict() for _ in range(n)]
            degree = [0] * n
            for i in range(n):
                lst = ac.read_list_ints_minus_one()[1:]
                for j in lst:
                    dct[j][i] = 0 if i > j else 1
                degree[i] = len(lst)

            visit = [0] * n
            stack = [i for i in range(n) if not degree[i]]
            while stack:
                nex = []
                for i in stack:
                    for j in dct[i]:
                        degree[j] -= 1
                        if visit[i] + dct[i][j] > visit[j]:
                            visit[j] = visit[i] + dct[i][j]
                        if not degree[j]:
                            nex.append(j)
                stack = nex
            if max(degree) == 0:
                ac.st(max(visit) + 1)
            else:
                ac.st(-1)
        return

    @staticmethod
    def cf_1037d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1037/D
        tag: 01-bfs|implemention|classical
        """
        n = ac.read_int()
        edge = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            edge[i].append(j)
            edge[j].append(i)

        dct = [set() for _ in range(n)]
        stack = [(0, -1)]
        parent = [-1] * n
        while stack:
            nex = []
            for i, fa in stack:
                for j in edge[i]:
                    if j != fa:
                        nex.append((j, i))
                        dct[i].add(j)
                        parent[j] = i
            stack = nex[:]

        nums = ac.read_list_ints_minus_one()
        stack = deque([{0}])
        for num in nums:
            if not stack or num not in stack[0]:
                ac.no()
                return
            stack[0].discard(num)
            if not stack[0]:
                stack.popleft()
            if dct[num]:
                stack.append(dct[num])
        ac.yes()
        return

    @staticmethod
    def lg_p1099(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1099
        tag: tree_diameter|two_pointers|brute_force|monotonic_queue
        """
        n, s = ac.read_list_ints()
        dct = [dict() for _ in range(n)]
        for _ in range(n - 1):
            i, j, w = ac.read_list_ints()
            dct[i - 1][j - 1] = w
            dct[j - 1][i - 1] = w

        def bfs_diameter(src):
            res, node = 0, src
            stack = [[src, 0]]
            parent = [-1] * n
            while stack:
                u, dis = stack.pop()
                if dis > res:
                    res = dis
                    node = u
                for v in dct[u]:
                    if v != parent[u]:
                        parent[v] = u
                        stack.append([v, dis + dct[u][v]])
            pa = [node]
            while parent[pa[-1]] != -1:
                pa.append(parent[pa[-1]])
            pa.reverse()
            return node, pa

        start, _ = bfs_diameter(0)
        end, path = bfs_diameter(start)

        def bfs_distance(src):
            dis = [0] * n
            stack = [[src, -1, 1]]
            while stack:
                u, fa, state = stack.pop()
                if state:
                    stack.append([u, fa, 0])
                    for v in dct[u]:
                        if v != fa:
                            stack.append([v, u, 1])
                else:
                    x = 0
                    for v in dct[u]:
                        if v != fa:
                            x = max(x, dct[u][v] + dis[v])
                    dis[u] = x
            return dis

        dis1 = bfs_distance(start)  # start -> end
        dis2 = bfs_distance(end)  # end -> start

        def bfs_node(src):
            stack = [[src, -1, 0]]
            res = 0
            while stack:
                u, fa, dis = stack.pop()
                res = max(res, dis)
                for v in dct[u]:
                    if v != fa and v not in diameter:
                        stack.append([v, u, dis + dct[u][v]])
            diameter[src] = res
            return

        diameter = {node: 0 for node in path}
        for node in diameter:
            bfs_node(node)

        m = len(path)
        ans = math.inf
        gap = 0
        j = 0
        q = deque()
        q.append([diameter[path[0]], 0])
        for i in range(m):
            while q and q[0][1] < i:
                q.popleft()
            if i:
                gap -= dct[path[i - 1]][path[i]]
            while j + 1 < m and gap + dct[path[j]][path[j + 1]] <= s:
                gap += dct[path[j]][path[j + 1]]
                while q and q[-1][0] < diameter[path[j + 1]]:
                    q.pop()
                q.append([diameter[path[j + 1]], j + 1])
                j += 1

            ans = min(ans, max(dis2[path[i]], dis1[path[j]], q[0][0]))
        ac.st(ans)
        return

    @staticmethod
    def abc_133e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc133/tasks/abc133_e
        tag: bfs|coloring_method|counter
        """

        n, k = ac.read_list_ints()
        mod = 1000000007
        dct = [[] for _ in range(n)]
        degree = [0] * n
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
            degree[i] += 1
            degree[j] += 1
        if n == 1:
            ac.st(k)
            return
        root = [i for i in range(n) if degree[i] == 1][0]
        stack = [[root, -1, 0, 0]]
        ans = 1
        while stack:
            i, fa, pre, c = stack.pop()
            if pre == 0:
                ans *= (k - c)
            elif pre == 1:
                ans *= (k - 1 - c)
            else:
                ans *= (k - 2 - c)
            ans %= mod
            cnt = 0
            for j in dct[i]:
                if j != fa:
                    cnt += 1
                    stack.append([j, i, pre + 1, cnt - 1])
        ac.st(ans)
        return

    @staticmethod
    def ac_175(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/175/
        tag: multi_source_bfs|classical
        """

        m, n = ac.read_list_ints()
        grid = [ac.read_list_str() for _ in range(m)]
        stack = []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    grid[i][j] = 0
                    stack.append([i, j])
                else:
                    grid[i][j] = math.inf
        while stack:
            nex = []
            for i, j in stack:
                for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                    if 0 <= x < m and 0 <= y < n and grid[x][y] == math.inf:
                        nex.append([x, y])
                        grid[x][y] = grid[i][j] + 1
            stack = nex[:]
        for g in grid:
            ac.lst(g)
        return

    @staticmethod
    def ac_177(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/177/
        tag: monotonic_queue|bfs
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_str() for _ in range(m)]
            dct = [dict() for _ in range((m + 1) * (n + 1))]
            for i in range(m):
                for j in range(n):
                    x1, x2, x3, x4 = i * (n + 1) + j, i * (n + 1) + j + 1, \
                                     (i + 1) * (n + 1) + j, (i + 1) * (n + 1) + j + 1
                    if grid[i][j] == "/":
                        dct[x2][x3] = dct[x3][x2] = 0
                        dct[x1][x4] = dct[x4][x1] = 1
                    else:
                        dct[x2][x3] = dct[x3][x2] = 1
                        dct[x1][x4] = dct[x4][x1] = 0
            visit = [math.inf] * ((m + 1) * (n + 1))
            visit[0] = 0
            stack = deque([0])
            while stack and visit[-1] == math.inf:
                i = stack.popleft()
                d = visit[i]
                for j in dct[i]:
                    dd = d + dct[i][j]
                    if dd < visit[j]:
                        visit[j] = dd
                        if dd == d + 1:
                            stack.append(j)
                        else:
                            stack.appendleft(j)
            ac.st(visit[-1] if visit[-1] < math.inf else "NO SOLUTION")
        return

    @staticmethod
    def ac_179(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/179/
        tag: multi_source_bfs|bilateral_bfs
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_str() for _ in range(m)]
            ghost = []
            boy = []
            girl = []
            for i in range(m):
                for j in range(n):
                    w = grid[i][j]
                    if w == "M":
                        boy = [i, j]
                    elif w == "G":
                        girl = [i, j]
                    elif w == "Z":
                        ghost.append([i, j])

            dis_boy = [[math.inf] * n for _ in range(m)]
            stack_boy = [boy]
            for i, j in stack_boy:
                dis_boy[i][j] = 0

            dis_girl = [[math.inf] * n for _ in range(m)]
            stack_girl = [girl]
            for i, j in stack_girl:
                dis_girl[i][j] = 0

            dis_ghost = [[math.inf] * n for _ in range(m)]
            stack_ghost = ghost[:]
            for i, j in stack_ghost:
                dis_ghost[i][j] = 0
            pre = 0

            ans = math.inf
            while ans == math.inf and stack_girl and stack_boy:
                pre += 1
                for _ in range(2):
                    nex_ghost = []
                    for i, j in stack_ghost:
                        for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                            if 0 <= x < m and 0 <= y < n and dis_ghost[x][y] == math.inf:
                                dis_ghost[x][y] = pre
                                nex_ghost.append([x, y])
                    stack_ghost = nex_ghost[:]

                for _ in range(3):
                    nex_boy = []
                    for i, j in stack_boy:
                        if dis_ghost[i][j] == math.inf:
                            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                                if 0 <= x < m and 0 <= y < n and dis_boy[x][y] == math.inf and grid[x][y] != "X" and \
                                        dis_ghost[x][y] == math.inf:
                                    dis_boy[x][y] = pre
                                    nex_boy.append([x, y])
                                    if dis_girl[x][y] < math.inf:
                                        ans = pre
                    stack_boy = nex_boy[:]

                for _ in range(1):
                    nex = []
                    for i, j in stack_girl:
                        if dis_ghost[i][j] == math.inf:
                            for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                                if 0 <= x < m and 0 <= y < n and dis_girl[x][y] == math.inf and grid[x][y] != "X" and \
                                        dis_ghost[x][y] == math.inf:
                                    dis_girl[x][y] = pre
                                    if dis_boy[x][y] < math.inf:
                                        ans = pre
                                    nex.append([x, y])
                    stack_girl = nex[:]

            ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p1213(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1213
        tag: state_compression|01-bfs
        """

        nex = {0: 1, 1: 2, 2: 3, 3: 0}
        lst = "ABDE,ABC,BCEF,ADG,BDEFH,CFI,DEGH,GHI,EFHI".split(",")
        ind = dict()
        for i, st in enumerate(lst):
            ind[i + 1] = [ord(w) - ord("A") for w in st]

        grid = []
        for _ in range(3):
            grid.extend([(num - 3) // 3 for num in ac.read_list_ints()])

        def list_to_num(ls):
            res = 0
            for num in ls:
                res *= 4
                res += num
            return res

        def num_to_list(num):
            res = []
            while num:
                res.append(num % 4)
                num //= 4
            while len(res) < 9:
                res.append(0)
            return res[::-1]

        ans = ""
        start = list_to_num(grid)
        target = list_to_num([3] * 9)

        stack = deque([start])
        visit = dict()
        visit[start] = ""
        if start == target:
            ac.st("")
            return

        while stack:
            state = stack.popleft()
            pre = visit[state]
            if ans and len(pre) > len(ans):
                continue
            if state == target:
                if len(pre) < len(ans) or (len(pre) == len(ans) and pre < ans) or not ans:
                    ans = pre
                continue

            state = num_to_list(state)
            for i in range(9):
                tmp = state[:]
                for w in ind[i + 1]:
                    tmp[w] = nex[tmp[w]]
                cur = list_to_num(tmp)
                if cur not in visit:
                    visit[cur] = pre + str(i + 1)
                    stack.append(cur)
        ac.lst(list(ans))
        return

    @staticmethod
    def lg_p1902(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1902
        tag: binary_search|bfs|in_place_hash
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        for j in range(n):
            grid[0][j] = -grid[0][j] - 1
        dct = dict()

        def check(x):
            stack = [(0, j) for j in range(n)]
            cnt = 0
            while stack and cnt < n:
                i, j = stack.pop()
                cnt += 1 if i == m - 1 else 0
                if i + 1 < m:
                    a, b = i + 1, j
                    w = grid[a][b]
                    if x >= w >= 0:
                        stack.append((a, b))
                        grid[a][b] = -w - 1
                if i - 1 >= 0:
                    a, b = i - 1, j
                    w = grid[a][b]
                    if x >= w >= 0:
                        stack.append((a, b))
                        grid[a][b] = -w - 1
                if j + 1 < n:
                    a, b = i, j + 1
                    w = grid[a][b]
                    if x >= w >= 0:
                        stack.append((a, b))
                        grid[a][b] = -w - 1
                if j - 1 >= 0:
                    a, b = i, j - 1
                    w = grid[a][b]
                    if x >= w >= 0:
                        stack.append((a, b))
                        grid[a][b] = -w - 1
            for i in range(1, m):
                for j in range(n):
                    w = grid[i][j]
                    if w < 0:
                        grid[i][j] = -w - 1
            return cnt == n

        low = 0
        high = 1000
        while low < high - 1:
            mid = low + (high - low) // 2
            if check(mid):
                high = mid
                dct[mid] = True
            else:
                low = mid
                dct[mid] = False

        if low in dct:
            ac.st(low if dct[low] else high)
        elif high in dct and not dct[high]:
            ac.st(low)
        else:
            ac.st(low if check(low) else high)
        return

    @staticmethod
    def lg_p2199(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2199
        tag: deque_bfs|01-bfs
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_str() for _ in range(m)]
        ind = [[0, 1], [0, -1], [1, 0], [-1, 0],
               [1, 1], [1, -1], [-1, 1], [-1, -1]]
        while True:
            lst = ac.read_list_ints_minus_one()
            if lst == [-1, -1, -1, -1]:
                break
            end = [lst[0], lst[1]]
            start = [lst[2], lst[3]]

            seen = set()
            i, j = end
            seen.add((i, j))
            for a, b in ind:
                x, y = i, j
                while 0 <= x < m and 0 <= y < n and grid[x][y] != "X":
                    seen.add((x, y))
                    x += a
                    y += b
            if (start[0], start[1]) in seen:
                ac.st(0)
                continue

            visit = [[math.inf] * n for _ in range(m)]
            stack = deque([[0, start[0], start[1]]])
            ans = -1
            visit[start[0]][start[1]] = 0
            while stack and ans == -1:
                d, i, j = stack.popleft()
                for a, b in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                    if 0 <= a < m and 0 <= b < n and grid[a][b] != "X" and visit[a][b] == math.inf:
                        visit[a][b] = d + 1
                        stack.append([d + 1, a, b])
                        if (a, b) in seen:
                            ans = d + 1
                            break
            ac.st(ans if ans != -1 else "Poor Harry")
        return

    @staticmethod
    def lg_p2226(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2226
        tag: bfs
        """
        m, n = ac.read_list_ints()
        s1, s2, e1, e2 = ac.read_list_ints_minus_one()
        grid = [ac.read_list_ints() for _ in range(m)]
        ind = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        for t in range(1, 11):
            stack = deque([[s1, s2, -1, 0]])
            visit = [[[0 for _ in range(4)] for _ in range(n)] for _ in range(m)]
            ans = -1
            while stack and ans == -1:
                i, j, d, total = stack.popleft()
                pre = visit[i][j][d] if d != -1 else math.inf
                for dd in range(4):
                    x, y = i + ind[dd][0], j + ind[dd][1]
                    if 0 <= x < m and 0 <= y < n and grid[x][y] == 1 and (dd == d or pre >= t):
                        nex = pre + 1 if d == dd else 1
                        if visit[x][y][dd] < nex:
                            visit[x][y][dd] = nex
                            stack.append([x, y, dd, total + 1])
                            if (x, y) == (e1, e2):
                                ans = total + 1
                                break
            if ans != -1:
                ac.lst([t, ans])
        return

    @staticmethod
    def lg_p2296(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2296
        tag: reverse_graph|bfs
        """
        n, m = ac.read_list_ints()
        dct = [set() for _ in range(n)]
        rev = [set() for _ in range(n)]
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            if x != y:
                dct[x].add(y)
                rev[y].add(x)
        s, t = ac.read_list_ints_minus_one()

        reach = [0] * n
        reach[t] = 1
        stack = [t]
        while stack:
            i = stack.pop()
            for j in rev[i]:
                if not reach[j]:
                    reach[j] = 1
                    stack.append(j)
        if not all(reach[x] for x in dct[s]):
            ac.st(-1)
            return

        visit = [math.inf] * n
        visit[s] = 0
        stack = deque([s])
        while stack:
            i = stack.popleft()
            for j in dct[i]:
                if all(reach[k] for k in dct[j]) and visit[j] == math.inf:
                    visit[j] = visit[i] + 1
                    stack.append(j)
        ac.st(visit[t] if visit[t] < math.inf else -1)
        return

    @staticmethod
    def lg_p2919(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2919
        tag: bfs
        """
        m, n = ac.read_list_ints()
        grid = []
        for _ in range(m):
            grid.append(ac.read_list_ints())
        nodes = []
        for i in range(m):
            for j in range(n):
                nodes.append([i, j])
        nodes = deque(sorted(nodes, reverse=True, key=lambda it: grid[it[0]][it[1]]))

        ans = 0
        while nodes:
            i, j = nodes.popleft()
            if grid[i][j] == -1:
                continue
            ans += 1
            stack = [[grid[i][j], i, j]]
            grid[i][j] = -1
            while stack:
                val, i, j = stack.pop()
                for x, y in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1],
                             [i - 1, j - 1], [i - 1, j + 1], [i + 1, j - 1], [i + 1, j + 1]]:
                    if 0 <= x < m and 0 <= y < n and -1 < grid[x][y] <= val:
                        stack.append([grid[x][y], x, y])
                        grid[x][y] = -1
        ac.st(ans)
        return

    @staticmethod
    def lg_p2937(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2937
        tag: 01-bfs|monotonic_queue
        """
        n, m = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        visit = [[[math.inf] * 4 for _ in range(n)] for _ in range(m)]
        res = []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "C":
                    res.append([i, j])
        start, end = res[0], res[1]
        ind = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        stack = deque([[d, start[0], start[1]] for d in range(4)])
        visit[start[0]][start[1]] = [0, 0, 0, 0]
        while stack:
            d, i, j = stack.popleft()
            x, y = i + ind[d][0], j + ind[d][1]
            if 0 <= x < m and 0 <= y < n and grid[x][y] != "*" and visit[x][y][d] > visit[i][j][d]:
                visit[x][y][d] = visit[i][j][d]
                stack.appendleft([d, x, y])
            for dd in [d - 1, d + 1]:
                dd %= 4
                x, y = i + ind[dd][0], j + ind[dd][1]
                if 0 <= x < m and 0 <= y < n and grid[x][y] != "*" and visit[x][y][dd] > visit[i][j][d] + 1:
                    visit[x][y][dd] = visit[i][j][d] + 1
                    stack.append([dd, x, y])
        ac.st(min(visit[end[0]][end[1]]))
        return

    @staticmethod
    def lg_p3456(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3456
        tag: bfs
        """
        n = ac.read_int()
        grid = [ac.read_list_ints() for _ in range(n)]
        visit = [[0] * n for _ in range(n)]
        ceil = floor = 0
        for x in range(n):
            for y in range(n):
                if visit[x][y]:
                    continue
                visit[x][y] = 1
                stack = [[x, y]]
                big = small = False
                while stack:
                    i, j = stack.pop()
                    for a, b in ((i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j - 1),
                                 (i, j + 1), (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)):
                        if 0 <= a < n and 0 <= b < n:
                            if grid[a][b] > grid[x][y]:
                                big = True
                            elif grid[a][b] < grid[x][y]:
                                small = True
                            else:
                                if not visit[a][b]:
                                    stack.append([a, b])
                                    visit[a][b] = 1
                if small and big:
                    continue
                else:
                    if big:
                        ceil += 1
                    elif small:
                        floor += 1
                    else:
                        ceil += 1
                        floor += 1
        ac.lst([ceil, floor][::-1])
        return

    @staticmethod
    def lg_p3818(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3818
        tag: 01-bfs|deque_bfs
        """
        m, n, d, r = ac.read_list_ints()
        grid = []
        for _ in range(m):
            grid.append(ac.read_str())
        visit = [[[None] * 2 for _ in range(n)] for _ in range(m)]
        visit[0][0][0] = 0
        stack = deque([[0, 0, 0]])
        while stack:
            i, j, s = stack.popleft()
            if i == m - 1 and j == n - 1:
                ac.st(visit[i][j][s])
                return
            if (s == 0 and 0 <= i + d < m and 0 <= j + r < n and
                    not visit[i + d][j + r][1] and grid[i + d][j + r] != "#"):
                visit[i + d][j + r][1] = visit[i][j][s] + 1
                stack.append([i + d, j + r, 1])
            for x, y in [[i - 1, j], [i, j + 1], [i + 1, j], [i, j - 1]]:
                if 0 <= x < m and 0 <= y < n and not visit[x][y][s] and grid[x][y] != "#":
                    visit[x][y][s] = visit[i][j][s] + 1
                    stack.append([x, y, s])
        ac.st(-1)
        return

    @staticmethod
    def lg_p3855(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3855
        tag: bfs|md_state
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        gg = [-1, -1]
        mm = [-1, -1]
        tt = [-1, -1]
        for i in range(m):
            for j in range(n):
                w = grid[i][j]
                if w == "G":
                    gg = [i, j]
                elif w == "M":
                    mm = [i, j]
                elif w == "T":
                    tt = [i, j]

        visit = [[[[-1 for _ in range(n)] for _ in range(m)] for _ in range(n)] for _ in range(m)]
        stack = deque([[gg[0], gg[1], mm[0], mm[1]]])
        visit[gg[0]][gg[1]][mm[0]][mm[1]] = 0
        while stack:
            a, b, c, d = stack.popleft()
            ind = [[1, 0, 1, 0], [-1, 0, -1, 0], [0, 1, 0, -1], [0, -1, 0, 1]]
            for a0, b0, c0, d0 in ind:
                if 0 <= a + a0 < m and 0 <= b + b0 < n and grid[a + a0][b + b0] == "X":
                    continue
                if 0 <= c + c0 < m and 0 <= d + d0 < n and grid[c + c0][d + d0] == "X":
                    continue
                if 0 <= a + a0 < m and 0 <= b + b0 < n and grid[a + a0][b + b0] != "#":
                    x, y = a + a0, b + b0
                else:
                    x, y = a, b
                if 0 <= c + c0 < m and 0 <= d + d0 < n and grid[c + c0][d + d0] != "#":
                    p, q = c + c0, d + d0
                else:
                    p, q = c, d

                if visit[x][y][p][q] == -1:
                    visit[x][y][p][q] = visit[a][b][c][d] + 1
                    stack.append([x, y, p, q])
                    if [x, y] == [p, q] == tt:
                        ac.st(visit[x][y][p][q])
                        return
        ac.no()
        return

    @staticmethod
    def lg_p3869(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3869
        tag: bfs|state_compression
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        k = ac.read_int()
        pos = dict()
        ind = dict()
        for i in range(k):
            a, b, c, d = ac.read_list_ints_minus_one()
            if (c, d) not in ind:
                ind[(c, d)] = len(ind)
            if (a, b) not in pos:
                pos[(a, b)] = []
            pos[(a, b)].append((c, d))
        k = len(ind)

        visit = [[[math.inf] * (1 << k) for _ in range(n)] for _ in range(m)]
        ss = [-1, -1]
        tt = [-1, -1]
        for i in range(m):
            for j in range(n):
                w = grid[i][j]
                if w == "S":
                    ss = [i, j]
                elif w == "T":
                    tt = [i, j]
        stack = deque([[ss[0], ss[1], 0]])
        visit[ss[0]][ss[1]][0] = 0
        while stack:
            i, j, state = stack.popleft()
            if [i, j] == tt:
                break
            for a, b in [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= a < m and 0 <= b < n:
                    if (a, b) not in ind:
                        if grid[a][b] != "#":
                            cur_state = state
                            if (a, b) in pos:
                                for (c, d) in pos[(a, b)]:
                                    cur_state ^= (1 << ind[(c, d)])
                            if visit[a][b][cur_state] == math.inf:
                                stack.append([a, b, cur_state])
                                visit[a][b][cur_state] = visit[i][j][state] + 1
                    else:
                        if (grid[a][b] != "#") == (not state & (1 << ind[(a, b)])):
                            cur_state = state
                            if (a, b) in pos:
                                for (c, d) in pos[(a, b)]:
                                    cur_state ^= (1 << ind[(c, d)])
                            if visit[a][b][cur_state] == math.inf:
                                stack.append([a, b, cur_state])
                                visit[a][b][cur_state] = visit[i][j][state] + 1
        ac.st(min(visit[tt[0]][tt[1]]))
        return

    @staticmethod
    def lg_p4554(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4554
        tag: classical|01-bfs|implemention
        """
        while True:
            lst = ac.read_list_ints()
            if lst == [0, 0]:
                break
            m, n = lst
            grid = [ac.read_str() for _ in range(m)]
            x1, y1, x2, y2 = ac.read_list_ints()
            visit = [[math.inf] * n for _ in range(m)]
            stack = deque([[x1, y1]])
            visit[x1][y1] = 0
            while stack and visit[x2][y2] == math.inf:
                x, y = stack.popleft()
                w = grid[x][y]
                d = visit[x][y]
                for a, b in [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]:
                    if 0 <= a < m and 0 <= b < n:
                        cost = d if grid[a][b] == w else d + 1
                        if visit[a][b] > cost:
                            visit[a][b] = cost
                            if cost == d:
                                stack.appendleft([a, b])
                            else:
                                stack.append([a, b])
            ac.st(visit[x2][y2])
        return

    @staticmethod
    def lg_p4667(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4667
        tag: 01-bfs|implemention
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        dct = [dict() for _ in range((m + 1) * (n + 1))]
        for i in range(m):
            for j in range(n):
                x1, x2, x3, x4 = i * (n + 1) + j, i * (n + 1) + j + 1, (i + 1) * (n + 1) + j, (i + 1) * (n + 1) + j + 1
                if grid[i][j] == "/":
                    dct[x2][x3] = dct[x3][x2] = 0
                    dct[x1][x4] = dct[x4][x1] = 1
                else:
                    dct[x2][x3] = dct[x3][x2] = 1
                    dct[x1][x4] = dct[x4][x1] = 0
        visit = [math.inf] * ((m + 1) * (n + 1))
        visit[0] = 0
        stack = deque([[0, 0]])
        while stack and visit[-1] == math.inf:
            i, d = stack.popleft()
            if visit[i] < d:
                continue
            for j in dct[i]:
                dd = d + dct[i][j]
                if dd < visit[j]:
                    visit[j] = dd
                    if dd == d + 1:
                        stack.append([j, dd])
                    else:
                        stack.appendleft([j, dd])
        ac.st(visit[-1] if visit[-1] < math.inf else "NO SOLUTION")
        return

    @staticmethod
    def lg_p5096(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5096
        tag: state_compression|bfs|implemention
        """
        n, m, k = ac.read_list_ints()  # TLE
        dct = [dict() for _ in range(n)]
        cao = dict()
        for i in range(k):
            cao[ac.read_int() - 1] = i

        for _ in range(m):
            a, b, c = ac.read_list_ints_minus_one()
            dct[a][b] = dct[b][a] = c + 1
        visit = [[0] * (1 << k) for _ in range(n)]
        cnt = [bin(x).count("1") for x in range(1 << k)]
        visit[0][0] = 1
        stack = [[0, 0]]
        while stack:
            i, state = stack.pop()
            for j in dct[i]:
                w = dct[i][j]
                if cnt[state] > w:
                    continue
                nex = state
                if j in cao:
                    nex |= 1 << cao[j]
                if not visit[j][nex]:
                    visit[j][nex] = 1
                    stack.append([j, nex])
                if not visit[j][state]:
                    visit[j][state] = 1
                    stack.append([j, state])
        ans = 0
        for x in range(1 << k):
            if visit[0][x]:
                ans = max(ans, cnt[x])
        ac.st(ans)
        return

    @staticmethod
    def lg_p5099(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5099
        tag: 01-bfs|implemention
        """
        n, t = ac.read_list_ints()
        dct = dict()
        for i in range(n):
            x, z = ac.read_list_ints()
            dct[(x, z)] = i
        visit = [math.inf] * n
        stack = deque([[0, 0, -1]])
        ans = math.inf
        while stack:
            i, j, ind = stack.popleft()
            d = 0 if ind == -1 else visit[ind]
            if j == t:
                ans = d
                break
            for a in range(-2, 3, 1):
                for b in range(-2, 3, 1):
                    if (i + a, j + b) in dct and visit[dct[(i + a, j + b)]] > d + 1:
                        visit[dct[(i + a, j + b)]] = d + 1
                        stack.append([i + a, j + b, dct[(i + a, j + b)]])
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p5195(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5195
        tag: bfs
        """
        n, m = ac.read_list_ints()
        lst = []
        while len(lst) < m * n:
            lst.extend(ac.read_list_ints())
        grid = [lst[i * n: i * n + n] for i in range(m)]
        del lst
        pos_2 = [-1, -1]
        wood = []
        for i in range(m):
            for j in range(n):
                w = grid[i][j]
                if w == 2:
                    pos_2 = [i, j]
                elif w == 4:
                    wood.append([i, j])

        visit = [[[math.inf, math.inf] for _ in range(n)] for _ in range(m)]
        stack = deque([pos_2 + [0]])
        visit[pos_2[0]][pos_2[1]][0] = 0
        ans = math.inf
        while stack:
            i, j, state = stack.popleft()
            d = visit[i][j][state]
            if grid[i][j] == 3 and state == 1:
                ans = d
                break
            for a, b in [[i + 1, j], [i - 1, j], [i, j - 1], [i, j + 1]]:
                if 0 <= a < m and 0 <= b < n:
                    if state and grid[a][b] != 1 and visit[a][b][state] > d + 1:
                        visit[a][b][state] = d + 1
                        stack.append([a, b, state])
                    if not state and grid[a][b] not in [1, 3]:
                        if grid[a][b] == 4:
                            cur = 1
                        else:
                            cur = 0
                        if visit[a][b][cur] > d + 1:
                            visit[a][b][cur] = d + 1
                            stack.append([a, b, cur])

        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p6131(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6131
        tag: bfs|union_find
        """
        m, n = ac.read_list_ints()
        grid = [ac.read_list_str() for _ in range(m)]

        color = 0
        dct = []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "X":
                    stack = [[i, j]]
                    grid[i][j] = str(color)
                    cur = []
                    while stack:
                        a, b = stack.pop()
                        cur.append([a, b])
                        for x, y in [[a - 1, b], [a + 1, b], [a, b - 1], [a, b + 1]]:
                            if 0 <= x < m and 0 <= y < n and grid[x][y] == "X":
                                stack.append([x, y])
                                grid[x][y] = str(color)
                    color += 1
                    dct.append(cur)

        dis = [[0] * n for _ in range(m)]
        for c in range(3):
            stack = deque(dct[c])
            cur = [[math.inf] * n for _ in range(m)]
            for i, j in stack:
                cur[i][j] = 0
            while stack:
                a, b = stack.popleft()
                for x, y in [[a - 1, b], [a + 1, b], [a, b - 1], [a, b + 1]]:
                    if 0 <= x < m and 0 <= y < n:
                        if grid[x][y] != ".":
                            if cur[x][y] > cur[a][b]:
                                cur[x][y] = cur[a][b]
                                stack.append([x, y])
                        else:
                            if cur[x][y] > cur[a][b] + 1:
                                cur[x][y] = cur[a][b] + 1
                                stack.append([x, y])
            for i in range(m):
                for j in range(n):
                    dis[i][j] += cur[i][j]

        ans = math.inf
        for i in range(m):
            for j in range(n):
                if grid[i][j] == ".":
                    ans = min(ans, dis[i][j] - 2)
                else:
                    ans = min(ans, dis[i][j])
        ac.st(ans)
        return

    @staticmethod
    def lg_p6909(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6909
        tag: preprocess|bfs
        """

        m, n = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]

        up = [[-1] * n for _ in range(m)]
        for j in range(n):
            for i in range(1, m):
                if grid[i][j] == grid[i - 1][j]:
                    up[i][j] = up[i - 1][j]
                else:
                    up[i][j] = i - 1

        down = [[-1] * n for _ in range(m)]
        for j in range(n):
            for i in range(m - 2, -1, -1):
                if grid[i][j] == grid[i + 1][j]:
                    down[i][j] = down[i + 1][j]
                else:
                    down[i][j] = i + 1

        left = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(1, n):
                if grid[i][j] == grid[i][j - 1]:
                    left[i][j] = left[i][j - 1]
                else:
                    left[i][j] = j - 1

        right = [[-1] * n for _ in range(m)]
        for i in range(m):
            for j in range(n - 2, -1, -1):
                if grid[i][j] == grid[i][j + 1]:
                    right[i][j] = right[i][j + 1]
                else:
                    right[i][j] = j + 1

        s = ac.read_str() + "*"
        k = len(s)
        visit = [[-1] * n for _ in range(m)]
        visit[0][0] = 0
        stack = deque([[0, 0, 0, 0]])
        ans = -1
        while stack and ans == -1:
            d, ind, i, j = stack.popleft()
            if s[ind] == grid[i][j]:
                if ind + 1 > visit[i][j]:
                    stack.append([d + 1, ind + 1, i, j])
                    visit[i][j] = ind + 1
                    if ind + 1 == k:
                        ans = d + 1
                        break
            if up[i][j] != -1:
                x, y = up[i][j], j
                if visit[x][y] < ind:
                    visit[x][y] = ind
                    stack.append([d + 1, ind, x, y])
            if down[i][j] != -1:
                x, y = down[i][j], j
                if visit[x][y] < ind:
                    visit[x][y] = ind
                    stack.append([d + 1, ind, x, y])
            if left[i][j] != -1:
                x, y = i, left[i][j]
                if visit[x][y] < ind:
                    visit[x][y] = ind
                    stack.append([d + 1, ind, x, y])
            if right[i][j] != -1:
                x, y = i, right[i][j]
                if visit[x][y] < ind:
                    visit[x][y] = ind
                    stack.append([d + 1, ind, x, y])
        ac.st(ans)
        return

    @staticmethod
    def lg_p9065(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9065
        tag: brain_teaser|bfs|brute_force
        """
        m, n, k = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        pos = set(tuple(ac.read_list_ints_minus_one()) for _ in range(k))

        def bfs(s1, s2):
            stack = deque()
            dis = [[math.inf] * n for _ in range(m)]
            dis[s1][s2] = 0
            stack.append([0, s1, s2])
            while stack:
                d, ii, jj = stack.popleft()
                for x, y in [[ii - 1, jj], [ii + 1, jj], [ii, jj - 1], [ii, jj + 1]]:
                    if 0 <= x < m and 0 <= y < n and d + 1 < dis[x][y] and grid[x][y]:
                        dis[x][y] = d + 1
                        stack.append([d + 1, x, y])
            return dis

        dis1 = bfs(0, 0)
        dis2 = bfs(m - 1, n - 1)
        ans = dis1[m - 1][n - 1]
        if pos:
            pre = defaultdict(lambda: math.inf)
            for i, j in pos:
                pre[grid[i][j]] = min(pre[grid[i][j]], dis1[i][j])
            floor = min(pre.values())
            for i, j in pos:
                cur = min(pre[grid[i][j]], floor + 1) + dis2[i][j] + 1
                ans = min(ans, cur)
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def cf_1594d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1594/problem/D
        tag: build_graph|coloring_method|bfs|bipartite_graph
        """
        for _ in range(ac.read_int()):

            def check():
                n, m = ac.read_list_ints()
                dct = [[] for _ in range(n)]
                for _ in range(m):
                    x, y, w = ac.read_list_strs()
                    x = int(x) - 1
                    y = int(y) - 1
                    if w == "imposter":
                        z = 1
                    else:
                        z = 0
                    dct[x].append([y, z])
                    dct[y].append([x, z])
                color = [-1] * n
                ans = 0
                for i in range(n):
                    if color[i] == -1:
                        stack = [i]
                        color[i] = 0
                        cnt = [0, 0]
                        cnt[0] = 1
                        while stack:
                            x = stack.pop()
                            for y, z in dct[x]:
                                ww = color[x] ^ z
                                if color[y] == -1:
                                    color[y] = ww
                                    stack.append(y)
                                    cnt[ww] += 1
                                else:
                                    if color[y] != ww:
                                        ac.st(-1)
                                        return
                        ans += max(cnt)
                ac.st(ans)
                return

            check()
        return

    @staticmethod
    def lc_909(board: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/snakes-and-ladders/
        tag: 01-bfs|implemention
        """

        def position(num):
            i = (num - 1) // n
            j = (num - 1) % n
            if i % 2:
                return [n - 1 - i, n - 1 - j]
            return [n - 1 - i, j]

        n = len(board)
        visit = {1}
        stack = deque([[1, 0]])
        while stack:
            pre, ans = stack.popleft()
            if pre == n * n:
                return ans
            for nex in range(pre + 1, pre + 7):
                a, b = position(nex)
                if board[a][b] != -1:
                    nex = board[a][b]
                if nex == n * n:
                    return ans + 1
                if nex not in visit:
                    visit.add(nex)
                    stack.append([nex, ans + 1])
        return -1

    @staticmethod
    def lc_994(grid: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/rotting-oranges/description/
        tag: deque_bfs|implemention
        """

        m, n = len(grid), len(grid[0])
        stack = deque()
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    stack.append([i, j, 0])
        ans = 0
        while stack:
            i, j, d = stack.popleft()
            ans = d
            for x, y in [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]:
                if 0 <= x < m and 0 <= y < n and grid[x][y] == 1:
                    grid[x][y] = 2
                    stack.append([x, y, d + 1])
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 1:
                    return -1
        return ans

    @staticmethod
    def lc_1036_1(blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/escape-a-large-maze/
        tag: bound_bfs|discretization_bfs
        """

        def check(node):
            stack = [node]
            visit = {tuple(node)}
            while stack:
                nex = []
                for i, j in stack:
                    for x, y in [[i - 1, j], [i + 1, j], [i, j + 1], [i, j - 1]]:
                        if 0 <= x < n and 0 <= y < n and (x, y) not in visit and (x, y) not in block:
                            nex.append([x, y])
                            visit.add((x, y))
                stack = nex
                if len(visit) >= ceil:
                    break
            return visit

        n = 10 ** 6
        block = set(tuple(b) for b in blocked)
        m = len(block)
        ceil = m * m
        visit_s = check(source)
        visit_t = check(target)
        return len(visit_s.intersection(visit_t)) > 0 or (len(visit_s) >= ceil and len(visit_t) >= ceil)

    @staticmethod
    def lc_1036_2(blocked: List[List[int]], source: List[int], target: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/escape-a-large-maze/
        tag: bound_bfs|discretization_bfs
        """

        nodes_r = {0, 10 ** 6 - 1}
        nodes_c = {0, 10 ** 6 - 1}
        for a, b in blocked + [source] + [target]:
            nodes_r.add(a)
            nodes_c.add(b)

        nodes_r = sorted(list(nodes_r))
        m = len(nodes_r)
        ind_r = dict()
        x = 0
        ind_r[nodes_r[0]] = x
        for i in range(1, m):
            if nodes_r[i] == nodes_r[i - 1] + 1:
                x += 1
            else:
                x += 2
            ind_r[nodes_r[i]] = x
        r_id = x

        nodes_c = sorted(list(nodes_c))
        m = len(nodes_c)
        ind_c = dict()
        x = 0
        ind_c[nodes_c[0]] = x
        for i in range(1, m):
            if nodes_c[i] == nodes_c[i - 1] + 1:
                x += 1
            else:
                x += 2
            ind_c[nodes_c[i]] = x
        c_id = x

        blocked = set((ind_r[b[0]], ind_c[b[1]]) for b in blocked)
        source = (ind_r[source[0]], ind_c[source[1]])
        target = (ind_r[target[0]], ind_c[target[1]])
        stack = deque([source])
        visit = {source}
        while stack:
            i, j = stack.popleft()
            for x, y in [[i - 1, j], [i + 1, j], [i, j + 1], [i, j - 1]]:
                if 0 <= x <= r_id and 0 <= y <= c_id and (x, y) not in visit and (x, y) not in blocked:
                    stack.append((x, y))
                    if (x, y) == target:
                        return True
                    visit.add((x, y))
        return False

    @staticmethod
    def ac_4415(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4418
        tag: bfs|coloring_method|odd_circle|specific_plan|counter
        """
        mod = 998244353

        def check():
            n, m = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(m):
                u, v = ac.read_list_ints_minus_one()
                dct[u].append(v)
                dct[v].append(u)

            visit = [-1] * n
            ans = 1
            for i in range(n):
                if visit[i] == -1:
                    stack = [i]
                    color = 0
                    visit[i] = color
                    cnt = [1, 0]
                    while stack:
                        color = 1 - color
                        nex = []
                        for x in stack:
                            for y in dct[x]:
                                if visit[y] == -1:
                                    visit[y] = color
                                    cnt[color] += 1
                                    nex.append(y)
                                elif visit[y] != color:
                                    ac.st(0)
                                    return
                        stack = nex
                    res = pow(2, cnt[0], mod) + pow(2, cnt[1], mod)
                    ans *= res
                    ans %= mod
            ac.st(ans)
            return

        for _ in range(ac.read_int()):
            check()
        return

    @staticmethod
    def lg_p1330(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1330
        tag: bfs|level_wise|coloring_method|union_find|odd_circle
        """
        n, m = ac.read_list_ints()
        edge = [[] for _ in range(n)]
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            edge[u].append(v)
            edge[v].append(u)

        visit = [-1] * n
        ans = 0
        for i in range(n):
            if visit[i] == -1:
                stack = [i]
                color = 0
                visit[i] = color
                cnt = [1, 0]
                while stack:
                    color = 1 - color
                    nex = []
                    for x in stack:
                        for y in edge[x]:
                            if visit[y] == -1:
                                visit[y] = color
                                cnt[color] += 1
                                nex.append(y)
                            elif visit[y] != color:
                                # 奇数环
                                ac.st("Impossible")
                                return
                    stack = nex
                ans += cnt[0] if cnt[0] < cnt[1] else cnt[1]
        ac.st(ans)
        return

    @staticmethod
    def ac_4484(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/4484/
        tag: 01-bfs
        """

        m, n = ac.read_list_ints()
        r, c = ac.read_list_ints_minus_one()
        x, y = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]

        visit = [[0] * n for _ in range(m)]
        visit[r][c] = 1
        stack = deque([[0, 0, r, c]])
        while stack:
            a, b, x1, y1 = stack.popleft()
            for c, d in [[x1 - 1, y1], [x1 + 1, y1]]:
                if 0 <= c < m and 0 <= d < n and grid[c][d] == "." and not visit[c][d]:
                    visit[c][d] = 1
                    stack.appendleft([a, b, c, d])

            for c, d in [[x1, y1 + 1]]:
                if 0 <= c < m and 0 <= d < n and grid[c][d] == "." and b + \
                        1 <= y and not visit[c][d]:
                    visit[c][d] = 1
                    stack.append([a, b + 1, c, d])

            for c, d in [[x1, y1 - 1]]:
                if 0 <= c < m and 0 <= d < n and grid[c][d] == "." and a + \
                        1 <= x and not visit[c][d]:
                    visit[c][d] = 1
                    stack.append([a + 1, b, c, d])

        ans = 0
        for i in range(m):
            for j in range(n):
                if visit[i][j]:
                    ans += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p1144(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1144
        tag: number_of_shortest_path|bfs
        """
        mod = 100003
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(y)
            dct[y].append(x)
        n = len(dct)
        dis = [math.inf for _ in range(n)]
        cnt = [0] * n
        queue = deque([0])
        dis[0] = 0
        cnt[0] = 1
        while queue:
            u = queue.popleft()
            for v in dct[u]:
                if dis[v] > dis[u] + 1:
                    dis[v] = dis[u] + 1
                    cnt[v] = cnt[u]
                    cnt[v] %= mod
                    queue.append(v)
                elif dis[v] == dis[u] + 1:
                    cnt[v] += cnt[u]
                    cnt[v] %= mod
        for x in cnt:
            ac.st(x)
        return

    @staticmethod
    def abc_070d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc070/tasks/abc070_d
        tag: classical|bfs|tree_dis
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            a, b, c = ac.read_list_ints()
            dct[a - 1].append((b - 1, c))
            dct[b - 1].append((a - 1, c))

        q, k = ac.read_list_ints()
        k -= 1
        dis = [0] * n
        stack = [[k, -1]]
        while stack:
            i, fa = stack.pop()
            for j, w in dct[i]:
                if j != fa:
                    stack.append([j, i])
                    dis[j] = dis[i] + w
        for _ in range(q):
            a, b = ac.read_list_ints_minus_one()
            ac.st(dis[a] + dis[b])
        return

    @staticmethod
    def abc_336f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc336/tasks/abc336_f
        tag: bilateral_bfs|classical|matrix_rotate
        """
        m, n = ac.read_list_ints()
        grid = []
        for _ in range(m):
            grid.extend(ac.read_list_ints())

        def check():
            visit = {tuple(grid): 0}
            stack = [grid[:]]
            for s in range(10):
                nex = []
                for pre in stack:

                    for a, b, c, d in [[0, 0, m - 2, n - 2], [0, 1, m - 2, n - 1], [1, 0, m - 1, n - 2],
                                       [1, 1, m - 1, n - 1]]:
                        tmp = pre[:]
                        for i in range(m):
                            for j in range(n):
                                if a <= i <= c and b <= j <= d:
                                    new_i = c - (i - a)
                                    new_j = d - (j - b)
                                else:
                                    new_i = i
                                    new_j = j
                                tmp[new_i * n + new_j] = pre[i * n + j]
                        if tuple(tmp) not in visit:
                            visit[tuple(tmp)] = s + 1
                            nex.append(tmp[:])
                stack = [ls[:] for ls in nex]
            return visit

        visit1 = check()
        grid = list(range(1, m * n + 1))
        visit2 = check()
        ans = math.inf
        for k in visit1:
            if k in visit2:
                ans = min(ans, visit1[k] + visit2[k])
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def cf_1593e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1593/problem/E
        tag: classical|topological_sort|undirected
        """
        for _ in range(ac.read_int()):
            ac.read_str()
            n, k = ac.read_list_ints()
            degree = [0] * n
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                u, v = ac.read_list_ints_minus_one()
                dct[u].append(v)
                dct[v].append(u)
                degree[u] += 1
                degree[v] += 1
            stack = [i for i in range(n) if degree[i] == 1]
            for _ in range(k):
                if not stack:
                    break
                nex = []
                for i in stack:
                    degree[i] = 0
                for i in stack:
                    for j in dct[i]:
                        if degree[j] > 1:
                            degree[j] -= 1
                            if degree[j] == 1:
                                nex.append(j)
                stack = nex[:]
            ans = sum(x >= 1 for x in degree)
            ac.st(ans)
        return

    @staticmethod
    def cf_1674g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1674/problem/G
        tag: classical|brain_teaser|dag_dp|topologic_sort
        """
        n, m = ac.read_list_ints()
        in_degree = [0] * n
        out_degree = [0] * n
        dp = [1] * n
        dct = [[] for _ in range(n)]
        for _ in range(m):
            u, v = ac.read_list_ints_minus_one()
            in_degree[v] += 1
            out_degree[u] += 1
            dct[u].append(v)
        stack = deque([x for x in range(n) if in_degree[x] == 0])
        degree = in_degree[:]
        while stack:
            x = stack.popleft()
            for y in dct[x]:
                if out_degree[x] > 1 and in_degree[y] > 1:
                    dp[y] = max(dp[y], dp[x] + 1)
                degree[y] -= 1
                if not degree[y]:
                    stack.append(y)
        ac.st(max(dp))
        return

    @staticmethod
    def abc_302f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc302/tasks/abc302_f
        tag: build_graph|bfs|brain_teaser
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(m + n)]
        for i in range(n):
            ac.read_int()
            lst = ac.read_list_ints_minus_one()
            for x in lst:
                dct[x].append(m + i)
                dct[m + i].append(x)
        dis = [math.inf] * (m + n)
        dis[0] = 0
        stack = [0]
        while stack:
            nex = []
            for i in stack:
                if i == m - 1:
                    ac.st((dis[m - 1] - 2) // 2)
                    return
                for j in dct[i]:
                    if dis[j] == math.inf:
                        dis[j] = dis[i] + 1
                        nex.append(j)
            stack = nex
        ac.st(-1)
        return

    @staticmethod
    def abc_282d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc282/tasks/abc282_d
        tag: color_method|bipartite_graph|bfs|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        color = [-1] * n
        ans = pre = 0
        for x in range(n):
            if color[x] == -1:
                stack = [x]
                color[x] = 0
                zero = 1
                tot = 1
                edge = 0
                while stack:
                    nex = []
                    for i in stack:
                        c = color[i]
                        for j in dct[i]:
                            edge += 1
                            if color[j] != -1:
                                if color[j] != 1 - c:
                                    ac.st(0)
                                    return
                            else:
                                color[j] = 1 - c
                                nex.append(j)
                                tot += 1
                                if c:
                                    zero += 1
                    stack = nex[:]
                ans += zero * (tot - zero) - edge // 2
                ans += pre * tot
                pre += tot
        ac.st(ans)
        return

    @staticmethod
    def abc_280f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc280/tasks/abc280_f
        tag: bfs|negative_circle|positive_circle|brain_teaser|classical
        """
        n, m, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        dis = [math.inf] * n
        for _ in range(m):
            a, b, c = ac.read_list_ints_minus_one()
            c += 1
            dct[a].append((b, c))
            dct[b].append((a, -c))
        visit = [0] * n
        for i in range(n):
            if not visit[i]:
                visit[i] = 1
                dis[i] = 0
                stack = [i]
                lst = [i]
                circle = 0
                while stack:
                    x = stack.pop()
                    for y, w in dct[x]:
                        if dis[y] != math.inf and dis[y] != dis[x] + w:
                            circle = 1
                        dis[y] = dis[x] + w
                        if not visit[y]:
                            visit[y] = 1
                            lst.append(y)
                            stack.append(y)
                            dis[y] = dis[x] + w
                if circle:
                    for x in lst:
                        dis[x] = math.inf
                for x in lst:
                    visit[x] = lst[0] + 1
        for _ in range(q):
            x, y = ac.read_list_ints_minus_one()
            if visit[x] != visit[y]:
                ac.st("nan")
            elif dis[x] == math.inf:
                ac.st("math.inf")
            else:
                ac.st(dis[y] - dis[x])
        return

    @staticmethod
    def abc_246e_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc246/tasks/abc246_e
        tag: bfs|union_find|brain_teaser|prune|classical
        """
        n = ac.read_int()
        sx, sy = ac.read_list_ints_minus_one()
        tx, ty = ac.read_list_ints_minus_one()

        grid = [ac.read_str() for _ in range(n)]
        visit = [[math.inf] * n for _ in range(n)]
        ind = [[-1, 1], [-1, -1], [1, 1], [1, -1]]
        visit[sx][sy] = 0
        stack = [(sx, sy)]
        while stack:
            nex = []
            for x, y in stack:
                d = visit[x][y] + 1
                for dx, dy in ind:
                    px, py = x, y
                    while 0 <= px + dx < n and 0 <= py + dy < n and grid[px + dx][py + dy] != "#" and visit[px + dx][
                        py + dy] >= d:
                        px, py = px + dx, py + dy
                        if visit[px][py] == math.inf:
                            visit[px][py] = d
                            nex.append((px, py))

            stack = nex
        ans = visit[tx][ty]
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_246e_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc246/tasks/abc246_e
        tag: bfs|union_find|brain_teaser|prune|classical
        """
        n = ac.read_int()
        sx, sy = ac.read_list_ints_minus_one()
        tx, ty = ac.read_list_ints_minus_one()
        visit = [[math.inf] * n for _ in range(n)]
        grid = [ac.read_str() for _ in range(n)]
        stack = [(sx, sy)]
        visit[sx][sy] = 0
        uf1 = UnionFind(n * n)
        uf2 = UnionFind(n * n)
        uf3 = UnionFind(n * n)
        uf4 = UnionFind(n * n)

        while stack:
            nex = []
            for x, y in stack:
                cx, cy = x, y
                while True:
                    root = uf1.find(cx * n + cy)
                    if root == cx * n + cy:
                        root = (cx - 1) * n + cy + 1
                    if not (0 <= (cx - 1) < n and 0 <= cy + 1 < n and 0 <= root < n * n):
                        break
                    px, py = root // n, root % n
                    if 0 <= px < n and 0 <= py < n:
                        uf1.union_right(cx * n + cy, root)
                        if grid[px][py] != '#':
                            if visit[px][py] == math.inf:
                                nex.append((px, py))
                                visit[px][py] = visit[x][y] + 1
                            cx, cy = px, py
                        else:
                            break
                    else:
                        break

                cx, cy = x, y
                while True:
                    root = uf2.find(cx * n + cy)
                    if root == cx * n + cy:
                        root = (cx - 1) * n + cy - 1
                    if not (0 <= (cx - 1) < n and 0 <= cy - 1 < n and 0 <= root < n * n):
                        break
                    px, py = root // n, root % n
                    if 0 <= px < n and 0 <= py < n:
                        uf2.union_right(cx * n + cy, root)
                        if grid[px][py] != '#':
                            if visit[px][py] == math.inf:
                                nex.append((px, py))
                                visit[px][py] = visit[x][y] + 1
                            cx, cy = px, py
                        else:
                            break
                    else:
                        break

                cx, cy = x, y
                while True:
                    root = uf3.find(cx * n + cy)
                    if root == cx * n + cy:
                        root = (cx + 1) * n + cy - 1
                    if not (0 <= (cx + 1) < n and 0 <= cy - 1 < n and 0 <= root < n * n):
                        break
                    px, py = root // n, root % n

                    if 0 <= px < n and 0 <= py < n:
                        uf3.union_right(cx * n + cy, root)
                        if grid[px][py] != '#':
                            if visit[px][py] == math.inf:
                                nex.append((px, py))
                                visit[px][py] = visit[x][y] + 1
                            cx, cy = px, py
                        else:
                            break
                    else:
                        break

                cx, cy = x, y
                while True:
                    root = uf4.find(cx * n + cy)
                    if root == cx * n + cy:
                        root = (cx + 1) * n + cy + 1
                    if not (0 <= (cx + 1) < n and 0 <= cy + 1 < n and 0 <= root < n * n):
                        break
                    px, py = root // n, root % n

                    if 0 <= px < n and 0 <= py < n:
                        uf4.union_right(cx * n + cy, root)
                        if grid[px][py] != '#':
                            if visit[px][py] == math.inf:
                                nex.append((px, py))
                                visit[px][py] = visit[x][y] + 1
                            cx, cy = px, py
                        else:
                            break
                    else:
                        break

            stack = nex
        ac.st(visit[tx][ty] if visit[tx][ty] < math.inf else -1)
        return

    @staticmethod
    def abc_244f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc244/tasks/abc244_f
        tag: bfs|bit_operation|brain_teaser
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints()
            dct[i - 1].append(j - 1)
            dct[j - 1].append(i - 1)
        dis = [[math.inf] * (1 << n) for _ in range(n)]
        for i in range(n):
            dis[i][0] = 0
        stack = []
        for i in range(n):
            dis[i][1 << i] = 1
            stack.append((1 << i, i))
        while stack:
            nex = []
            for s, i in stack:
                d = dis[i][s]
                for j in dct[i]:
                    dj = d + 1
                    if dis[j][s ^ (1 << j)] == math.inf:
                        dis[j][s ^ (1 << j)] = dj
                        nex.append((s ^ (1 << j), j))
            stack = nex
        ac.st(sum(min(dis[i][j] for i in range(n)) for j in range(1 << n)))
        return

    @staticmethod
    def abc_241f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc241/tasks/abc241_f
        tag: bfs|implemention
        """
        m, n, k = ac.read_list_ints()
        sx, sy = ac.read_list_ints()
        gx, gy = ac.read_list_ints()
        points = [ac.read_list_ints() for _ in range(k)]
        dct_x = defaultdict(list)
        dct_y = defaultdict(list)
        obs = {(x, y) for x, y in points}
        for x, y in points:
            for a, b in [(0, 0)]:
                if 1 <= x + a <= m and 1 <= y + b <= n:
                    dct_x[x + a].append(y + b)
                    dct_y[y + b].append(x + a)

        for x in dct_x:
            dct_x[x] = sorted(set(dct_x[x]))
        for y in dct_y:
            dct_y[y] = sorted(set(dct_y[y]))

        dis = defaultdict(lambda: math.inf)
        dis[(sx, sy)] = 0
        stack = [(0, sx, sy)]

        while stack:
            d, i, j = heappop(stack)
            if dis[(i, j)] < d:
                continue
            ind = bisect.bisect_left(dct_y[j], i) - 1
            if 0 <= ind < len(dct_y[j]):
                ii = dct_y[j][ind] + 1

                if (ii, j) not in obs:
                    dj = d + 1
                    if dj < dis[(ii, j)]:
                        dis[(ii, j)] = dj
                        heappush(stack, (dj, ii, j))

            ind = bisect.bisect_right(dct_y[j], i)
            if 0 <= ind < len(dct_y[j]):
                ii = dct_y[j][ind] - 1

                if (ii, j) not in obs:
                    dj = d + 1
                    if dj < dis[(ii, j)]:
                        dis[(ii, j)] = dj
                        heappush(stack, (dj, ii, j))

            ind = bisect.bisect_left(dct_x[i], j) - 1
            if 0 <= ind < len(dct_x[i]):
                jj = dct_x[i][ind] + 1
                if (i, jj) not in obs:
                    dj = d + 1
                    if dj < dis[(i, jj)]:
                        dis[(i, jj)] = dj
                        heappush(stack, (dj, i, jj))

            ind = bisect.bisect_right(dct_x[i], j)
            if 0 <= ind < len(dct_x[i]):
                jj = dct_x[i][ind] - 1
                if (i, jj) not in obs:
                    dj = d + 1
                    if dj < dis[(i, jj)]:
                        dis[(i, jj)] = dj
                        heappush(stack, (dj, i, jj))

        ans = dis[(gx, gy)]
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_226c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc226/tasks/abc226_c
        tag: reverse_graph|bfs
        """
        n = ac.read_int()

        rev = [[] for _ in range(n)]
        ans = [0] * n
        for i in range(n):
            lst = ac.read_list_ints()
            for x in lst[2:]:
                rev[i].append(x - 1)
            ans[i] = lst[0]

        stack = [n - 1]
        res = ans[n - 1]
        ans[n - 1] = -1
        while stack:
            nex = []
            for i in stack:
                for j in rev[i]:
                    if ans[j] != -1:
                        nex.append(j)
                        res += ans[j]
                        ans[j] = -1
            stack = nex[:]
        ac.st(res)
        return

    @staticmethod
    def abc_218f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc218/tasks/abc218_f
        tag: shortest_path|bfs|brute_force|brain_teaser
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for x in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append((j, x))

        dis = [math.inf] * n
        dis[0] = 0
        stack = [0]
        parent = [-1]*n
        index = [-1]*n
        while stack:
            nex = []
            for i in stack:
                for j, y in dct[i]:
                    if dis[j] == math.inf:
                        dis[j] = dis[i] + 1
                        parent[j] = i
                        index[j] = y
                        nex.append(j)
            stack = nex

        if dis[-1] == math.inf:
            path = set()
        else:
            path = []
            node = n-1
            while node != 0:
                path.append(index[node])
                node = parent[node]
            path = set(path)
        res = dis[-1] if dis[-1] < math.inf else -1
        for x in range(m):
            if x not in path:
                ac.st(res)
                continue
            dis = [math.inf] * n
            dis[0] = 0
            stack = [0]
            while stack:
                nex = []
                for i in stack:
                    for j, y in dct[i]:
                        if y != x and dis[j] == math.inf:
                            dis[j] = dis[i] + 1
                            nex.append(j)
                stack = nex
            ac.st(dis[-1] if dis[-1] < math.inf else -1)
        return

    @staticmethod
    def abc_211e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc211/tasks/abc211_e
        tag: bfs|classical|not_dfs_back_trace
        """
        n = ac.read_int()
        k = ac.read_int()
        grid = [ac.read_str() for _ in range(n)]
        pre = set()
        for i in range(n):
            for j in range(n):
                if grid[i][j] == ".":
                    pre.add((i * n + j,))
        for _ in range(k - 1):
            cur = set()
            for ls in pre:
                tmp = list(ls)
                dct = set(ls)
                for x in ls:
                    ii, jj = x // n, x % n
                    for a, b in ((ii - 1, jj), (ii + 1, jj), (ii, jj - 1), (ii, jj + 1)):
                        if 0 <= a < n and 0 <= b < n and grid[a][b] == "." and a * n + b not in dct:
                            cur.add(tuple(sorted(tmp + [a * n + b])))
            pre = cur
        ac.st(len(pre))
        return

    @staticmethod
    def abc_209e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc209/tasks/abc209_e
        tag: build_graph|reverse_graph|brain_teaser|game_dp
        """
        n = ac.read_int()
        words = [ac.read_str() for _ in range(n)]

        nodes = set()
        for i, word in enumerate(words):
            nodes.add(word[:3])
            nodes.add(word[-3:])
        nodes = list(nodes)
        k = len(nodes)
        rev = [set() for _ in range(k)]
        ind = {num: i for i, num in enumerate(nodes)}

        for i, word in enumerate(words):
            rev[ind[word[-3:]]].add(ind[word[:3]])

        degree = [0] * k
        for i in range(k):
            for j in rev[i]:
                degree[j] += 1

        stack = [i for i in range(k) if not degree[i]]
        dis = [0] * k
        for i in stack:
            dis[i] = 1

        while stack:
            nex = []
            for i in stack:
                for j in rev[i]:
                    degree[j] -= 1
                    if dis[j] == 0:
                        if dis[i] == 1:
                            dis[j] = -1
                            nex.append(j)
                        elif dis[i] == -1 and degree[j] == 0:
                            dis[j] = 1
                            nex.append(j)
            stack = nex

        for i in range(n):
            cur = dis[ind[words[i][-3:]]]
            if cur == 0:
                ac.st("Draw")
            elif cur == -1:
                ac.st("Aoki")
            else:
                ac.st("Takahashi")
        return

    @staticmethod
    def cf_1063b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1063/B
        tag: bfs|observation|classical
        """
        m, n = ac.read_list_ints()
        r, c = ac.read_list_ints_minus_one()
        x, y = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]

        stack = deque([(r, c, x, y)])
        visit = [-1] * n * m
        visit[r*n+c] = 0
        while stack:
            a, b, xx, yy = stack.pop()
            for i, j in [(a + 1, b), (a - 1, b), (a, b - 1), (a, b + 1)]:
                if 0 <= i < m and 0 <= j < n and grid[i][j] == ".":
                    dij = [xx, yy]
                    if j != b:
                        if j == b - 1:
                            dij[0] -= 1
                        else:
                            dij[1] -= 1
                    if dij[0] < 0 or dij[1] < 0:
                        continue
                    if visit[i*n+j] < dij[0]:
                        visit[i*n+j] = dij[0]
                        if dij[0] == xx:
                            stack.appendleft((i, j, dij[0], dij[1]))
                        else:
                            stack.append((i, j, dij[0], dij[1]))
        ans = sum(x > -1 for x in visit)
        ac.st(ans)
        return

    @staticmethod
    def cf_1344b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1344/problem/B
        tag: bfs|observation
        """
        m, n = ac.read_list_ints()
        grid = [list(ac.read_str()) for _ in range(m)]
        flag1 = 0
        for i in range(m):
            pre = -1
            for j in range(n):
                if grid[i][j] == "#":
                    if pre != -1 and j - pre > 1:
                        ac.st(-1)
                        return
                    pre = j
            if pre == -1:
                flag1 = 1

        flag2 = 0
        for j in range(n):
            pre = -1
            for i in range(m):
                if grid[i][j] == "#":
                    if pre != -1 and i - pre > 1:
                        ac.st(-1)
                        return
                    pre = i
            if pre == -1:
                flag2 = 1
        if flag1 != flag2:
            ac.st(-1)
            return
        ans = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "#":
                    ans += 1
                    stack = [(i, j)]
                    grid[i][j] = "."
                    while stack:
                        x, y = stack.pop()
                        for a, b in [(x - 1, y), (x, y + 1), (x, y - 1), (x + 1, y)]:
                            if 0 <= a < m and 0 <= b < n and grid[a][b] == "#":
                                stack.append((a, b))
                                grid[a][b] = "."
        ac.st(ans)
        return

    @staticmethod
    def cf_877d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/877/D
        tag: bfs|observation|brain_teaser|union_find
        """
        m, n, k = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]
        x1, y1, x2, y2 = ac.read_list_ints_minus_one()
        visit = [-1] * m * n

        visit[x1 * n + y1] = 0
        stack = [(x1, y1)]
        while stack:
            nex = []
            for x, y in stack:
                d = visit[x * n + y] + 1
                for a, b in ac.dire4:
                    xx, yy = x, y
                    for _ in range(k):
                        xx, yy = xx + a, yy + b
                        if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == "." and visit[xx * n + yy] <= d:
                            if visit[xx * n + yy] == -1:
                                stack.append((xx, yy))
                                visit[xx * n + yy] = d
                            elif visit[xx * n + yy] == d:
                                continue
                            else:
                                break
                        else:
                            break
            stack = nex[:]
        ac.st(visit[x2 * n + y2])
        return

    @staticmethod
    def cf_987d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/987/problem/D
        tag: several_source|bfs|brute_force
        """
        n, m, k, s = ac.read_list_ints()
        a = ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        start = [[] for _ in range(k)]
        for i in range(n):
            start[a[i]].append(i)

        res = [[] for _ in range(n)]
        dis = [math.inf] * n
        for c in range(k):
            for i in range(n):
                dis[i] = math.inf
            stack = start[c][:]
            for i in stack:
                dis[i] = 0
            while stack:
                nex = []
                for i in stack:
                    for j in dct[i]:
                        if dis[j] == math.inf:
                            dis[j] = dis[i] + 1
                            nex.append(j)
                stack = nex
            for i in range(n):
                res[i].append(dis[i])
        ans = []
        for i in range(n):
            res[i].sort()
            ans.append(sum(res[i][:s]))
        ac.lst(ans)
        return

    @staticmethod
    def cf_1349c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1349/C
        tag: bfs|observation|implemention
        """
        m, n, q = ac.read_list_ints()
        grid = [ac.read_str() for _ in range(m)]

        root = [[-1] * n for _ in range(m)]
        visit = [[-1] * n for _ in range(m)]
        stack = []
        for i in range(m):
            for j in range(n):
                if i + 1 < m and grid[i + 1][j] == grid[i][j]:
                    root[i][j] = root[i + 1][j] = int(grid[i][j])
                    visit[i][j] = visit[i + 1][j] = 0
                if j + 1 < n and grid[i][j + 1] == grid[i][j]:
                    root[i][j] = root[i][j + 1] = int(grid[i][j])
                    visit[i][j] = visit[i][j + 1] = 0
                if visit[i][j] != -1:
                    stack.append((i, j))
        while stack:
            nex = []
            for i, j in stack:
                for x, y in ac.dire4:
                    if 0 <= i + x < m and 0 <= j + y < n and visit[i + x][j + y] == -1:
                        visit[i + x][j + y] = visit[i][j] + 1
                        root[i + x][j + y] = root[i][j]
                        nex.append((i + x, j + y))
            stack = nex
        for _ in range(q):
            i, j, p = ac.read_list_ints_minus_one()
            p += 1
            if visit[i][j] == 0:
                ac.st(int(grid[i][j]) ^ (p & 1))
            elif visit[i][j] == -1:
                ac.st(int(grid[i][j]))
            else:
                if p < visit[i][j]:
                    ac.st(int(grid[i][j]))
                else:
                    ac.st(int(root[i][j]) ^ (p & 1))
        return

    @staticmethod
    def cf_1276b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1276/B
        tag: bfs|unweighted_graph|multiplication_method
        """

        class Graph(UnWeightedGraph):
            def bfs(self, src=0, target=0):
                dis = [math.inf] * (self.n + 1)
                dis[src] = 0
                stack = [src]
                while stack:
                    nex = []
                    for u in stack:
                        i = self.point_head[u]
                        while i:
                            j = self.edge_to[i]
                            dj = dis[u] + 1
                            if dj < dis[j]:
                                dis[j] = dj
                                if j != target:
                                    nex.append(j)
                            i = self.edge_next[i]
                    stack = nex
                return sum(x < math.inf for x in dis)

        for _ in range(ac.read_int()):
            n, m, a, b = ac.read_list_ints()
            a -= 1
            b -= 1
            graph = Graph(n)
            for _ in range(m):
                u, v = ac.read_list_ints_minus_one()
                graph.add_undirected_edge(u, v)
            ans = (n - graph.bfs(a, b)) * (n - graph.bfs(b, a))
            ac.st(ans)
        return
"""

Algorithm：dfs|coloring_method|brute_force|back_trace|euler_order|dfs_order|prune|iteration
Description：back_trace|brute_force|dfs_order|up_to_down|down_to_up|heuristic_method|dsu_on_tree


====================================LeetCode====================================
473（https://leetcode.cn/problems/matchsticks-to-square/）dfs|back_trace
301（https://leetcode.cn/problems/remove-invalid-parentheses/）back_trace|dfs|prune
2581（https://leetcode.cn/problems/count-number-of-possible-root-nodes）dfs_order|diff_array|counter|reroot_dp
1059（https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/）memory_search|dfs|back_trace
1718（https://leetcode.cn/problems/construct-the-lexicographically-largest-valid-sequence/）back_trace
2322（https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/）dfs_order|brute_force
1240（https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/）dfs|back_trace|prune
1239（https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/）dfs|back_trace|2-base|brute_force
1080（https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/description/）dfs|up_to_down|down_to_up
2056（https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/description/）back_trace|brute_force
2458（https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries）dfs_order|classical
2858（https://leetcode.cn/problems/minimum-edge-reversals-so-every-node-is-reachable/）reroot_dp|dfs|dfs_order|diff_array

=====================================LuoGu======================================
P2383（https://www.luogu.com.cn/problem/P2383）dfs|back_trace
P1120（https://www.luogu.com.cn/problem/P1120）dfs|back_trace
P1692（https://www.luogu.com.cn/problem/P1692）dfs|brute_force|lexicographical_order
P1612（https://www.luogu.com.cn/problem/P1612）dfs|prefix_sum|binary_search
P1475（https://www.luogu.com.cn/problem/P1475）dfs
P2080（https://www.luogu.com.cn/problem/P2080）dfs|back_trace|prune
P2090（https://www.luogu.com.cn/problem/P2090）dfs|greedy|back_trace|prune|euclidean_division|euclidean_minus
P2420（https://www.luogu.com.cn/problem/P2420）brain_teaser|dfs|shortest_path|xor_path|classical
P1473（https://www.luogu.com.cn/problem/P1473）dfs|brute_force
P1461（https://www.luogu.com.cn/problem/P1461）dfs|back_trace|brute_force
P1394（https://www.luogu.com.cn/problem/P1394）dfs
P1180（https://www.luogu.com.cn/problem/P1180）dfs|implemention
P1118（https://www.luogu.com.cn/problem/P1118）implemention|lexicographical_order|dfs
P3252（https://www.luogu.com.cn/problem/P3252）dfs|back_trace|prefix_sum|hash
P4913（https://www.luogu.com.cn/problem/P4913）dfs
P5118（https://www.luogu.com.cn/problem/P5118）dfs|back_trace|hash|implemention
P5197（https://www.luogu.com.cn/problem/P5197）tree_dp|implemention|coloring_method
P5198（https://www.luogu.com.cn/problem/P5198）union_find
P5318（https://www.luogu.com.cn/problem/P5318）bfs|topological_sort|dfs_order
P6691（https://www.luogu.com.cn/problem/P6691）coloring_method|bipartite_graph|specific_plan|counter
P7370（https://www.luogu.com.cn/problem/P7370）ancestor
P1036（https://www.luogu.com.cn/problem/P1036）back_trace|prune
P8578（https://www.luogu.com.cn/problem/P8578）greedy|dfs_order
P8838（https://www.luogu.com.cn/problem/P8838）dfs|back_trace
P1444（https://www.luogu.com.cn/problem/P1444）dfs|back_trace|circle_check|brain_teaser|observation

===================================CodeForces===================================
570D（https://codeforces.com/contest/570/problem/D）dfs_order|binary_search|offline_query
208E（https://codeforces.com/contest/208/problem/E）dfs_order|lca|binary_search|counter
1006E（https://codeforces.com/contest/1006/problem/E）dfs_order|template
1702G2（https://codeforces.com/contest/1702/problem/G2）dfs_order|lca
1899G（https://codeforces.com/contest/1899/problem/G）dfs|inclusion_exclusion|classical|point_add_range_sum|heuristic_merge
1714G（https://codeforces.com/contest/1714/problem/G）dfs|binary_search|prefix_sum
1675F（https://codeforces.com/contest/1675/problem/F）dfs_order|greedy
219D（https://codeforces.com/contest/219/problem/D）reroot_dp|dfs|dfs_order|diff_array
246E（https://codeforces.com/problemset/problem/246/E）tree_array|offline_query|range_unique|dfs_order
1076E（https://codeforces.com/problemset/problem/1076/E）tree_diff_array|dfs|classical
383C（https://codeforces.com/problemset/problem/383/C）dfs_order|odd_even|range_add|point_get
3C（https://codeforces.com/problemset/problem/3/C）dfs|back_trace|brute_force|implemention
459C（https://codeforces.com/problemset/problem/459/C）back_trace|brute_force|classical|implemention
1918F（https://codeforces.com/problemset/problem/1918/F）dfs_order|greedy|tree_lca|implemention|observation|brain_teaser
1882D（https://codeforces.com/problemset/problem/1882/D）dfs_order|diff_array|contribution_method|greedy
1009F（https://codeforces.com/problemset/problem/1009/F）heuristic_merge|classical
27E（https://codeforces.com/problemset/problem/27/E）prime_factor|brute_force|factor_dp

====================================AtCoder=====================================
ABC133F（https://atcoder.jp/contests/abc133/tasks/abc133_f）euler_order|online_tree_dis|binary_search|prefix_sum
ABC337G（https://atcoder.jp/contests/abc337/tasks/abc337_g）dfs_order|contribution_method|classical|tree_array
ABC328E（https://atcoder.jp/contests/abc328/tasks/abc328_e）dfs|back_trace|union_find|brute_force
ABC326D（https://atcoder.jp/contests/abc326/tasks/abc326_d）dfs|back_trace|brute_force
ABC322D（https://atcoder.jp/contests/abc322/tasks/abc322_d）dfs|back_trace|brute_force
ABC284E（https://atcoder.jp/contests/abc284/tasks/abc284_e）dfs|back_trace|classical
ABC268D（https://atcoder.jp/contests/abc268/tasks/abc268_d）dfs|back_trace|prune|classical
ABC244G（https://atcoder.jp/contests/abc244/tasks/abc244_g）construction|euler_order|brain_teaser|classical
ABC240F（https://atcoder.jp/contests/abc240/tasks/abc240_e）dfs_order|leaf|classical
ABC236D（https://atcoder.jp/contests/abc236/tasks/abc236_d）back_trace|prune|brute_force|classical
ABC213D（https://atcoder.jp/contests/abc213/tasks/abc213_d）euler_order|classical
ABC196D（https://atcoder.jp/contests/abc196/tasks/abc196_d）dfs|state_compression|bit_operation

=====================================AcWing=====================================
4313（https://www.acwing.com/problem/content/4313/）dfs_order|template
21（https://www.acwing.com/problem/content/description/21/）back_trace|template

"""

import bisect
from bisect import bisect_right, bisect_left
from collections import defaultdict
from itertools import accumulate, permutations
from typing import List, Optional

from src.basis.diff_array.template import PreFixSumMatrix
from src.basis.tree_node.template import TreeNode
from src.data_structure.segment_tree.template import RangeAddPointGet
from src.data_structure.tree_array.template import PointAddRangeSum
from src.graph.tree_lca.template import TreeAncestor, OfflineLCA
from src.graph.union_find.template import UnionFind
from src.search.dfs.template import DFS, DfsEulerOrder, UnWeightedTree
from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_473_1(matchsticks: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/matchsticks-to-square/
        tag: dfs|back_trace|state_dp|classical
        """

        def dfs(i):
            nonlocal ans
            if ans:
                return
            if i == n:
                if len(pre) == 4:
                    ans = True
                return
            if len(pre) > 4:
                return
            for j in range(len(pre)):
                if pre[j] + matchsticks[i] <= m:
                    pre[j] += matchsticks[i]
                    dfs(i + 1)
                    pre[j] -= matchsticks[i]
            pre.append(matchsticks[i])
            dfs(i + 1)
            pre.pop()
            return

        n, s = len(matchsticks), sum(matchsticks)
        if s % 4 or max(matchsticks) > s // 4:
            return False
        matchsticks.sort(reverse=True)  # important!!!
        m = s // 4
        ans = False
        pre = []
        dfs(0)
        return ans

    @staticmethod
    def lc_473_2(matchsticks: List[int]) -> bool:
        """
        url: https://leetcode.cn/problems/matchsticks-to-square/
        tag: dfs|back_trace|state_dp|classical
        """
        n = len(matchsticks)
        tot = sum(matchsticks)
        if tot % 4:
            return False
        single = tot // 4
        dp = [-1] * (1 << n)
        dp[0] = 0
        for s in range(1, 1 << n):
            for i, x in enumerate(matchsticks):
                if not s & (1 << i):
                    continue
                pre = s ^ (1 << i)
                if dp[pre] >= 0 and dp[pre] + x <= single:
                    dp[s] = (dp[pre] + x) % single
                    break
        return dp[-1] == 0

    @staticmethod
    def lg_2383(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2383
        tag: dfs|back_trace|state_dp|classical
        """
        for _ in range(ac.read_int()):
            matchsticks = ac.read_list_ints()[1:]
            n = len(matchsticks)
            tot = sum(matchsticks)
            if tot % 4:
                ac.no()
                continue
            single = tot // 4
            dp = [-1] * (1 << n)
            dp[0] = 0
            for s in range(1, 1 << n):
                for i, x in enumerate(matchsticks):
                    if not s & (1 << i):
                        continue
                    pre = s ^ (1 << i)
                    if dp[pre] >= 0 and dp[pre] + x <= single:
                        dp[s] = (dp[pre] + x) % single
                        break
            ac.st("yes" if dp[-1] == 0 else "no")
        return

    @staticmethod
    def lc_2858(n: int, edges: List[List[int]]) -> List[int]:
        """
        url: https://leetcode.cn/problems/minimum-edge-reversals-so-every-node-is-reachable/）
        tag：reroot_dp|dfs|dfs_order|diff_array
        """
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)
        start, end = DFS().gen_bfs_order_iteration(dct)
        diff = [0] * n
        for i, j in edges:
            if start[i] < start[j]:
                a, b = start[j], end[j]
                diff[a] += 1
                if b + 1 < n:
                    diff[b + 1] -= 1
            else:
                a, b = start[i], end[i]
                if 0 <= a - 1:
                    diff[0] += 1
                    diff[a] -= 1
                if b + 1 <= n - 1:
                    diff[b + 1] += 1
        diff = list(accumulate(diff))
        return [diff[start[i]] for i in range(n)]

    @staticmethod
    def cf_1006e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1006/problem/E
        tag: dfs_order|template
        """

        n, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        p = ac.read_list_ints_minus_one()
        for i in range(n - 1):
            dct[p[i]].append(i + 1)
        for i in range(n):
            dct[i].reverse()
        dfs = DfsEulerOrder(dct)
        for _ in range(q):
            u, k = ac.read_list_ints()
            u -= 1
            x = dfs.start[u]
            if n - x < k or dfs.start[dfs.order_to_node[x + k - 1]] > dfs.end[u]:
                ac.st(-1)
            else:
                ac.st(dfs.order_to_node[x + k - 1] + 1)
        return

    @staticmethod
    def cf_1899g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1899/problem/G
        tag: dfs|inclusion_exclusion|classical|point_add_range_sum
        """
        for _ in range(ac.read_int()):
            n, q = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            for _ in range(n - 1):
                i, j = ac.read_list_ints_minus_one()
                dct[i].append(j)
                dct[j].append(i)
            p = ac.read_list_ints_minus_one()

            ind = [-1] * n
            for i in range(n):
                ind[p[i]] = i

            qs = [[] for _ in range(n)]
            ans = [0] * q
            for i in range(q):
                ll, rr, xx = ac.read_list_ints_minus_one()
                qs[xx].append((ll, rr, i))

            tree = PointAddRangeSum(n)
            stack = [(0, -1)]
            while stack:
                i, fa = stack.pop()
                if i >= 0:
                    stack.append((~i, fa))
                    for ll, rr, xx in qs[i]:
                        ans[xx] -= tree.range_sum(ll + 1, rr + 1)
                    tree.point_add(ind[i] + 1, 1)
                    for j in dct[i]:
                        if j != fa:
                            stack.append((j, i))
                else:
                    i = ~i
                    for ll, rr, xx in qs[i]:
                        ans[xx] += tree.range_sum(ll + 1, rr + 1)
            for a in ans:
                ac.st("YES" if a > 0 else "NO")
        return

    @staticmethod
    def lc_301(s):
        """
        url: https://leetcode.cn/problems/remove-invalid-parentheses/
        tag: back_trace|dfs|prune
        """

        def dfs(i):
            nonlocal ans, pre, left, right
            if i == n:
                if left == right:
                    if len(pre) == len(ans[-1]):
                        ans.append("".join(pre))
                    elif len(pre) > len(ans[-1]):
                        ans = ["".join(pre)]
                return
            if right > left or right + n - i < left or len(pre) + n - i < len(ans[-1]):
                return

            dfs(i + 1)
            left += int(s[i] == "(")
            right += int(s[i] == ")")
            pre.append(s[i])
            dfs(i + 1)
            left -= int(s[i] == "(")
            right -= int(s[i] == ")")
            pre.pop()
            return

        n = len(s)
        ans = [""]
        left = right = 0
        pre = []
        dfs(0)
        return list(set(ans))

    @staticmethod
    def lg_p5318(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5318
        tag: bfs|topological_sort|dfs_order
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(y)
        for i in range(n):
            dct[i].sort()

        edge = [ls[::-1] for ls in dct]
        stack = [0]
        dfs = []
        visit = [0] * n
        while stack:
            x = stack.pop()
            if not visit[x]:
                dfs.append(x)
                visit[x] = 1
            while edge[x]:
                y = edge[x].pop()
                if not visit[y]:
                    stack.append(x)
                    stack.append(y)
                    break
        ac.lst([x + 1 for x in dfs])

        stack = [0]
        visit = [0] * n
        bfs = []
        visit[0] = 1
        while stack:
            bfs.extend(stack)
            nex = []
            for i in stack:
                for j in dct[i]:
                    if not visit[j]:
                        nex.append(j)
                        visit[j] = 1
            stack = nex
        ac.lst([x + 1 for x in bfs])
        return

    @staticmethod
    def lc_1080(root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:
        """
        url: https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/description/
        tag: dfs|up_to_down|down_to_up
        """

        def dfs(node, lmt):
            if not node:
                return
            if not node.left and not node.right:
                if node.val < lmt:
                    return
                return node
            left = dfs(node.left, lmt - node.val)
            right = dfs(node.right, lmt - node.val)
            if not left and not right:
                return
            node.left = left
            node.right = right
            return node

        return dfs(root, limit)

    @staticmethod
    def lc_1239(arr: List[str]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters/
        tag: dfs|back_trace|2-base|brute_force
        """

        ans = 0
        arr = [word for word in arr if len(set(word)) == len(word)]
        n = len(arr)

        def dfs(i):
            nonlocal ans, pre
            if i == n:
                if len(pre) > ans:
                    ans = len(pre)
                return
            if not set(arr[i]).intersection(pre):
                pre |= set(arr[i])
                dfs(i + 1)
                pre -= set(arr[i])
            dfs(i + 1)
            return

        pre = set()
        dfs(0)
        return ans

    @staticmethod
    def lc_1240(n: int, m: int) -> int:
        """
        url: https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares/
        tag: dfs|back_trace|prune
        """

        def dfs():
            nonlocal cnt, ans
            if cnt >= ans:  # prune
                return

            pre = PreFixSumMatrix([g[:] for g in grid])
            if pre.query(0, 0, m - 1, n - 1) == m * n:
                # prune
                ans = ans if ans < cnt else cnt
                return

            for i in range(m):
                for j in range(n):
                    if not grid[i][j]:
                        ceil = m - i
                        if n - j < ceil:
                            ceil = n - j
                        # brute_force left_up point
                        for x in range(ceil, 0, -1):
                            if pre.query(i, j, i + x - 1, j + x - 1) == 0 and cnt + 1 < ans:
                                for a in range(i, i + x):
                                    for b in range(j, j + x):
                                        grid[a][b] = 1
                                cnt += 1
                                dfs()
                                cnt -= 1
                                for a in range(i, i + x):
                                    for b in range(j, j + x):
                                        grid[a][b] = 0
                        return

            return

        grid = [[0] * n for _ in range(m)]
        ans = m * n
        cnt = 0
        dfs()
        return ans

    @staticmethod
    def lc_2056(pieces: List[str], positions: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/description/
        tag: back_trace|brute_force
        """

        dct = dict()
        dct["rook"] = [[-1, 0], [1, 0], [0, -1], [0, 1]]
        dct["queen"] = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, 1], [1, 1], [1, -1], [-1, -1]]
        dct["bishop"] = [[-1, 1], [1, 1], [1, -1], [-1, -1]]

        ans = 0
        n = len(pieces)

        def dfs(i):
            nonlocal ans
            if i == n:
                ans += 1
                return
            x, y = positions[i]
            cnt = 0
            for a, b in dct[pieces[i]]:
                for step in range(8):
                    if step == 0 and cnt:
                        continue
                    cnt += 1
                    if not (1 <= x + a * step <= 8 and 1 <= y + b * step <= 8):
                        break
                    lst = [(x + a * s, y + b * s) for s in range(step + 1)]
                    while len(lst) < 8:
                        lst.append(lst[-1])
                    for ii, w in enumerate(lst):
                        if w in pre[ii]:
                            break
                    else:
                        for ii, w in enumerate(lst):
                            pre[ii].add(w)
                        dfs(i + 1)
                        for ii, w in enumerate(lst):
                            pre[ii].discard(w)

            return

        pre = [set() for _ in range(8)]
        dfs(0)
        return ans

    @staticmethod
    def lc_2322(nums: List[int], edges: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/
        tag: dfs_order|brute_force
        """

        n = len(nums)
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)

        order = 0
        start = [-1] * n
        end = [-1] * n
        parent = [-1] * n
        stack = [(0, -1)]
        sub = [0] * n
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                start[i] = order
                end[i] = order
                order += 1
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        parent[j] = i
                        stack.append((j, i))
            else:
                i = ~i
                sub[i] = nums[i]
                for j in dct[i]:
                    if j != fa:
                        sub[i] ^= sub[j]
                if parent[i] != -1:
                    end[parent[i]] = end[i]

        total = sub[0]

        ans = math.inf
        for i in range(n - 1):
            x, y = edges[i]
            if parent[x] == y:
                x, y = y, x
            for j in range(i + 1, n - 1):
                a, b = edges[j]
                if parent[a] == b:
                    a, b = b, a
                yy = sub[y]
                bb = sub[b]
                if start[y] <= start[b] <= end[y]:
                    yy ^= bb
                if start[b] <= start[y] <= end[b]:
                    bb ^= yy
                cur = [yy, bb, total ^ yy ^ bb]
                ans = min(ans, max(cur) - min(cur))
        return ans

    @staticmethod
    def lc_2458(root: Optional[TreeNode], queries: List[int]) -> List[int]:
        """
        url: https://leetcode.cn/height-of-binary-tree-after-subtree-removal-queries/
        tag: dfs|tree_dp|up_to_down|down_to_up|dfs
        """
        ans = defaultdict(int)
        stack = [(root, 0)]
        x = 0
        while stack:
            node, h = stack.pop()
            ans[node.val] = x
            if h > x:
                x = h
            if node.right:
                stack.append((node.right, h + 1))
            if node.left:
                stack.append((node.left, h + 1))

        stack = [(root, 0)]
        x = 0
        while stack:
            node, h = stack.pop()
            if x > ans[node.val]:
                ans[node.val] = x
            if h > x:
                x = h
            if node.left:
                stack.append((node.left, h + 1))
            if node.right:
                stack.append((node.right, h + 1))

        return [ans[i] for i in queries]

    @staticmethod
    def lc_2581(edges: List[List[int]], guesses: List[List[int]], k: int) -> int:
        """
        url: https://leetcode.cn/problems/count-number-of-possible-root-nodes
        tag: dfs_order|diff_array|counter|reroot_dp
        """

        n = len(edges) + 1
        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)

        visit, interval = DFS().gen_bfs_order_iteration(dct)
        diff = [0] * n
        for u, v in guesses:
            if visit[u] <= visit[v]:
                a, b = interval[v]
                lst = [[0, a - 1], [b + 1, n - 1]]
            else:
                a, b = interval[u]
                lst = [[a, b]]

            for x, y in lst:
                if x <= y:
                    diff[x] += 1
                    if y + 1 < n:
                        diff[y + 1] -= 1

        for i in range(1, n):
            diff[i] += diff[i - 1]
        return sum(x >= k for x in diff)

    @staticmethod
    def cf_219d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/219/problem/D
        tag: reroot_dp|dfs|dfs_order|diff_array
        """

        n = ac.read_int()
        edges = [ac.read_list_ints_minus_one() for _ in range(n - 1)]

        dct = [[] for _ in range(n)]
        for i, j in edges:
            dct[i].append(j)
            dct[j].append(i)
        start, end = DFS().gen_bfs_order_iteration(dct)
        diff = [0] * n
        for i, j in edges:
            if start[i] < start[j]:
                a, b = start[j], end[j]
                diff[a] += 1
                if b + 1 < n:
                    diff[b + 1] -= 1
            else:
                a, b = start[i], end[i]
                if 0 <= a - 1:
                    diff[0] += 1
                    diff[a] -= 1
                if b + 1 <= n - 1:
                    diff[b + 1] += 1
        diff = ac.accumulate(diff)[1:]
        res = [diff[start[i]] for i in range(n)]
        low = min(res)
        ac.st(low)
        ac.lst([i + 1 for i in range(n) if res[i] == low])
        return

    @staticmethod
    def cf_570d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/570/problem/D
        tag: dfs_order|binary_search|offline_query|classical
        """

        n, m = ac.read_list_ints()
        parent = ac.read_list_ints_minus_one()
        edge = [[] for _ in range(n)]
        for i in range(n - 1):
            edge[parent[i]].append(i + 1)
        s = ac.read_str()

        queries = [[] for _ in range(n)]
        for i in range(m):
            v, h = ac.read_list_ints()
            queries[v - 1].append([h - 1, i])

        ans = [0] * m
        depth = [0] * n

        stack = [(0, 1, 0)]
        while stack:
            i, state, height = stack.pop()
            if state:
                for h, j in queries[i]:
                    ans[j] ^= depth[h]
                depth[height] ^= 1 << (ord(s[i]) - ord("a"))
                stack.append((i, 0, height))
                for j in edge[i]:
                    stack.append((j, 1, height + 1))
            else:
                for h, j in queries[i]:
                    ans[j] ^= depth[h]
        for a in ans:
            ac.st("Yes" if a & (a - 1) == 0 else "No")
        return

    @staticmethod
    def cf_208e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/208/problem/E
        tag: dfs_order|lca|binary_search|counter
        """

        n = ac.read_int()
        parent = ac.read_list_ints()

        edge = [[] for _ in range(n + 1)]
        for i in range(n):
            edge[parent[i]].append(i + 1)
            edge[i + 1].append(parent[i])
        del parent

        tree = TreeAncestor(edge)
        start, end = DFS().gen_bfs_order_iteration(edge)

        dct = [[] for _ in range(n + 1)]
        for i in range(n + 1):
            dct[tree.depth[i]].append(start[i])
        for i in range(n + 1):
            dct[i].sort()

        ans = []
        for _ in range(ac.read_int()):
            v, p = ac.read_list_ints()
            if tree.depth[v] - 1 < p:
                ans.append(0)
                continue
            u = tree.get_kth_ancestor(v, p)
            low, high = start[u], end[u]
            cur = bisect.bisect_right(
                dct[tree.depth[v]], high) - bisect.bisect_left(dct[tree.depth[v]], low)
            ans.append(max(cur - 1, 0))
        ac.lst(ans)
        return

    @staticmethod
    def lg_p8838(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8838
        tag: dfs|back_trace
        """
        n, k = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        if n < k:
            ac.st(-1)
            return
        for item in permutations(list(range(n)), k):
            if all(a[item[i]] >= b[i] for i in range(k)):
                ac.lst([x + 1 for x in item])
                break
        else:
            ac.st(-1)
        return

    @staticmethod
    def ac_4313(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/4313/
        tag: dfs_order|template
        """
        n, q = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        nums = ac.read_list_ints_minus_one()
        for i in range(n - 1):
            dct[nums[i]].append(i + 1)
        for i in range(n):
            dct[i].sort(reverse=True)

        start, end = DFS().gen_bfs_order_iteration(dct)
        ind = {num: i for i, num in enumerate(start)}
        for _ in range(q):
            u, k = ac.read_list_ints()
            u -= 1
            if end[u] - start[u] + 1 < k:
                ac.st(-1)
            else:
                ac.st(ind[start[u] + k - 1] + 1)
        return

    @staticmethod
    def abc_133f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc133/tasks/abc133_f
        tag: euler_order|online_tree_dis|binary_search|prefix_sum
        """

        n, q = ac.read_list_ints()
        dct = [dict() for _ in range(n)]
        edges = [[] for _ in range(n)]
        for _ in range(n - 1):
            a, b, c, d = ac.read_list_ints()
            a -= 1
            b -= 1
            dct[a][b] = [c, d]
            dct[b][a] = [c, d]
            edges[a].append(b)
            edges[b].append(a)
        tree = TreeAncestor(edges)

        dis = [0] * n
        stack = [[0, -1]]
        while stack:
            x, fa = stack.pop()
            for y in dct[x]:
                if y != fa:
                    c, d = dct[x][y]
                    dct[x][y] = [c, d]
                    dct[y][x] = [-c, d]
                    dis[y] = dis[x] + d
                    stack.append([y, x])

        euler_order = DfsEulerOrder(edges).euler_order[:]
        m = len(euler_order)
        euler_ind = [-1] * n
        color_pos_ind = defaultdict(list)
        color_neg_ind = defaultdict(list)
        color_pos_pre = defaultdict(lambda: [0])
        color_neg_pre = defaultdict(lambda: [0])
        for i in range(m):
            if euler_ind[euler_order[i]] == -1:
                euler_ind[euler_order[i]] = i
            if i:
                a, b = euler_order[i - 1], euler_order[i]
                c, d = dct[a][b]
                if c > 0:
                    color_pos_ind[c].append(i)
                    color_pos_pre[c].append(color_pos_pre[c][-1] + d)
                else:
                    color_neg_ind[-c].append(i)
                    color_neg_pre[-c].append(color_neg_pre[-c][-1] + d)

        for _ in range(q):
            x, y, u, v = ac.read_list_ints()
            u -= 1
            v -= 1
            ancestor = tree.get_lca(u, v)
            if euler_ind[u] > euler_ind[v]:
                u, v = v, u
            cur_dis = dict()
            for w in [u, v, ancestor]:
                start, end = euler_ind[0] + 1, euler_ind[w]
                pos_range = [bisect_left(color_pos_ind[x], start), bisect_right(color_pos_ind[x], end)]
                neg_range = [bisect_left(color_neg_ind[x], start), bisect_right(color_neg_ind[x], end)]

                pre_color = color_pos_pre[x][pos_range[1]] - color_pos_pre[x][pos_range[0]]
                pre_color -= color_neg_pre[x][neg_range[1]] - color_neg_pre[x][neg_range[0]]

                post_color_cnt = pos_range[1] - pos_range[0] - (neg_range[1] - neg_range[0])
                cur_dis[w] = dis[w] - pre_color + post_color_cnt * y
            ac.st(cur_dis[u] + cur_dis[v] - 2 * cur_dis[ancestor])
        return

    @staticmethod
    def ac_23(matrix, string):
        """
        url: https://www.acwing.com/problem/content/description/21/
        tag: back_trace|template
        """
        if not matrix:
            return False

        m, n = len(matrix), len(matrix[0])

        def dfs(ind, x, y):
            nonlocal ans
            if ind == k or ans:
                ans = True
                return
            for a, b in [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]]:
                if 0 <= a < m and 0 <= b < n and not visit[a][b] and matrix[a][b] == string[ind]:
                    visit[a][b] = 1
                    dfs(ind + 1, a, b)
                    visit[a][b] = 0
            return

        ans = False
        visit = [[0] * n for _ in range(m)]
        k = len(string)
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == string[0]:
                    visit[i][j] = 1
                    dfs(1, i, j)
                    visit[i][j] = 0
                    if ans:
                        return True
        return False

    @staticmethod
    def abc_337g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc337/tasks/abc337_g
        tag: dfs_order|contribution_method|classical|tree_array
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        start, end = DFS().gen_bfs_order_iteration(dct, 0)

        diff = [0] * (n + 1)

        tree = PointAddRangeSum(n)
        for i in range(n):
            v = i
            for j in dct[i]:
                if start[j] > start[i]:
                    x = tree.range_sum(start[j] + 1, end[j] + 1)
                    if 0 <= start[j] - 1:
                        diff[0] += x  # [0, start[j]-1]
                        diff[start[j]] -= x
                    if end[j] + 1 <= n - 1:
                        diff[end[j] + 1] += x  # [end[j]+1, n-1]
                        diff[n] -= x
                    v -= x
            # [start[i], end[i]]
            diff[start[i]] += v
            diff[end[i] + 1] -= v
            tree.point_add(start[i] + 1, 1)

        for i in range(1, n):
            diff[i] += diff[i - 1]
        ac.lst([diff[start[i]] for i in range(n)])
        return

    @staticmethod
    def cf_246e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/246/E
        tag: tree_array|offline_query|range_unique|dfs_order
        """
        n = ac.read_int()
        n += 1
        names = [""] * n
        parent = [-1] * n
        dct = [[] for _ in range(n)]
        for i in range(1, n):
            name, fa = ac.read_list_strs()
            fa = int(fa)
            names[i] = name
            parent[i] = fa
            dct[fa].append(i)
        ind = {name: i for i, name in enumerate(list(set(names)))}
        names = [ind[x] for x in names]
        del ind

        order = 0
        start = [-1] * n
        end = [-1] * n
        stack = [(0, -1)]
        depth = [0] * n
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                start[i] = order
                end[i] = order
                order += 1
                stack.append((~i, fa))
                for j in dct[i]:
                    depth[j] = depth[i] + 1
                    stack.append((j, i))
            else:
                i = ~i
                if parent[i] != -1:
                    end[parent[i]] = end[i]

        m = ac.read_int()
        queries = [ac.read_list_ints() for _ in range(m)]
        dct = [[] for _ in range(n)]
        for i in range(m):
            v, k = queries[i]
            if depth[v] + k <= n - 1:
                dct[depth[v] + k].append((start[v], end[v], i))
        nodes = [[] for _ in range(n)]
        for i in range(n):
            nodes[depth[i]].append(i)

        ans = [0] * m
        pre = [-1] * n
        for d in range(n):
            lst = nodes[d]

            lst.sort(key=lambda it: start[it])
            dfs_order = [start[x] for x in lst]
            check = [(bisect.bisect_left(dfs_order, s), bisect.bisect_right(dfs_order, e) - 1, i) for s, e, i in dct[d]]
            for x in lst:
                pre[names[x]] = -1
            k = len(lst)
            tree = PointAddRangeSum(k)
            check.sort(key=lambda it: it[1])

            i = 0
            for ll, rr, ii in check:
                while i <= rr:
                    num = names[lst[i]]
                    if pre[num] != -1:
                        tree.point_add(pre[num] + 1, -1)
                    pre[num] = i
                    tree.point_add(i + 1, 1)
                    i += 1
                ans[ii] = tree.range_sum(ll + 1, rr + 1)
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def cf_1076e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1076/E
        tag: tree_diff_array|dfs|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            dct[x].append(y)
            dct[y].append(x)
        ops = [[] for _ in range(n)]
        for _ in range(ac.read_int()):
            v, d, x = ac.read_list_ints()
            v -= 1
            ops[v].append((d, x))
        pre = [0] * (n + 1)
        ans = [0] * n
        stack = [(0, -1)]
        depth = [0] * n
        while stack:
            x, fa = stack.pop()
            if x >= 0:
                stack.append((~x, fa))
                if depth[x]:
                    pre[depth[x]] += pre[depth[x] - 1]
                for d, v in ops[x]:
                    pre[depth[x]] += v
                    if depth[x] + d + 1 < n:
                        pre[depth[x] + d + 1] -= v
                ans[x] = pre[depth[x]]
                for y in dct[x]:
                    if y != fa:
                        stack.append((y, x))
                        depth[y] = depth[x] + 1
            else:
                x = ~x
                if depth[x]:
                    pre[depth[x]] -= pre[depth[x] - 1]
                for d, v in ops[x]:
                    pre[depth[x]] -= v
                    if depth[x] + d + 1 < n:
                        pre[depth[x] + d + 1] += v
        ac.lst(ans)
        return

    @staticmethod
    def abc_328e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc328/tasks/abc328_e
        tag: dfs|back_trace|union_find|brute_force
        """
        n, m, k = ac.read_list_ints()
        edges = [ac.read_list_ints() for _ in range(m)]

        def dfs(i):
            if uf.part == 1:
                ans[0] = min(ans[0], pre[0] % k)
                return
            if i == m:
                return
            dfs(i + 1)
            u, v, w = edges[i]
            if not uf.is_connected(u - 1, v - 1):
                cur = uf.root_or_size[:]
                uf.union(u - 1, v - 1)
                pre[0] += w
                dfs(i + 1)
                pre[0] -= w
                uf.root_or_size[:] = cur[:]
                uf.part += 1
            return

        ans = [k + 1]
        pre = [0]
        uf = UnionFind(n)
        dfs(0)
        ac.st(ans[0])
        return

    @staticmethod
    def abc_284e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc284/tasks/abc284_e
        tag: dfs|back_trace|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        ans = [0]
        visit = [0] * n
        visit[0] = 1
        ceil = 10 ** 6

        @ac.bootstrap
        def dfs(x):
            if ans[0] > ceil:
                yield
            ans[0] += 1
            for y in dct[x]:
                if not visit[y]:
                    visit[y] = 1
                    yield dfs(y)
                    visit[y] = 0
            yield

        dfs(0)
        ac.st(min(ans[0], ceil))
        return

    @staticmethod
    def abc_268d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc268/tasks/abc268_d
        tag: dfs|back_trace|prune|classical
        """
        n, m = ac.read_list_ints()
        words = [ac.read_str() for _ in range(n)]
        forbid = set([ac.read_str() for _ in range(m)])

        ans = ""
        for lst in permutations(words, n):
            pre_len = ac.accumulate([len(w) for w in lst])

            if ans:
                break

            def dfs(i):
                nonlocal pre, ans
                if ans:
                    return
                if i == n:
                    if 3 <= len(pre) <= 16 and pre not in forbid:
                        ans = pre
                    return
                if len(pre) + n - i + pre_len[-1] - pre_len[i] > 16:
                    return

                for c in range(1, 20):
                    if len(pre) + c + pre_len[-1] - pre_len[i] + n - i - 1 <= 16:
                        tmp = pre
                        pre += "_" * c + lst[i]
                        dfs(i + 1)
                        pre = tmp
                    else:
                        break
                return

            pre = lst[0]
            dfs(1)
        ac.st(ans if ans else -1)
        return

    @staticmethod
    def abc_244g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc244/tasks/abc244_g
        tag: construction|euler_order|brain_teaser|classical
        """
        n, m = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        uf = UnionFind(n)
        for _ in range(m):
            i, j = ac.read_list_ints_minus_one()
            if uf.union(i, j):
                dct[i].append(j)
                dct[j].append(i)
        s = [int(w) for w in ac.read_str()]
        t = [0] * n
        euler_order = []
        root = 0
        stack = [(root, -1)]
        parent = [-1] * n
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                euler_order.append(i)
                t[i] ^= 1
                stack.append((~i, fa))
                for j in dct[i]:
                    if j != fa:
                        parent[j] = i
                        stack.append((j, i))
            else:
                i = ~i
                if i != root:
                    euler_order.append(parent[i])
                    t[parent[i]] ^= 1
                    if t[i] != s[i]:
                        euler_order.append(i)
                        t[i] ^= 1
                        euler_order.append(parent[i])
                        t[parent[i]] ^= 1
                elif t[i] != s[i]:
                    euler_order.append(dct[i][0])
                    euler_order.append(i)
                    t[i] ^= 1
                    euler_order.append(dct[i][0])
        assert t == s
        ac.st(len(euler_order))
        ac.lst([x + 1 for x in euler_order])
        return

    @staticmethod
    def abc_240e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc240/tasks/abc240_e
        tag: dfs_order|leaf|classical
        """
        n = ac.read_int()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        start = [0] * n
        end = [0] * n
        order = 0
        stack = [(0, -1)]
        while stack:
            i, fa = stack.pop()
            if i >= 0:
                stack.append((~i, fa))
                cnt = 0
                for j in dct[i]:
                    if j != fa:
                        stack.append((j, i))
                        cnt += 1
                if not cnt:
                    start[i] = order
                    end[i] = order
                    order += 1
                    stack.pop()
            else:
                i = ~i
                s = math.inf
                e = -math.inf
                for j in dct[i]:
                    if j != fa:
                        s = min(s, start[j])
                        e = max(e, end[j])
                start[i] = s
                end[i] = e
        for i in range(n):
            ac.lst([start[i] + 1, end[i] + 1])
        return

    @staticmethod
    def abc_236d(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc236/tasks/abc236_d
        tag: back_trace|prune|brute_force|classical
        """
        n = ac.read_int()
        grid = [[0] * 2 * n for _ in range(2 * n)]
        for i in range(2 * n - 1):
            lst = ac.read_list_ints()
            for j in range(i + 1, 2 * n):
                grid[i][j] = lst[j - i - 1]

        def dfs(x):
            if x == n:
                ans[0] = max(ans[0], pre[0])
                return
            ind = [x for x in range(2 * n) if not visit[x]]
            a = ind[0]
            for b in ind[1:]:
                pre[0] ^= grid[a][b]
                visit[a] = visit[b] = 1
                dfs(x + 1)
                pre[0] ^= grid[a][b]
                visit[a] = visit[b] = 0
            return

        ans = [-math.inf]
        pre = [0]
        visit = [0] * 2 * n
        dfs(0)
        ac.st(ans[0])
        return

    @staticmethod
    def cf_383c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/383/C
        tag: dfs_order|odd_even|range_add|point_get
        """
        n, q = ac.read_list_ints()
        nums = ac.read_list_ints()
        dct = [[] for _ in range(n)]
        for _ in range(n - 1):
            i, j = ac.read_list_ints_minus_one()
            dct[i].append(j)
            dct[j].append(i)
        res = DFS().gen_bfs_order_iteration(dct, 0)
        start, end, depth, parent = res
        dfn = [0] * n
        for i in range(n):
            dfn[start[i]] = i

        odd_tree = RangeAddPointGet(n)
        odd_tree.build([nums[dfn[i]] for i in range(n)])
        even_tree = RangeAddPointGet(n)
        even_tree.build([nums[dfn[i]] for i in range(n)])

        for _ in range(q):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                v, c = lst[1], lst[2]
                v -= 1
                if depth[v] % 2:
                    even_tree.range_add(start[v], end[v], -c)
                    odd_tree.range_add(start[v], end[v], c)
                else:
                    even_tree.range_add(start[v], end[v], c)
                    odd_tree.range_add(start[v], end[v], -c)
            else:
                v = lst[1]
                v -= 1
                if depth[v] % 2:
                    ans = odd_tree.point_get(start[v])
                else:
                    ans = even_tree.point_get(start[v])
                ac.st(ans)
        return

    @staticmethod
    def cf_3c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/3/C
        tag: dfs|back_trace|brute_force|implemention
        """

        def check():
            for i in range(3):
                if all(grid[i][j] == "X" for j in range(3)):
                    return "the first player won"
                if all(grid[i][j] == "0" for j in range(3)):
                    return "the second player won"
            for j in range(3):
                if all(grid[i][j] == "X" for i in range(3)):
                    return "the first player won"
                if all(grid[i][j] == "0" for i in range(3)):
                    return "the second player won"

            if all(grid[i][i] == "X" for i in range(3)):
                return "the first player won"
            if all(grid[i][i] == "0" for i in range(3)):
                return "the second player won"
            if all(grid[i][2 - i] == "X" for i in range(3)):
                return "the first player won"
            if all(grid[i][2 - i] == "0" for i in range(3)):
                return "the second player won"
            if all(grid[i][j] != "." for i in range(3) for j in range(3)):
                return "draw"
            return ""

        def dfs():
            if state in ans:
                return
            cur_state = "".join("".join(ls) for ls in grid)
            if cur_state in ans:
                return
            res = check()
            if res:
                ans[cur_state] = res
                return
            order[0] = 1 - order[0]
            ans[cur_state] = "first" if order[0] == 0 else "second"
            for i in range(3):
                for j in range(3):
                    if grid[i][j] == "." and st[order[0]] == cur[i][j]:
                        grid[i][j] = st[order[0]]
                        dfs()
                        grid[i][j] = "."
            order[0] = 1 - order[0]
            return

        grid = [["."] * 3 for _ in range(3)]
        st = "X0"
        order = [1]
        cur = [ac.read_str() for _ in range(3)]
        state = "".join(cur)
        ans = dict()
        dfs()
        if state not in ans:
            ac.st("illegal")
        else:
            ac.st(ans[state])
        return

    @staticmethod
    def cf_459c(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/459/C
        tag: back_trace|brute_force|classical|implemention
        """
        n, k, d = ac.read_list_ints()

        pre = []
        res = []

        def dfs():
            if len(res) == n:
                return
            if len(pre) == d:
                res.append(pre[:])
                return

            for xx in range(1, k + 1):
                pre.append(xx)
                dfs()
                pre.pop()
                if len(res) == n:
                    break
            return

        dfs()
        if len(res) < n:
            ac.st(-1)
            return
        ans = [[0] * n for _ in range(d)]
        for ls in res:
            if not n:
                break
            n -= 1
            for x in range(d):
                ans[x][n] = ls[x]
        for ls in ans:
            ac.lst(ls)
        return

    @staticmethod
    def cf_1918f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1918/F
        tag: dfs_order|greedy|tree_lca|implemention|observation|brain_teaser
        """
        n, k = ac.read_list_ints()
        k += 1
        parent = [-1] + ac.read_list_ints_minus_one()
        dct = [[] for _ in range(n)]
        for i in range(1, n):
            dct[parent[i]].append(i)
        depth = [0] * n
        sub = [0] * n
        stack = [0]
        while stack:
            x = stack.pop()
            if x >= 0:
                stack.append(~x)
                for y in dct[x]:
                    depth[y] = depth[x] + 1
                    stack.append(y)
            else:
                x = ~x
                sub[x] = depth[x]
                for y in dct[x]:
                    sub[x] = max(sub[x], sub[y])
        for i in range(1, n):
            dct[i].sort(key=lambda it: -sub[it])

        order = 0
        start = [-1] * n
        stack = [0]
        while stack:
            i = stack.pop()
            start[i] = order
            order += 1
            for j in dct[i]:
                parent[j] = i
                stack.append(j)

        leaf = [i for i in range(n) if not dct[i]]
        leaf.sort(key=lambda it: start[it])
        m = len(leaf)
        queries = [(leaf[i], leaf[i + 1]) for i in range(m - 1)]
        ancestor = OfflineLCA().bfs_iteration(dct, queries)
        ans = 2 * (n - 1)
        dis = [depth[leaf[-1]]]
        for i in range(m - 1):
            cur = max(0, depth[leaf[i]] - 2 * depth[ancestor[i]])
            dis.append(cur)
        dis.sort(reverse=True)
        ans -= sum(dis[:k])
        ac.st(ans)
        return

    @staticmethod
    def lg_p1444(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1444
        tag: dfs|back_trace|circle_check|brain_teaser|observation
        """
        n = ac.read_int()
        nums = [ac.read_list_ints() for _ in range(n)]
        edges = []
        dct = defaultdict(list)
        for i, (x, y) in enumerate(nums):
            dct[y].append((x, i))
        for y in dct:
            dct[y].sort()
            k = len(dct[y])
            for i in range(k - 1):
                edges.append((dct[y][i][1], dct[y][i + 1][1]))
        nums.sort(key=lambda it: (it[1], it[0]))

        def check():
            walk = [-1] * n
            skip = [-1] * n
            for xx, yy in pre:
                skip[xx] = yy
                skip[yy] = xx
            for xx, yy in edges:
                if skip[xx] != yy:
                    walk[xx] = yy
                else:
                    return 1

            for s in range(n):
                cur = {s}
                while s != -1:
                    if walk[s] == -1:
                        break
                    s = skip[walk[s]]
                    if s in cur:
                        return 1
                    cur.add(s)
            return 0

        visit = [0] * n

        def dfs():
            if len(pre) * 2 == n:
                ans[0] += check()
                return

            for ind in range(n):
                if not visit[ind]:
                    visit[ind] = 1
                    for nex in range(ind + 1, n):
                        if not visit[nex]:
                            visit[nex] = 1
                            pre.append((ind, nex))
                            dfs()
                            visit[nex] = 0
                            pre.pop()
                    visit[ind] = 0
                    break
            return

        ans = [0]
        pre = []
        dfs()
        ac.st(ans[0])
        return

    @staticmethod
    def cf_1882d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1882/D
        tag: dfs_order|diff_array|contribution_method|greedy
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            nums = ac.read_list_ints()
            dct = [[] for _ in range(n)]
            edges = [ac.read_list_ints_minus_one() for _ in range(n - 1)]
            for i, j in edges:
                dct[i].append(j)
                dct[j].append(i)

            order = 0
            start = [-1] * n
            end = [-1] * n
            parent = [-1] * n
            stack = [0]
            # depth of every original node
            depth = [0] * n
            # index is dfs order and value is original node
            order_to_node = [-1] * n
            sub = [1] * n
            diff = [0] * n
            while stack:
                val = stack.pop()
                if val >= 0:
                    i, fa = val // n, val % n
                    stack.append(~val)
                    start[i] = order
                    order_to_node[order] = i
                    end[i] = order
                    order += 1
                    for j in dct[i]:
                        # the order of son nodes can be assigned for lexicographical order
                        if j != fa:
                            parent[j] = i
                            depth[j] = depth[i] + 1
                            stack.append(j * n + i)
                else:
                    val = ~val
                    i, fa = val // n, val % n
                    if parent[i] != -1:
                        end[parent[i]] = end[i]
                    for j in dct[i]:
                        # the order of son nodes can be assigned for lexicographical order
                        if j != fa:
                            sub[i] += sub[j]
                            cur = nums[i] ^ nums[j]
                            s, e = start[j], end[j]
                            diff[0] += sub[j] * cur
                            diff[s] += (n - 2 * sub[j]) * cur
                            if e + 1 < n:
                                diff[e + 1] -= (n - 2 * sub[j]) * cur
            for i in range(1, n):
                diff[i] += diff[i - 1]
            ac.lst([diff[start[i]] for i in range(n)])
        return

    @staticmethod
    def cf_1009f(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1009/F
        tag: heuristic_merge|classical
        """
        n = ac.read_int()
        graph = UnWeightedTree(n)
        for _ in range(n - 1):
            x, y = ac.read_list_ints_minus_one()
            graph.add_undirected_edge(x, y)
        ans = graph.heuristic_merge()
        ac.flatten(ans)
        return
"""
Algorithm：meet_in_middle
Description：data_range|brute_force 

====================================LeetCode====================================
1755（https://leetcode.cn/problems/closest-subsequence-sum/）meet_in_middle
2035（https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/）meet_in_middle|sort|binary_search|two_pointers
956（https://leetcode.cn/problems/tallest-billboard/description/）meet_in_middle|bag_dp

=====================================LuoGu======================================
P5194（https://www.luogu.com.cn/problem/P5194）fibonacci|meet_in_middle|brute_force|binary_search

P5691（https://www.luogu.com.cn/problem/P5691）meet_in_middle|sorted_list|two_pointers|brute_force

=====================================CodeForces=====================================
1006F（https://codeforces.com/contest/1006/problem/F）prefix_sum|hash|counter|meet_in_middle
525E（https://codeforces.com/problemset/problem/525/E）meet_in_middle
888E（https://codeforces.com/problemset/problem/888/E）meet_in_middle|classical


=====================================AtCoder=====================================
ABC326F（https://atcoder.jp/contests/abc326/tasks/abc326_f）meet_in_middle|brain_teaser|classical
ABC271F（https://atcoder.jp/contests/abc271/tasks/abc271_f）meet_in_middle|brute_force|classical


=====================================AcWing=====================================
173（https://www.acwing.com/problem/content/173/）meet_in_middle


"""

import bisect
import random
from collections import defaultdict, Counter
from itertools import combinations
from typing import List

from src.utils.fast_io import FastIO



class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_956_1(rods: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/tallest-billboard/description/
        tag: meet_in_middle|dp
        """

        def check(lst):
            cur = {(0, 0)}
            for num in lst:
                cur |= {(a + num, b) for a, b in cur} | {(a, b + num) for a, b in cur}
            dct = defaultdict(int)
            for a, b in cur:
                dct[a - b] = max(dct[a - b], a)
            return dct

        m = len(rods)
        pre = check(rods[:m // 2])
        post = check(rods[m // 2:])
        ans = 0
        for k in pre:
            if -k in post:
                ans = max(ans, pre[k] + post[-k])
        return ans

    @staticmethod
    def lc_956_2(rods: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/tallest-billboard/description/
        tag: meet_in_middle|dp
        """

        pre = defaultdict(int)
        pre[0] = 0
        for num in rods:
            cur = pre.copy()
            for p in pre:
                cur[p + num] = max(cur[p + num], pre[p] + num)
                cur[p - num] = max(cur[p - num], pre[p])
            pre = cur
        return pre[0]

    @staticmethod
    def lc_2035(nums: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/
        tag: meet_in_middle|sort|binary_search|two_pointers|brute_force|group_by_length
        """

        def check(lst):
            m = len(lst)
            total = sum(lst)
            res = [set() for _ in range(m + 1)]
            res[0].add(0)
            res[m].add(total)
            for x in range(1, m // 2 + 1):
                for item in combinations(lst, x):
                    cur = sum(item)
                    res[k].add(cur)
                    res[m - k].add(total - cur)
            return res

        def find(left, right):
            a, b = len(left), len(right)
            res = math.inf
            i = 0
            j = b - 1
            while i < a and j >= 0:
                cur = abs(target - left[i] - right[j])
                res = res if res < cur else cur
                if left[i] + right[j] == target:
                    return 0
                if left[i] + right[j] > target:
                    j -= 1
                elif left[i] + right[j] < target:
                    i += 1
            return res

        n = len(nums) // 2
        pre = check(nums[:n])
        post = check(nums[n:])
        ans = math.inf
        target = sum(nums) / 2
        for k in range(n + 1):
            ans = min(ans, 2 * find(sorted(list(pre[k])), sorted(list(post[n - k]))))
        return int(ans)

    @staticmethod
    def lg_p5194(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5194
        tag: fibonacci|meet_in_middle|brute_force|binary_search
        """

        def check(lst):
            cur = {0}
            for x in lst:
                cur |= {p + x for p in cur if p + x <= c}
            return sorted(cur)

        n, c = ac.read_list_ints()
        val = [ac.read_int() for _ in range(n)]
        val = [x for x in val if x <= c]
        n = len(val)
        res1 = check(val[:n // 2])
        res2 = check(val[n // 2:])
        ans = 0
        n = len(res1)
        j = n - 1
        for num in res2:
            while num + res1[j] > c:
                j -= 1
            ans = max(ans, num + res1[j])
        ac.st(ans)
        return

    @staticmethod
    def cf_1006f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1006/problem/F
        tag: prefix_sum|hash|counter|meet_in_middle|classical
        """
        ac.get_random_seed()
        m, n, k = ac.read_list_ints()
        grid = [ac.read_list_ints() for _ in range(m)]
        pre = [[dict() for _ in range(n)] for _ in range(m)]
        stack = [(0, 0, grid[0][0])]
        half = (m + n - 2) // 2
        while stack:
            x, y, val = stack.pop()
            if x + y == half:
                pre[x][y][val ^ ac.random_seed] = pre[x][y].get(val ^ ac.random_seed, 0) + 1
                continue

            if x + 1 < m:
                stack.append((x + 1, y, val ^ grid[x + 1][y]))
            if y + 1 < n:
                stack.append((x, y + 1, val ^ grid[x][y + 1]))

        ans = 0
        stack = [(m - 1, n - 1, k ^ grid[m - 1][n - 1])]
        while stack:
            x, y, val = stack.pop()
            if x + y == half:
                val ^= grid[x][y]
                ans += pre[x][y].get(val ^ ac.random_seed, 0)
                continue

            if x - 1 >= 0:
                stack.append((x - 1, y, val ^ grid[x - 1][y]))
            if y - 1 >= 0:
                stack.append((x, y - 1, val ^ grid[x][y - 1]))
        ac.st(ans)
        return

    @staticmethod
    def ac_173(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/173/
        tag: meet_in_middle
        """

        def check(tmp):
            cur = {0}
            for x in tmp:
                cur |= {p + x for p in cur if p + x <= w}
            return cur

        w, n = ac.read_list_ints()
        lst = [ac.read_int() for _ in range(n)]
        lst.sort()
        pre = sorted(list(check(lst[:n // 2])))
        post = sorted(list(check(lst[n // 2:])))
        if len(pre) > len(post):
            pre, post = post, pre
        ans = 0
        n = len(post)
        j = n - 1
        for num in pre:
            while num + post[j] > w:
                j -= 1
            ans = max(ans, num + post[j])
        ac.st(ans)
        return

    @staticmethod
    def lg_p5691(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5691
        tag: meet_in_middle|sorted_list|two_pointers|brute_force
        """

        def check(lst):
            dct = defaultdict(int)
            dct[0] = 1
            for k, p in lst:
                cur = defaultdict(int)
                for pp in dct:
                    for x in range(1, m + 1):
                        cur[pp + k * x ** p] += dct[pp]
                dct = cur
            return dct

        n = ac.read_int()
        m = ac.read_int()
        pos = [ac.read_list_ints() for _ in range(n)]
        pre = check(pos[:n // 2])
        post = check(pos[n // 2:])
        ans = sum(pre[x] * post[-x] for x in pre)
        ac.st(ans)
        return

    @staticmethod
    def abc_326f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc326/tasks/abc326_f
        tag: meet_in_middle|brain_teaser|classical
        """
        n, x, y = ac.read_list_ints()
        a = ac.read_list_ints()

        def check(lst):
            k = len(lst)
            res = {0: 0}
            for j in range(k):
                cur = dict()
                cur.update({num + a[lst[j]]: res[num] | (1 << lst[j]) for num in res})
                cur.update({num - a[lst[j]]: res[num] for num in res})
                res = cur
            return res

        axis = list(range(1, n, 2))
        m = len(axis)
        pre = axis[:m // 2]
        post = axis[m // 2:]
        res1 = check(pre)
        res2 = check(post)
        state = 0
        for xx in res1:
            if x - xx in res2:
                state |= res1[xx] | res2[x - xx]
                break
        else:
            ac.no()
            return

        axis = list(range(0, n, 2))
        m = len(axis)
        pre = axis[:m // 2]
        post = axis[m // 2:]
        res1 = check(pre)
        res2 = check(post)
        for yy in res1:
            if y - yy in res2:
                state |= res1[yy] | res2[y - yy]
                break
        else:
            ac.no()
            return

        ac.yes()
        ans = ""
        pre = 1
        for i in range(n):
            if i % 2 == 0:
                if (state >> i) & 1 == pre:
                    ans += "L"
                else:
                    ans += "R"
            else:
                if (state >> i) & 1 == pre:
                    ans += "R"
                else:
                    ans += "L"
            pre = (state >> i) & 1
        ac.st(ans)
        return

    @staticmethod
    def abc_271f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc271/tasks/abc271_f
        tag: meet_in_middle|brute_force|classical
        """
        n = ac.read_int()
        grid = [ac.read_list_ints() for _ in range(n)]
        left = [[Counter() for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if i == j == 0:
                    left[i][j] = Counter([grid[i][j]])
                    continue
                num = grid[i][j]
                if i + j <= n - 1:
                    cur = Counter()
                    if i:
                        pre = left[i - 1][j]
                        for p in pre:
                            cur[p ^ num] += pre[p]
                        left[i - 1][j] = Counter()
                    if j:
                        pre = left[i][j - 1]
                        for p in pre:
                            cur[p ^ num] += pre[p]
                    left[i][j] = cur
                else:
                    break

        right = [[Counter() for _ in range(n)] for _ in range(n)]
        for i in range(n - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                if i == j == n - 1:
                    right[i][j] = Counter([grid[i][j]])
                    continue
                num = grid[i][j]
                if i + j >= n - 1:
                    cur = Counter()
                    if i + 1 < n:
                        pre = right[i + 1][j]
                        for p in pre:
                            cur[p ^ num] += pre[p]
                        right[i + 1][j] = Counter()
                    if j + 1 < n:
                        pre = right[i][j + 1]
                        for p in pre:
                            cur[p ^ num] += pre[p]
                    right[i][j] = cur
                else:
                    break
        ans = 0
        for i in range(n):
            pre = left[i][n - 1 - i]
            x = grid[i][n - 1 - i]
            nex = right[i][n - 1 - i]
            for p in pre:
                ans += nex[p ^ x] * pre[p]
        ac.st(ans)
        return

    @staticmethod
    def cf_888e(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/888/E
        tag: meet_in_middle|classical
        """
        n, m = ac.read_list_ints()
        nums = ac.read_list_ints()
        random.shuffle(nums)
        pre = {0}
        for num in nums[:n // 2]:
            pre = pre | {(p + num) % m for p in pre} | {num % m}
        post = {0}
        for num in nums[n // 2:]:
            post = post | {(p + num) % m for p in post} | {num % m}
        pre = sorted(pre)
        ans = pre[-1]
        for num in post:
            ans = max(ans, (pre[-1] + num) % m)
            ans = max(ans, num)
            i = bisect.bisect_left(pre, m - num) - 1
            if i >= 0:
                ans = max(ans, (pre[i] + num) % m)
        ac.st(ans)
        return"""
Algorithm：automaton|sub_sequence_automaton|suffix_automaton|palindrome_automaton
Description：kmp|trie_like|word_count|text

====================================LeetCode====================================
1717（https://leetcode.cn/problems/multi-search-lcci/）ac_automaton|counter|trie_like
727（https://leetcode.cn/problems/minimum-window-subsequence）sub_sequence_automaton
792（https://leetcode.cn/problems/number-of-matching-subsequences）sub_sequence_automaton
2014（https://leetcode.cn/problems/longest-subsequence-repeated-k-times/）sub_sequence_automaton|brute_force
2350（https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/）brain_teaser|classical|sub_sequence_automaton
3292（https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-ii）ac_automaton|AhoCorasick
3213（https://leetcode.cn/problems/construct-string-with-minimum-cost/）ac_automaton|AhoCorasick

=====================================LuoGu======================================
P3808（https://www.luogu.com.cn/problem/P3808）ac_automan|classical
P3796（https://www.luogu.com.cn/problem/P3796）ac_automan|classical
P5357（https://www.luogu.com.cn/problem/P5357）ac_automan|classical
P5826（https://www.luogu.com.cn/problem/P5826）sub_sequence_automaton|binary_search
P9572（https://www.luogu.com.cn/problem/P9572）sub_sequence_automaton|binary_search

=====================================AtCoder======================================
ABC362G（https://atcoder.jp/contests/abc362/tasks/abc362_g）ac_automan|classical

===================================CodeForces===================================
91A（https://codeforces.com/contest/91/problem/A）sub_sequence_automaton
1845C（https://codeforces.com/contest/1845/problem/C）sub_sequence_automaton

"""
import bisect
from collections import Counter
from itertools import permutations

from typing import List

from src.strings.automaton.template import AcAutomaton, AhoCorasick
from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1717(big: str, smalls: List[str]) -> List[List[int]]:
        """
        url: https://leetcode.cn/problems/construct-string-with-minimum-cost/
        tag: ac_automaton|AhoCorasick
        """
        ac = AhoCorasick()
        for i, word in enumerate(smalls):
            ac.insert(word, i)
        ac.set_fail()
        res = ac.search(big)
        ans = [[] for _ in range(len(smalls))]
        for i in range(len(big)):
            for j in res[i]:
                ans[j].append(i)
        return ans

    @staticmethod
    def lg_p5826(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5826
        tag: sub_sequence_automaton|binary_search
        """
        _, n, q, m = ac.read_list_ints()
        ind = [[] for _ in range(m + 1)]
        lst = ac.read_list_ints()
        for i, num in enumerate(lst):
            ind[num].append(i)
        for _ in range(q):
            lst = ac.read_list_ints()[1:]
            i = 0
            for w in lst:
                j = bisect.bisect_left(ind[w], i)
                if j >= len(ind[w]):
                    ac.no()
                    break
                i = ind[w][j] + 1
            else:
                ac.yes()
        return

    @staticmethod
    def lc_727(s1: str, s2: str) -> str:
        """
        url: https://leetcode.cn/problems/minimum-window-subsequence
        tag: sub_sequence_automaton
        """
        lst1 = [ord(w) - ord("a") for w in s1]
        lst2 = [ord(w) - ord("a") for w in s2]
        m, n = len(s1), len(s2)

        nxt = [-1] * 26 * m
        post = dict()
        for i in range(m - 1, -1, -1):
            post[lst1[i]] = i
            for j in post:
                nxt[i * 26 + j] = post[j]

        ans = [0, m]
        for i in range(m):
            j = 0
            k = i
            while j < n and k < m:
                k = nxt[k * 26 + lst2[j]]
                if k == -1:
                    break
                k += 1
                j += 1
            if j == n and k - i < ans[1] - ans[0] + 1:
                ans = [i, k - 1]
        if ans == [0, m]:
            return ""
        return s1[ans[0]:ans[1] + 1]

    @staticmethod
    def lc_792(s: str, words: List[str]) -> int:
        """
        url: https://leetcode.cn/problems/number-of-matching-subsequences/
        tag: sub_sequence_automaton
        """
        lst = [ord(w) - ord("a") for w in s]
        m = len(s)

        nxt = [-1] * 26 * m
        post = dict()
        for i in range(m - 1, -1, -1):
            post[lst[i]] = i
            for j in post:
                nxt[i * 26 + j] = post[j]

        ans = 0
        for word in words:
            lst = [ord(w) - ord("a") for w in word]
            n = len(word)

            j = 0
            k = 0
            while j < n and k < m:
                k = nxt[k * 26 + lst[j]]
                if k == -1:
                    break
                k += 1
                j += 1
            if j == n:
                ans += 1
        return ans

    @staticmethod
    def lc_2014(s: str, k: int) -> str:
        """
        url: https://leetcode.cn/problems/longest-subsequence-repeated-k-times/
        tag: sub_sequence_automaton|brute_force
        """
        lst = [ord(w) - ord("a") for w in s]
        n = len(s)
        nxt = [-1] * 26 * n
        post = dict()
        for i in range(n - 1, -1, -1):
            post[lst[i]] = i
            for j in post:
                nxt[i * 26 + j] = post[j]

        cnt = Counter(lst)
        hot = []
        for w in sorted(cnt, reverse=True):
            hot.extend([w] * (cnt[w] // k))

        pre = set()
        for m in range(min(len(hot), 7), 0, -1):
            for item in permutations(hot, m):
                if item in pre:
                    continue
                pre.add(item)
                i = j = 0
                while j < k * m and i < n:
                    i = nxt[i * 26 + item[j % m]]
                    if i == -1:
                        break
                    i += 1
                    j += 1
                if j == k * m:
                    word = "".join([chr(x + ord("a")) for x in item])
                    return word
        return ""

    @staticmethod
    def cf_91a(ac=FastIO()):
        """
        url: https://codeforces.com/contest/91/problem/A
        tag: sub_sequence_automaton
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        t = [ord(w) - ord("a") for w in ac.read_str()]
        n, m = len(s), len(t)

        nxt = [-1] * 26 * n
        post = dict()
        for i in range(n - 1, -1, -1):
            post[s[i]] = i

        for i in range(n - 1, -1, -1):
            for j in post:
                nxt[i * 26 + j] = post[j]
            post[s[i]] = i

        if nxt[(n - 1) * 26 + t[0]] == -1:
            ac.st(-1)
            return

        i = nxt[(n - 1) * 26 + t[0]]
        ans = 1
        for j in t[1:]:
            k = nxt[i * 26 + j]
            if k == -1:
                ac.st(-1)
                return
            if k <= i:
                ans += 1
            i = k
        ac.st(ans)
        return

    @staticmethod
    def lg_p9572(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P9572
        tag: sub_sequence_automaton
        """
        n, m, c1, c2 = ac.read_list_ints()
        s = ac.read_list_ints()
        dct = dict()
        for i, w in enumerate(s):
            if w not in dct:
                dct[w] = []
            dct[w].append(i)
        t = [w for w in ac.read_list_ints() if w in dct]
        if not t:
            ac.lst([0, 0])
            return
        ans = 1
        i = dct[t[0]][0]
        for x in t[1:]:
            if dct[x][-1] > i:
                i = dct[x][bisect.bisect_right(dct[x], i)]
            else:
                ans += 1
                i = dct[x][0]
        ac.lst([c1 * len(t), c2 * ans])
        return

    @staticmethod
    def cf_1845c(ac=FastIO()):

        """
        url: https://codeforces.com/contest/1845/problem/C
        tag: sub_sequence_automaton
        """

        def check():
            i = 0
            ll, rr = int(s1[i]), int(s2[i])
            pre = set()
            for w in s:
                if ll <= int(w) <= rr:
                    pre.add(int(w))
                if len(pre) == rr - ll + 1:
                    pre = set()
                    i += 1
                    if i == m:
                        ac.no()
                        return
                    ll, rr = int(s1[i]), int(s2[i])
            ac.yes()
            return

        for _ in range(ac.read_int()):
            s = ac.read_str()
            m = ac.read_int()
            s1 = ac.read_str()
            s2 = ac.read_str()
            check()
        return

    @staticmethod
    def lc_2350(rolls: List[int], k: int) -> int:
        """
        url: https://leetcode.cn/problems/shortest-impossible-sequence-of-rolls/
        tag: brain_teaser|classical|sub_sequence_automaton
        """
        ans = 1
        pre = set()
        for num in rolls:
            pre.add(num)
            if len(pre) == k:
                ans += 1
                pre = set()
        return ans

    @staticmethod
    def abc_362g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc362/tasks/abc362_g
        tag: ac_automan|classical
        """
        s = ac.read_str()
        q = ac.read_int()
        words = [ac.read_str() for _ in range(q)]
        am = AcAutomaton(words)
        res = am.search(s)
        for a in res:
            ac.st(a)
        return

    @staticmethod
    def lg_p5357(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5357
        tag: ac_automan|classical
        """
        q = ac.read_int()
        words = [ac.read_str() for _ in range(q)]
        s = ac.read_str()
        am = AcAutomaton(words)
        res = am.search(s)
        for a in res:
            ac.st(a)
        return

    @staticmethod
    def lg_p3808(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3808
        tag: ac_automan|classical
        """
        q = ac.read_int()
        words = [ac.read_str() for _ in range(q)]
        s = ac.read_str()
        am = AcAutomaton(words)
        res = am.search(s)
        ans = sum(x > 0 for x in res)
        ac.st(ans)
        return

    @staticmethod
    def lg_p3796(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3796
        tag: ac_automan|classical
        """
        while True:
            q = ac.read_int()
            if not q:
                break
            words = [ac.read_str() for _ in range(q)]
            s = ac.read_str()
            am = AcAutomaton(words)
            res = am.search(s)
            i = res.index(max(res))
            ac.st(res[i])
            for j in range(q):
                if res[j] == res[i]:
                    ac.st(words[j])
        return

    @staticmethod
    def lc_3213(target: str, words: List[str], costs: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/construct-string-with-minimum-cost/
        tag: ac_automaton|AhoCorasick
        """
        ac = AhoCorasick()
        for word, cost in zip(words, costs):
            ac.insert(word, cost)
        ac.set_fail()
        f = [0] + [math.inf] * len(target)
        x = ac.root
        for i, c in enumerate(target, 1):
            while x and c not in x.son:
                x = x.fail
            x = x.son[c] if x else ac.root
            cur = x
            while cur:
                if cur.len:
                    tmp = f[i - cur.len] + cur.val
                    if f[i] > tmp:
                        f[i] = tmp
                cur = cur.last
        return f[-1] if f[-1] < math.inf else -1"""

Algorithm：stack
Description：xxx

====================================LeetCode====================================
1597（https://leetcode.cn/problems/build-binary-expression-tree-from-math.infix-expression/）

=====================================LuoGu======================================
P1175（https://www.luogu.com.cn/problem/P1175）
P1617（https://www.luogu.com.cn/problem/P1617）
P1322（https://www.luogu.com.cn/problem/P1322）
"""
"""
Algorithm：kmp|find|z-function|circular_section
Description：string|prefix_suffix

====================================LeetCode====================================
28（https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/）kmp|find
214（https://leetcode.cn/problems/shortest-palindrome/）longest_palindrome_prefix
796（https://leetcode.cn/problems/rotate-string/）rotate_string
25（https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/）find|kmp|substring
1392（https://leetcode.cn/problems/longest-happy-prefix/）longest_prefix_suffix|kmp|z_function|template
2223（https://leetcode.cn/problems/sum-of-scores-of-built-strings）z_function
2800（https://leetcode.cn/problems/shortest-string-that-contains-three-strings/）kmp|prefix_suffix|greedy|brain_teaser
2851（https://leetcode.cn/problems/string-transformation/description/）kmp|matrix_fast_power|string_hash
3008（https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-ii/）kmp|find
686（https://leetcode.cn/problems/repeated-string-match/）kmp|find|greedy
1397（https://leetcode.cn/problems/find-all-good-strings/）digital_dp|kmp_automaton
459（https://leetcode.cn/problems/repeated-substring-pattern/）kmp|circular_section
1163（https://leetcode.cn/problems/last-substring-in-lexicographical-order/）kmp|matrix_dp|kmp_automaton
3292（https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-ii/）kmp|greedy|linear_dp
100433（https://leetcode.com/problems/find-the-occurrence-of-first-almost-equal-substring/）z_function|greedy|classical

=====================================LuoGu======================================
P3375（https://www.luogu.com.cn/problem/P3375）longest_prefix_suffix|find
P4391（https://www.luogu.com.cn/problem/P4391）brain_teaser|kmp|n-pi[n-1]
P3435（https://www.luogu.com.cn/problem/P3435）kmp|longest_circular_section|prefix_function_reverse|classical
P4824（https://www.luogu.com.cn/problem/P4824）
P2375（https://www.luogu.com.cn/problem/P2375）kmp|z-function|diff_array
P7114（https://www.luogu.com.cn/problem/P7114）
P3426（https://www.luogu.com.cn/problem/P3426）
P3193（https://www.luogu.com.cn/problem/P3193）kmp_automaton|matrix_fast_power|matrix_dp
P4036（https://www.luogu.com.cn/problem/P4036）kmp|z-function
P5410（https://www.luogu.com.cn/problem/P5410）kmp|z-function
P1368（https://www.luogu.com.cn/problem/P1368）
P3121（https://www.luogu.com.cn/problem/P3121）
P5829（https://www.luogu.com.cn/problem/P5829）kmp|z-function|fail_tree|classical|border|longest_common_border|tree_lca
P8112（https://www.luogu.com.cn/problem/P8112）z_function|point_set|range_min|classical


===================================CodeForces===================================
1326D2（https://codeforces.com/problemset/problem/1326/D2）manacher|greedy|prefix_suffix|longest_prefix_suffix|palindrome_substring
432D（https://codeforces.com/contest/432/problem/D）kmp|z-function|sorted_list
25E（https://codeforces.com/contest/25/problem/E）kmp|prefix_suffix|greedy|longest_common_prefix_suffix
126B（https://codeforces.com/contest/126/problem/B）kmp|z-function|classical|brute_force
471D（https://codeforces.com/contest/471/problem/D）kmp|brain_teaser|classical|diff_array
346B（https://codeforces.com/contest/346/problem/B）kmp|lcs|matrix_dp
494B（https://codeforces.com/contest/494/problem/B）kmp|linear_dp|prefix_sum
1200E（https://codeforces.com/problemset/problem/1200/E）string_hash|kmp
615C（https://codeforces.com/contest/615/problem/C）kmp|linear_dp|specific_plan
1163D（https://codeforces.com/problemset/problem/1163/D）kmp|matrix_dp|kmp_automaton
526D（https://codeforces.com/contest/526/problem/D）brain_teaser|classical|kmp|circular_section
954I（https://codeforces.com/problemset/problem/954/I）
808G（https://codeforces.com/contest/808/problem/G）kmp|kmp_automaton|z-function|matrix_dp
182D（https://codeforces.com/problemset/problem/182/D）kmp|circular_section|num_factor
535D（https://codeforces.com/problemset/problem/535/D）kmp|z-function|union_find
1051E（https://codeforces.com/contest/1051/problem/E）kmp|z-function|linear_dp
1015F（https://codeforces.com/contest/1015/problem/F）kmp_automaton|matrix_dp
1690F（https://codeforces.com/contest/1690/problem/F）permutation_circle|kmp|circle_section
1968G2（https://codeforces.com/contest/1968/problem/G2）z_algorithm|offline_query|binary_search|brute_force|preprocess
1984D（https://codeforces.com/contest/1984/problem/D）kmp|z_function|euler_series|brain_teaser|brute_force

=====================================AcWing=====================================
143（https://www.acwing.com/problem/content/143/）kmp|circular_section
162（https://www.acwing.com/problem/content/162/）z_function|template
3826（https://www.acwing.com/problem/content/3826/）kmp|z_function

=====================================AtCoder=====================================
ABC284F（https://atcoder.jp/contests/abc284/tasks/abc284_f）
ABC343G（https://atcoder.jp/contests/abc343/tasks/abc343_g）kmp|state_dp|classical
ABC257G（https://atcoder.jp/contests/abc257/tasks/abc257_g）z_function|point_set|range_min|classical

=====================================LibraryChecker=====================================
1（https://www.luogu.com.cn/training/53971）
2（https://loj.ac/p/103）
3（https://acm.hdu.edu.cn/showproblem.php?pid=2087）
4（https://oj.socoding.cn/p/1446）
5（https://www.lanqiao.cn/problems/5132/learning/?contest_id=144）
6（https://www.luogu.com.cn/problem/UVA10298）
7（https://www.luogu.com.cn/problem/UVA11022）
8（https://poj.org/problem?id=2406）
9（https://www.luogu.com.cn/problem/UVA455）
10（https://judge.yosupo.jp/problem/zalgorithm）kmp|z-function
11（https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A）kmp|z-function
12（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/A）kmp|circular_section
13（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/B）kmp|find|z-function
14（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/C）kmp|diff_array|z-function
15（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/D）kmp|find_longest_palindrome
16（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/E）kmp|z-function
17（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/F）kmp|z-function
18（https://poj.org/problem?id=1509）
19（https://codeforces.com/gym/103585/problem/K）


1（https://www.codechef.com/problems/BREAKSTRING）kmp|z_function

"""
import bisect
import math
from collections import Counter
from functools import lru_cache
from itertools import permutations
from typing import List

from src.data_structure.segment_tree.template import PointSetRangeMin
from src.data_structure.sorted_list.template import SortedList
from src.graph.tree_lca.template import TreeAncestor
from src.graph.union_find.template import UnionFind
from src.mathmatics.fast_power.template import MatrixFastPower
from src.mathmatics.number_theory.template import NumFactor
from src.strings.kmp.template import KMP
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lg_p3375(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3375
        tag: longest_prefix_suffix|find
        """
        s1 = ac.read_str()
        s2 = ac.read_str()
        m, n = len(s1), len(s2)
        pi = KMP().prefix_function(s2 + "@" + s1)
        for i in range(n, m + n + 1):
            if pi[i] == n:
                ac.st(i - n + 1 - n)
        ac.lst(pi[:n])
        return

    @staticmethod
    def cf_1326d2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1326/D2
        tag: manacher|greedy|prefix_suffix|longest_prefix_suffix|palindrome_substring
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            i, j = 0, n - 1
            while i < j:
                if s[i] == s[j]:
                    i += 1
                    j -= 1
                else:
                    break
            if i >= j:
                ac.st(s)
                continue

            a = KMP().find_longest_palindrome(s[i:j + 1])
            b = KMP().find_longest_palindrome(s[i:j + 1], "suffix")
            ans = s[:i + a] + s[j + 1:] if a > b else s[:i] + s[j - b + 1:]
            ac.st(ans)
        return

    @staticmethod
    def lc_214(s: str) -> str:
        """
        url: https://leetcode.cn/problems/shortest-palindrome/
        tag: longest_palindrome_prefix
        """
        k = KMP().find_longest_palindrome(s)
        return s[k:][::-1] + s

    @staticmethod
    def lc_796(s: str, goal: str) -> bool:
        """
        url: https://leetcode.cn/problems/rotate-string/
        tag: rotate_string
        """
        ans = KMP().find(s + s, goal)
        return len(ans) > 0 and len(s) == len(goal)

    @staticmethod
    def lc_28(haystack: str, needle: str) -> int:
        """
        url: https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/
        tag: kmp|find
        """
        ans = KMP().find(haystack, needle)
        return ans[0] if ans else -1

    @staticmethod
    def lc_1392(s: str) -> str:
        """
        url: https://leetcode.cn/problems/longest-happy-prefix/
        tag: longest_prefix_suffix|kmp|z_function|template
        """
        pi = KMP().prefix_function(s)
        return s[:pi[-1]]

    @staticmethod
    def lc_2223(s: str) -> int:
        """
        url: https://leetcode.cn/problems/sum-of-scores-of-built-strings
        tag: z_function
        """
        ans = sum(KMP().z_function(s)) + len(s)
        return ans

    @staticmethod
    def lg_p4391(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4391
        tag: brain_teaser|kmp|n-pi[n-1]|classical
        """

        n = ac.read_int()
        s = ac.read_str()
        pi = KMP().prefix_function(s)
        ac.st(n - pi[-1])
        return

    @staticmethod
    def ac_143(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/143/
        tag: kmp|circular_section
        """
        ind = 0
        while True:
            n = ac.read_int()
            if not n:
                break
            s = ac.read_str()
            ind += 1
            ac.st(f"Test case #{ind}")
            pi = KMP().prefix_function(s)
            for i in range(1, n):
                if pi[i] and (i + 1) % (i + 1 - pi[i]) == 0:
                    ac.lst([i + 1, (i + 1) // (i + 1 - pi[i])])
            ac.st("")
        return

    @staticmethod
    def ac_160(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/162/
        tag: z_function|template
        """

        n, m, q = ac.read_list_ints()
        s = ac.read_str()
        t = ac.read_str()
        st = t + "#" + s
        z = KMP().z_function(st)
        cnt = Counter(z[m + 1:])
        for _ in range(q):
            x = ac.read_int()
            ac.st(cnt[x])
        return

    @staticmethod
    def cf_25e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/25/problem/E
        tag: kmp|prefix_suffix|greedy|longest_common_prefix_suffix
        """

        s = [ac.read_str() for _ in range(3)]

        ind = list(range(3))
        ans = sum(len(w) for w in s)
        kmp = KMP()
        for item in permutations(ind, 3):
            cur = len(kmp.merge_b_from_a(kmp.merge_b_from_a(s[item[0]], s[item[1]]), s[item[2]]))
            if cur < ans:
                ans = cur
        ac.st(ans)
        return

    @staticmethod
    def lc_2800(a: str, b: str, c: str) -> str:
        """
        url: https://leetcode.cn/problems/shortest-string-that-contains-three-strings/
        tag: kmp|prefix_suffix|greedy|brain_teaser
        """

        s = [a, b, c]
        ind = list(range(3))
        ans = sum(len(w) for w in s)
        kmp = KMP()
        res = a + b + c
        for item in permutations(ind, 3):
            st = kmp.merge_b_from_a(kmp.merge_b_from_a(s[item[0]], s[item[1]]), s[item[2]])
            cur = len(st)
            if cur < ans or (cur == ans and st < res):
                ans = cur
                res = st
        return res

    @staticmethod
    def lc_2851(s: str, t: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/string-transformation/description/
        tag: kmp|matrix_fast_power|string_hash|brain_teaser
        """

        n = len(s)
        mod = 10 ** 9 + 7
        kmp = KMP()
        z = kmp.prefix_function(t + "#" + s + s)
        p = sum(z[i] == n for i in range(2 * n, 3 * n))
        q = n - p
        mat = [[p - 1, p], [q, q - 1]]
        vec = [1, 0] if z[2 * n] == n else [0, 1]
        res = MatrixFastPower().matrix_pow(mat, k, mod)
        ans = vec[0] * res[0][0] + vec[1] * res[0][1]
        return ans % mod

    @staticmethod
    def ac_3826(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/3826/
        tag: kmp|z_function
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            z = KMP().z_function(s)
            pre = 0
            for i in range(1, n):
                if z[i] == n - i and pre >= z[i]:
                    ac.st(s[:z[i]])
                    break
                pre = max(pre, z[i])
            else:
                ac.st("not exist")
        return

    @staticmethod
    def lc_3008(s: str, a: str, b: str, k: int) -> List[int]:
        """"
        url: https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-ii/
        tag: kmp|find
        """
        lst1 = KMP().find(s, a)
        lst2 = KMP().find(s, b)
        ans = []
        for i in lst1:
            j = bisect.bisect_left(lst2, i)
            for x in [j - 1, j, j + 1]:
                if 0 <= x < len(lst2) and abs(lst2[x] - i) <= k:
                    ans.append(i)
                    break
        return ans

    @staticmethod
    def cf_1200e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1200/problem/E
        tag: string_hash|kmp
        """
        ac.read_int()
        lst = ac.read_list_strs()
        ans = []
        kmp = KMP()
        for word in lst:
            if not ans:
                ans.extend(list(word))
            else:
                m = len(word)
                k = min(len(ans), m)
                s = list(word[:k]) + ans[-k:]
                z = kmp.z_function(s)
                inter = 0
                for i in range(1, k + 1):
                    if z[-i] == i:
                        inter = i
                for j in range(inter, m):
                    ans.append(word[j])
        ac.st("".join(ans))
        return

    @staticmethod
    def lc_186(a: str, b: str) -> int:
        """
        url: https://leetcode.cn/problems/repeated-string-match/
        tag: kmp|find|greedy
        """
        ceil = len(b) // len(a) + 2
        kmp = KMP()
        ans = kmp.find(ceil * a, b)
        if not ans:
            return -1
        res = (ans[0] + len(b) + len(a) - 1) // len(a)
        return res

    @staticmethod
    def cf_126b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/126/problem/B
        tag: kmp|z-function|classical|brute_force
        """
        s = ac.read_str()
        n = len(s)
        z = KMP().z_function(s)
        pre = 0
        for i in range(1, n):
            if z[i] == n - i and pre >= z[i]:
                ac.st(s[:z[i]])
                break
            pre = max(pre, z[i])
        else:
            ac.st("Just a legend")
        return

    @staticmethod
    def cf_471d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/471/problem/D
        tag: kmp|brain_teaser|classical|diff_array
        """
        m, n = ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        if n == 1:
            ac.st(m)
            return
        if m < n:
            ac.st(0)
            return
        a = [a[i + 1] - a[i] for i in range(m - 1)]
        b = [b[i + 1] - b[i] for i in range(n - 1)]
        ans = len(KMP().find_lst(a, b, -10 ** 9 - 1))
        ac.st(ans)
        return

    @staticmethod
    def cf_432d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/432/problem/D
        tag: kmp|z-function|sorted_list
        """
        s = ac.read_str()
        z = KMP().z_function(s)
        lst = SortedList()
        n = len(s)
        ans = []
        for i in range(1, n):
            if z[i] == n - i:
                ans.append((n - i, lst.bisect_right(i - n) + 2))
            lst.add(-z[i])
        ans.reverse()
        ans.append((n, 1))
        ac.st(len(ans))
        for ls in ans:
            ac.lst(ls)
        return

    @staticmethod
    def cf_346b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/346/problem/B
        tag: kmp|lcs|matrix_dp|specific_plan|classical
        """
        s = [ord(w) - ord("A") for w in ac.read_str()]
        t = [ord(w) - ord("A") for w in ac.read_str()]
        virus = [ord(w) - ord("A") for w in ac.read_str()]
        m, n, k = len(s), len(t), len(virus)

        nxt = [[-1] * 26 for _ in range(k)]
        kmp = KMP()
        pre = []
        for i in range(k):
            for j in range(26):
                nxt[i][j] = kmp.prefix_function(virus + [-1] + pre + [j])[-1]
            pre.append(virus[i])

        dp = [[[0] * (k + 1) for _ in range(n + 1)] for _ in range(m + 1)]
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                for x in range(k):
                    a, b = dp[i + 1][j][x], dp[i][j + 1][x]
                    dp[i][j][x] = max(a, b)
                    if s[i] == t[j] and nxt[x][s[i]] < k and dp[i + 1][j + 1][nxt[x][s[i]]] + 1 > dp[i][j][x]:
                        dp[i][j][x] = dp[i + 1][j + 1][nxt[x][s[i]]] + 1
        length = dp[0][0][0]
        if length:
            ans = []
            i, j, x = 0, 0, 0
            while len(ans) < length:
                if dp[i][j][x] == dp[i + 1][j][x]:
                    i += 1
                elif dp[i][j][x] == dp[i][j + 1][x]:
                    j += 1
                else:
                    ans.append(s[i])
                    i, j, x = i + 1, j + 1, nxt[x][s[i]]
            ac.st("".join([chr(i + ord("A")) for i in ans]))
        else:
            ac.st("0")
        return

    @staticmethod
    def cf_494b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/494/problem/B
        tag: kmp|linear_dp|prefix_sum
        """
        s = ac.read_str()
        t = ac.read_str()
        m, n = len(t), len(s)
        pi = KMP().prefix_function(t + "#" + s)
        mod = 10 ** 9 + 7
        dp = [0] * (n + 1)
        pre = [0] * (n + 1)
        dp[0] = pre[0] = 1
        last = -1
        for i in range(1, n + 1):
            if pi[i + m] == m:
                last = i - m + 1
            if last != -1:
                dp[i] = dp[i - 1] + pre[last - 1]
            else:
                dp[i] = dp[i - 1]
            dp[i] %= mod
            pre[i] = (pre[i - 1] + dp[i]) % mod
        ac.st((dp[-1] - 1) % mod)
        return

    @staticmethod
    def cf_615c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/615/problem/C
        tag: kmp|linear_dp|specific_plan
        """
        s = ac.read_str()
        t = ac.read_str()
        m, n = len(s), len(t)
        dp = [math.inf] * (n + 1)
        dp[0] = 0
        state = [() for _ in range(n + 1)]
        for i in range(n):
            pre = t[:i + 1][::-1]
            z_flip = KMP().z_function(pre + "#" + s)
            for j in range(i + 2, i + 2 + m):
                if z_flip[j] and dp[i + 1 - z_flip[j]] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[i + 1 - z_flip[j]] + 1
                    a, b = j - i - 2, j - i - 2 + z_flip[j] - 1
                    state[i + 1] = (b, a)

            z_flip = KMP().z_function(pre + "#" + s[::-1])
            for j in range(i + 2, i + 2 + m):
                if z_flip[j] and dp[i + 1 - z_flip[j]] + 1 < dp[i + 1]:
                    dp[i + 1] = dp[i + 1 - z_flip[j]] + 1
                    a, b = j - i - 2, j - i - 2 + z_flip[j] - 1
                    state[i + 1] = (m - 1 - b, m - 1 - a)
        if dp[-1] == math.inf:
            ac.st(-1)
        else:
            ans = []
            x = n
            while x:
                ans.append(state[x])
                x -= abs(state[x][0] - state[x][1]) + 1
            ac.st(len(ans))
            ans.reverse()
            for ls in ans:
                ac.lst((x + 1 for x in ls))
        return

    @staticmethod
    def cf_1163d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1163/problem/D
        tag: kmp|matrix_dp|kmp_automaton
        """
        c = [ord(w) - ord("a") for w in ac.read_str()]
        s = [ord(w) - ord("a") for w in ac.read_str()]
        t = [ord(w) - ord("a") for w in ac.read_str()]
        n, m, k = len(c), len(s), len(t)

        nxt_s = KMP().kmp_automaton(s)
        nxt_t = KMP().kmp_automaton(t)

        dp = [[-math.inf] * (k + 1) * (m + 1) for _ in range(2)]
        dp[0][0] = 0
        for i in range(n):
            if chr(c[i] + ord("a")) == "*":
                lst = list(range(26))
            else:
                lst = [c[i]]
            for j in range(m + 1):
                for x in range(k + 1):
                    dp[(i & 1) ^ 1][j * (k + 1) + x] = -math.inf
            for j in range(m + 1):
                for x in range(k + 1):
                    cur = dp[i & 1][j * (k + 1) + x]
                    if cur == -math.inf:
                        continue
                    for w in lst:
                        tmp = cur
                        jj = nxt_s[j * 26 + w]
                        xx = nxt_t[x * 26 + w]
                        if jj == m:
                            tmp += 1
                        if xx == k:
                            tmp -= 1
                        if tmp > dp[(i & 1) ^ 1][jj * (k + 1) + xx]:
                            dp[(i & 1) ^ 1][jj * (k + 1) + xx] = tmp
        ac.st(max(dp[n & 1]))
        return

    @staticmethod
    def cf_526d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/526/problem/D
        tag: brain_teaser|classical|kmp|circular_section
        """
        n, k = ac.read_list_ints()
        ans = ["0"] * n
        s = ac.read_str()
        pi = KMP().prefix_function(s)
        for i in range(n):
            c = i + 1 - pi[i]
            low = math.ceil((i + 1) / ((k + 1) * c))
            high = (i + 1) // (k * c)
            if low <= high:
                ans[i] = "1"
        ac.st("".join(ans))
        return

    @staticmethod
    def cf_808g(ac=FastIO()):
        """
        url: https://codeforces.com/contest/808/problem/G
        tag: kmp|kmp_automaton|z-function|matrix_dp
        """
        s = ac.read_str()
        t = ac.read_str()
        m, n = len(s), len(t)
        z = KMP().z_function(t)
        ind = [0]
        for i in range(1, n):
            if z[i] == n - i:
                ind.append(n - i)

        dp = [[-math.inf] * n for _ in range(2)]
        pre = 0
        dp[pre][0] = 0
        for w in s:
            cur = 1 - pre
            for j in range(n):
                dp[cur][j] = -math.inf
            dp[cur][0] = max(dp[pre])
            for j in range(n):
                if t[j] == w or w == "?":
                    if j == n - 1:
                        for x in ind:
                            dp[cur][x] = max(dp[cur][x], dp[pre][j] + 1)
                    else:
                        dp[cur][j + 1] = max(dp[cur][j + 1], dp[pre][j])
            pre = cur
        ac.st(max(dp[pre]))
        return

    @staticmethod
    def lc_1397(n: int, s1: str, s2: str, evil: str) -> int:

        """
        url: https://leetcode.cn/problems/find-all-good-strings/
        tag: digital_dp|kmp_automaton
        """

        @lru_cache(None)
        def dfs(i, is_floor_limit, is_ceil_limit, sub_evil):
            if sub_evil == m:
                return 0
            if i == n:
                return 1
            res = 0
            start = 0 if not is_floor_limit else s1[i]
            end = 25 if not is_ceil_limit else s2[i]
            for w in range(start, end + 1):
                cur_evil = sub_evil + 1 if evil[sub_evil] == w else nxt[sub_evil * 26 + w]
                res += dfs(i + 1, is_floor_limit and s1[i] == w, is_ceil_limit and s2[i] == w, cur_evil)
                res %= mod
            return res

        mod = 10 ** 9 + 7
        m = len(evil)
        s1 = [ord(w) - ord("a") for w in s1]
        s2 = [ord(w) - ord("a") for w in s2]
        evil = [ord(w) - ord("a") for w in evil]
        n = len(s1)
        nxt = KMP().kmp_automaton(evil)
        ans = dfs(0, True, True, 0)
        return ans

    @staticmethod
    def lg_p3435(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3435
        tag: kmp|longest_circular_section|prefix_function_reverse|classical
        """
        n = ac.read_int()
        s = ac.read_str()
        nxt = KMP().prefix_function_reverse(s)
        ans = sum(i + 1 - nxt[i] for i in range(1, n) if nxt[i])
        ac.st(ans)
        return

    @staticmethod
    def lg_p2375(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2375
        tag: kmp|z-function|diff_array
        """
        mod = 10 ** 9 + 7
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            z = KMP().z_function(s)
            diff = [0] * n
            for i in range(1, n):
                if z[i]:
                    x = min(z[i], i)
                    diff[i] += 1
                    if i + x < n:
                        diff[i + x] -= 1
            ans = 1
            for i in range(1, n):
                diff[i] += diff[i - 1]
                ans *= (diff[i] + 1)
                ans %= mod
            ac.st(ans)
        return

    @staticmethod
    def lg_p3193(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3193
        tag: kmp_automaton|matrix_fast_power|matrix_dp
        """
        n, m, k = ac.read_list_ints()
        lst = [int(w) for w in ac.read_str()]
        nxt = KMP().kmp_automaton(lst, 10)
        grid = [[0] * (m + 9) for _ in range(m + 9)]
        for i in range(10):
            for j in range(m):
                ind = i if j == 0 else j + 9
                for x in range(10):
                    y = nxt[j * 10 + x]
                    if y == 0:
                        grid[x][ind] = 1
                    elif y < m:
                        grid[y + 9][ind] = 1

        initial = [0] * (m + 9)
        for x in range(10):
            if x == lst[0] and m > 1:
                initial[10] = 1
            elif x != lst[0]:
                initial[x] = 1
        mat = MatrixFastPower().matrix_pow(grid, n - 1, k)
        ans = 0
        for i in range(m + 9):
            ans += sum(mat[i][j] * initial[j] for j in range(m + 9))
        ac.st(ans % k)
        return

    @staticmethod
    def lg_p4036(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4036
        tag: kmp|z-function
        """
        lst = [ord(w) - ord("a") for w in ac.read_str()]
        for _ in range(ac.read_int()):
            cur = ac.read_list_strs()
            if cur[0] == "Q":
                x, y = [int(w) - 1 for w in cur[1:]]
                n = len(lst)
                ans = KMP().z_function(lst[x:] + [-1] + lst[y:])[n - x + 1]
                ac.st(ans)
            elif cur[0] == "R":
                x = int(cur[1]) - 1
                w = ord(cur[2]) - ord("a")
                lst[x] = w
            else:
                x = int(cur[1])
                w = ord(cur[2]) - ord("a")
                lst.insert(x, w)
        return

    @staticmethod
    def lg_p5829(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5829
        tag: kmp|z-function|fail_tree|classical|border|longest_common_border|tree_lca
        """
        lst = [ord(w) - ord("a") for w in ac.read_str()]
        n = len(lst)
        pi = [0] + KMP().prefix_function(lst)

        edges = [[] for _ in range(n + 1)]
        for i in range(1, n + 1):
            if pi[i]:
                edges[pi[i]].append(i)
            else:
                edges[0].append(i)
        tree = TreeAncestor(edges, 0)
        for _ in range(ac.read_int()):
            p, q = ac.read_list_ints()
            ac.st(tree.get_lca(pi[p], pi[q]))
        return

    @staticmethod
    def cf_182d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/182/problem/D
        tag: kmp|circular_section|num_factor
        """
        s = ac.read_str()
        t = ac.read_str()
        m, n = len(s), len(t)
        c1 = m - KMP().prefix_function(s)[-1]
        c2 = n - KMP().prefix_function(t)[-1]
        if m % c1:
            c1 = m
        if n % c2:
            c2 = n
        if c1 != c2 or s[:c1] != t[:c2]:
            ac.st(0)
        else:
            ac.st(len(NumFactor().get_all_factor(math.gcd(m // c1, n // c2))))
        return

    @staticmethod
    def lc_459(s: str) -> bool:
        """
        url: https://leetcode.cn/problems/repeated-substring-pattern/
        tag: kmp|circular_section
        """
        n = len(s)
        c = n - KMP().prefix_function(s)[-1]
        return n % c == 0 and n // c > 1

    @staticmethod
    def library_check_10(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/zalgorithm
        tag: kmp|z-function
        """
        s = ac.read_str()
        z = KMP().z_function(s)
        z[0] = len(s)
        ac.lst(z)
        return

    @staticmethod
    def library_check_11(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/3/practice/contest/272263/problem/A
        tag: kmp|z-function
        """
        s = ac.read_str()
        z = KMP().z_function(s)
        ac.lst(z)
        return

    @staticmethod
    def lg_p5410(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5410
        tag: kmp|z-function
        """
        a = ac.read_str()
        b = ac.read_str()  # TLE
        m, n = len(a), len(b)
        z = KMP().z_function(b + "#" + a)
        z[0] = n
        ans = 0
        for i in range(n):
            ans ^= (i + 1) * (z[i] + 1)
        ac.st(ans)

        ans = 0
        for i in range(n + 1, n + m + 1):
            ans ^= (i - n) * (z[i] + 1)
        ac.st(ans)
        return

    @staticmethod
    def cf_535d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/535/problem/D
        tag: kmp|z-function|union_find
        """
        n, k = ac.read_list_ints()
        s = ac.read_str()
        m = len(s)
        lst = [""] * n
        uf = UnionFind(n + 1)
        pos = ac.read_list_ints_minus_one()
        for i in pos:
            start = i
            end = i + m - 1
            while uf.find(i) <= end:
                j = uf.find(i)
                lst[j] = s[j - start]
                uf.union_right(j, j + 1)
                i = j + 1

        z = KMP().z_function(list(s) + ["#"] + lst)
        if not all(z[m + 1 + i] == m for i in pos):
            ac.st(0)
            return
        mod = 1000000007
        ans = pow(26, lst.count(""), mod)
        ac.st(ans)
        return

    @staticmethod
    def cf_1051e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1051/problem/E
        tag: kmp|z-function|linear_dp
        """
        s = ac.read_str()
        ll = ac.read_str()
        rr = ac.read_str()
        n = len(s)
        nll = len(ll)
        nrr = len(rr)
        zll = KMP().z_function(ll + "#" + s)[nll + 1:]
        zrr = KMP().z_function(rr + "#" + s)[nrr + 1:]

        def compare_ll(ind):
            lcp = zll[ind]
            if lcp == nll:
                return True
            return s[ind + lcp] >= ll[lcp]

        def compare_rr(ind):
            lcp = zrr[ind]
            if lcp == nrr:
                return True
            return s[ind + lcp] <= rr[lcp]

        mod = 998244353
        dp = [0] * (n + 1)
        post = [0] * (n + 1)
        dp[n] = post[n] = 1
        for i in range(n - 1, -1, -1):
            if s[i] == "0":
                if ll == "0":
                    dp[i] = dp[i + 1]
                post[i] = (post[i + 1] + dp[i]) % mod
                continue
            left = i + nll
            right = i + nrr
            if i + nll > n or not compare_ll(i):
                left += 1
            if i + nrr > n or not compare_rr(i):
                right -= 1
            if left <= right and left <= n:
                dp[i] = (post[left] - (post[right + 1] if right < n else 0)) % mod
            post[i] = (post[i + 1] + dp[i]) % mod
        ac.st(dp[0])
        return

    @staticmethod
    def library_check_12(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/A
        tag: kmp|circular_section
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            ans = n - KMP().prefix_function(s)[-1]
            ac.st(s[:ans])
        return

    @staticmethod
    def library_check_13(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/B
        tag: kmp|find|z-function
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            t = ac.read_str()
            ind = KMP().find(s + s, t)
            if not ind:
                ac.st(-1)
            else:
                ac.st(ind[0])
        return

    @staticmethod
    def library_check_14(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/C
        tag: kmp|diff_array|z-function
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            diff = [0] * (n + 1)
            z = KMP().z_function(s + "#" + s)[n + 1:]
            for x in z:
                diff[0] += 1
                if x + 1 <= n:
                    diff[x + 1] -= 1
            for i in range(1, n + 1):
                diff[i] += diff[i - 1]
            ac.lst(diff[1:])
        return

    @staticmethod
    def library_check_15(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/D
        tag: kmp|find_longest_palindrome
        """
        s = ac.read_str()
        ac.st(KMP().find_longest_palindrome(s, "prefix"))
        return

    @staticmethod
    def library_check_16(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/E
        tag: kmp|z-function
        """
        s = ac.read_str()
        t = ac.read_str()

        n = len(s)
        if len(t) != n:
            ac.no()
            return
        if s == t:
            ac.yes()
            ac.st(0)
            return

        z1 = KMP().z_function(t + "#" + s)[n + 1:]
        z2 = KMP().z_function(t[::-1] + "#" + s)[n + 1:]
        for i in range(n):
            if z1[i] == n - i and z2[0] >= i:
                ac.yes()
                ac.st(i)
                return
        ac.no()
        return

    @staticmethod
    def library_check_17(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/F
        tag: kmp|z-function
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            t = ac.read_str()
            if t in s:
                ac.st(s)
                continue
            if s in t:
                ac.st(t)
                continue
            m, n = len(s), len(t)
            z = KMP().z_function(s + "#" + t)[m + 1:]
            ans = s + t
            for i in range(n):
                if z[i] == n - i:
                    cur = t[:-z[i]] + s
                    if len(cur) < len(ans):
                        ans = cur
                    break

            z = KMP().z_function(t + "#" + s)[n + 1:]
            for i in range(m):
                if z[i] == m - i:
                    cur = s[:-z[i]] + t
                    if len(cur) < len(ans):
                        ans = cur
                    break
            ac.st(ans)
        return

    @staticmethod
    def abc_284f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc284/tasks/abc284_f
        tag: kmp|z-function
        """
        n = ac.read_int()
        s = ac.read_str()
        sr = s[::-1]
        z1 = KMP().z_function(sr + s)[2 * n:]  # 4*n
        z2 = KMP().z_function(s + sr)[2 * n:]  # 4*n
        for i in range(n):
            right = 2 * n - n - i
            left = n - right
            if z2[i] >= right and z1[right] >= left:
                ac.st(sr[i:i + n])
                ac.st(right)
                return
        ac.st(-1)
        return

    @staticmethod
    def cf_1015f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1015/problem/F
        tag: kmp_automaton|matrix_dp
        """
        n = ac.read_int()
        s = ac.read_str()
        lst = [int(w == ")") for w in s]
        nxt = KMP().kmp_automaton(lst, 2)
        m = len(s)
        mod = 10 ** 9 + 7

        dp = [[0] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        for _ in range(2 * n):
            ndp = [[0] * (m + 1) for _ in range(n + 1)]
            for s in range(n + 1):
                for p in range(m + 1):
                    if dp[s][p]:
                        for x in [0, 1]:
                            nxt_p = nxt[p * 2 + x] if p != m else m
                            nxt_s = s + 1 if not x else s - 1
                            if n >= nxt_s >= 0:
                                ndp[nxt_s][nxt_p] += dp[s][p]
            dp = [[x % mod for x in ls] for ls in ndp]
        ac.st(dp[0][m])
        return

    @staticmethod
    def cf_1690f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1690/problem/F
        tag: permutation_circle|kmp|circle_section
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            s = ac.read_str()
            ind = ac.read_list_ints_minus_one()
            dct = {w: i for i, w in enumerate(ind)}
            ans = 1
            visit = [0] * n
            for i in range(n):
                if not visit[i]:
                    lst = [i]
                    visit[i] = 1
                    while not visit[dct[lst[-1]]]:
                        lst.append(dct[lst[-1]])
                        visit[lst[-1]] = 1
                    tmp = [s[j] for j in lst]
                    x = KMP().prefix_function(tmp)[-1]
                    if len(tmp) % (len(tmp) - x) == 0:
                        x = len(tmp) - x
                    else:
                        x = len(tmp)
                    ans = ans * x // math.gcd(ans, x)
            ac.st(ans)
        return

    @staticmethod
    def abc_257g(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc257/tasks/abc257_g
        tag: z_function|point_set|range_min|classical
        """
        s = ac.read_str()
        t = ac.read_str()
        n = len(s)
        m = len(t)
        z = KMP().z_function(s + "#" + t)
        tree = PointSetRangeMin(m + 1)
        tree.point_set(m, 0)
        for i in range(m - 1, -1, -1):
            s = z[i + n + 1]
            if s:
                nex = tree.range_min(i + 1, i + s) + 1
                tree.point_set(i, nex)
        ans = tree.range_min(0, 0)
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def lg_p8112(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P8112
        tag: z_function|point_set|range_min|classical|monotonic_queue|binary_search
        """
        n, m = ac.read_list_ints()  # TLE
        s = ac.read_str()
        t = ac.read_str()
        z = KMP().z_function(s + "#" + t)
        tree = PointSetRangeMin(m + 1)
        tree.point_set(m, 0)
        for i in range(m - 1, -1, -1):
            s = z[i + n + 1]
            if s:
                nex = tree.range_min(i + 1, i + s) + 1
                tree.point_set(i, nex)
        ans = tree.range_min(0, 0)
        ac.st(ans if ans < math.inf else "Fake")
        return

    @staticmethod
    def cf_1968g2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1968/problem/G2
        tag: z_algorithm|offline_query|binary_search|brute_force|preprocess
        """
        for _ in range(ac.read_int()):
            n, ll, rr = ac.read_list_ints()
            s = ac.read_str()
            z = KMP().z_function(s + "#" + s)

            lst = [(z[i + n + 1], i) for i in range(n)]
            lst.sort(reverse=True)

            ans = [-n - 1] * (n + 1)
            i = 0
            ind = SortedList()
            for x in range(n, 0, -1):
                while i < n and lst[i][0] >= x:
                    ind.add(lst[i][1])
                    i += 1
                if not ind:
                    continue
                cur = ind[0]
                cnt = 1
                while cur + x <= ind[-1]:
                    cur = ind[ind.bisect_left(cur + x)]
                    cnt += 1
                ans[x] = -cnt

            res = []
            for x in range(ll, rr + 1):
                res.append(bisect.bisect_right(ans, -x) - 1)

            ac.lst(res)
        return

    @staticmethod
    def cf_1984d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1984/problem/D
        tag: kmp|z_function|euler_series|brain_teaser|brute_force
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            post = [-1] * (n + 1)
            start = -1
            for i in range(n - 1, -1, -1):
                if s[i] != "a":
                    start = i
                post[i] = start
            if post[0] == -1:
                ac.st(n - 1)
                continue
            z = KMP().z_function(s[start:])
            ans = 0
            for j in range(start, n):
                pre = start
                length = j - start + 1
                k = j + 1
                flag = 1
                while k < n:
                    cur = post[k] - k
                    k = post[k]
                    if k == -1:
                        break
                    pre = min(pre, cur)
                    if z[k - start] >= length:
                        k += length
                    else:
                        flag = 0
                        break
                if flag:
                    ans += pre + 1
            ac.st(ans)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/BREAKSTRING
        tag: kmp|z_function
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            if n % 2:
                ac.st(0)
                continue
            z1 = KMP().z_function(s)
            z2 = KMP().z_function(s[::-1])
            ans = 0
            for i in range(n // 2 + 1):
                p = i
                r = n // 2 - i
                if z1[i] >= p and z2[r] >= r:
                    ans += 1
            ac.st(ans)
        return

    @staticmethod
    def lc_3292(words: List[str], target: str) -> int:
        """
        url: https://leetcode.cn/problems/minimum-number-of-valid-strings-to-form-target-ii/
        tag: kmp|greedy|linear_dp
        """
        m = len(target)
        post = [0] * m
        k = len(words)
        for i in range(k):
            s = words[i] + target
            tmp = len(words[i])
            z = KMP().z_function(s)
            for j in range(tmp, tmp + m):
                if z[j]:
                    post[j - tmp] = max(post[j - tmp], min(z[j], tmp))

        ans = 0
        right = -1
        nex = -1
        for i, num in enumerate(post):
            if right < i:
                if nex < i-1:
                    return -1
                ans += 1
                nex = max(nex, i + num - 1)
                right = nex
            else:
                nex = max(nex, i + num - 1)
        return ans if right >= m-1 else -1

    @staticmethod
    def lc_100433(s: str, pattern: str) -> int:
        """
        url: https://leetcode.com/problems/find-the-occurrence-of-first-almost-equal-substring/
        tag: z_function|greedy|classical
        """
        m, n = len(s), len(pattern)
        z1 = KMP().z_function(pattern + s)
        z2 = KMP().z_function((s + pattern)[::-1])[::-1]
        for i in range(m - n + 1):
            left = min(z1[n + i], n)
            if left < n - 1:
                if z2[i + n - 1] >= n - 1 - left:
                    return i
            else:
                return i
        return -1
"""
Algorithm：lyndon_composition|minimum_expression|maximum_expression
Description：rotate_string|lexicographical_order

====================================LeetCode====================================
1163（https://leetcode.cn/problems/last-substring-in-lexicographical-order/）brain_teaser|maximum_expression|minimum_expression|maximum_expression

=====================================LuoGu======================================
P1368（https://www.luogu.com.cn/problem/P1368）lyndon_decomposition|min_express

===================================CodeForces===================================
496B（https://codeforces.com/problemset/problem/496/B）lyndon_decomposition|min_express

=====================================AcWing=====================================
158（https://www.acwing.com/problem/content/160/）minimum_expression

=====================================LibraryChecker=====================================
1（https://codeforces.com/gym/103585/problem/K） lyndon_decomposition|max_express

"""

from src.strings.lyndon_decomposition.template import LyndonDecomposition
from src.utils.fast_io import FastIO


class Solution:

    def __init__(self):
        return

    @staticmethod
    def lc_1163(s: str) -> str:
        """
        url: https://leetcode.cn/problems/last-substring-in-lexicographical-order/
        tag: brain_teaser|maximum_expression|minimum_expression|maximum_expression
        """
        ld = LyndonDecomposition()
        ans = ld.max_express(s + "0")[0]
        return s[ans:]

    @staticmethod
    def ac_158(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/160/
        tag: minimum_expression
        """
        # 求字符串的minimum_expression
        s = ac.read_str()
        t = ac.read_str()
        _, s1 = LyndonDecomposition().min_express(s)
        _, t1 = LyndonDecomposition().min_express(t)
        if s1 == t1:
            ac.yes()
            ac.st(s1)
        else:
            ac.no()
        return

    @staticmethod
    def lg_p1368(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1368
        tag: lyndon_decomposition|min_express
        """
        ac.read_int()
        lst = ac.read_list_ints()
        ans = LyndonDecomposition().min_express(lst)
        ac.lst(ans[1])
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://codeforces.com/gym/103585/problem/K
        tag: lyndon_decomposition|max_express
        """
        s = ac.read_str()
        ans = LyndonDecomposition().max_express(s[::-1])
        if ans[0]:
            ac.st(ans[1])
        else:
            w = max(s[:-1])
            i = s.index(w)
            ac.st(s[:i + 1][::-1] + s[i + 1:][::-1])
        return

    @staticmethod
    def cf_496b(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/496/B
        tag: lyndon_decomposition|min_express
        """
        ac.read_int()
        lst = [int(w) for w in ac.read_str()]
        ld = LyndonDecomposition()
        ans = ld.min_express(lst)[1]
        for _ in range(10):
            lst = [(x + 1) % 10 for x in lst]
            cur = ld.min_express(lst)[1]
            if cur < ans:
                ans = cur
        ac.st("".join(str(x) for x in ans))
        return
"""
Algorithm：manacher|palindrome_substring|plindrome_subsequence
Description：dp|center|center_expansion_method|manacher

====================================LeetCode====================================
5（https://leetcode.cn/problems/longest-palindromic-substring/）longest_palindrome_substring|classical
132（https://leetcode.cn/problems/palindrome-partitioning-ii/）linear_dp|manacher|longest_palindrome_substring
1960（https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/）longest_palindrome_substring|prefix_suffix|classical
1745（https://leetcode-cn.com/problems/palindrome-partitioning-iv/）manacher|palindrome_start_end
2472（https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/）
214（https://leetcode-cn.com/problems/shortest-palindrome/）manacher|linear_dp|palindrome_start_end
647（https://leetcode-cn.com/problems/palindromic-substrings/）manacher|palindrome_count

=====================================AcWing======================================
141（https://www.acwing.com/problem/content/141/）manacher|longest_palindrome_substring|binary_search|hash

=====================================LuoGu======================================
P4555（https://www.luogu.com.cn/problem/P4555）longest_palindrome_substring|prefix_suffix
P1210（https://www.luogu.com.cn/problem/P1210）longest_palindrome_substring
P4888（https://www.luogu.com.cn/problem/P4888）center_expansion_method|two_pointers
P1872（https://www.luogu.com.cn/problem/P1872）counter|palindrome_substring|manacher|classical
P6297（https://www.luogu.com.cn/problem/P6297）center_expansion_method|plindrome
P3805（https://www.luogu.com.cn/problem/P3805）palindrome_longest_length|manacher
P1659（https://www.luogu.com.cn/problem/P1659）manacher|palindrome_length_count
P3501（https://www.luogu.com.cn/problem/P3501）manacher|palindrome_length_count|classical|change_manacher
P6216（https://www.luogu.com.cn/problem/P6216）
P5446（https://www.luogu.com.cn/problem/P5446）

===================================CodeForces===================================
1682A（https://codeforces.com/contest/1682/problem/A）palindromic|center_extension
1326D2（https://codeforces.com/problemset/problem/1326/D2）palindrome_post_pre|manacher
7D（https://codeforces.com/problemset/problem/7/D）palindrome_just_start|manacher
835D（https://codeforces.com/problemset/problem/835/D）
17E（https://codeforces.com/contest/17/problem/E）palindrome_count_start_end|manacher
1081H（https://codeforces.com/problemset/problem/1081/H）
1827C（https://codeforces.com/contest/1827/problem/C）


===================================LibraryChecker===================================
1（https://judge.yosupo.jp/problem/enumerate_palindromes）counter|palindrome_substring
2（https://www.luogu.com.cn/problem/UVA11475）palindrome_just_end|manacher


"""

from src.strings.manacher_palindrome.template import ManacherPlindrome

from src.utils.fast_io import FastIO


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1745(s: str) -> bool:
        """
        url: https://leetcode-cn.com/problems/palindrome-partitioning-iv/
        tag: manacher|palindrome_start_end
        """
        start, end = ManacherPlindrome().palindrome_start_end(s)
        dct = [set(ls) for ls in end]
        for i in start[0]:
            for j in end[-1]:
                if i < j and i + 1 in dct[j - 1]:
                    return True
        return False

    @staticmethod
    def lg_4555(s):
        """
        url: https://www.luogu.com.cn/problem/P4555
        tag: longest_palindrome_substring|prefix_suffix
        """
        n = len(s)
        post, pre = ManacherPlindrome().palindrome_post_pre(s)
        ans = max(post[i + 1] + pre[i] for i in range(n - 1))
        return ans

    @staticmethod
    def lc_5(s: str) -> str:
        """
        url: https://leetcode.cn/problems/longest-palindromic-substring/
        tag: longest_palindrome_substring|classical
        """
        post, pre = ManacherPlindrome().palindrome_post_pre(s)
        i = post.index(max(post))
        return s[i: i + post[i]]

    @staticmethod
    def ac_141(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/141/
        tag: manacher|longest_palindrome_substring|binary_search|hash
        """
        ind = 0
        while True:
            s = ac.read_str()
            if s == "END":
                break
            ind += 1
            ans = ManacherPlindrome().palindrome_longest_length(s)
            ac.st(f"Case {ind}: {ans}")
        return

    @staticmethod
    def lg_p1872(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1872
        tag: counter|palindrome_substring|manacher|classical
        """

        s = ac.read_str()
        n = len(s)
        start, end = ManacherPlindrome().palindrome_start_end(s)
        start = [len(x) for x in start]
        end = [len(x) for x in end]
        pre = ans = 0
        for i in range(n):
            ans += pre * start[i]
            pre += end[i]
        ac.st(ans)
        return

    @staticmethod
    def lg_p6297(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6297
        tag: center_expansion_method|plindrome
        """

        n, k = ac.read_list_ints()
        mod = 10 ** 9 + 7
        nums = ac.read_list_ints()
        ans = 0
        for i in range(n):
            cur = nums[i]
            rem = k
            x, y = i - 1, i + 1
            while x >= 0 and y < n:
                if nums[x] != nums[y]:
                    if not rem:
                        break
                    rem -= 1
                cur *= nums[x] * nums[y]
                x -= 1
                y += 1
            ans = max(ans, cur)

            if i + 1 < n:
                cur = 0
                rem = k
                x, y = i, i + 1
                while x >= 0 and y < n:
                    if nums[x] != nums[y]:
                        if not rem:
                            break
                        rem -= 1
                    cur = cur if cur else 1
                    cur *= nums[x] * nums[y]
                    x -= 1
                    y += 1
                ans = max(ans, cur)
        ac.st(ans % mod)
        return

    @staticmethod
    def lc_1960(s: str) -> int:
        """
        url: https://leetcode.cn/problems/maximum-product-of-the-length-of-two-palindromic-substrings/
        tag: longest_palindrome_substring|prefix_suffix|classical
        """
        post, pre = ManacherPlindrome().palindrome_post_pre(s)

        n = len(s)
        if post[-1] % 2 == 0:
            post[-1] = 1
        for i in range(n - 2, -1, -1):
            if post[i] % 2 == 0:
                post[i] = 1
            post[i] = post[i] if post[i] > post[i + 1] else post[i + 1]

        ans = x = 0
        for i in range(n - 1):
            if pre[i] % 2 == 0:
                pre[i] = 1
            x = x if x > pre[i] else pre[i]
            ans = ans if ans > x * post[i + 1] else x * post[i + 1]
        return ans

    @staticmethod
    def lc_2472(s: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/
        tag: manacher|linear_dp|palindrome_start_end
        """
        n = len(s)
        _, end = ManacherPlindrome().palindrome_start_end(s)
        dp = [0] * (n + 1)
        for i in range(n):
            dp[i + 1] = dp[i]
            for j in end[i]:
                if i - j + 1 >= k and dp[j] + 1 > dp[i + 1]:
                    dp[i + 1] = dp[j] + 1
        return dp[n]

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/enumerate_palindromes
        tag: manacher
        """
        s = ac.read_str()
        t = "#".join(s)
        dp = ManacherPlindrome().manacher(t)
        n = len(t)

        for i in range(n):
            x = 2 * dp[i] - 1
            if t[i + dp[i] - 1] == "#":
                dp[i] = (x - 1) // 2
            else:
                dp[i] = (x + 1) // 2
        ac.lst(dp)
        return

    @staticmethod
    def lg_p3805(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3805
        tag: palindrome_longest_length|manacher
        """
        s = ac.read_str()
        ans = ManacherPlindrome().palindrome_longest_length(s)
        ac.st(ans)
        return

    @staticmethod
    def cf_1362d2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1326/D2
        tag: palindrome_post_pre|manacher
        """
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)

            i, j = 0, n - 1
            while i < j and s[i] == s[j]:
                i += 1
                j -= 1
            ans = s[:i]
            s = s[i:j + 1]
            post, pre = ManacherPlindrome().palindrome_post_pre(s)
            n = len(s)
            mid = ""
            for i in range(n - 1, -1, -1):
                if pre[i] == i + 1:
                    mid = s[:i + 1]
                    break
            for i in range(n):
                if post[i] == n - i:
                    if n - i > len(mid):
                        mid = s[-post[i]:]
                    break
            ac.st(ans + mid + ans[::-1])
        return

    @staticmethod
    def cf_7d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/7/D
        tag: palindrome_just_start|manacher
        """
        s = ac.read_str()
        dct = set(ManacherPlindrome().palindrome_just_start(s))
        n = len(s)
        dp = [0] * (n + 1)
        for i in range(n):
            if i not in dct:
                continue
            dp[i + 1] = dp[(i + 1) // 2] + 1
        ac.st(sum(dp))
        return

    @staticmethod
    def cf_17e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/17/problem/E
        tag: palindrome_count_start_end|manacher|inclusion_exclusion|reverse_thinking
        """
        mod = 51123987
        n = ac.read_int()
        s = ac.read_str()
        start, end = ManacherPlindrome().palindrome_count_start_end(s)
        tot = sum(start)
        ans = tot * (tot - 1) // 2
        pre = 0
        for i in range(n):
            ans -= pre * start[i]
            pre += end[i]
            pre %= mod
            ans %= mod
        ac.st(ans)
        return

    @staticmethod
    def lg_p1659(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P1659
        tag: manacher|palindrome_length_count
        """
        n, k = ac.read_list_ints()
        s = ac.read_str()
        cnt = ManacherPlindrome().palindrome_length_count(s)
        ans = 1
        mod = 19930726
        for i in range(n, 0, -1):
            if i % 2:
                x = min(cnt[i], k)
                ans *= pow(i, x, mod)
                ans %= mod
                k -= x
                if not k:
                    ac.st(ans)
                    return
        ac.st(-1)
        return

    @staticmethod
    def lg_p3501(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3501
        tag: manacher|palindrome_length_count|classical|change_manacher
        """

        def manacher(s):
            """template of get the palindrome radius for every i-th character as center"""
            n = len(s)
            arm = [0] * n
            left, right = 0, -1
            for i in range(0, n):
                a, b = arm[left + right - i], right - i + 1
                a = a if a < b else b
                k = 0 if i > right else a
                while 0 <= i - k and i + k < n and (
                        (s[i - k] != s[i + k] and s[i - k] != "#" and s[i + k] != "#") or s[i - k] == s[i + k] == "#"):
                    k += 1
                arm[i] = k
                k -= 1
                if i + k > right:
                    left = i - k
                    right = i + k
            # s[i-arm[i]+1: i+arm[i]] is palindrome substring for every i
            return arm

        m = ac.read_int()
        mp = ManacherPlindrome()
        mp.manacher = manacher
        cnt = mp.palindrome_length_count(ac.read_str())
        ans = sum(cnt[i] for i in range(2, m + 1, 2))
        ac.st(ans)
        return

    @staticmethod
    def library_check_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/UVA11475
        tag: palindrome_just_end|manacher
        """
        while True:
            s = ac.read_str()
            if not s:
                break
            post = ManacherPlindrome().palindrome_just_end(s)
            if not post:
                ac.st(s + s)
            else:
                x = min(post)
                ac.st(s + s[:x][::-1])
        return

    @staticmethod
    def lc_647(s: str) -> int:
        """
        url: https://leetcode.cn/problems/palindromic-substrings/
        tag: manacher|palindrome_count
        """
        return ManacherPlindrome().palindrome_count(s)
"""
Algorithm：palindrome_number|brute_force
Description：

====================================LeetCode====================================
2081（https://leetcode.cn/problems/sum-of-k-mirror-numbers/）brute_force|10-base|palindrome_number
866（https://leetcode.cn/problems/prime-palindrome/）brute_force|palindrome_prime
564（https://leetcode.cn/problems/find-the-closest-palindrome/）brute_force
906（https://leetcode.cn/problems/super-palindromes/）preprocess|brute_force
1088（https://leetcode.cn/problems/confusing-number-ii/description/）implemention|brute_force
100151（https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/）palindrome_number|brute_force|median_greedy|binary_search|classical

=====================================LuoGu======================================
P1609（https://www.luogu.com.cn/problem/P1609）brute_force


"""
import bisect
from cmath import math.inf
from collections import defaultdict
from itertools import accumulate
from typing import List

from src.strings.palindrome_num.template import PalindromeNum


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_906(left: str, right: str) -> int:
        """
        url: https://leetcode.cn/problems/super-palindromes/
        tag: preprocess|brute_force
        """
        # preprocess所有的回文数其开方也是回文数
        nums = PalindromeNum().get_palindrome_num_2(10)
        res = [num * num for num in nums if str(num * num)[::-1] == str(num * num)]
        left = int(left)
        right = int(right)
        return bisect.bisect_right(res, right) - bisect.bisect_left(res, left)

    @staticmethod
    def lc_100151(lst: List[int]) -> int:
        """
        url：https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/
        tag：palindrome_number|brute_force|median_greedy|binary_search|classical
        """
        nums = PalindromeNum().get_palindrome_num_1(9)
        nums.append(10 ** 9 + 1)
        lst.sort()
        pre = list(accumulate(lst, initial=0))
        n = len(lst)
        jj = bisect.bisect_left(nums, lst[n // 2])
        ans = math.inf
        for j in [jj - 1, jj]:
            if j >= 0:
                i = bisect.bisect_left(lst, nums[j])
                yy = nums[j]
                cur = i * yy - pre[i] + pre[-1] - pre[i] - (n - i) * yy
                if cur < ans:
                    ans = cur
        return ans

    @staticmethod
    def lc_1088(n: int) -> int:
        """
        url: https://leetcode.cn/problems/confusing-number-ii/description/
        tag: implemention|brute_force
        """
        # preprocess后binary_search
        ind = {0: 0, 1: 1, 6: 9, 8: 8, 9: 6}
        pre = [0, 1, 6, 8, 9]
        res = pre[:]
        for _ in range(2, 10):
            nex = []
            for num in pre:
                for d in ind:
                    # brute_force方式
                    nex.append(num * 10 + d)
            res.extend(nex)
            pre = nex[:]
        res = sorted(set(res))

        def check(x):
            # check函数
            if x <= 0:
                return False
            s = str(x)
            t = int("".join(str(ind[int(w)]) for w in s[::-1]))
            return t != x

        res = [num for num in res if check(num)]
        res.append(1000000000)  # 注意边界
        return bisect.bisect_right(res, n)

    @staticmethod
    def lc_2081(k: int, n: int) -> int:
        """
        url: https://leetcode.cn/problems/sum-of-k-mirror-numbers/
        tag: brute_force|10-base|palindrome_number
        """
        # brute_force 10 进制palindrome_number并判断其 k 进制是否依然回文
        dct = defaultdict(list)
        # 放到preprocess
        nums = PalindromeNum().get_palindrome_num_2(12)
        for k in range(2, 10):
            for num in nums:
                lst = NumberTheory().get_k_bin_of_n(num, k)
                if lst == lst[::-1]:
                    dct[k].append(num)
                    if len(dct[k]) >= 30:
                        break
        return sum(dct[k][:n])
"""
Algorithm：string_hash|tree_hash|matrix_hash|tree_minimum_expression|longest_prefix_palindrome_substring|longest_suffix_palindrome_substring
Description：counter|sliding_window|double_random_mod|hash_crush

====================================LeetCode====================================
214（https://leetcode.cn/problems/shortest-palindrome/）reverse_hash|string_hash|longest_prefix_palindrome_substring|kmp|manacher
572（https://leetcode.cn/problems/subtree-of-another-tree/）tree_hash
1044（https://leetcode.cn/problems/shortest-palindrome/）suffix_array|height|classical|string_hash
1316（https://leetcode.cn/problems/distinct-echo-substrings）string_hash
2156（https://leetcode.cn/problems/find-substring-with-given-hash-value/）reverse_hash|string_hash
652（https://leetcode.cn/problems/find-duplicate-subtrees/）tree_hash
1554（https://leetcode.cn/problems/strings-differ-by-one-character/）string_hash|trie
1923（https://leetcode.cn/problems/longest-common-subpath/）binary_search|rolling_hash
1948（https://leetcode.cn/problems/delete-duplicate-folders-in-system/）trie_like|tree_hash
2261（https://leetcode.cn/problems/k-divisible-elements-subarrays/submissions/）string_hash
187（https://leetcode-cn.com/problems/repeated-dna-sequences/）
2851（https://leetcode.cn/problems/string-transformation/）string_hash|kmp|matrix_dp|matrix_fast_power
2977（https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/）string_hash|dp|dijkstra|trie
100208（https://leetcode.com/contest/weekly-contest-385/problems/count-prefix-and-suffix-pairs-ii/）string_hash|brute_force

=====================================LuoGu======================================
P6140（https://www.luogu.com.cn/problem/P6140）greedy|implemention|lexicographical_order|string_hash|binary_search|reverse_order|lcs
P2870（https://www.luogu.com.cn/problem/P2870）greedy|implemention|lexicographical_order|string_hash|binary_search|reverse_order|lcs
P5832（https://www.luogu.com.cn/problem/P5832）string_hash
P2852（https://www.luogu.com.cn/problem/P2852）binary_search|suffix_array|height|monotonic_queue|string_hash
P4656（https://www.luogu.com.cn/problem/P4656）string_hash|greedy
P6739（https://www.luogu.com.cn/problem/P6739）prefix_suffix|string_hash
P3370（https://www.luogu.com.cn/problem/P3370）string_hash
P2601（https://www.luogu.com.cn/problem/P2601）matrix_hash
P4824（https://www.luogu.com.cn/problem/P4824）string_hash
P4503（https://www.luogu.com.cn/problem/P4503）string_hash
P3538（https://www.luogu.com.cn/problem/P3538）string_hash|prime_factor|brute_force|circular_section
P6312（https://www.luogu.com.cn/problem/P6312）string_hash|classical

===================================CodeForces===================================
1800D（https://codeforces.com/contest/1800/problem/D）prefix_suffix|hash
514C（https://codeforces.com/problemset/problem/514/C）string_hash
1200E（https://codeforces.com/problemset/problem/1200/E）string_hash|kmp
580E（https://codeforces.com/problemset/problem/580/E）segment_tree_hash|range_change|range_hash_reverse|circular_section
452F（https://codeforces.com/contest/452/problem/F）segment_tree_hash|string_hash|point_set|range_hash|range_reverse
7D（https://codeforces.com/problemset/problem/7/D）string_hash|palindrome|classical
835D（https://codeforces.com/problemset/problem/835/D）palindrome|string_hash
1977D（https://codeforces.com/contest/1977/problem/D）string_hash|brute_force|brain_teaser|classical
1418G（https://codeforces.com/problemset/problem/1418/G）string_hash|random_hash|classical|two_pointers

====================================AtCoder=====================================
ABC141E（https://atcoder.jp/contests/abc141/tasks/abc141_e）binary_search|string_hash|check
ABC331F（https://atcoder.jp/contests/abc331/tasks/abc331_f）point_set|range_hash_reverse|palindrome|classical
ABC310C（https://atcoder.jp/contests/abc310/tasks/abc310_c）string_hash|classical
ABC353E（https://atcoder.jp/contests/abc353/tasks/abc353_e）string_hash|trie
ABC367F（https://atcoder.jp/contests/abc367/tasks/abc367_f）random_seed|random_hash

=====================================AcWing=====================================
140（https://www.acwing.com/problem/content/140/）string_hash
158（https://www.acwing.com/problem/content/description/158/）matrix_hash
159（https://www.acwing.com/problem/content/description/159/）tree_hash|tree_minimum_expression
139（https://www.acwing.com/problem/content/139/）matrix_hash

=====================================LibraryChecker=====================================
1（https://ac.nowcoder.com/acm/contest/64384/D）string_hash|implemention
2（https://www.luogu.com.cn/problem/UVA11019）matrix_hash|string_hash
3（https://ac.nowcoder.com/acm/problem/51003）matrix_hash|string_hash

"""

import random
from collections import defaultdict, Counter
from itertools import accumulate
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.graph.dijkstra.template import Dijkstra
from src.mathmatics.fast_power.template import MatrixFastPower
from src.mathmatics.prime_factor.template import PrimeFactor
from src.strings.string_hash.template import StringHash, PointSetRangeHashReverse, RangeSetRangeHashReverse, \
    MatrixHash, MatrixHashReverse, StringHashSingle, StringHashSingleBuild
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __init__(self):
        return

    @staticmethod
    def cf_1800g(ac=FastIO()):
        # tree_hash编码判断树是否对称
        for _ in range(ac.read_int()):
            n = ac.read_int()
            edge = [[] for _ in range(n)]
            for _ in range(n - 1):
                u, v = ac.read_list_ints_minus_one()
                edge[u].append(v)
                edge[v].append(u)

            @ac.bootstrap
            def dfs(i, fa):
                res = []
                cnt = 1
                for j in edge[i]:
                    if j != fa:
                        yield dfs(j, i)
                        res.append(tree_hash[j])
                        cnt += sub[j]
                st = (tuple(sorted(res)), cnt)
                if st not in seen:
                    seen[st] = len(seen) + 1
                tree_hash[i] = seen[st]
                sub[i] = cnt
                yield

            # dfs|或者迭代预先将子tree_hash编码
            tree_hash = [-1] * n
            sub = [0] * n
            seen = dict()
            dfs(0, -1)

            # 逐层判断hash值不为0的子树是否对称
            u = 0
            father = -1
            ans = "YES"
            while u != -1:
                dct = Counter(tree_hash[v] for v in edge[u] if v != father)
                single = 0
                for w in dct:
                    single += dct[w] % 2
                if single == 0:
                    break
                if single > 1:
                    ans = "NO"
                    break
                for v in edge[u]:
                    if v != father and dct[tree_hash[v]] % 2:
                        u, father = v, u
                        break
            ac.st(ans)
        return

    @staticmethod
    def lc_214(s: str) -> str:
        """
        url: https://leetcode.cn/problems/shortest-palindrome/
        tag: reverse_hash|string_hash|longest_prefix_palindrome_substring|kmp|manacher
        """

        # 正向与反向string_hash字符串前缀最长palindrome_substring，也可以用KMP与manacher

        def query(x, y):
            # 字符串区间的hash值，索引从 0 开始
            ans = [0, 0]
            for ii in range(2):
                if x <= y:
                    ans[ii] = (pre[ii][y + 1] - pre[ii][x] * pp[ii][y - x + 1]) % mod[ii]
            return ans

        def query_rev(x, y):
            # 字符串区间的hash值，索引从 0 开始
            ans = [0, 0]
            for ii in range(2):
                if x <= y:
                    ans[ii] = (rev[ii][y + 1] - rev[ii][x] * pp[ii][y - x + 1]) % mod[ii]
            return ans

        n = len(s)
        p = [random.randint(26, 100), random.randint(26, 100)]
        mod = [random.randint(10 ** 9 + 7, 2 ** 31 - 1), random.randint(10 ** 9 + 7, 2 ** 31 - 1)]
        pre = [[0], [0]]
        pp = [[1], [1]]
        for w in s:
            for i in range(2):
                pre[i].append((pre[i][-1] * p[i] + ord(w) - ord("a")) % mod[i])
                pp[i].append((pp[i][-1] * p[i]) % mod[i])

        rev = [[0], [0]]
        for w in s[::-1]:
            for i in range(2):
                rev[i].append((rev[i][-1] * p[i] + ord(w) - ord("a")) % mod[i])

        length = 1
        for i in range(1, n):
            m = (i + 1) // 2
            left = query(0, m - 1)
            right = query_rev((n - 1) - i, (n - 1) - (i - m + 1))
            if left == right:
                length = i + 1
        return s[length:][::-1] + s

    @staticmethod
    def lc_652(root):
        """
        url: https://leetcode.cn/problems/find-duplicate-subtrees/
        tag: tree_hash
        """

        # tree_hash编码序列化子树，查找重复子树
        def dfs(node):
            if not node:
                return 0

            state = (node.val, dfs(node.left), dfs(node.right))
            if state in seen:
                node, idy = seen[state]
                repeat.add(node)
                return idy
            seen[state] = [node, len(seen) + 1]
            return seen[state][1]

        seen = dict()
        repeat = set()
        dfs(root)
        return list(repeat)

    @staticmethod
    def cf_1800d_1(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1800/problem/D
        tag: prefix_suffix|hash
        """

        n = 2 * 10 ** 5
        p1 = random.randint(26, 100)
        p2 = random.randint(26, 100)
        mod1 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)
        mod2 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)

        dp1 = [1]
        for _ in range(1, n + 1):
            dp1.append((dp1[-1] * p1) % mod1)
        dp2 = [1]
        for _ in range(1, n + 1):
            dp2.append((dp2[-1] * p2) % mod2)

        for _ in range(ac.read_int()):
            n = ac.read_int()
            s = ac.read_str()

            post1 = [0] * (n + 1)
            for i in range(n - 1, -1, -1):
                post1[i] = (post1[i + 1] + (ord(s[i]) - ord("a")) * dp1[n - 1 - i]) % mod1

            post2 = [0] * (n + 1)
            for i in range(n - 1, -1, -1):
                post2[i] = (post2[i + 1] + (ord(s[i]) - ord("a")) * dp2[n - 1 - i]) % mod2

            ans = set()
            pre1 = pre2 = 0
            for i in range(n - 1):
                x1 = pre1
                y1 = post1[i + 2]
                x2 = pre2
                y2 = post2[i + 2]
                ans.add(((x1 * dp1[n - i - 2] + y1) % mod1, (x2 * dp2[n - i - 2] + y2) % mod2))
                pre1 = (pre1 * p1) % mod1 + ord(s[i]) - ord("a")
                pre2 = (pre2 * p2) % mod2 + ord(s[i]) - ord("a")
            ac.st(len(ans))
        return

    @staticmethod
    def cf_1800d_2(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1800/problem/D
        tag: prefix_suffix|hash
        """

        for _ in range(ac.read_int()):
            n = ac.read_int()
            s = ac.read_str()
            ans = n - 1
            for i in range(2, n):
                if s[i] == s[i - 2]:
                    ans -= 1
            ac.st(ans)
        return

    @staticmethod
    def abc_141e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc141/tasks/abc141_e
        tag: suffix_array|height|binary_search|string_hash
        """

        def check(x):
            if x == 0:
                return True
            pre = dict()
            for i in range(x - 1, n):
                cur = (sh1.query(i - x + 1, i), sh2.query(i - x + 1, i))
                if cur in pre:
                    if i - pre[cur] >= x:
                        return True
                else:
                    pre[cur] = i
            return False

        n = ac.read_int()
        s = ac.read_str()
        sh1 = StringHash([ord(w) - ord("a") for w in s])
        sh2 = StringHash([ord(w) - ord("a") for w in s])
        ans = BinarySearch().find_int_right(0, n, check)
        ac.st(ans)
        return

    @staticmethod
    def ac_138(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/140/
        tag: string_hash
        """
        # string_hash，子串是否完全相等
        p1 = random.randint(26, 100)
        p2 = random.randint(26, 100)
        mod1 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)
        mod2 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)

        s = ac.read_str()
        n = len(s)
        pre1 = [0] * (n + 1)
        pre2 = [0] * (n + 1)
        for i in range(n):
            pre1[i + 1] = (pre1[i] * p1 + ord(s[i]) - ord("a")) % mod1
            pre2[i + 1] = (pre2[i] * p2 + ord(s[i]) - ord("a")) % mod2
        m = ac.read_int()
        lst = []
        while len(lst) < m * 4:
            lst.extend(ac.read_list_ints_minus_one())

        for i in range(0, m * 4, 4):
            x1, y1, x2, y2 = lst[i: i + 4]
            m1 = y1 - x1 + 1
            m2 = y2 - x2 + 1
            if m1 != m2:
                ac.no()
                continue
            cur1 = ((pre1[y1 + 1] - pre1[x1] * pow(p1, m1, mod1)) % mod1,
                    (pre2[y1 + 1] - pre2[x1] * pow(p2, m2, mod2)) % mod2)
            cur2 = ((pre1[y2 + 1] - pre1[x2] * pow(p1, m1, mod1)) % mod1,
                    (pre2[y2 + 1] - pre2[x2] * pow(p2, m2, mod2)) % mod2)
            if cur1 == cur2:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def ac_158(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/158/
        tag: matrix_hash
        """
        m, n, a, b = ac.read_list_ints()
        grid = []
        for _ in range(n):
            grid.extend([int(w) for w in ac.read_str()])
        mh = MatrixHash(m, n, grid)
        pre = set()
        for i in range(a - 1, m):
            for j in range(b - 1, n):
                pre.add(mh.query_sub(i, j, a, b))

        for _ in range(ac.read_int()):
            mat = []
            for _ in range(a):
                mat.extend([int(w) for w in ac.read_str()])
            cur = mh.query_matrix(a, b, mat)
            ac.st(1 if cur in pre else 0)
        return

    @staticmethod
    def ac_157(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/description/159/
        tag: tree_hash|tree_minimum_expression
        """

        def check(st):
            # 解码原始树的字符串表示，再tree_minimum_expression

            parent = [-1]
            pa = 0
            ind = 0
            dct = defaultdict(list)
            for w in st:
                if w == "0":
                    ind += 1
                    dct[pa].append(ind)
                    parent.append(pa)
                    pa = ind
                else:
                    pa = parent[pa]

            # 生成tree_minimum_expression
            n = ind + 1
            stack = [0]
            sub = [""] * n
            while stack:
                i = stack.pop()
                if i >= 0:
                    stack.append(~i)
                    for j in dct[i]:
                        stack.append(j)
                else:
                    i = ~i
                    lst = []
                    for j in dct[i]:
                        lst.append("0" + sub[j] + "1")
                        sub[j] = ""
                    lst.sort()
                    sub[i] = "".join(lst)
            return sub[0]

        for _ in range(ac.read_int()):
            s = ac.read_str()
            t = ac.read_str()
            if check(s) == check(t):
                ac.st("same")
            else:
                ac.st("different")
        return

    @staticmethod
    def lc_2851(s: str, t: str, k: int) -> int:
        """
        url: https://leetcode.cn/problems/string-transformation/
        tag: string_hash|kmp|matrix_dp|matrix_fast_power
        """
        mod = 10 ** 9 + 7
        n = len(s)
        sh1 = StringHash([ord(w) - ord("a") for w in t] + [26] + [ord(w) - ord("a") for w in s + s])
        sh2 = StringHash([ord(w) - ord("a") for w in t] + [26] + [ord(w) - ord("a") for w in s + s])
        target = (sh1.query(0, n - 1), sh2.query(0, n - 1))
        p = sum((sh1.query(i - n + 1, i), sh2.query(0, n - 1)) == target for i in range(2 * n, 3 * n))
        q = n - p
        mat = [[p - 1, p], [q, q - 1]]
        vec = [1, 0] if (sh1.query(n + 1, 2 * n), sh2.query(n + 1, 2 * n)) == target else [0, 1]
        res = MatrixFastPower().matrix_pow(mat, k, mod)
        ans = vec[0] * res[0][0] + vec[1] * res[0][1]
        return ans % mod

    @staticmethod
    def lg_p2852(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2852
        tag: binary_search|suffix_array|height|monotonic_queue|string_hash
        """

        def check(x):
            pre = defaultdict(int)
            for i in range(n):
                if i >= x - 1:
                    pre[(sh1.query(i - x + 1, i), sh2.query(i - x + 1, i))] += 1
            return max(pre.values()) >= k

        n, k = ac.read_list_ints()
        nums = [ac.read_int() for _ in range(n)]
        sh1 = StringHash(nums)
        sh2 = StringHash(nums)
        ans = BinarySearch().find_int_right(0, n, check)
        ac.st(ans)

        return

    @staticmethod
    def lg_p4656(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4656
        tag: string_hash|greedy
        """
        # string_hashgreedy选取

        p1 = random.randint(26, 100)
        p2 = random.randint(26, 100)
        mod1 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)
        mod2 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)

        for _ in range(ac.read_int()):
            s = ac.read_str()
            ans = 0
            n = len(s)
            i, j = 0, n - 1
            while j - i + 1 >= 2:
                # 从两边依次选取
                flag = False
                pre1 = post1 = pre2 = post2 = 0
                pp1 = pp2 = 1
                x, y = i, j
                while True:
                    if pre1 == post1 and pre2 == post2 and x > i:
                        flag = True
                        i = x
                        j = y
                        break
                    if y - x + 1 <= 1:
                        break
                    w = s[x]
                    pre1 = (pre1 * p1 + ord(w) - ord("a")) % mod1
                    pre2 = (pre2 * p2 + ord(w) - ord("a")) % mod2

                    w = s[y]
                    post1 = (post1 + pp1 * (ord(w) - ord("a"))) % mod1
                    post2 = (post2 + pp2 * (ord(w) - ord("a"))) % mod2
                    pp1 = (pp1 * p1) % mod1
                    pp2 = (pp2 * p2) % mod2
                    x += 1
                    y -= 1
                # 如果构成一对回文增| 2 否则增| 1
                if flag:
                    ans += 2
                else:
                    ans += 1
                    i = j + 1
                    break
            # 特判还剩中间一个字母的情况
            if i == j:
                ans += 1
            ac.st(ans)

        return

    @staticmethod
    def lg_p6739(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P6739
        tag: prefix_suffix|string_hash
        """
        n = ac.read_int()
        s = ac.read_str()
        if n % 2 == 0:
            ac.st("NOT POSSIBLE")
            return

        sh1 = StringHash([ord(w) - ord("a") for w in s])
        sh2 = StringHash([ord(w) - ord("a") for w in s])

        ans = dict()
        for i in range(n):
            if len(ans) > 1:
                break
            if i < n // 2:
                ss = (sh1.query(0, i - 1), sh2.query(0, i - 1))
                tt = (sh1.query(i + 1, n // 2), sh2.query(i + 1, n // 2))
                a = (ss[0] * sh1.pp[n // 2 - i] + tt[0]) % sh1.mod
                b = (ss[1] * sh2.pp[n // 2 - i] + tt[1]) % sh2.mod

                if sh1.query(n // 2 + 1, n - 1) == a and sh2.query(n // 2 + 1, n - 1) == b:
                    ans[(a, b)] = i

            elif i == n // 2:
                a, b = sh1.query(0, n // 2 - 1), sh2.query(0, n // 2 - 1)
                if sh1.query(n // 2 + 1, n - 1) == a and sh2.query(n // 2 + 1, n - 1) == b:
                    ans[(a, b)] = i
            else:
                ss = (sh1.query(n // 2, i - 1), sh2.query(n // 2, i - 1))
                tt = (sh1.query(i + 1, n - 1), sh2.query(i + 1, n - 1))
                a = (ss[0] * sh1.pp[n - 1 - i] + tt[0]) % sh1.mod
                b = (ss[1] * sh2.pp[n - 1 - i] + tt[1]) % sh2.mod

                if sh1.query(0, n // 2 - 1) == a and sh2.query(0, n // 2 - 1) == b:
                    ans[(a, b)] = i
        if not ans:
            ac.st("NOT POSSIBLE")
        elif len(ans) > 1:
            ac.st("NOT UNIQUE")
        else:
            i = list(ans.values())[0]
            if i >= n // 2:
                ac.st(s[:n // 2])
            elif i < n // 2:
                ac.st(s[-(n // 2):])
        return

    @staticmethod
    def lc_1948(paths: List[List[str]]) -> List[List[str]]:
        """
        url: https://leetcode.cn/problems/delete-duplicate-folders-in-system/
        tag: trie_like|tree_hash
        """
        # tree_hashtrie的子树编码

        dct = dict()  # 建树
        for path in paths:
            cur = dct
            for w in path:
                if w not in cur:
                    cur[w] = dict()
                cur = cur[w]
            cur["**"] = 1

        def dfs(node, cur_w):  # hash
            if not node:
                return tuple([0])

            state = tuple()
            for ww in sorted(node):
                if ww != "**" and ww != "##":
                    state += dfs(node[ww], ww)
            if state not in seen:
                seen[state] = len(seen) + 1
            node["##"] = seen[state]
            cnt[seen[state]] += 1
            return seen[state], cur_w

        seen = dict()
        cnt = Counter()
        dfs(dct, "")

        def dfs(node):
            if not node:
                return
            if cnt[node["##"]] > 1 and node["##"] > 1:
                return
            if pre:
                ans.append(pre[:])
            for ww in node:
                if ww != "##" and ww != "**":
                    pre.append(ww)
                    dfs(node[ww])
                    pre.pop()
            return

        # back_trace取出路径
        ans = []
        pre = []
        dfs(dct)
        return ans

    @staticmethod
    def lc_2261(nums: List[int], k: int, p: int) -> int:
        """
        url: https://leetcode.cn/problems/k-divisible-elements-subarrays/submissions/
        tag: string_hash
        """
        # string_hash对数组编码
        n = len(nums)
        pre = list(accumulate([int(num % p == 0) for num in nums], initial=0))
        p = [random.randint(26, 100), random.randint(26, 100)]
        mod = [random.randint(10 ** 9 + 7, 2 ** 31 - 1), random.randint(10 ** 9 + 7, 2 ** 31 - 1)]
        ans = set()
        for i in range(n):
            lst = [0, 0]
            for j in range(i, n):
                if pre[j + 1] - pre[i] <= k:
                    for x in range(2):
                        lst[x] = (lst[x] * p[x] + nums[j]) % mod[x]
                    ans.add((j - i + 1,) + tuple(lst))
                else:
                    break
        return len(ans)

    @staticmethod
    def lc_1316(text: str) -> int:
        """
        url: https://leetcode.cn/problems/distinct-echo-substrings
        tag: string_hash
        """
        n = len(text)
        sh1 = StringHash([ord(w) - ord("a") for w in text])
        sh2 = StringHash([ord(w) - ord("a") for w in text])

        ans = 0
        for x in range(1, n // 2 + 1):
            cur = set()
            for i in range(n - 2 * x + 1):
                ans1 = (sh1.query(i, i + x - 1), sh2.query(i, i + x - 1))
                ans2 = (sh1.query(i + x, i + 2 * x - 1), sh2.query(i + x, i + 2 * x - 1))
                if ans1 == ans2:
                    cur.add(ans1)
            ans += len(cur)
        return ans

    @staticmethod
    def lc_1923_1(n: int, paths: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/longest-common-subpath/
        tag: binary_search|string_hash
        """

        def check(x):
            pre = set()
            ind = 0
            for i in range(k):
                m = len(paths[i])
                cur = set()
                for j in range(ind, ind + m - x + 1):
                    cur.add((sh1.query(j, j + x - 1), sh2.query(j, j + x - 1)))
                if not i:
                    pre = cur
                else:
                    pre = pre.intersection(cur)
                ind += m
            return len(pre) > 0

        k = len(paths)
        lst = []
        for path in paths:
            lst.extend(path)
        n += 1
        sh1 = StringHash(lst)
        sh2 = StringHash(lst)
        ans = BinarySearch().find_int_right(0, min(len(p) for p in paths), check)
        return ans

    @staticmethod
    def lc_1923_2(n: int, paths: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/longest-common-subpath/
        tag: binary_search|string_hash
        """

        def check(x):
            pre = set()
            ind = 0
            for i in range(k):
                m = len(paths[i])
                cur = set()
                for j in range(ind, ind + m - x + 1):
                    cur.add(sh1.query(j, j + x - 1))
                if not i:
                    pre = cur
                else:
                    pre = pre.intersection(cur)
                if not pre:
                    return False
                ind += m
            return len(pre) > 0

        k = len(paths)
        lst = []
        for path in paths:
            lst.extend(path)
        sh1 = StringHashSingle(lst)
        ans = BinarySearch().find_int_right(0, min(len(p) for p in paths), check)
        return ans

    @staticmethod
    def lg_p3370_1(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3370
        tag: string_hash
        """
        ans = set()
        p1, p2 = [random.randint(26, 100), random.randint(26, 100)]
        mod1, mod2 = [random.randint(10 ** 9 + 7, 2 ** 31 - 1), random.randint(10 ** 9 + 7, 2 ** 31 - 1)]
        for _ in range(ac.read_int()):
            s = ac.read_str()
            x1 = x2 = 0
            for w in s:
                x1 = (x1 * p1 + ord(w)) % mod1
                x2 = (x2 * p2 + ord(w)) % mod2
            ans.add((x1, x2))
        ac.st(len(ans))
        return

    @staticmethod
    def lg_p3370_2(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3370
        tag: string_hash
        """
        ans = set()
        for _ in range(ac.read_int()):
            ans.add(hash(ac.read_str()))
        ac.st(len(ans))
        return

    @staticmethod
    def cf_514c(ac=FastIO()):
        """
        url: https://codeforces.com/contest/514/problem/C
        tag: string_hash
        """

        n = 6 * 10 ** 5
        p = [random.randint(26, 100), random.randint(26, 100)]
        mod = [random.randint(10 ** 9 + 7, 2 ** 31 - 1), random.randint(10 ** 9 + 7, 2 ** 31 - 1)]
        pre = [[0] * (n + 1), [0] * (n + 1)]
        pp = [[1] * (n + 1), [1] * (n + 1)]
        for j in range(n):
            for i in range(2):
                pp[i][j + 1] = (pp[i][j] * p[i]) % mod[i]

        def query(x, y):
            if y < x:
                return 0, 0
            res = tuple((pre[i][y + 1] - pre[i][x] * pp[i][y - x + 1]) % mod[i] for i in range(2))
            return res

        ans = set()
        n, m = ac.read_list_ints()
        for _ in range(n):
            s = ac.read_str()
            k = len(s)
            lst = [ord(w) - ord("a") for w in s]
            for j, w in enumerate(lst):
                for i in range(2):
                    pre[i][j + 1] = (pre[i][j] * p[i] + w) % mod[i]

            for i in range(k):
                ll = query(0, i - 1)
                rr = query(i + 1, k - 1)
                for w in range(3):
                    if w != lst[i]:
                        cur = [0, 0]
                        for j in range(2):
                            cur[j] = ((ll[j] * p[j] + w) * pp[j][k - i - 1] + rr[j]) % mod[j]
                        ans.add((k, cur[0], cur[1]))

        for _ in range(m):
            s = ac.read_str()
            k = len(s)
            lst = [ord(w) - ord("a") for w in s]
            cur = [0, 0]
            for j, w in enumerate(lst):
                for i in range(2):
                    cur[i] = (cur[i] * p[i] + w) % mod[i]
            ac.st("YES" if (k, cur[0], cur[1]) in ans else "NO")
        return

    @staticmethod
    def cf_1200e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1200/problem/E
        tag: string_hash|kmp
        """
        ac.read_int()
        lst = ac.read_list_strs()
        n = sum(len(s) for s in lst)
        p = [random.randint(26, 100), random.randint(26, 100)]
        mod = [random.randint(10 ** 9 + 7, 2 ** 31 - 1), random.randint(10 ** 9 + 7, 2 ** 31 - 1)]
        pre = [[0] * (n + 1), [0] * (n + 1)]
        pp = [[1] * (n + 1), [1] * (n + 1)]
        for j in range(n):
            for i in range(2):
                pp[i][j + 1] = (pp[i][j] * p[i]) % mod[i]

        def query1(x, y):
            if y < x:
                return 0, 0
            res = tuple((pre[ii][y + 1] - pre[ii][x] * pp[ii][y - x + 1]) % mod[ii] for ii in range(2))
            return res

        def query2(x, y):
            if y < x:
                return 0, 0
            res = tuple((cur[ii][y + 1] - cur[ii][x] * pp[ii][y - x + 1]) % mod[ii] for ii in range(2))
            return res

        ans = []
        k = 0
        for word in lst:
            m = len(word)
            cur = [[0] * (m + 1), [0] * (m + 1)]
            inter = 0
            for j, w in enumerate(word):
                for i in range(2):
                    cur[i][j + 1] = (cur[i][j] * p[i] + ord(w)) % mod[i]
                if query1(k - j - 1, k - 1) == query2(0, j):
                    inter = j + 1
            for j in range(inter, m):
                w = word[j]
                ans.append(w)
                for i in range(2):
                    pre[i][k + 1] = (pre[i][k] * p[i] + ord(w)) % mod[i]
                k += 1
        ac.st("".join(ans))
        return

    @staticmethod
    def lc_1044(s: str) -> str:
        """
        url: https://leetcode.cn/problems/longest-duplicate-substring/
        tag: suffix_array|height|classical|string_hash
        """
        sh1 = StringHash([ord(w) - ord("a") for w in s])
        sh2 = StringHash([ord(w) - ord("a") for w in s])
        n = len(s)

        def check(x):
            return compute(x) > -1

        def compute(x):
            pre = set()
            for ii in range(n - x + 1):
                cur1, cur2 = sh1.query(ii, ii + x - 1), sh2.query(ii, ii + x - 1)
                if (cur1, cur2) in pre:
                    return ii
                pre.add((cur1, cur2))
            return -1

        length = BinarySearch().find_int_right(0, n, check)
        if length == 0:
            return ""
        i = compute(length)
        return s[i:i + length]

    @staticmethod
    def lc_1554(words: List[str]) -> bool:
        """
        url: https://leetcode.cn/problems/strings-differ-by-one-character/
        tag: string_hash|trie
        """
        pre = set()
        m = len(words[0])
        sh1 = StringHash([0] * m)
        sh2 = StringHash([0] * m)
        for word in words:
            lst = [ord(w) - ord("a") for w in word]
            for j, w in enumerate(lst):
                sh1.pre[j + 1] = (sh1.pre[j] * sh1.p + w) % sh1.mod
                sh2.pre[j + 1] = (sh2.pre[j] * sh2.p + w) % sh2.mod

            for j in range(m):
                ll = sh1.query(0, j - 1)
                rr = sh1.query(j + 1, m - 1)
                cur1 = ((ll * sh1.p + 26) * sh1.pp[m - j - 1] + rr) % sh1.mod

                ll = sh2.query(0, j - 1)
                rr = sh2.query(j + 1, m - 1)
                cur2 = ((ll * sh2.p + 26) * sh2.pp[m - j - 1] + rr) % sh2.mod

                if (cur1, cur2) in pre:
                    return True
                pre.add((cur1, cur2))
        return False

    @staticmethod
    def lc_2156(s: str, p: int, modulo: int, k: int, hash_value: int) -> str:
        """
        url: https://leetcode.cn/problems/find-substring-with-given-hash-value
        tag: string_hash|reverse_order
        """
        ans = -1
        n = len(s)
        pp = pow(p, k - 1, modulo)
        post = 0
        for i in range(n - 1, -1, -1):
            post = post * p + ord(s[i]) - ord("a") + 1
            post %= modulo
            if post == hash_value and i + k - 1 <= n - 1:
                ans = i
            if i + k - 1 <= n - 1:
                post -= (ord(s[i + k - 1]) - ord("a") + 1) * pp
                post %= modulo
        return s[ans: ans + k]

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://ac.nowcoder.com/acm/contest/64384/D
        tag: string_hash|implemention
        """
        n, m, k = ac.read_list_ints()
        s = ac.read_str()
        sh1 = StringHash([int(w) for w in s])
        sh2 = StringHash([int(w) for w in s])
        ind = defaultdict(list)
        for i in range(m - 1, n):
            cur = (sh1.query(i - m + 1, i), sh2.query(i - m + 1, i))
            ind[cur].append(i)
        ans = 0
        for lst in ind.values():
            cur = 0
            pre = -m
            for i in lst:
                if i - pre >= m:
                    cur += 1
                    pre = i
            ans += cur == k
        ac.st(ans)
        return

    @staticmethod
    def cf_452f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/452/problem/F
        tag: segment_tree_hash|string_hash|point_set|range_hash|range_reverse
        """
        n = ac.read_int()
        tree1 = PointSetRangeHashReverse(n)  # TLE
        tree2 = PointSetRangeHashReverse(n)
        nums = ac.read_list_ints_minus_one()
        for num in nums:
            tree1.point_set(num, num, 1)
            tree2.point_set(num, num, 1)
            if num == 0 or num == n - 1:
                continue
            length = min(num + 1, n - num)
            cur1 = [tree1.range_hash(num - length + 1, num), tree2.range_hash(num - length + 1, num)]
            cur2 = [tree1.range_hash_reverse(num, num + length - 1), tree2.range_hash_reverse(num, num + length - 1)]
            if cur1 != cur2:
                ac.yes()
                break
        else:
            ac.no()
        return

    @staticmethod
    def cf_580e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/580/problem/E
        tag: segment_tree_hash|range_change|range_hash_reverse|circular_section
        """
        n, m, k = ac.read_list_ints()
        tree1 = RangeSetRangeHashReverse(n, 10)
        tree2 = RangeSetRangeHashReverse(n, 10)
        s = ac.read_str()
        tree1.build([int(w) for w in s])
        tree2.build([int(w) for w in s])
        for _ in range(m + k):
            lst = ac.read_list_ints()
            if lst[0] == 1:
                l, r, c = lst[1:]
                tree1.range_set(l - 1, r - 1, c)
                tree2.range_set(l - 1, r - 1, c)
            else:
                l, r, d = lst[1:]
                if d == r - l + 1:
                    ac.yes()
                    continue
                else:
                    if tree1.range_hash(l - 1, r - d - 1) == tree1.range_hash(l + d - 1, r - 1):
                        if tree2.range_hash(l - 1, r - d - 1) == tree2.range_hash(l + d - 1, r - 1):
                            ac.yes()
                        else:
                            ac.no()
                    else:
                        ac.no()
        return

    @staticmethod
    def lc_2977(source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:

        """
        url: https://leetcode.cn/problems/minimum-cost-to-convert-string-ii
        tag: string_hash|dp|dijkstra|trie
        """

        sh1 = StringHash([ord(w) - ord("a") for w in source + target])
        sh2 = StringHash([ord(w) - ord("a") for w in source + target])

        has = dict()

        nodes = set(original + changed)
        for string in nodes:
            lst = [len(string)]

            p, mod = sh1.p, sh1.mod
            state = 0
            for w in string:
                state *= p
                state += ord(w) - ord("a")
                state %= mod
            lst.append(state)

            p, mod = sh2.p, sh2.mod
            state = 0
            for w in string:
                state *= p
                state += ord(w) - ord("a")
                state %= mod
            lst.append(state)

            has[tuple(lst)] = string

        ind = {x: i for i, x in enumerate(nodes)}
        m = len(ind)
        dct = [[] for _ in range(m)]
        for x, y, z in zip(original, changed, cost):
            x = ind[x]
            y = ind[y]
            dct[x].append([y, z])
        dis = []
        for x in range(m):
            dis.append(Dijkstra().get_shortest_path(dct, x))

        n = len(source)
        dp = [math.inf] * (n + 1)

        exist = defaultdict(list)
        for s in original:
            exist[s[-1]].append(s)

        dp[0] = 0
        for i in range(n):
            if source[i] == target[i]:
                dp[i + 1] = dp[i]
            for w in exist[source[i]]:
                j = i - len(w) + 1
                s1 = (i - j + 1, sh1.query(j, i), sh2.query(j, i))
                t1 = (i - j + 1, sh1.query(j + n, i + n), sh2.query(j + n, i + n))
                if s1 in has and t1 in has:
                    x, y = ind[has[s1]], ind[has[t1]]
                    z = dis[x][y]
                    if dp[j] + z < dp[i + 1]:
                        dp[i + 1] = dp[j] + z

        return dp[-1] if dp[-1] < math.inf else -1

    @staticmethod
    def ac_139(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/139/
        tag: matrix_hash
        """
        p1 = random.randint(26, 100)
        p2 = random.randint(26, 100)
        mod1 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)
        mod2 = random.randint(10 ** 9 + 7, 2 ** 31 - 1)

        def compute(ls):
            res1 = 0
            for num in ls:
                res1 *= p1
                res1 += num
                res1 %= mod1
            res2 = 0
            for num in ls:
                res2 *= p2
                res2 += num
                res2 %= mod2
            return res1, res2

        def check():
            res = []
            for ii in range(6):
                cu = tuple(lst[ii:] + lst[:ii])
                res.append(compute(cu))
                cu = tuple(lst[:ii + 1][::-1] + lst[ii + 1:][::-1])
                res.append(compute(cu))
            return res

        n = ac.read_int()
        pre = set()
        for _ in range(n):
            lst = ac.read_list_ints()
            now = check()
            if any(cur in pre for cur in now):
                ac.st("Twin snowflakes found.")
                break
            for cur in now:
                pre.add(cur)
        else:
            ac.st("No two snowflakes are alike.")
        return

    @staticmethod
    def library_check_2(ac=FastIO()):

        """
        url: https://www.luogu.com.cn/problem/UVA11019
        tag: matrix_hash|string_hash
        """
        for _ in range(ac.read_int()):  # TLE
            m, n = ac.read_list_ints()
            grid = []
            for _ in range(n):
                grid.extend([ord(w) - ord("a") for w in ac.read_str()])

            mh = MatrixHash(m, n, grid)
            a, b = ac.read_list_ints()
            mat = []
            for _ in range(a):
                mat.extend([ord(w) - ord("a") for w in ac.read_str()])
            cur = mh.query_matrix(a, b, mat)
            ans = 0
            for i in range(a - 1, n):
                for j in range(b - 1, m):
                    if mh.query_sub(i, j, a, b) == cur:
                        ans += 1
            ac.st(ans)
        return

    @staticmethod
    def library_check_3(ac=FastIO()):
        """
        url: https://ac.nowcoder.com/acm/problem/51003
        tag: matrix_hash|string_hash
        """

        m, n, a, b = ac.read_list_ints()
        grid = []
        for _ in range(n):
            grid.extend([int(w) for w in ac.read_str()])
        mh = MatrixHash(m, n, grid)
        pre = set()
        for i in range(a - 1, m):
            for j in range(b - 1, n):
                pre.add(mh.query_sub(i, j, a, b))

        for _ in range(ac.read_int()):
            mat = []
            for _ in range(a):
                mat.extend([int(w) for w in ac.read_str()])
            cur = mh.query_matrix(a, b, mat)
            ac.st(1 if cur in pre else 0)
        return

    @staticmethod
    def lg_p2601(ac=FastIO()):

        """
        url: https://www.luogu.com.cn/problem/P2601
        tag: matrix_hash|string_hash
        """
        m, n = ac.read_list_ints()
        lst = []
        for _ in range(m):
            lst.extend(ac.read_list_ints())
        mh = MatrixHashReverse(m, n, lst)

        def check1(x):

            res1 = mh.query_left_up(i + x - 1, j + x - 1, 2 * x - 1, 2 * x - 1)
            res2 = mh.query_right_up(i + x - 1, j - x + 1, 2 * x - 1, 2 * x - 1)
            res3 = mh.query_left_down(i - x + 1, j + x - 1, 2 * x - 1, 2 * x - 1)
            res4 = mh.query_right_down(i - x + 1, j - x + 1, 2 * x - 1, 2 * x - 1)
            return res1 == res2 == res3 == res4

        def check2(x):

            res1 = mh.query_left_up(i + x, j + x, 2 * x, 2 * x)
            res2 = mh.query_right_up(i + x, j - x + 1, 2 * x, 2 * x)
            res3 = mh.query_left_down(i - x + 1, j + x, 2 * x, 2 * x)
            res4 = mh.query_right_down(i - x + 1, j - x + 1, 2 * x, 2 * x)
            return res1 == res2 == res3 == res4

        bs = BinarySearch()
        ans = i = j = 0

        for i in range(m):
            for j in range(n):
                y = min(i + 1, m - i, j + 1, n - j)
                ans += bs.find_int_right(0, y, check1)
                y = min(i + 1, j + 1, m - i - 1, n - j - 1)
                ans += bs.find_int_right(0, y, check2)
        ac.st(ans)
        return

    @staticmethod
    def lg_p4824(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4824
        tag: string_hash|stack|implemention
        """

        s = ac.read_str()
        t = ac.read_str()
        m, n = len(s), len(t)
        sh = StringHash([ord(w) - ord("a") for w in s + t])
        del t
        target = sh.query(m, m + n - 1)
        i = 0
        stack = []
        for w in s:
            x = ord(w) - ord("a")
            stack.append(w)
            sh.pre[i + 1] = (sh.pre[i] * sh.p + x) % sh.mod
            i += 1
            if i >= n and sh.query(i - n, i - 1) == target:
                i -= n
                for _ in range(n):
                    stack.pop()
        ac.st("".join(stack))
        return

    @staticmethod
    def lg_p4503(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4503
        tag: string_hash
        """

        ind = dict()
        words = []
        for i in range(10):
            ind[str(i)] = i
            words.append(str(i))
        for i in range(26):
            ind[chr(i + ord("a"))] = 10 + i
            words.append(chr(i + ord("a")))
        for i in range(26):
            ind[chr(i + ord("A"))] = 36 + i
            words.append(chr(i + ord("A")))
        ind["_"] = 62
        ind["@"] = 63
        words.extend(["_", "@"])

        n, ll, s = ac.read_list_ints()
        sh1 = StringHash([0] * ll)
        sh2 = StringHash([0] * ll)
        cnt = dict()
        ans = 0
        for _ in range(n):
            st = [ind[w] + 1 for w in ac.read_str()]
            for j in range(ll):
                sh1.pre[j + 1] = (sh1.pre[j] * sh1.p + st[j]) % sh1.mod
                sh2.pre[j + 1] = (sh2.pre[j] * sh2.p + st[j]) % sh2.mod
            for j in range(ll):
                pre1 = sh1.pre[j]
                post1 = sh1.query(j + 1, ll - 1)
                pre2 = sh2.pre[j]
                post2 = sh2.query(j + 1, ll - 1)
                right = ll - j - 1
                cur1 = (pre1 * sh1.pp[right + 1] + post1) % sh1.mod
                cur2 = (pre2 * sh2.pp[right + 1] + post2) % sh2.mod
                ans += cnt.get((cur1, cur2), 0)
                cnt[(cur1, cur2)] = cnt.get((cur1, cur2), 0) + 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p3538(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3538
        tag: string_hash|prime_factor|brute_force|circular_section
        """
        n = ac.read_int()
        lst = [ord(w) - ord("a") for w in ac.read_str()]
        sh1 = StringHash(lst)
        sh2 = StringHash(lst)  # TLE

        def check(cur):
            pre1 = sh1.query(a, b - cur)
            post1 = sh1.query(a + cur, b)

            pre2 = sh2.query(a, b - cur)
            post2 = sh2.query(a + cur, b)
            return pre1 == post1 and pre2 == post2

        pf = PrimeFactor(n)
        for _ in range(ac.read_int()):
            a, b = ac.read_list_ints_minus_one()
            length = b - a + 1
            ans = length
            while length > 1:
                p = pf.min_prime[length]
                if check(ans // p):
                    ans //= p
                length //= p
            ac.st(ans)
        return

    @staticmethod
    def cf_7d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/7/D
        tag: string_hash|palindrome|classical
        """
        p = 131
        mod = 10 ** 9 + 7
        s = ac.read_str()
        n = len(s)
        pre = rev = 0
        pp = 1
        dp = [0] * (n + 1)
        for i in range(n):
            x = ord(s[i]) - ord("a")
            pre = (pre * p + x) % mod
            rev = (x * pp + rev) % mod
            pp = (pp * p) % mod
            if pre != rev:
                continue
            dp[i + 1] = dp[(i + 1) // 2] + 1
        ac.st(sum(dp))
        return

    @staticmethod
    def cf_835d(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/835/D
        tag: palindrome|string_hash
        """
        s = ac.read_str()
        lst = [ord(w) - ord("a") for w in s]
        n = len(s)
        dp = [0] * (n + 1)
        ans = [0] * (n + 1)
        p = 131
        mod = 10 ** 9 + 7
        for i in range(n):
            dp[i] = 1
            pp = p
            pre = rev = lst[i]
            ans[1] += 1
            for j in range(i + 1, n):
                pre = (pre * p + lst[j]) % mod
                rev = (lst[j] * pp + rev) % mod
                pp = (pp * p) % mod
                if pre == rev:
                    dp[j] = dp[i + (j - i + 1) // 2 - 1] + 1
                    ans[dp[j]] += 1
                else:
                    dp[j] = 0
        for i in range(n - 1, -1, -1):
            ans[i] += ans[i + 1]
        ac.lst(ans[1:])
        return

    @staticmethod
    def lc_100208(words: List[str]) -> int:
        """
        url: https://leetcode.com/contest/weekly-contest-385/problems/count-prefix-and-suffix-pairs-ii/
        tag: string_hash|brute_force
        """
        ans = 0
        st = "".join(words)
        sh1 = StringHash([ord(w) - ord("a") for w in st])
        sh2 = StringHash([ord(w) - ord("a") for w in st])
        pre = defaultdict(int)
        length = 0
        for word in words:
            m = len(word)
            for i in range(1, m + 1):
                prefix = (sh1.query(length, length + i - 1), sh2.query(length, length + i - 1))
                suffix = (sh1.query(length + m - 1 - i + 1, length + m - 1),
                          sh2.query(length + m - 1 - i + 1, length + m - 1))
                if prefix == suffix:
                    ans += pre[prefix]

            prefix = (sh1.query(length, length + m - 1), sh2.query(length, length + m - 1))
            pre[prefix] += 1
            length += m
        return ans

    @staticmethod
    def abc_331f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc331/tasks/abc331_f
        tag: point_set|range_hash_reverse|palindrome|classical
        """
        n, q = ac.read_list_ints()
        tree1 = PointSetRangeHashReverse(n)
        tree2 = PointSetRangeHashReverse(n)
        s = ac.read_str()
        tree1.build([ord(w) - ord("a") for w in s])
        tree2.build([ord(w) - ord("a") for w in s])
        for _ in range(q):
            lst = ac.read_list_strs()
            if lst[0] == "1":
                x, c = lst[1:]
                x = int(x)
                c = ord(c) - ord("a")
                tree1.point_set(x - 1, x - 1, c)
                tree2.point_set(x - 1, x - 1, c)
            else:
                ll, rr = [int(w) - 1 for w in lst[1:]]
                cur1 = (tree1.range_hash(ll, rr), tree2.range_hash(ll, rr))
                cur2 = (tree1.range_hash_reverse(ll, rr), tree2.range_hash_reverse(ll, rr))
                if cur1 == cur2:
                    ac.yes()
                else:
                    ac.no()
        return

    @staticmethod
    def abc_310c(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc310/tasks/abc310_c
        tag: string_hash|classical
        """
        n = ac.read_int()
        pre = 0
        sh = StringHashSingle([150])
        ans = set()
        for i in range(n):
            lst = [ord(w) - ord("a") for w in ac.read_str()]
            cur = len(lst)
            bb, aa = sh.check(lst)
            dd, cc = sh.check(lst[::-1])
            tp = [aa] + sorted([bb, dd])
            ans.add(tuple(tp))
            pre += cur
        ac.st(len(ans))
        return

    @staticmethod
    def abc_353e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc353/tasks/abc353_e
        tag: string_hash|trie
        """
        ac.read_int()
        words = ac.read_list_strs()
        ans = 0
        p = random.randint(150, 150 * 2)
        mod = random.getrandbits(64)
        cnt = defaultdict(int)
        for word in words:
            hash_x = 0
            for i, w in enumerate(word):
                hash_x = (hash_x * p + ord(w) - ord("a")) % mod
                cur = cnt[(i, hash_x)]
                ans -= i * cur
                ans += (i + 1) * cur
                cnt[(i, hash_x)] += 1
        ac.st(ans)
        return

    @staticmethod
    def cf_1977d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1977/problem/D
        tag: string_hash|brute_force|brain_teaser|classical
        """
        for _ in range(ac.read_int()):
            m, n = ac.read_list_ints()
            grid = [ac.read_str() for _ in range(m)]
            dct = defaultdict(set)
            sh = StringHashSingleBuild(m)
            for j in range(n):
                lst = [int(grid[i][j]) for i in range(m)]
                sh.build(lst)
                for i in range(m):
                    left = sh.query(0, i - 1)
                    right = sh.query(i + 1, m - 1)
                    mid = 1 - int(grid[i][j])
                    cur = ((left * sh.p + mid) * sh.pp[m - i - 1] + right) % sh.mod
                    dct[cur].add(j)
            res = -1
            for k in dct:
                if res == -1 or len(dct[k]) > len(dct[res]):
                    res = k
            ac.st(len(dct[res]))
            j = list(dct[res])[0]
            lst = [int(grid[i][j]) for i in range(m)]
            sh.build(lst)
            for i in range(m):
                left = sh.query(0, i - 1)
                right = sh.query(i + 1, m - 1)
                mid = 1 - int(grid[i][j])
                cur = ((left * sh.p + mid) * sh.pp[m - i - 1] + right) % sh.mod
                if cur == res:
                    ans = [grid[i][j] for i in range(m)]
                    ans[i] = "1" if grid[i][j] == "0" else "0"
                    ac.st("".join(ans))
                    break
        return

    @staticmethod
    def cf_1418g(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/1418/G
        tag: string_hash|random_hash|classical|two_pointers
        """
        n = ac.read_int()
        nums = ac.read_list_ints()
        rd = [random.getrandbits(64) for _ in range(5 * 10 ** 5 + 1)]
        ac.get_random_seed()
        pre_hash = [0] * (n + 1)
        cnt = defaultdict(int)
        for i in range(n):
            pre_hash[i + 1] = pre_hash[i]
            num = nums[i]
            pre_hash[i + 1] -= cnt[num] * rd[num]
            cnt[num] = (cnt[num] + 1) % 3
            pre_hash[i + 1] += cnt[num] * rd[num]

        pre = defaultdict(int)
        pre[pre_hash[0]] = 1
        cur = defaultdict(int)
        ans = i = 0
        for j in range(n):
            cur[nums[j]] += 1
            while cur[nums[j]] > 3:
                pre[pre_hash[i]] -= 1
                cur[nums[i]] -= 1
                i += 1
            ans += pre[pre_hash[j + 1]]
            pre[pre_hash[j + 1]] += 1
        ac.st(ans)
        return

    @staticmethod
    def lg_p4503(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4503
        tag: string_hash|random_hash
        """
        n, ll, ss = ac.read_list_ints()  # MLE
        seed = [random.getrandbits(64) for _ in range(n)]
        nums = [[0] * (ll + 1) for _ in range(n)]
        for i in range(n):
            x = 0
            s = ac.read_str()
            for j in range(ll):
                nums[i][j] = ord(s[j])
                x += ord(s[j]) * seed[j]
            nums[i][ll] = x
        ans = 0
        for j in range(ll):
            pre = dict()
            for i in range(n):
                val = nums[i][-1] - nums[i][j] * seed[j]
                ans += pre.get(val, 0)
                pre[val] = pre.get(val, 0) + 1
        ac.st(ans)
        return

    @staticmethod
    def abc_367f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc367/tasks/abc367_f
        tag: random_seed|random_hash
        """
        n, q=  ac.read_list_ints()
        a = ac.read_list_ints()
        b = ac.read_list_ints()
        seed = [random.getrandbits(64) for _ in range(2*10**5+1)]
        pre_a = ac.accumulate([seed[x] for x in a])
        pre_b = ac.accumulate([seed[x] for x in b])
        for _ in range(q):
            l1, r1, l2, r2 = ac.read_list_ints_minus_one()
            if pre_a[r1+1]-pre_a[l1] == pre_b[r2+1]-pre_b[l2] and r1-l1==r2-l2:
                ac.yes()
            else:
                ac.no()
        return"""
Algorithm：suffix_array
Description：suffix_array

====================================LeetCode====================================
718（https://leetcode.cn/problems/maximum-length-of-repeated-subarray/）suffix_array|height|sa|lcp|trick|lcs
1754（https://leetcode.cn/problems/largest-merge-of-two-strings/）largest|suffix_array
1698（https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/）suffix_array|height
1044（https://leetcode.cn/problems/longest-duplicate-substring/）suffix_array|height|classical
1062（https://leetcode.cn/problems/longest-repeating-substring/）suffix_array|height|classical
2261（ https://leetcode.cn/problems/k-divisible-elements-subarrays/）suffix_array|height|different_limited_substring
1923（https://leetcode.cn/problems/longest-common-subpath/）suffix_array|lcs|lcp|monotonic_queue
1977（https://leetcode-cn.com/problems/number-of-ways-to-separate-numbers/）
1018（https://leetcode-cn.com/problems/string-matching-in-an-array/）

=====================================LuoGu======================================
P3809（https://www.luogu.com.cn/problem/P3809）suffix_array
P2852（https://www.luogu.com.cn/problem/P2852）binary_search|suffix_array|height|monotonic_queue|string_hash
P2852（https://www.luogu.com.cn/problem/P2408）suffix_array|height
P3804（https://www.luogu.com.cn/problem/P3804）suffix_array|height|monotonic_stack
P4248（https://www.luogu.com.cn/problem/P4248）suffix_array|height|lcp|monotonic_stack
P3975（https://www.luogu.com.cn/problem/P3975）greedy|bfs|suffix_array|height
P3796（https://www.luogu.com.cn/problem/P3796）suffix_array|height|sa|monotonic_stack|prefix_sum
P5546（https://www.luogu.com.cn/problem/P5546）suffix_array|lcs|lcp|monotonic_queue
P4341（https://www.luogu.com.cn/problem/P4341）suffix_array|height
P4070（https://www.luogu.com.cn/problem/P4070）
P6095（https://www.luogu.com.cn/problem/P6095）
P2870（https://www.luogu.com.cn/problem/P2870）suffix_array|greedy|implemention|classical

=====================================AcWing=====================================
142（https://www.acwing.com/problem/content/142/）suffix_array|template
140（https://www.acwing.com/problem/content/140/）suffix_array|lexicographical_order|lcp|sparse_table|sub_string|classical

=====================================CodeForces=====================================
123D（https://codeforces.com/problemset/problem/123/D）suffix_array|height|monotonic_stack
271D（https://codeforces.com/contest/271/problem/D）suffix_array|height|different_limited_substring
802I（https://codeforces.com/contest/802/problem/I）suffix_array|height|monotonic_stack
128B（https://codeforces.com/contest/128/problem/B）greedy|bfs|suffix_array|height
427D（https://codeforces.com/contest/427/problem/D）suffix_array|height|sa|lcp|trick|lcs
1526E（https://codeforces.com/contest/1526/problem/E）suffix_array|reverse_thinking|comb|construction
611D（https://codeforces.com/problemset/problem/611/D）
600A（https://codeforces.com/problemset/problem/600/A）
873F（https://codeforces.com/contest/873/problem/F）suffix_array|reverse_thinking|lcp|prefix_sum

=====================================AtCoder=====================================
ABC141E（https://atcoder.jp/contests/abc141/tasks/abc141_e）suffix_array|height|binary_search|string_hash
ABC213F（https://atcoder.jp/contests/abc213/tasks/abc213_f）suffix_array|height|lcp
ABC272F（https://atcoder.jp/contests/abc272/tasks/abc272_f）suffix_array|sa|trick

=====================================LibraryChecker=====================================
1（https://judge.yosupo.jp/problem/suffixarray）suffix_array
2（https://judge.yosupo.jp/problem/number_of_substrings）suffix_array|sa
3（https://www.hackerrank.com/challenges/morgan-and-a-string/）lexicographical_order|classical
4（https://loj.ac/p/111）suffix_array|template
5（https://atcoder.jp/contests/practice2/tasks/practice2_i）suffix_array|height
6（https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/A）suffix_array|height
7（https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/H）suffix_array|height
8（https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/F）suffix_array|height|lcp|brute_force
9（https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/D）suffix_array|height|monotonic_stack
10（https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/B）suffix_array|height|sa|lcp|trick|lcs
11（https://www.spoj.com/problems/LCS2/）suffix_array|lcs|lcp|monotonic_queue
12（https://loj.ac/p/171）suffix_array|lcs|lcp|monotonic_queue
13（https://www.spoj.com/problems/PHRASES/）suffix_array|height|sa|lcp|binary_search
14（https://poj.org/problem?id=3581)
15（https://poj.org/problem?id=1226）
16（https://poj.org/problem?id=3450）
17（https://poj.org/problem?id=3729）
18（https://onlinejudge.u-aizu.ac.jp/problems/2292）
19（https://poj.org/problem?id=3415）
20（https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/E）suffix_array|monotonic_stack|height|counter
21（https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/C）suffix_array|lexicographical_order|lcp|sparse_table|sub_string|classical
22（https://codeforces.com/edu/course/2/lesson/2/2/practice/contest/269103/problem/A）suffix_array
23（https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/A）suffix_array|height|lcp|monotonic_stack|prefix_sum|binary_search
24（https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/B）suffix_array|height|lcp|monotonic_stack|prefix_sum|binary_search
25（https://codeforces.com/edu/course/2/lesson/2/4/practice/contest/269119/problem/A）suffix_array|height|lcp


1（https://www.codechef.com/problems/CABABAA）sparse_table|suffix_array|monotonic_stack
"""

from collections import deque
from functools import cmp_to_key
from typing import List

from src.basis.binary_search.template import BinarySearch
from src.data_structure.monotonic_stack.template import Rectangle
from src.data_structure.sorted_list.template import SortedList
from src.data_structure.sparse_table.template import SparseTable
from src.mathmatics.comb_perm.template import Combinatorics
from src.strings.suffix_array.template import SuffixArray
from src.utils.fast_io import FastIO, math.inf


class Solution:
    def __init__(self):
        return

    @staticmethod
    def lc_1754_1(word1: str, word2: str) -> str:
        """
        url: https://leetcode.cn/problems/largest-merge-of-two-strings/
        tag: largest|suffix_array
        """

        s = [ord(w) - ord("a") + 1 for w in word1] + [0] + [ord(w) - ord("a") + 1 for w in word2]
        sa, rk, height = SuffixArray().build(s, 27)
        m, n = len(word1), len(word2)
        i = 0
        j = 0
        merge = ""
        while i < m and j < n:
            if rk[i] > rk[j + m + 1]:
                merge += word1[i]
                i += 1
            else:
                merge += word2[j]
                j += 1
        merge += word1[i:]
        merge += word2[j:]
        return merge

    @staticmethod
    def lc_1754_2(word1: str, word2: str) -> str:
        """
        url: https://leetcode.cn/problems/largest-range_merge_to_disjoint-of-two-strings/
        tag: largest|suffix_array
        """
        merge = ""
        i = j = 0
        m, n = len(word1), len(word2)
        while i < m and j < n:
            if word1[i:] > word2[j:]:
                merge += word1[i]
                i += 1
            else:
                merge += word2[j]
                j += 1
        merge += word1[i:]
        merge += word2[j:]
        return merge

    @staticmethod
    def lg_p3809(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3809
        tag: suffix_array
        """
        words = ([str(x) for x in range(10)]
                 + [chr(i + ord("A")) for i in range(26)]
                 + [chr(i + ord("a")) for i in range(26)])
        ind = {st: i for i, st in enumerate(words)}
        rk = [ind[w] for w in ac.read_str()]
        sa = SuffixArray().build(rk, len(ind))[0]
        ac.lst([x + 1 for x in sa])
        return

    @staticmethod
    def library_check_1(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/suffixarray
        tag: suffix_array
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa = SuffixArray().build(s, 26)[0]
        ac.lst(sa)
        return

    @staticmethod
    def library_check_2(ac=FastIO()):
        """
        url: https://judge.yosupo.jp/problem/number_of_substrings
        tag: suffix_array|sa
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        n = len(s)
        ans = sum(height)
        ac.st(n * (n + 1) // 2 - ans)
        return

    @staticmethod
    def ac_142(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/142/
        tag: suffix_array|template
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        ac.lst(sa)
        ac.lst(height)
        return

    @staticmethod
    def library_check_3(ac=FastIO()):
        """
        url: https://www.hackerrank.com/challenges/morgan-and-a-string/
        tag: lexicographical_order|classical
        """
        for _ in range(ac.read_int()):
            word1 = ac.read_str()
            word2 = ac.read_str()

            s = [ord(w) - ord("A") for w in word1] + [26] + [ord(w) - ord("A") for w in word2] + [26]
            sa, rk, height = SuffixArray().build(s, 27)
            m, n = len(word1), len(word2)
            i = 0
            j = 0
            merge = []
            while i < m and j < n:
                if rk[i] < rk[j + m + 1]:
                    merge.append(word1[i])
                    i += 1
                else:
                    merge.append(word2[j])
                    j += 1
            merge.extend(list(word1[i:]))
            merge.extend(list(word2[j:]))
            ans = "".join(merge)
            ac.st(ans)
        return

    @staticmethod
    def lc_1698(s: str) -> int:
        """
        url: https://leetcode.cn/problems/number-of-distinct-substrings-in-a-string/
        tag: suffix_array|height
        """
        s = [ord(w) - ord("a") for w in s]
        sa, rk, height = SuffixArray().build(s, 26)
        n = len(s)
        ans = sum(height)
        return n * (n + 1) // 2 - ans

    @staticmethod
    def library_check_4(ac=FastIO()):
        """
        url: https://loj.ac/p/111
        tag: suffix_array|template
        """
        words = ([str(x) for x in range(10)]  # TLE
                 + [chr(i + ord("A")) for i in range(26)]
                 + [chr(i + ord("a")) for i in range(26)])
        ind = {st: i for i, st in enumerate(words)}
        rk = [ind[w] for w in ac.read_str()]
        sa = SuffixArray().build(rk, len(ind))[0]
        ac.lst([x + 1 for x in sa])
        return

    @staticmethod
    def lc_1044(s: str) -> str:
        """
        url: https://leetcode.cn/problems/longest-duplicate-substring/
        tag: suffix_array|height|classical
        """
        sa, rk, height = SuffixArray().build([ord(w) - ord("a") for w in s], 26)
        j = height.index(max(height))
        i = sa[j]
        return s[i: i + height[j]]

    @staticmethod
    def lc_1062(s: str) -> int:
        """
        url: https://leetcode.cn/problems/longest-repeating-substring/
        tag: suffix_array|height|classical
        """
        sa, rk, height = SuffixArray().build([ord(w) - ord("a") for w in s], 26)
        return max(height)

    @staticmethod
    def abc_141e(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc141/tasks/abc141_e
        tag: suffix_array|height|binary_search|string_hash
        """
        n = ac.read_int()
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)

        def check(x):
            lst = [sa[0]]
            for i in range(1, n):
                if height[i] >= x:
                    lst.append(sa[i])
                else:
                    a, b = min(lst), max(lst)
                    if a + x <= b:
                        return True
                    lst = [sa[i]]
            a, b = min(lst), max(lst)
            if a + x <= b:
                return True
            return False

        ans = BinarySearch().find_int_right(0, max(height), check)
        ac.st(ans)
        return

    @staticmethod
    def lg_p2852(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2852
        tag: binary_search|suffix_array|height|monotonic_queue
        """
        n, k = ac.read_list_ints()
        s = [ac.read_int() for _ in range(n)]
        ind = {num: i for i, num in enumerate(sorted(list(set(s))))}
        s = [ind[d] for d in s]

        _, _, height = SuffixArray().build(s, len(ind))
        stack = deque()
        ans = []
        for i in range(n):
            while stack and stack[0][1] <= i - (k - 1):
                stack.popleft()
            while stack and stack[-1][0] >= height[i]:
                stack.pop()
            stack.append((height[i], i))
            if i >= (k - 1) - 1:
                ans.append(stack[0][0])
        ac.st(max(ans))
        return

    @staticmethod
    def lg_p2408(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2408
        tag: suffix_array|height
        """
        ac.read_int()
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        n = len(s)
        ans = sum(height)
        ac.st(n * (n + 1) // 2 - ans)
        return

    @staticmethod
    def library_check_5(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/practice2/tasks/practice2_i
        tag: suffix_array|height
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        n = len(s)
        ans = sum(height)
        ac.st(n * (n + 1) // 2 - ans)
        return

    @staticmethod
    def lc_2261(nums: List[int], k: int, p: int) -> int:
        """
        url: https://leetcode.cn/problems/k-divisible-elements-subarrays/
        tag: suffix_array|height|different_limited_substring
        """
        cnt = res = 0
        n = len(nums)
        j = 0
        right = [0] * n
        for i in range(n):
            while j < n and cnt + (nums[j] % p == 0) <= k:
                cnt += (nums[j] % p == 0)
                j += 1
            res += j - i
            right[i] = j
            cnt -= (nums[i] % p == 0)
        sa, rk, height = SuffixArray().build(nums, max(nums) + 1)
        dup = sum(min(height[i], right[sa[i]] - sa[i]) for i in range(1, n))
        res -= dup
        return res

    @staticmethod
    def library_check_6(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/A
        tag: suffix_array|height
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        n = len(s)
        ans = sum(height)
        ac.st(n * (n + 1) // 2 - ans)
        return

    @staticmethod
    def library_check_7(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/3/4/practice/contest/272262/problem/H
        tag: suffix_array|height
        """
        words = ([chr(i + ord("A")) for i in range(26)]
                 + [chr(i + ord("a")) for i in range(26)])
        ind = {st: i for i, st in enumerate(words)}
        s = [ind[w] for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, len(ind))
        n = len(s)
        ans = n * (n + 1) * (n + 2) // 6 - sum(height[i] * (height[i] + 1) // 2 for i in range(n))
        ac.st(ans)
        return

    @staticmethod
    def cf_271d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/271/problem/D
        tag: suffix_array|height|different_limited_substring
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        good = [1 - int(w) for w in ac.read_str()]
        k = ac.read_int()
        n = len(s)
        j = cnt = ans = 0
        right = [0] * n
        for i in range(n):
            while j < n and cnt + good[s[j]] <= k:
                cnt += good[s[j]]
                j += 1
            ans += j - i
            right[i] = j
            cnt -= good[s[i]]
        sa, rk, height = SuffixArray().build(s, 26)
        dup = sum(min(height[i], right[sa[i]] - sa[i]) for i in range(1, n))
        ans -= dup
        ac.st(ans)
        return

    @staticmethod
    def library_check_8(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/F
        tag: suffix_array|height|lcp|brute_force
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        n = len(s)
        sa, rk, height = SuffixArray().build(s, 26)
        ans = 1
        st = SparseTable(height, min)

        def lcp(ii, jj):
            ri, rj = rk[ii], rk[jj]
            if ri > rj:
                ri, rj = rj, ri
            if ri == rj:
                return n - sa[ri]
            return st.query(ri + 1, rj)

        for x in range(1, n):
            for i in range(0, n - x, x):
                rep_len = lcp(i, i + x)
                rep_cnt = rep_len // x + 1
                p = i - (x - rep_len % x)
                if p >= 0 and lcp(p, p + x) >= x:
                    rep_cnt += 1
                if rep_cnt > ans:
                    ans = rep_cnt
        ac.st(ans)
        return

    @staticmethod
    def cf_123d_1(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/123/D
        tag: suffix_array|height|monotonic_stack
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        ans = Rectangle().compute_number([h + 1 for h in height])
        ac.st(ans)
        return

    @staticmethod
    def cf_123d_2(ac=FastIO()):
        """
        url: https://codeforces.com/problemset/problem/123/D
        tag: suffix_array|height|monotonic_stack
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        n = len(s)
        sa, rk, height = SuffixArray().build(s, 26)
        ans = Rectangle().compute_number(height)
        ans += sum(n - sa[j] for j in range(n))
        ac.st(ans)
        return

    @staticmethod
    def library_check_9(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/D
        tag: suffix_array|height|monotonic_stack
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        n = len(s)
        sa, rk, height = SuffixArray().build(s, 26)
        ans = Rectangle().compute_number([h for h in height])
        ans += n * (n + 1) // 2
        ac.st(ans)
        return

    @staticmethod
    def cf_802i(ac=FastIO()):
        """
        url: https://codeforces.com/contest/802/problem/I
        tag: suffix_array|height|monotonic_stack
        """

        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            sa, rk, height = SuffixArray().build([ord(w) - ord("a") for w in s], 26)
            stack = [[-1, 0]]
            ans = n * (n + 1) // 2
            for i in range(n):
                while stack[-1][0] >= 0 and height[i] < height[stack[-1][0]]:
                    stack.pop()
                stack.append([i, stack[-1][1] + (i - stack[-1][0]) * height[i]])
                ans += stack[-1][1] * 2
            ac.st(ans)

        return

    @staticmethod
    def lg_p3804(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3804
        tag: suffix_array|height|monotonic_stack
        """

        s = ac.read_str()
        sa, rk, height = SuffixArray().build([ord(w) - ord("a") for w in s], 26)
        n = len(s)
        left = [1] * n
        right = [n - 1] * n
        stack = []
        for i in range(n):
            while stack and height[stack[-1]] > height[i]:
                right[stack.pop()] = i - 1
            stack.append(i)

        stack = []
        for i in range(n - 1, -1, -1):
            while stack and height[stack[-1]] > height[i]:
                left[stack.pop()] = i + 1
            stack.append(i)

        ans = 0
        for i in range(n):
            cur = height[i] * (right[i] - left[i] + 2)
            ans = ans if ans > cur else cur

        ac.st(ans)
        return

    @staticmethod
    def abc_213f(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc213/tasks/abc213_f
        tag: suffix_array|height|lcp
        """
        n = ac.read_int()
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, nums = SuffixArray().build(s, 26)

        pre = [0] * n  # initial can be 0 or -1 dependent on usage
        stack = [0]
        for i in range(1, n):  # can be also range(n-1, -1, -1) dependent on usage
            while stack and nums[stack[-1]] > nums[i]:  # can be < or > or <=  or >=  dependent on usage
                stack.pop()  # can be i or i-1 dependent on usage
            pre[i] = pre[stack[-1]] + nums[i] * (i - stack[-1])
            stack.append(i)

        nums.append(0)
        post = [0] * (n + 1)  # initial can be 0 or -1 dependent on usage
        stack = [n]
        for i in range(n - 1, -1, -1):  # can be also range(n-1, -1, -1) dependent on usage
            while stack and nums[stack[-1]] > nums[i]:  # can be < or > or <=  or >=  dependent on usage
                stack.pop()  # can be i or i-1 dependent on usage
            post[i] = post[stack[-1]] + nums[i] * (stack[-1] - i)
            stack.append(i)

        ans = [n - i for i in range(n)]
        for i in range(n):
            ans[i] += pre[rk[i]] + post[rk[i] + 1]
        for a in ans:
            ac.st(a)
        return

    @staticmethod
    def lg_p4248(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4248
        tag: suffix_array|height|lcp
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(s, 26)
        height.append(0)
        n = len(s)
        pre = [0] * (n + 1)
        stack = [0]
        for i in range(n):
            if i:
                pre[i] = pre[i - 1]
            while stack[-1] and height[stack[-1]] > height[i]:
                j = stack.pop()
                pre[i] -= (j - stack[-1]) * height[j]
            pre[i] += (i - stack[-1]) * height[i]
            stack.append(i)

        post = [0] * (n + 1)
        stack = [n]
        for i in range(n - 1, -1, -1):
            post[i] = post[i + 1]
            while stack[-1] < n and height[stack[-1]] > height[i]:
                j = stack.pop()
                post[i] -= (stack[-1] - j) * height[j]
            post[i] += (stack[-1] - i) * height[i]
            stack.append(i)

        suf = ans = 0
        for i in range(n - 1, -1, -1):
            ans += (n - i) * (n - i - 1) + suf
            suf += n - i

        for i in range(n):
            ans -= pre[rk[i]] + post[rk[i] + 1]
        ac.st(ans)
        return

    @staticmethod
    def cf_128b(ac=FastIO()):
        """
        url: https://codeforces.com/contest/128/problem/B
        tag: greedy|bfs|suffix_array|height
        """
        s = ac.read_str()
        lst = [ord(w) - ord("a") for w in s]
        k = ac.read_int()
        n = len(s)
        if k > n * (n + 1) // 2:
            ac.st("No such line.")
            return
        ans = []
        ind = list(range(n))
        while ind and k > 0:
            dct = [[] for _ in range(26)]
            for i in ind:
                dct[lst[i]].append(i)
            for x in range(26):
                cur = sum(n - i for i in dct[x])
                if cur < k:
                    k -= cur
                else:
                    ans.append(chr(x + ord("a")))
                    ind = [i + 1 for i in dct[x] if i + 1 < n]
                    k -= len(dct[x])
                    break
        ac.st("".join(ans))
        return

    @staticmethod
    def lc_718(nums1: List[int], nums2: List[int]) -> int:
        """
        url: https://leetcode.cn/problems/maximum-length-of-repeated-subarray/
        tag: suffix_array|height|sa|lcp|trick|lcs
        """
        m, n = len(nums1), len(nums2)
        nums = nums1 + [101] + nums2
        sa, rk, height = SuffixArray().build(nums, 102)
        ans = 0
        for i in range(1, m + n + 1):
            if (sa[i - 1] < m < sa[i] or sa[i - 1] > m > sa[i]) and height[i] > ans:
                ans = height[i]
        return ans

    @staticmethod
    def library_check_10(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/B
        tag: suffix_array|height|sa|lcp|trick|lcs
        """
        s = ac.read_str()
        nums1 = [ord(w) - ord("a") for w in s]
        nums2 = [ord(w) - ord("a") for w in ac.read_str()]
        m, n = len(nums1), len(nums2)
        nums = nums1 + [26] + nums2
        sa, rk, height = SuffixArray().build(nums, 27)
        ans = 0
        ind = -1
        for i in range(1, m + n + 1):
            if (sa[i - 1] < m < sa[i] or sa[i - 1] > m > sa[i]) and height[i] > ans:
                ans = height[i]
                ind = min(sa[i - 1], sa[i])
        ac.st(s[ind:ind + ans])
        return

    @staticmethod
    def cf_427d(ac=FastIO()):
        """
        url: https://codeforces.com/contest/427/problem/D
        tag: suffix_array|height|sa|lcp|trick|lcs
        """
        s = ac.read_str()
        nums1 = [ord(w) - ord("a") for w in s]
        nums2 = [ord(w) - ord("a") for w in ac.read_str()]
        m, n = len(nums1), len(nums2)
        nums = nums1 + [26] + nums2
        sa, rk, height = SuffixArray().build(nums, 27)
        height.append(0)
        ans = math.inf
        for i in range(1, m + n + 1):
            if not height[i]:
                continue
            if sa[i - 1] < m < sa[i] or sa[i - 1] > m > sa[i]:
                a = max(height[i - 1], height[i + 1])
                if a + 1 <= height[i] and a + 1 < ans:
                    ans = a + 1
        ac.st(ans if ans < math.inf else -1)
        return

    @staticmethod
    def abc_272f_1(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc272/tasks/abc272_f
        tag: suffix_array|sa|trick
        """
        n = ac.read_int()
        nums1 = [ord(w) - ord("a") + 1 for w in ac.read_str()]
        nums2 = [ord(w) - ord("a") + 1 for w in ac.read_str()]
        nums = nums1 + nums1 + [0] + nums2 + nums2 + [27]
        sa, rk, height = SuffixArray().build(nums, 28)
        ans = post = 0
        for i in range(4 * n + 1, -1, -1):
            if 2 * n + 1 < sa[i] < 3 * n + 2:
                post += 1
            elif sa[i] < n:
                ans += post
        ac.st(ans)
        return

    @staticmethod
    def abc_272f_2(ac=FastIO()):
        """
        url: https://atcoder.jp/contests/abc272/tasks/abc272_f
        tag: suffix_array|sa|trick
        """
        n = ac.read_int()
        s = [ord(w) - ord("a") for w in ac.read_str()]
        t = [ord(w) - ord("a") for w in ac.read_str()]
        lst = s + s + t + t
        sa, rk, height = SuffixArray().build(lst, 26)
        ans = 0
        ind = SortedList(list(range(2 * n, 3 * n)))
        j = 0
        for i in range(4 * n):
            if height[i] < n:
                while j < i:
                    if 2 * n <= sa[j] < 3 * n:
                        ind.discard(sa[j])
                    j += 1
            if 0 <= sa[i] < n:
                ans += len(ind)
        ac.st(ans)
        return

    @staticmethod
    def library_check_11(ac=FastIO()):
        """
        url: https://www.spoj.com/problems/LCS2/
        tag: suffix_array|lcs|lcp|monotonic_queue
        """

        lst = []  # TLE
        while True:
            s = ac.read_str()
            if not s:
                break
            lst.append([ord(w) - ord("a") for w in s])

        ind = []
        nums = []
        k = len(lst)
        for i in range(k):
            m = len(lst[i])
            ind.extend([i] * m)
            ind.append(i)
            nums.extend(lst[i])
            nums.append(26 + i)
        if k == 1:
            return len(nums)
        sa, rk, height = SuffixArray().build(nums, 26 + k)

        def add(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                if not item[w]:
                    cnt += 1
                item[w] += 1
            return

        def remove(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                item[w] -= 1
                if not item[w]:
                    cnt -= 1
            return

        ans = cnt = 0
        j = 1
        item = [0] * k
        n = len(height)
        stack = deque()
        for i in range(1, n):
            while stack and stack[0] < i:
                stack.popleft()
            while j < n and cnt < k:
                add(j)
                while stack and height[stack[-1]] > height[j]:
                    stack.pop()
                stack.append(j)
                j += 1
            if cnt == k and stack and height[stack[0]] > ans:
                ans = height[stack[0]]
            remove(i)

        ac.st(ans)
        return

    @staticmethod
    def library_check_12(ac=FastIO()):
        """
        url: https://loj.ac/p/171
        tag: suffix_array|lcs|lcp|monotonic_queue
        """

        lst = []
        for _ in range(ac.read_int()):
            lst.append([ord(w) - ord("a") for w in ac.read_str()])

        ind = []
        nums = []
        k = len(lst)
        for i in range(k):
            m = len(lst[i])
            ind.extend([i] * m)
            ind.append(i)
            nums.extend(lst[i])
            nums.append(26 + i)
        if k == 1:
            return len(nums)
        sa, rk, height = SuffixArray().build(nums, 26 + k)

        def add(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                if not item[w]:
                    cnt += 1
                item[w] += 1
            return

        def remove(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                item[w] -= 1
                if not item[w]:
                    cnt -= 1
            return

        ans = cnt = 0
        j = 1
        item = [0] * k
        n = len(height)
        stack = deque()
        for i in range(1, n):
            while stack and stack[0] < i:
                stack.popleft()
            while j < n and cnt < k:
                add(j)
                while stack and height[stack[-1]] > height[j]:
                    stack.pop()
                stack.append(j)
                j += 1
            if cnt == k and stack and height[stack[0]] > ans:
                ans = height[stack[0]]
            remove(i)

        ac.st(ans)
        return

    @staticmethod
    def lc_1923(n: int, paths: List[List[int]]) -> int:
        """
        url: https://leetcode.cn/problems/longest-common-subpath/
        tag: suffix_array|lcs|lcp|monotonic_queue
        """
        ind = []
        nums = []
        k = len(paths)
        for i in range(k):
            m = len(paths[i])
            ind.extend([i] * m)
            ind.append(i)
            nums.extend(paths[i])
            nums.append(n + i + 1)
        if k == 1:
            return len(nums)
        sa, rk, height = SuffixArray().build(nums, n + k + 1)

        def add(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                if not item[w]:
                    cnt += 1
                item[w] += 1
            return

        def remove(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                item[w] -= 1
                if not item[w]:
                    cnt -= 1
            return

        ans = cnt = 0
        j = 1
        item = [0] * k
        n = len(height)
        stack = deque()
        for i in range(1, n):
            while stack and stack[0] < i:
                stack.popleft()
            while j < n and cnt < k:
                add(j)
                while stack and height[stack[-1]] > height[j]:
                    stack.pop()
                stack.append(j)
                j += 1
            if cnt == k and stack and height[stack[0]] > ans:
                ans = height[stack[0]]
            remove(i)

        return ans

    @staticmethod
    def library_check_13(ac=FastIO()):
        """
        url: https://www.spoj.com/problems/PHRASES/
        tag: suffix_array|height|sa|lcp|binary_search
        """

        for _ in range(ac.read_int()):
            k = ac.read_int()
            lst = []
            for _ in range(k):
                lst.append([ord(w) - ord("a") for w in ac.read_str()])

            ind = []
            nums = []
            k = len(lst)
            for i in range(k):
                m = len(lst[i])
                ind.extend([i] * m)
                ind.append(i)
                nums.extend(lst[i])
                nums.append(26 + i)

            sa, rk, height = SuffixArray().build(nums, 26 + k)
            n = len(height)

            def check(x):

                index = [[] for _ in range(k)]
                for ii in range(n):
                    if height[ii] >= x:
                        a, b = sa[ii - 1], sa[ii]
                        index[ind[a]].append(a)
                        index[ind[b]].append(b)
                    else:
                        if all(len(ls) > 0 for ls in index) and all(max(ls) - min(ls) >= x for ls in index):
                            return True
                        index = [[] for _ in range(k)]

                if all(len(ls) > 0 for ls in index) and all(max(ls) - min(ls) >= x for ls in index):
                    return True
                return False

            ans = BinarySearch().find_int_right(0, min(len(ls) for ls in lst) // 2, check)
            ac.st(ans)
        return

    @staticmethod
    def lg_p3796(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P3796
        tag: suffix_array|height|sa|monotonic_stack|prefix_sum
        """
        while True:  # MLE
            k = ac.read_int()
            if not k:
                break
            lst = []
            for _ in range(k + 1):
                lst.append([ord(w) - ord("a") for w in ac.read_str()])

            ind = []
            nums = []
            for i in range(k + 1):
                m = len(lst[i])
                ind.extend([i] * m)
                ind.append(i)
                nums.extend(lst[i])
                nums.append(26 + i)

            sa, _, height = SuffixArray().build(nums, 26 + k + 1)
            del nums

            n = len(height)
            height.append(0)

            right = [n - 1] * (n + 1)
            stack = []
            for i in range(n):
                while stack and height[stack[-1]] > height[i]:
                    right[stack.pop()] = i - 1
                stack.append(i)

            left = [0] * (n + 1)
            stack = []
            for i in range(n - 1, -1, -1):
                while stack and height[stack[-1]] > height[i]:
                    left[stack.pop()] = i + 1
                stack.append(i)
            pre = ac.accumulate([int(ind[sa[i]] == k) for i in range(n)])
            cnt = [0] * k
            for i in range(n):
                j = sa[i]
                if ind[j] < k and height[i] == len(lst[ind[j]]):
                    a, b = left[i], right[i]

                    if pre[b + 1] - pre[a - 1] > cnt[ind[j]]:
                        cnt[ind[j]] = pre[b + 1] - pre[a - 1]
            ceil = max(cnt)
            ac.st(ceil)
            for i in range(k):
                if cnt[i] == ceil:
                    ac.st("".join([chr(ord("a") + w) for w in lst[i]]))
        return

    @staticmethod
    def cf_1526e(ac=FastIO()):
        """
        url: https://codeforces.com/contest/1526/problem/E
        tag: suffix_array|reverse_thinking|comb|construction
        """
        mod = 998244353
        n, k = ac.read_list_ints()
        sa = ac.read_list_ints()
        cb = Combinatorics(n + k, mod)
        rk = [0] * n
        for i in range(n):
            rk[sa[i]] = i
        m = 0
        for i in range(1, n):
            if sa[i] < n - 1 and sa[i - 1] < n - 1 and rk[sa[i] + 1] > rk[sa[i - 1] + 1]:
                m += 1
            elif sa[i - 1] == n - 1:
                m += 1
        ans = cb.comb(m + k, n)
        ac.st(ans)
        return

    @staticmethod
    def lg_p5546(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P5546
        tag: suffix_array|lcs|lcp|monotonic_queue
        """
        lst = []
        for _ in range(ac.read_int()):
            lst.append([ord(w) - ord("a") for w in ac.read_str()])

        ind = []
        nums = []
        k = len(lst)
        for i in range(k):
            m = len(lst[i])
            ind.extend([i] * m)
            ind.append(i)
            nums.extend(lst[i])
            nums.append(26 + i)
        if k == 1:
            return len(nums)
        sa, rk, height = SuffixArray().build(nums, 26 + k)

        def add(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                if not item[w]:
                    cnt += 1
                item[w] += 1
            return

        def remove(ii):
            nonlocal cnt
            for w in [ind[sa[ii - 1]], ind[sa[ii]]]:
                item[w] -= 1
                if not item[w]:
                    cnt -= 1
            return

        ans = cnt = 0
        j = 1
        item = [0] * k
        n = len(height)
        stack = deque()
        for i in range(1, n):
            while stack and stack[0] < i:
                stack.popleft()
            while j < n and cnt < k:
                add(j)
                while stack and height[stack[-1]] > height[j]:
                    stack.pop()
                stack.append(j)
                j += 1
            if cnt == k and stack and height[stack[0]] > ans:
                ans = height[stack[0]]
            remove(i)

        ac.st(ans)
        return

    @staticmethod
    def lg_p4341(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P4341
        tag: suffix_array|height
        """
        n = ac.read_int()
        lst = [int(w) for w in ac.read_str()]
        sa, rk, height = SuffixArray().build(lst, 2)

        for i in range(n):
            j = sa[i]
            for x in range(height[i] + 1, n - j + 1):
                y = 1
                for k in range(i + 1, n):
                    if height[k] >= x:
                        y += 1
                    else:
                        break
                if y > 1:
                    ac.st(y)
        return

    @staticmethod
    def cf_837f(ac=FastIO()):
        """
        url: https://codeforces.com/contest/873/problem/F
        tag: suffix_array|reverse_thinking|lcp|prefix_sum
        """
        n = ac.read_int()
        a = ac.read_str()[::-1]
        s = ac.read_str()[::-1]
        sa, rk, height = SuffixArray().build([ord(w) - ord("a") for w in a], 26)

        left = [1] * n
        right = [n - 1] * n
        stack = []
        for i in range(1, n):
            while stack and height[stack[-1]] > height[i]:
                right[stack.pop()] = i - 1
            stack.append(i)

        stack = []
        for i in range(n - 1, -1, -1):
            while stack and height[stack[-1]] > height[i]:
                left[stack.pop()] = i + 1
            stack.append(i)

        pre = ac.accumulate([1 - int(s[i]) for i in sa])
        ans = max(height[i] * (pre[right[i] + 1] - pre[left[i] - 1]) for i in range(n))
        # special case
        for i in sa:
            if s[i] == "0" and n - i > ans:
                ans = n - i
        ac.st(ans)
        return

    @staticmethod
    def library_check_21(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/C
        tag: suffix_array|lexicographical_order|lcp|sparse_table|sub_string|classical
        """
        s = [ord(w) - 33 for w in ac.read_str()]
        n = len(s)
        sa, rk, height = SuffixArray().build(s, 95)
        st = SparseTable(height, min)
        q = ac.read_int()
        queries = [tuple(ac.read_list_ints_minus_one()) for _ in range(q)]

        def lcp(ii, jj):
            ri, rj = rk[ii], rk[jj]
            if ri > rj:
                ri, rj = rj, ri
            if ri == rj:
                return n - sa[ri]
            return st.query(ri + 1, rj)

        def compare(a, b):
            i1, j1 = a
            i2, j2 = b
            x = lcp(i1, i2)
            x = min(x, j1 - i1 + 1)
            x = min(x, j2 - i2 + 1)
            if x == j1 - i1 + 1:
                if x == j2 - i2 + 1:
                    return -1 if i1 < i2 else 1
                return -1
            if x == j2 - i2 + 1:
                return 1
            return -1 if s[i1 + x] < s[i2 + x] else 1

        queries.sort(key=cmp_to_key(compare))
        for q in queries:
            ac.lst([x + 1 for x in q])
        return

    @staticmethod
    def ac_140(ac=FastIO()):
        """
        url: https://www.acwing.com/problem/content/140/
        tag: suffix_array|lexicographical_order|lcp|sparse_table|sub_string|classical
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        n = len(s)
        sa, rk, height = SuffixArray().build(s, 26)
        st = SparseTable(height, min)

        def lcp(ii, jj):
            ri, rj = rk[ii], rk[jj]
            if ri > rj:
                ri, rj = rj, ri
            if ri == rj:
                return n - sa[ri]
            return st.query(ri + 1, rj)

        for _ in range(ac.read_int()):
            i1, j1, i2, j2 = ac.read_list_ints_minus_one()
            x = lcp(i1, i2)
            x = min(x, j1 - i1 + 1)
            if j1 - i1 + 1 == j2 - i2 + 1 == x:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def library_check_20(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/5/practice/contest/269656/problem/E
        tag: suffix_array|monotonic_stack|height|counter
        """
        n, m = ac.read_list_ints()
        s = ac.read_list_ints_minus_one()
        sa, rk, height = SuffixArray().build(s, m)

        left = [1] * n
        right = [n - 1] * n
        stack = []
        for i in range(n):
            while stack and height[stack[-1]] > height[i]:
                right[stack.pop()] = i - 1
            stack.append(i)

        stack = []
        for i in range(n - 1, -1, -1):
            while stack and height[stack[-1]] > height[i]:
                left[stack.pop()] = i + 1
            stack.append(i)

        ans = n
        res = [0, n]
        for i in range(n):
            cur = height[i] * (right[i] - left[i] + 2)
            if cur > ans:
                ans = cur
                res = [sa[i], sa[i] + height[i]]
        ac.st(ans)
        ac.st(res[1] - res[0])
        ac.lst([x + 1 for x in s[res[0]:res[1]]])
        return

    @staticmethod
    def library_check_22(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/2/practice/contest/269103/problem/A
        tag: suffix_array
        """
        s = [ord(w) - ord("a") for w in ac.read_str()]
        sa, _, _ = SuffixArray().build(s, 26)
        ac.lst([len(sa)] + sa)
        return

    @staticmethod
    def library_check_23_1(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/A
        tag: suffix_array|height|lcp|monotonic_stack|prefix_sum
        """
        t = ac.read_str()
        words = [ac.read_str() for _ in range(ac.read_int())]

        lst = [ord(w) - ord("a") for w in t] + [26]
        ind = []
        m = len(lst)
        length = dict()
        k = len(words)
        for i, s in enumerate(words):
            ind.append(len(lst))
            cur = [ord(w) - ord("a") for w in s] + [26 + i + 1]
            length[len(lst)] = len(cur) - 1
            lst.extend(cur)
        sa, rk, height = SuffixArray().build(lst, 26 + k + 1)
        n = len(sa)

        right = [n - 1] * n
        stack = []
        for i in range(n):
            while stack and height[stack[-1]] > height[i]:
                right[stack.pop()] = i - 1
            stack.append(i)

        left = [1] * n
        stack = []
        for i in range(n - 1, 0, -1):
            while stack and height[stack[-1]] > height[i]:
                left[stack.pop()] = i + 1
            stack.append(i)

        pre = ac.accumulate([int(i < m - 1) for i in sa])
        ans = []
        for i in ind:
            j = rk[i]
            if height[j] >= length[i]:
                ll = left[j]
                if pre[j + 1] > pre[ll - 1]:
                    ans.append(True)
                    continue
            if j + 1 < n and height[j + 1] >= length[i]:
                rr = right[j + 1]
                if pre[rr + 1] > pre[j]:
                    ans.append(True)
                    continue
            ans.append(False)
        for a in ans:
            ac.st("Yes" if a else "No")
        return

    @staticmethod
    def library_check_23_2(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/A
        tag: suffix_array|height|lcp|monotonic_stack|prefix_sum|binary_search
        """

        t = ac.read_str()
        lst = [ord(w) - ord("a") for w in t]
        sa, _, _ = SuffixArray().build(lst, 26)
        m = len(t)

        def check(i):
            j = sa[i]
            return t[j:j + n] >= s

        bs = BinarySearch()
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)
            x = bs.find_int_left(0, m - 1, check)
            if t[sa[x]:sa[x] + n] == s:
                ac.yes()
            else:
                ac.no()
        return

    @staticmethod
    def library_check_24_1(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/B
        tag: suffix_array|height|lcp|monotonic_stack|prefix_sum|binary_search
        """

        t = ac.read_str()
        words = [ac.read_str() for _ in range(ac.read_int())]

        lst = [ord(w) - ord("a") for w in t] + [26]
        ind = []
        m = len(lst)
        length = dict()
        k = len(words)
        for i, s in enumerate(words):
            ind.append(len(lst))
            cur = [ord(w) - ord("a") for w in s] + [26 + i + 1]
            length[len(lst)] = len(cur) - 1
            lst.extend(cur)
        sa, rk, height = SuffixArray().build(lst, 26 + k + 1)
        n = len(sa)

        right = [n - 1] * n
        stack = []
        for i in range(n):
            while stack and height[stack[-1]] > height[i]:
                right[stack.pop()] = i - 1
            stack.append(i)

        left = [1] * n
        stack = []
        for i in range(n - 1, 0, -1):
            while stack and height[stack[-1]] > height[i]:
                left[stack.pop()] = i + 1
            stack.append(i)

        pre = ac.accumulate([int(i < m - 1) for i in sa])
        for i in ind:
            ans = 0
            j = rk[i]
            if height[j] >= length[i]:
                ll = left[j]
                ans += pre[j + 1] - pre[ll - 1]
            if j + 1 < n and height[j + 1] >= length[i]:
                rr = right[j + 1]
                ans += pre[rr + 1] - pre[j + 1]
            ac.st(ans)
        return

    @staticmethod
    def library_check_24_2(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/3/practice/contest/269118/problem/B
        tag: suffix_array|height|lcp|monotonic_stack|prefix_sum|binary_search
        """

        t = ac.read_str()
        lst = [ord(w) - ord("a") for w in t]
        sa, _, _ = SuffixArray().build(lst, 26)
        m = len(t)

        def check(i):
            j = sa[i]
            return t[j:j + n] >= s

        def check2(i):
            j = sa[i]
            return t[j:j + n + 1] <= s

        bs = BinarySearch()
        for _ in range(ac.read_int()):
            s = ac.read_str()
            n = len(s)

            x = bs.find_int_left(0, m - 1, check)
            if t[sa[x]:sa[x] + n] == s:
                s += chr(1 + ord("z"))
                y = bs.find_int_right(0, m - 1, check2)
                ac.st(y - x + 1)
            else:
                ac.st(0)
        return

    @staticmethod
    def library_check_25(ac=FastIO()):
        """
        url: https://codeforces.com/edu/course/2/lesson/2/4/practice/contest/269119/problem/A
        tag: suffix_array|height|lcp
        """

        t = ac.read_str()

        lst = [ord(w) - ord("a") for w in t]

        sa, rk, height = SuffixArray().build(lst, 26)
        n = len(sa)
        ac.lst([n] + sa)
        ac.lst(height)
        return

    @staticmethod
    def cc_1(ac=FastIO()):
        """
        url: https://www.codechef.com/problems/CABABAA
        tag: sparse_table|suffix_array|monotonic_stack
        """
        for _ in range(ac.read_int()):
            n = ac.read_int()
            s = [ord(w) - ord("a") for w in ac.read_str()]
            sa, rk, height = SuffixArray().build(s, 26)
            st = SparseTable(height, min)
            sa.reverse()

            def lcp(ii, jj):
                ri, rj = rk[ii], rk[jj]
                if ri > rj:
                    ri, rj = rj, ri
                if ri == rj:
                    return n - sa[ri]
                return st.query(ri + 1, rj)

            def compare(a, b):
                i1, j1 = a
                i2, j2 = b
                x = lcp(i1, i2)
                x = min(x, j1 - i1 + 1)
                x = min(x, j2 - i2 + 1)
                if x == j1 - i1 + 1:
                    if x == j2 - i2 + 1:
                        return -1 if i1 < i2 else 1
                    return -1
                if x == j2 - i2 + 1:
                    return 1
                return -1 if s[i1 + x] < s[i2 + x] else 1

            stack = [n]
            for i in range(n - 1, -1, -1):
                while len(stack) >= 2 and i < stack[-1] and compare((stack[-1], stack[-2] - 1),
                                                                    (i, stack[-2] - 1)) == -1:
                    stack.pop()
                stack.append(i)
            ans = []
            right = n - 1
            for i in stack[1:]:
                ans.extend(s[i:right + 1])
                right = i - 1
            ac.st("".join(chr(x + ord("a")) for x in ans))
        return


    @staticmethod
    def lg_p2870(ac=FastIO()):
        """
        url: https://www.luogu.com.cn/problem/P2870
        tag: suffix_array|greedy|implemention|classical
        """
        s = []
        for _ in range(ac.read_int()):
            s.append(ord(ac.read_str()[0]) - ord("A"))
        n = len(s)
        s += s[::-1]

        _, rk, _ = SuffixArray().build(s, 26)

        ans = []
        ll, rr = 0, n - 1
        for _ in range(n):
            if rk[ll] < rk[2 * n - 1 - rr]:
                ans.append(s[ll])
                ll += 1
            else:
                ans.append(s[rr])
                rr -= 1
            if len(ans) == 80:
                res = "".join(chr(x + ord("A")) for x in ans)
                ac.st(res)
                ans = []
        if ans:
            res = "".join(chr(x + ord("A")) for x in ans)
            ac.st(res)
        return